// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `def.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ADVSignedKeyIndexList)
pub struct ADVSignedKeyIndexList {
    // message fields
    // @@protoc_insertion_point(field:proto.ADVSignedKeyIndexList.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ADVSignedKeyIndexList.accountSignature)
    pub accountSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ADVSignedKeyIndexList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVSignedKeyIndexList {
    fn default() -> &'a ADVSignedKeyIndexList {
        <ADVSignedKeyIndexList as ::protobuf::Message>::default_instance()
    }
}

impl ADVSignedKeyIndexList {
    pub fn new() -> ADVSignedKeyIndexList {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes accountSignature = 2;

    pub fn accountSignature(&self) -> &[u8] {
        match self.accountSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_accountSignature(&mut self) {
        self.accountSignature = ::std::option::Option::None;
    }

    pub fn has_accountSignature(&self) -> bool {
        self.accountSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.accountSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.accountSignature.is_none() {
            self.accountSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.accountSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.accountSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &ADVSignedKeyIndexList| { &m.details },
            |m: &mut ADVSignedKeyIndexList| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountSignature",
            |m: &ADVSignedKeyIndexList| { &m.accountSignature },
            |m: &mut ADVSignedKeyIndexList| { &mut m.accountSignature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVSignedKeyIndexList>(
            "ADVSignedKeyIndexList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVSignedKeyIndexList {
    const NAME: &'static str = "ADVSignedKeyIndexList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.accountSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.accountSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.accountSignature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVSignedKeyIndexList {
        ADVSignedKeyIndexList::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.accountSignature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVSignedKeyIndexList {
        static instance: ADVSignedKeyIndexList = ADVSignedKeyIndexList {
            details: ::std::option::Option::None,
            accountSignature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVSignedKeyIndexList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVSignedKeyIndexList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVSignedKeyIndexList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVSignedKeyIndexList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ADVSignedDeviceIdentity)
pub struct ADVSignedDeviceIdentity {
    // message fields
    // @@protoc_insertion_point(field:proto.ADVSignedDeviceIdentity.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ADVSignedDeviceIdentity.accountSignatureKey)
    pub accountSignatureKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ADVSignedDeviceIdentity.accountSignature)
    pub accountSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ADVSignedDeviceIdentity.deviceSignature)
    pub deviceSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ADVSignedDeviceIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVSignedDeviceIdentity {
    fn default() -> &'a ADVSignedDeviceIdentity {
        <ADVSignedDeviceIdentity as ::protobuf::Message>::default_instance()
    }
}

impl ADVSignedDeviceIdentity {
    pub fn new() -> ADVSignedDeviceIdentity {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes accountSignatureKey = 2;

    pub fn accountSignatureKey(&self) -> &[u8] {
        match self.accountSignatureKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_accountSignatureKey(&mut self) {
        self.accountSignatureKey = ::std::option::Option::None;
    }

    pub fn has_accountSignatureKey(&self) -> bool {
        self.accountSignatureKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountSignatureKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.accountSignatureKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountSignatureKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.accountSignatureKey.is_none() {
            self.accountSignatureKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.accountSignatureKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountSignatureKey(&mut self) -> ::std::vec::Vec<u8> {
        self.accountSignatureKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes accountSignature = 3;

    pub fn accountSignature(&self) -> &[u8] {
        match self.accountSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_accountSignature(&mut self) {
        self.accountSignature = ::std::option::Option::None;
    }

    pub fn has_accountSignature(&self) -> bool {
        self.accountSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.accountSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.accountSignature.is_none() {
            self.accountSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.accountSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.accountSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes deviceSignature = 4;

    pub fn deviceSignature(&self) -> &[u8] {
        match self.deviceSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_deviceSignature(&mut self) {
        self.deviceSignature = ::std::option::Option::None;
    }

    pub fn has_deviceSignature(&self) -> bool {
        self.deviceSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.deviceSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.deviceSignature.is_none() {
            self.deviceSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.deviceSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_deviceSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.deviceSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &ADVSignedDeviceIdentity| { &m.details },
            |m: &mut ADVSignedDeviceIdentity| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountSignatureKey",
            |m: &ADVSignedDeviceIdentity| { &m.accountSignatureKey },
            |m: &mut ADVSignedDeviceIdentity| { &mut m.accountSignatureKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountSignature",
            |m: &ADVSignedDeviceIdentity| { &m.accountSignature },
            |m: &mut ADVSignedDeviceIdentity| { &mut m.accountSignature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceSignature",
            |m: &ADVSignedDeviceIdentity| { &m.deviceSignature },
            |m: &mut ADVSignedDeviceIdentity| { &mut m.deviceSignature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVSignedDeviceIdentity>(
            "ADVSignedDeviceIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVSignedDeviceIdentity {
    const NAME: &'static str = "ADVSignedDeviceIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.accountSignatureKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.accountSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.deviceSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.accountSignatureKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.accountSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.deviceSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.accountSignatureKey.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.accountSignature.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.deviceSignature.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVSignedDeviceIdentity {
        ADVSignedDeviceIdentity::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.accountSignatureKey = ::std::option::Option::None;
        self.accountSignature = ::std::option::Option::None;
        self.deviceSignature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVSignedDeviceIdentity {
        static instance: ADVSignedDeviceIdentity = ADVSignedDeviceIdentity {
            details: ::std::option::Option::None,
            accountSignatureKey: ::std::option::Option::None,
            accountSignature: ::std::option::Option::None,
            deviceSignature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVSignedDeviceIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVSignedDeviceIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVSignedDeviceIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVSignedDeviceIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ADVSignedDeviceIdentityHMAC)
pub struct ADVSignedDeviceIdentityHMAC {
    // message fields
    // @@protoc_insertion_point(field:proto.ADVSignedDeviceIdentityHMAC.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ADVSignedDeviceIdentityHMAC.hmac)
    pub hmac: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ADVSignedDeviceIdentityHMAC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVSignedDeviceIdentityHMAC {
    fn default() -> &'a ADVSignedDeviceIdentityHMAC {
        <ADVSignedDeviceIdentityHMAC as ::protobuf::Message>::default_instance()
    }
}

impl ADVSignedDeviceIdentityHMAC {
    pub fn new() -> ADVSignedDeviceIdentityHMAC {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes hmac = 2;

    pub fn hmac(&self) -> &[u8] {
        match self.hmac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hmac(&mut self) {
        self.hmac = ::std::option::Option::None;
    }

    pub fn has_hmac(&self) -> bool {
        self.hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.hmac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hmac.is_none() {
            self.hmac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &ADVSignedDeviceIdentityHMAC| { &m.details },
            |m: &mut ADVSignedDeviceIdentityHMAC| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hmac",
            |m: &ADVSignedDeviceIdentityHMAC| { &m.hmac },
            |m: &mut ADVSignedDeviceIdentityHMAC| { &mut m.hmac },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVSignedDeviceIdentityHMAC>(
            "ADVSignedDeviceIdentityHMAC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVSignedDeviceIdentityHMAC {
    const NAME: &'static str = "ADVSignedDeviceIdentityHMAC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.hmac = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.hmac.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVSignedDeviceIdentityHMAC {
        ADVSignedDeviceIdentityHMAC::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.hmac = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVSignedDeviceIdentityHMAC {
        static instance: ADVSignedDeviceIdentityHMAC = ADVSignedDeviceIdentityHMAC {
            details: ::std::option::Option::None,
            hmac: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVSignedDeviceIdentityHMAC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVSignedDeviceIdentityHMAC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVSignedDeviceIdentityHMAC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVSignedDeviceIdentityHMAC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ADVKeyIndexList)
pub struct ADVKeyIndexList {
    // message fields
    // @@protoc_insertion_point(field:proto.ADVKeyIndexList.rawId)
    pub rawId: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ADVKeyIndexList.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.ADVKeyIndexList.currentIndex)
    pub currentIndex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ADVKeyIndexList.validIndexes)
    pub validIndexes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ADVKeyIndexList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVKeyIndexList {
    fn default() -> &'a ADVKeyIndexList {
        <ADVKeyIndexList as ::protobuf::Message>::default_instance()
    }
}

impl ADVKeyIndexList {
    pub fn new() -> ADVKeyIndexList {
        ::std::default::Default::default()
    }

    // optional uint32 rawId = 1;

    pub fn rawId(&self) -> u32 {
        self.rawId.unwrap_or(0)
    }

    pub fn clear_rawId(&mut self) {
        self.rawId = ::std::option::Option::None;
    }

    pub fn has_rawId(&self) -> bool {
        self.rawId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawId(&mut self, v: u32) {
        self.rawId = ::std::option::Option::Some(v);
    }

    // optional uint64 timestamp = 2;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 currentIndex = 3;

    pub fn currentIndex(&self) -> u32 {
        self.currentIndex.unwrap_or(0)
    }

    pub fn clear_currentIndex(&mut self) {
        self.currentIndex = ::std::option::Option::None;
    }

    pub fn has_currentIndex(&self) -> bool {
        self.currentIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentIndex(&mut self, v: u32) {
        self.currentIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rawId",
            |m: &ADVKeyIndexList| { &m.rawId },
            |m: &mut ADVKeyIndexList| { &mut m.rawId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ADVKeyIndexList| { &m.timestamp },
            |m: &mut ADVKeyIndexList| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentIndex",
            |m: &ADVKeyIndexList| { &m.currentIndex },
            |m: &mut ADVKeyIndexList| { &mut m.currentIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validIndexes",
            |m: &ADVKeyIndexList| { &m.validIndexes },
            |m: &mut ADVKeyIndexList| { &mut m.validIndexes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVKeyIndexList>(
            "ADVKeyIndexList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVKeyIndexList {
    const NAME: &'static str = "ADVKeyIndexList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rawId = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.currentIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.validIndexes)?;
                },
                32 => {
                    self.validIndexes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rawId {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.currentIndex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(4, &self.validIndexes);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rawId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.currentIndex {
            os.write_uint32(3, v)?;
        }
        os.write_repeated_packed_uint32(4, &self.validIndexes)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVKeyIndexList {
        ADVKeyIndexList::new()
    }

    fn clear(&mut self) {
        self.rawId = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.currentIndex = ::std::option::Option::None;
        self.validIndexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVKeyIndexList {
        static instance: ADVKeyIndexList = ADVKeyIndexList {
            rawId: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            currentIndex: ::std::option::Option::None,
            validIndexes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVKeyIndexList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVKeyIndexList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVKeyIndexList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVKeyIndexList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ADVDeviceIdentity)
pub struct ADVDeviceIdentity {
    // message fields
    // @@protoc_insertion_point(field:proto.ADVDeviceIdentity.rawId)
    pub rawId: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ADVDeviceIdentity.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.ADVDeviceIdentity.keyIndex)
    pub keyIndex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ADVDeviceIdentity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ADVDeviceIdentity {
    fn default() -> &'a ADVDeviceIdentity {
        <ADVDeviceIdentity as ::protobuf::Message>::default_instance()
    }
}

impl ADVDeviceIdentity {
    pub fn new() -> ADVDeviceIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 rawId = 1;

    pub fn rawId(&self) -> u32 {
        self.rawId.unwrap_or(0)
    }

    pub fn clear_rawId(&mut self) {
        self.rawId = ::std::option::Option::None;
    }

    pub fn has_rawId(&self) -> bool {
        self.rawId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawId(&mut self, v: u32) {
        self.rawId = ::std::option::Option::Some(v);
    }

    // optional uint64 timestamp = 2;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 keyIndex = 3;

    pub fn keyIndex(&self) -> u32 {
        self.keyIndex.unwrap_or(0)
    }

    pub fn clear_keyIndex(&mut self) {
        self.keyIndex = ::std::option::Option::None;
    }

    pub fn has_keyIndex(&self) -> bool {
        self.keyIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyIndex(&mut self, v: u32) {
        self.keyIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rawId",
            |m: &ADVDeviceIdentity| { &m.rawId },
            |m: &mut ADVDeviceIdentity| { &mut m.rawId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ADVDeviceIdentity| { &m.timestamp },
            |m: &mut ADVDeviceIdentity| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyIndex",
            |m: &ADVDeviceIdentity| { &m.keyIndex },
            |m: &mut ADVDeviceIdentity| { &mut m.keyIndex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ADVDeviceIdentity>(
            "ADVDeviceIdentity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ADVDeviceIdentity {
    const NAME: &'static str = "ADVDeviceIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rawId = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.keyIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rawId {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.keyIndex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rawId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.keyIndex {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ADVDeviceIdentity {
        ADVDeviceIdentity::new()
    }

    fn clear(&mut self) {
        self.rawId = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.keyIndex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ADVDeviceIdentity {
        static instance: ADVDeviceIdentity = ADVDeviceIdentity {
            rawId: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            keyIndex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ADVDeviceIdentity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ADVDeviceIdentity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ADVDeviceIdentity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ADVDeviceIdentity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DeviceProps)
pub struct DeviceProps {
    // message fields
    // @@protoc_insertion_point(field:proto.DeviceProps.os)
    pub os: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DeviceProps.version)
    pub version: ::protobuf::MessageField<device_props::AppVersion>,
    // @@protoc_insertion_point(field:proto.DeviceProps.platformType)
    pub platformType: ::std::option::Option<::protobuf::EnumOrUnknown<device_props::PlatformType>>,
    // @@protoc_insertion_point(field:proto.DeviceProps.requireFullSync)
    pub requireFullSync: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.DeviceProps.historySyncConfig)
    pub historySyncConfig: ::protobuf::MessageField<device_props::HistorySyncConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DeviceProps.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceProps {
    fn default() -> &'a DeviceProps {
        <DeviceProps as ::protobuf::Message>::default_instance()
    }
}

impl DeviceProps {
    pub fn new() -> DeviceProps {
        ::std::default::Default::default()
    }

    // optional string os = 1;

    pub fn os(&self) -> &str {
        match self.os.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os(&mut self) -> &mut ::std::string::String {
        if self.os.is_none() {
            self.os = ::std::option::Option::Some(::std::string::String::new());
        }
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.DeviceProps.PlatformType platformType = 3;

    pub fn platformType(&self) -> device_props::PlatformType {
        match self.platformType {
            Some(e) => e.enum_value_or(device_props::PlatformType::UNKNOWN),
            None => device_props::PlatformType::UNKNOWN,
        }
    }

    pub fn clear_platformType(&mut self) {
        self.platformType = ::std::option::Option::None;
    }

    pub fn has_platformType(&self) -> bool {
        self.platformType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platformType(&mut self, v: device_props::PlatformType) {
        self.platformType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool requireFullSync = 4;

    pub fn requireFullSync(&self) -> bool {
        self.requireFullSync.unwrap_or(false)
    }

    pub fn clear_requireFullSync(&mut self) {
        self.requireFullSync = ::std::option::Option::None;
    }

    pub fn has_requireFullSync(&self) -> bool {
        self.requireFullSync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requireFullSync(&mut self, v: bool) {
        self.requireFullSync = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &DeviceProps| { &m.os },
            |m: &mut DeviceProps| { &mut m.os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, device_props::AppVersion>(
            "version",
            |m: &DeviceProps| { &m.version },
            |m: &mut DeviceProps| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platformType",
            |m: &DeviceProps| { &m.platformType },
            |m: &mut DeviceProps| { &mut m.platformType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requireFullSync",
            |m: &DeviceProps| { &m.requireFullSync },
            |m: &mut DeviceProps| { &mut m.requireFullSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, device_props::HistorySyncConfig>(
            "historySyncConfig",
            |m: &DeviceProps| { &m.historySyncConfig },
            |m: &mut DeviceProps| { &mut m.historySyncConfig },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceProps>(
            "DeviceProps",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceProps {
    const NAME: &'static str = "DeviceProps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.os = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                24 => {
                    self.platformType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.requireFullSync = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.historySyncConfig)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.os.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.platformType {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.requireFullSync {
            my_size += 1 + 1;
        }
        if let Some(v) = self.historySyncConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.os.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.platformType {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.requireFullSync {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.historySyncConfig.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceProps {
        DeviceProps::new()
    }

    fn clear(&mut self) {
        self.os = ::std::option::Option::None;
        self.version.clear();
        self.platformType = ::std::option::Option::None;
        self.requireFullSync = ::std::option::Option::None;
        self.historySyncConfig.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceProps {
        static instance: DeviceProps = DeviceProps {
            os: ::std::option::Option::None,
            version: ::protobuf::MessageField::none(),
            platformType: ::std::option::Option::None,
            requireFullSync: ::std::option::Option::None,
            historySyncConfig: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceProps {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceProps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceProps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceProps {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DeviceProps`
pub mod device_props {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.DeviceProps.HistorySyncConfig)
    pub struct HistorySyncConfig {
        // message fields
        // @@protoc_insertion_point(field:proto.DeviceProps.HistorySyncConfig.fullSyncDaysLimit)
        pub fullSyncDaysLimit: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:proto.DeviceProps.HistorySyncConfig.fullSyncSizeMbLimit)
        pub fullSyncSizeMbLimit: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:proto.DeviceProps.HistorySyncConfig.storageQuotaMb)
        pub storageQuotaMb: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.DeviceProps.HistorySyncConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HistorySyncConfig {
        fn default() -> &'a HistorySyncConfig {
            <HistorySyncConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl HistorySyncConfig {
        pub fn new() -> HistorySyncConfig {
            ::std::default::Default::default()
        }

        // optional uint32 fullSyncDaysLimit = 1;

        pub fn fullSyncDaysLimit(&self) -> u32 {
            self.fullSyncDaysLimit.unwrap_or(0)
        }

        pub fn clear_fullSyncDaysLimit(&mut self) {
            self.fullSyncDaysLimit = ::std::option::Option::None;
        }

        pub fn has_fullSyncDaysLimit(&self) -> bool {
            self.fullSyncDaysLimit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fullSyncDaysLimit(&mut self, v: u32) {
            self.fullSyncDaysLimit = ::std::option::Option::Some(v);
        }

        // optional uint32 fullSyncSizeMbLimit = 2;

        pub fn fullSyncSizeMbLimit(&self) -> u32 {
            self.fullSyncSizeMbLimit.unwrap_or(0)
        }

        pub fn clear_fullSyncSizeMbLimit(&mut self) {
            self.fullSyncSizeMbLimit = ::std::option::Option::None;
        }

        pub fn has_fullSyncSizeMbLimit(&self) -> bool {
            self.fullSyncSizeMbLimit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fullSyncSizeMbLimit(&mut self, v: u32) {
            self.fullSyncSizeMbLimit = ::std::option::Option::Some(v);
        }

        // optional uint32 storageQuotaMb = 3;

        pub fn storageQuotaMb(&self) -> u32 {
            self.storageQuotaMb.unwrap_or(0)
        }

        pub fn clear_storageQuotaMb(&mut self) {
            self.storageQuotaMb = ::std::option::Option::None;
        }

        pub fn has_storageQuotaMb(&self) -> bool {
            self.storageQuotaMb.is_some()
        }

        // Param is passed by value, moved
        pub fn set_storageQuotaMb(&mut self, v: u32) {
            self.storageQuotaMb = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fullSyncDaysLimit",
                |m: &HistorySyncConfig| { &m.fullSyncDaysLimit },
                |m: &mut HistorySyncConfig| { &mut m.fullSyncDaysLimit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fullSyncSizeMbLimit",
                |m: &HistorySyncConfig| { &m.fullSyncSizeMbLimit },
                |m: &mut HistorySyncConfig| { &mut m.fullSyncSizeMbLimit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "storageQuotaMb",
                |m: &HistorySyncConfig| { &m.storageQuotaMb },
                |m: &mut HistorySyncConfig| { &mut m.storageQuotaMb },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistorySyncConfig>(
                "DeviceProps.HistorySyncConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HistorySyncConfig {
        const NAME: &'static str = "HistorySyncConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.fullSyncDaysLimit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.fullSyncSizeMbLimit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.storageQuotaMb = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.fullSyncDaysLimit {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.fullSyncSizeMbLimit {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.storageQuotaMb {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.fullSyncDaysLimit {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.fullSyncSizeMbLimit {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.storageQuotaMb {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HistorySyncConfig {
            HistorySyncConfig::new()
        }

        fn clear(&mut self) {
            self.fullSyncDaysLimit = ::std::option::Option::None;
            self.fullSyncSizeMbLimit = ::std::option::Option::None;
            self.storageQuotaMb = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HistorySyncConfig {
            static instance: HistorySyncConfig = HistorySyncConfig {
                fullSyncDaysLimit: ::std::option::Option::None,
                fullSyncSizeMbLimit: ::std::option::Option::None,
                storageQuotaMb: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HistorySyncConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DeviceProps.HistorySyncConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HistorySyncConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HistorySyncConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.DeviceProps.AppVersion)
    pub struct AppVersion {
        // message fields
        // @@protoc_insertion_point(field:proto.DeviceProps.AppVersion.primary)
        pub primary: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:proto.DeviceProps.AppVersion.secondary)
        pub secondary: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:proto.DeviceProps.AppVersion.tertiary)
        pub tertiary: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:proto.DeviceProps.AppVersion.quaternary)
        pub quaternary: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:proto.DeviceProps.AppVersion.quinary)
        pub quinary: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.DeviceProps.AppVersion.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AppVersion {
        fn default() -> &'a AppVersion {
            <AppVersion as ::protobuf::Message>::default_instance()
        }
    }

    impl AppVersion {
        pub fn new() -> AppVersion {
            ::std::default::Default::default()
        }

        // optional uint32 primary = 1;

        pub fn primary(&self) -> u32 {
            self.primary.unwrap_or(0)
        }

        pub fn clear_primary(&mut self) {
            self.primary = ::std::option::Option::None;
        }

        pub fn has_primary(&self) -> bool {
            self.primary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary(&mut self, v: u32) {
            self.primary = ::std::option::Option::Some(v);
        }

        // optional uint32 secondary = 2;

        pub fn secondary(&self) -> u32 {
            self.secondary.unwrap_or(0)
        }

        pub fn clear_secondary(&mut self) {
            self.secondary = ::std::option::Option::None;
        }

        pub fn has_secondary(&self) -> bool {
            self.secondary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_secondary(&mut self, v: u32) {
            self.secondary = ::std::option::Option::Some(v);
        }

        // optional uint32 tertiary = 3;

        pub fn tertiary(&self) -> u32 {
            self.tertiary.unwrap_or(0)
        }

        pub fn clear_tertiary(&mut self) {
            self.tertiary = ::std::option::Option::None;
        }

        pub fn has_tertiary(&self) -> bool {
            self.tertiary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tertiary(&mut self, v: u32) {
            self.tertiary = ::std::option::Option::Some(v);
        }

        // optional uint32 quaternary = 4;

        pub fn quaternary(&self) -> u32 {
            self.quaternary.unwrap_or(0)
        }

        pub fn clear_quaternary(&mut self) {
            self.quaternary = ::std::option::Option::None;
        }

        pub fn has_quaternary(&self) -> bool {
            self.quaternary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quaternary(&mut self, v: u32) {
            self.quaternary = ::std::option::Option::Some(v);
        }

        // optional uint32 quinary = 5;

        pub fn quinary(&self) -> u32 {
            self.quinary.unwrap_or(0)
        }

        pub fn clear_quinary(&mut self) {
            self.quinary = ::std::option::Option::None;
        }

        pub fn has_quinary(&self) -> bool {
            self.quinary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quinary(&mut self, v: u32) {
            self.quinary = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "primary",
                |m: &AppVersion| { &m.primary },
                |m: &mut AppVersion| { &mut m.primary },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "secondary",
                |m: &AppVersion| { &m.secondary },
                |m: &mut AppVersion| { &mut m.secondary },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tertiary",
                |m: &AppVersion| { &m.tertiary },
                |m: &mut AppVersion| { &mut m.tertiary },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quaternary",
                |m: &AppVersion| { &m.quaternary },
                |m: &mut AppVersion| { &mut m.quaternary },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quinary",
                |m: &AppVersion| { &m.quinary },
                |m: &mut AppVersion| { &mut m.quinary },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppVersion>(
                "DeviceProps.AppVersion",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AppVersion {
        const NAME: &'static str = "AppVersion";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.primary = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.secondary = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.tertiary = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.quaternary = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.quinary = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.primary {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.secondary {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.tertiary {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.quaternary {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.quinary {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.primary {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.secondary {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.tertiary {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.quaternary {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.quinary {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AppVersion {
            AppVersion::new()
        }

        fn clear(&mut self) {
            self.primary = ::std::option::Option::None;
            self.secondary = ::std::option::Option::None;
            self.tertiary = ::std::option::Option::None;
            self.quaternary = ::std::option::Option::None;
            self.quinary = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AppVersion {
            static instance: AppVersion = AppVersion {
                primary: ::std::option::Option::None,
                secondary: ::std::option::Option::None,
                tertiary: ::std::option::Option::None,
                quaternary: ::std::option::Option::None,
                quinary: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AppVersion {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DeviceProps.AppVersion").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AppVersion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AppVersion {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.DeviceProps.PlatformType)
    pub enum PlatformType {
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.CHROME)
        CHROME = 1,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.FIREFOX)
        FIREFOX = 2,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.IE)
        IE = 3,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.OPERA)
        OPERA = 4,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.SAFARI)
        SAFARI = 5,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.EDGE)
        EDGE = 6,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.DESKTOP)
        DESKTOP = 7,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.IPAD)
        IPAD = 8,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.ANDROID_TABLET)
        ANDROID_TABLET = 9,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.OHANA)
        OHANA = 10,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.ALOHA)
        ALOHA = 11,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.CATALINA)
        CATALINA = 12,
        // @@protoc_insertion_point(enum_value:proto.DeviceProps.PlatformType.TCL_TV)
        TCL_TV = 13,
    }

    impl ::protobuf::Enum for PlatformType {
        const NAME: &'static str = "PlatformType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PlatformType> {
            match value {
                0 => ::std::option::Option::Some(PlatformType::UNKNOWN),
                1 => ::std::option::Option::Some(PlatformType::CHROME),
                2 => ::std::option::Option::Some(PlatformType::FIREFOX),
                3 => ::std::option::Option::Some(PlatformType::IE),
                4 => ::std::option::Option::Some(PlatformType::OPERA),
                5 => ::std::option::Option::Some(PlatformType::SAFARI),
                6 => ::std::option::Option::Some(PlatformType::EDGE),
                7 => ::std::option::Option::Some(PlatformType::DESKTOP),
                8 => ::std::option::Option::Some(PlatformType::IPAD),
                9 => ::std::option::Option::Some(PlatformType::ANDROID_TABLET),
                10 => ::std::option::Option::Some(PlatformType::OHANA),
                11 => ::std::option::Option::Some(PlatformType::ALOHA),
                12 => ::std::option::Option::Some(PlatformType::CATALINA),
                13 => ::std::option::Option::Some(PlatformType::TCL_TV),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PlatformType] = &[
            PlatformType::UNKNOWN,
            PlatformType::CHROME,
            PlatformType::FIREFOX,
            PlatformType::IE,
            PlatformType::OPERA,
            PlatformType::SAFARI,
            PlatformType::EDGE,
            PlatformType::DESKTOP,
            PlatformType::IPAD,
            PlatformType::ANDROID_TABLET,
            PlatformType::OHANA,
            PlatformType::ALOHA,
            PlatformType::CATALINA,
            PlatformType::TCL_TV,
        ];
    }

    impl ::protobuf::EnumFull for PlatformType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("DeviceProps.PlatformType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PlatformType {
        fn default() -> Self {
            PlatformType::UNKNOWN
        }
    }

    impl PlatformType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PlatformType>("DeviceProps.PlatformType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PeerDataOperationRequestMessage)
pub struct PeerDataOperationRequestMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.PeerDataOperationRequestMessage.peerDataOperationRequestType)
    pub peerDataOperationRequestType: ::std::option::Option<::protobuf::EnumOrUnknown<PeerDataOperationRequestType>>,
    // @@protoc_insertion_point(field:proto.PeerDataOperationRequestMessage.requestStickerReupload)
    pub requestStickerReupload: ::std::vec::Vec<peer_data_operation_request_message::RequestStickerReupload>,
    // @@protoc_insertion_point(field:proto.PeerDataOperationRequestMessage.requestUrlPreview)
    pub requestUrlPreview: ::std::vec::Vec<peer_data_operation_request_message::RequestUrlPreview>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PeerDataOperationRequestMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerDataOperationRequestMessage {
    fn default() -> &'a PeerDataOperationRequestMessage {
        <PeerDataOperationRequestMessage as ::protobuf::Message>::default_instance()
    }
}

impl PeerDataOperationRequestMessage {
    pub fn new() -> PeerDataOperationRequestMessage {
        ::std::default::Default::default()
    }

    // optional .proto.PeerDataOperationRequestType peerDataOperationRequestType = 1;

    pub fn peerDataOperationRequestType(&self) -> PeerDataOperationRequestType {
        match self.peerDataOperationRequestType {
            Some(e) => e.enum_value_or(PeerDataOperationRequestType::UPLOAD_STICKER),
            None => PeerDataOperationRequestType::UPLOAD_STICKER,
        }
    }

    pub fn clear_peerDataOperationRequestType(&mut self) {
        self.peerDataOperationRequestType = ::std::option::Option::None;
    }

    pub fn has_peerDataOperationRequestType(&self) -> bool {
        self.peerDataOperationRequestType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peerDataOperationRequestType(&mut self, v: PeerDataOperationRequestType) {
        self.peerDataOperationRequestType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "peerDataOperationRequestType",
            |m: &PeerDataOperationRequestMessage| { &m.peerDataOperationRequestType },
            |m: &mut PeerDataOperationRequestMessage| { &mut m.peerDataOperationRequestType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requestStickerReupload",
            |m: &PeerDataOperationRequestMessage| { &m.requestStickerReupload },
            |m: &mut PeerDataOperationRequestMessage| { &mut m.requestStickerReupload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "requestUrlPreview",
            |m: &PeerDataOperationRequestMessage| { &m.requestUrlPreview },
            |m: &mut PeerDataOperationRequestMessage| { &mut m.requestUrlPreview },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerDataOperationRequestMessage>(
            "PeerDataOperationRequestMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerDataOperationRequestMessage {
    const NAME: &'static str = "PeerDataOperationRequestMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.peerDataOperationRequestType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.requestStickerReupload.push(is.read_message()?);
                },
                26 => {
                    self.requestUrlPreview.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.peerDataOperationRequestType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.requestStickerReupload {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.requestUrlPreview {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.peerDataOperationRequestType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.requestStickerReupload {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.requestUrlPreview {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerDataOperationRequestMessage {
        PeerDataOperationRequestMessage::new()
    }

    fn clear(&mut self) {
        self.peerDataOperationRequestType = ::std::option::Option::None;
        self.requestStickerReupload.clear();
        self.requestUrlPreview.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerDataOperationRequestMessage {
        static instance: PeerDataOperationRequestMessage = PeerDataOperationRequestMessage {
            peerDataOperationRequestType: ::std::option::Option::None,
            requestStickerReupload: ::std::vec::Vec::new(),
            requestUrlPreview: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerDataOperationRequestMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerDataOperationRequestMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerDataOperationRequestMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerDataOperationRequestMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PeerDataOperationRequestMessage`
pub mod peer_data_operation_request_message {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.PeerDataOperationRequestMessage.RequestUrlPreview)
    pub struct RequestUrlPreview {
        // message fields
        // @@protoc_insertion_point(field:proto.PeerDataOperationRequestMessage.RequestUrlPreview.url)
        pub url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.PeerDataOperationRequestMessage.RequestUrlPreview.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RequestUrlPreview {
        fn default() -> &'a RequestUrlPreview {
            <RequestUrlPreview as ::protobuf::Message>::default_instance()
        }
    }

    impl RequestUrlPreview {
        pub fn new() -> RequestUrlPreview {
            ::std::default::Default::default()
        }

        // optional string url = 1;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &RequestUrlPreview| { &m.url },
                |m: &mut RequestUrlPreview| { &mut m.url },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestUrlPreview>(
                "PeerDataOperationRequestMessage.RequestUrlPreview",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RequestUrlPreview {
        const NAME: &'static str = "RequestUrlPreview";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.url.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RequestUrlPreview {
            RequestUrlPreview::new()
        }

        fn clear(&mut self) {
            self.url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RequestUrlPreview {
            static instance: RequestUrlPreview = RequestUrlPreview {
                url: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RequestUrlPreview {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PeerDataOperationRequestMessage.RequestUrlPreview").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RequestUrlPreview {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RequestUrlPreview {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.PeerDataOperationRequestMessage.RequestStickerReupload)
    pub struct RequestStickerReupload {
        // message fields
        // @@protoc_insertion_point(field:proto.PeerDataOperationRequestMessage.RequestStickerReupload.fileSha256)
        pub fileSha256: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.PeerDataOperationRequestMessage.RequestStickerReupload.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RequestStickerReupload {
        fn default() -> &'a RequestStickerReupload {
            <RequestStickerReupload as ::protobuf::Message>::default_instance()
        }
    }

    impl RequestStickerReupload {
        pub fn new() -> RequestStickerReupload {
            ::std::default::Default::default()
        }

        // optional string fileSha256 = 1;

        pub fn fileSha256(&self) -> &str {
            match self.fileSha256.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_fileSha256(&mut self) {
            self.fileSha256 = ::std::option::Option::None;
        }

        pub fn has_fileSha256(&self) -> bool {
            self.fileSha256.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fileSha256(&mut self, v: ::std::string::String) {
            self.fileSha256 = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_fileSha256(&mut self) -> &mut ::std::string::String {
            if self.fileSha256.is_none() {
                self.fileSha256 = ::std::option::Option::Some(::std::string::String::new());
            }
            self.fileSha256.as_mut().unwrap()
        }

        // Take field
        pub fn take_fileSha256(&mut self) -> ::std::string::String {
            self.fileSha256.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fileSha256",
                |m: &RequestStickerReupload| { &m.fileSha256 },
                |m: &mut RequestStickerReupload| { &mut m.fileSha256 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestStickerReupload>(
                "PeerDataOperationRequestMessage.RequestStickerReupload",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RequestStickerReupload {
        const NAME: &'static str = "RequestStickerReupload";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.fileSha256 = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.fileSha256.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.fileSha256.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RequestStickerReupload {
            RequestStickerReupload::new()
        }

        fn clear(&mut self) {
            self.fileSha256 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RequestStickerReupload {
            static instance: RequestStickerReupload = RequestStickerReupload {
                fileSha256: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RequestStickerReupload {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PeerDataOperationRequestMessage.RequestStickerReupload").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RequestStickerReupload {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RequestStickerReupload {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PaymentInviteMessage)
pub struct PaymentInviteMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.PaymentInviteMessage.serviceType)
    pub serviceType: ::std::option::Option<::protobuf::EnumOrUnknown<payment_invite_message::ServiceType>>,
    // @@protoc_insertion_point(field:proto.PaymentInviteMessage.expiryTimestamp)
    pub expiryTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PaymentInviteMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentInviteMessage {
    fn default() -> &'a PaymentInviteMessage {
        <PaymentInviteMessage as ::protobuf::Message>::default_instance()
    }
}

impl PaymentInviteMessage {
    pub fn new() -> PaymentInviteMessage {
        ::std::default::Default::default()
    }

    // optional .proto.PaymentInviteMessage.ServiceType serviceType = 1;

    pub fn serviceType(&self) -> payment_invite_message::ServiceType {
        match self.serviceType {
            Some(e) => e.enum_value_or(payment_invite_message::ServiceType::UNKNOWN),
            None => payment_invite_message::ServiceType::UNKNOWN,
        }
    }

    pub fn clear_serviceType(&mut self) {
        self.serviceType = ::std::option::Option::None;
    }

    pub fn has_serviceType(&self) -> bool {
        self.serviceType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceType(&mut self, v: payment_invite_message::ServiceType) {
        self.serviceType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 expiryTimestamp = 2;

    pub fn expiryTimestamp(&self) -> i64 {
        self.expiryTimestamp.unwrap_or(0)
    }

    pub fn clear_expiryTimestamp(&mut self) {
        self.expiryTimestamp = ::std::option::Option::None;
    }

    pub fn has_expiryTimestamp(&self) -> bool {
        self.expiryTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryTimestamp(&mut self, v: i64) {
        self.expiryTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serviceType",
            |m: &PaymentInviteMessage| { &m.serviceType },
            |m: &mut PaymentInviteMessage| { &mut m.serviceType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiryTimestamp",
            |m: &PaymentInviteMessage| { &m.expiryTimestamp },
            |m: &mut PaymentInviteMessage| { &mut m.expiryTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentInviteMessage>(
            "PaymentInviteMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentInviteMessage {
    const NAME: &'static str = "PaymentInviteMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serviceType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.expiryTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serviceType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.expiryTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serviceType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.expiryTimestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentInviteMessage {
        PaymentInviteMessage::new()
    }

    fn clear(&mut self) {
        self.serviceType = ::std::option::Option::None;
        self.expiryTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentInviteMessage {
        static instance: PaymentInviteMessage = PaymentInviteMessage {
            serviceType: ::std::option::Option::None,
            expiryTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentInviteMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentInviteMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentInviteMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentInviteMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PaymentInviteMessage`
pub mod payment_invite_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.PaymentInviteMessage.ServiceType)
    pub enum ServiceType {
        // @@protoc_insertion_point(enum_value:proto.PaymentInviteMessage.ServiceType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.PaymentInviteMessage.ServiceType.FBPAY)
        FBPAY = 1,
        // @@protoc_insertion_point(enum_value:proto.PaymentInviteMessage.ServiceType.NOVI)
        NOVI = 2,
        // @@protoc_insertion_point(enum_value:proto.PaymentInviteMessage.ServiceType.UPI)
        UPI = 3,
    }

    impl ::protobuf::Enum for ServiceType {
        const NAME: &'static str = "ServiceType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ServiceType> {
            match value {
                0 => ::std::option::Option::Some(ServiceType::UNKNOWN),
                1 => ::std::option::Option::Some(ServiceType::FBPAY),
                2 => ::std::option::Option::Some(ServiceType::NOVI),
                3 => ::std::option::Option::Some(ServiceType::UPI),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ServiceType] = &[
            ServiceType::UNKNOWN,
            ServiceType::FBPAY,
            ServiceType::NOVI,
            ServiceType::UPI,
        ];
    }

    impl ::protobuf::EnumFull for ServiceType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentInviteMessage.ServiceType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ServiceType {
        fn default() -> Self {
            ServiceType::UNKNOWN
        }
    }

    impl ServiceType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ServiceType>("PaymentInviteMessage.ServiceType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.OrderMessage)
pub struct OrderMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.OrderMessage.orderId)
    pub orderId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.OrderMessage.thumbnail)
    pub thumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.OrderMessage.itemCount)
    pub itemCount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.OrderMessage.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<order_message::OrderStatus>>,
    // @@protoc_insertion_point(field:proto.OrderMessage.surface)
    pub surface: ::std::option::Option<::protobuf::EnumOrUnknown<order_message::OrderSurface>>,
    // @@protoc_insertion_point(field:proto.OrderMessage.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.OrderMessage.orderTitle)
    pub orderTitle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.OrderMessage.sellerJid)
    pub sellerJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.OrderMessage.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.OrderMessage.totalAmount1000)
    pub totalAmount1000: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.OrderMessage.totalCurrencyCode)
    pub totalCurrencyCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.OrderMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.OrderMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OrderMessage {
    fn default() -> &'a OrderMessage {
        <OrderMessage as ::protobuf::Message>::default_instance()
    }
}

impl OrderMessage {
    pub fn new() -> OrderMessage {
        ::std::default::Default::default()
    }

    // optional string orderId = 1;

    pub fn orderId(&self) -> &str {
        match self.orderId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: ::std::string::String) {
        self.orderId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderId(&mut self) -> &mut ::std::string::String {
        if self.orderId.is_none() {
            self.orderId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.orderId.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderId(&mut self) -> ::std::string::String {
        self.orderId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnail = 2;

    pub fn thumbnail(&self) -> &[u8] {
        match self.thumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnail(&mut self) {
        self.thumbnail = ::std::option::Option::None;
    }

    pub fn has_thumbnail(&self) -> bool {
        self.thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnail.is_none() {
            self.thumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 itemCount = 3;

    pub fn itemCount(&self) -> i32 {
        self.itemCount.unwrap_or(0)
    }

    pub fn clear_itemCount(&mut self) {
        self.itemCount = ::std::option::Option::None;
    }

    pub fn has_itemCount(&self) -> bool {
        self.itemCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemCount(&mut self, v: i32) {
        self.itemCount = ::std::option::Option::Some(v);
    }

    // optional .proto.OrderMessage.OrderStatus status = 4;

    pub fn status(&self) -> order_message::OrderStatus {
        match self.status {
            Some(e) => e.enum_value_or(order_message::OrderStatus::INQUIRY),
            None => order_message::OrderStatus::INQUIRY,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: order_message::OrderStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.OrderMessage.OrderSurface surface = 5;

    pub fn surface(&self) -> order_message::OrderSurface {
        match self.surface {
            Some(e) => e.enum_value_or(order_message::OrderSurface::CATALOG),
            None => order_message::OrderSurface::CATALOG,
        }
    }

    pub fn clear_surface(&mut self) {
        self.surface = ::std::option::Option::None;
    }

    pub fn has_surface(&self) -> bool {
        self.surface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surface(&mut self, v: order_message::OrderSurface) {
        self.surface = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string message = 6;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string orderTitle = 7;

    pub fn orderTitle(&self) -> &str {
        match self.orderTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_orderTitle(&mut self) {
        self.orderTitle = ::std::option::Option::None;
    }

    pub fn has_orderTitle(&self) -> bool {
        self.orderTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderTitle(&mut self, v: ::std::string::String) {
        self.orderTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_orderTitle(&mut self) -> &mut ::std::string::String {
        if self.orderTitle.is_none() {
            self.orderTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.orderTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_orderTitle(&mut self) -> ::std::string::String {
        self.orderTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sellerJid = 8;

    pub fn sellerJid(&self) -> &str {
        match self.sellerJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sellerJid(&mut self) {
        self.sellerJid = ::std::option::Option::None;
    }

    pub fn has_sellerJid(&self) -> bool {
        self.sellerJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sellerJid(&mut self, v: ::std::string::String) {
        self.sellerJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sellerJid(&mut self) -> &mut ::std::string::String {
        if self.sellerJid.is_none() {
            self.sellerJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sellerJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_sellerJid(&mut self) -> ::std::string::String {
        self.sellerJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string token = 9;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 totalAmount1000 = 10;

    pub fn totalAmount1000(&self) -> i64 {
        self.totalAmount1000.unwrap_or(0)
    }

    pub fn clear_totalAmount1000(&mut self) {
        self.totalAmount1000 = ::std::option::Option::None;
    }

    pub fn has_totalAmount1000(&self) -> bool {
        self.totalAmount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalAmount1000(&mut self, v: i64) {
        self.totalAmount1000 = ::std::option::Option::Some(v);
    }

    // optional string totalCurrencyCode = 11;

    pub fn totalCurrencyCode(&self) -> &str {
        match self.totalCurrencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_totalCurrencyCode(&mut self) {
        self.totalCurrencyCode = ::std::option::Option::None;
    }

    pub fn has_totalCurrencyCode(&self) -> bool {
        self.totalCurrencyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalCurrencyCode(&mut self, v: ::std::string::String) {
        self.totalCurrencyCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_totalCurrencyCode(&mut self) -> &mut ::std::string::String {
        if self.totalCurrencyCode.is_none() {
            self.totalCurrencyCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.totalCurrencyCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_totalCurrencyCode(&mut self) -> ::std::string::String {
        self.totalCurrencyCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &OrderMessage| { &m.orderId },
            |m: &mut OrderMessage| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnail",
            |m: &OrderMessage| { &m.thumbnail },
            |m: &mut OrderMessage| { &mut m.thumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemCount",
            |m: &OrderMessage| { &m.itemCount },
            |m: &mut OrderMessage| { &mut m.itemCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &OrderMessage| { &m.status },
            |m: &mut OrderMessage| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "surface",
            |m: &OrderMessage| { &m.surface },
            |m: &mut OrderMessage| { &mut m.surface },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &OrderMessage| { &m.message },
            |m: &mut OrderMessage| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderTitle",
            |m: &OrderMessage| { &m.orderTitle },
            |m: &mut OrderMessage| { &mut m.orderTitle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sellerJid",
            |m: &OrderMessage| { &m.sellerJid },
            |m: &mut OrderMessage| { &mut m.sellerJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &OrderMessage| { &m.token },
            |m: &mut OrderMessage| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "totalAmount1000",
            |m: &OrderMessage| { &m.totalAmount1000 },
            |m: &mut OrderMessage| { &mut m.totalAmount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "totalCurrencyCode",
            |m: &OrderMessage| { &m.totalCurrencyCode },
            |m: &mut OrderMessage| { &mut m.totalCurrencyCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &OrderMessage| { &m.contextInfo },
            |m: &mut OrderMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OrderMessage>(
            "OrderMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OrderMessage {
    const NAME: &'static str = "OrderMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.orderId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.thumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.itemCount = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.surface = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.orderTitle = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.sellerJid = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.totalAmount1000 = ::std::option::Option::Some(is.read_int64()?);
                },
                90 => {
                    self.totalCurrencyCode = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.orderId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.thumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.itemCount {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.surface {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.orderTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.sellerJid.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.totalAmount1000 {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.totalCurrencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.orderId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.thumbnail.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.itemCount {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.surface {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.orderTitle.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.sellerJid.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.totalAmount1000 {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.totalCurrencyCode.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OrderMessage {
        OrderMessage::new()
    }

    fn clear(&mut self) {
        self.orderId = ::std::option::Option::None;
        self.thumbnail = ::std::option::Option::None;
        self.itemCount = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.surface = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.orderTitle = ::std::option::Option::None;
        self.sellerJid = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.totalAmount1000 = ::std::option::Option::None;
        self.totalCurrencyCode = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OrderMessage {
        static instance: OrderMessage = OrderMessage {
            orderId: ::std::option::Option::None,
            thumbnail: ::std::option::Option::None,
            itemCount: ::std::option::Option::None,
            status: ::std::option::Option::None,
            surface: ::std::option::Option::None,
            message: ::std::option::Option::None,
            orderTitle: ::std::option::Option::None,
            sellerJid: ::std::option::Option::None,
            token: ::std::option::Option::None,
            totalAmount1000: ::std::option::Option::None,
            totalCurrencyCode: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OrderMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OrderMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OrderMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `OrderMessage`
pub mod order_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.OrderMessage.OrderSurface)
    pub enum OrderSurface {
        // @@protoc_insertion_point(enum_value:proto.OrderMessage.OrderSurface.CATALOG)
        CATALOG = 1,
    }

    impl ::protobuf::Enum for OrderSurface {
        const NAME: &'static str = "OrderSurface";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OrderSurface> {
            match value {
                1 => ::std::option::Option::Some(OrderSurface::CATALOG),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OrderSurface] = &[
            OrderSurface::CATALOG,
        ];
    }

    impl ::protobuf::EnumFull for OrderSurface {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OrderMessage.OrderSurface").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                OrderSurface::CATALOG => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for OrderSurface {
        fn default() -> Self {
            OrderSurface::CATALOG
        }
    }

    impl OrderSurface {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrderSurface>("OrderMessage.OrderSurface")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.OrderMessage.OrderStatus)
    pub enum OrderStatus {
        // @@protoc_insertion_point(enum_value:proto.OrderMessage.OrderStatus.INQUIRY)
        INQUIRY = 1,
    }

    impl ::protobuf::Enum for OrderStatus {
        const NAME: &'static str = "OrderStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OrderStatus> {
            match value {
                1 => ::std::option::Option::Some(OrderStatus::INQUIRY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OrderStatus] = &[
            OrderStatus::INQUIRY,
        ];
    }

    impl ::protobuf::EnumFull for OrderStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("OrderMessage.OrderStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                OrderStatus::INQUIRY => 0,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for OrderStatus {
        fn default() -> Self {
            OrderStatus::INQUIRY
        }
    }

    impl OrderStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OrderStatus>("OrderMessage.OrderStatus")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.LocationMessage)
pub struct LocationMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.LocationMessage.degreesLatitude)
    pub degreesLatitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.LocationMessage.degreesLongitude)
    pub degreesLongitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.LocationMessage.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.LocationMessage.address)
    pub address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.LocationMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.LocationMessage.isLive)
    pub isLive: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.LocationMessage.accuracyInMeters)
    pub accuracyInMeters: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.LocationMessage.speedInMps)
    pub speedInMps: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:proto.LocationMessage.degreesClockwiseFromMagneticNorth)
    pub degreesClockwiseFromMagneticNorth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.LocationMessage.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.LocationMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.LocationMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.LocationMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocationMessage {
    fn default() -> &'a LocationMessage {
        <LocationMessage as ::protobuf::Message>::default_instance()
    }
}

impl LocationMessage {
    pub fn new() -> LocationMessage {
        ::std::default::Default::default()
    }

    // optional double degreesLatitude = 1;

    pub fn degreesLatitude(&self) -> f64 {
        self.degreesLatitude.unwrap_or(0.)
    }

    pub fn clear_degreesLatitude(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
    }

    pub fn has_degreesLatitude(&self) -> bool {
        self.degreesLatitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLatitude(&mut self, v: f64) {
        self.degreesLatitude = ::std::option::Option::Some(v);
    }

    // optional double degreesLongitude = 2;

    pub fn degreesLongitude(&self) -> f64 {
        self.degreesLongitude.unwrap_or(0.)
    }

    pub fn clear_degreesLongitude(&mut self) {
        self.degreesLongitude = ::std::option::Option::None;
    }

    pub fn has_degreesLongitude(&self) -> bool {
        self.degreesLongitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLongitude(&mut self, v: f64) {
        self.degreesLongitude = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address = 4;

    pub fn address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address(&mut self) {
        self.address = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string url = 5;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool isLive = 6;

    pub fn isLive(&self) -> bool {
        self.isLive.unwrap_or(false)
    }

    pub fn clear_isLive(&mut self) {
        self.isLive = ::std::option::Option::None;
    }

    pub fn has_isLive(&self) -> bool {
        self.isLive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isLive(&mut self, v: bool) {
        self.isLive = ::std::option::Option::Some(v);
    }

    // optional uint32 accuracyInMeters = 7;

    pub fn accuracyInMeters(&self) -> u32 {
        self.accuracyInMeters.unwrap_or(0)
    }

    pub fn clear_accuracyInMeters(&mut self) {
        self.accuracyInMeters = ::std::option::Option::None;
    }

    pub fn has_accuracyInMeters(&self) -> bool {
        self.accuracyInMeters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accuracyInMeters(&mut self, v: u32) {
        self.accuracyInMeters = ::std::option::Option::Some(v);
    }

    // optional float speedInMps = 8;

    pub fn speedInMps(&self) -> f32 {
        self.speedInMps.unwrap_or(0.)
    }

    pub fn clear_speedInMps(&mut self) {
        self.speedInMps = ::std::option::Option::None;
    }

    pub fn has_speedInMps(&self) -> bool {
        self.speedInMps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speedInMps(&mut self, v: f32) {
        self.speedInMps = ::std::option::Option::Some(v);
    }

    // optional uint32 degreesClockwiseFromMagneticNorth = 9;

    pub fn degreesClockwiseFromMagneticNorth(&self) -> u32 {
        self.degreesClockwiseFromMagneticNorth.unwrap_or(0)
    }

    pub fn clear_degreesClockwiseFromMagneticNorth(&mut self) {
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::None;
    }

    pub fn has_degreesClockwiseFromMagneticNorth(&self) -> bool {
        self.degreesClockwiseFromMagneticNorth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesClockwiseFromMagneticNorth(&mut self, v: u32) {
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::Some(v);
    }

    // optional string comment = 11;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLatitude",
            |m: &LocationMessage| { &m.degreesLatitude },
            |m: &mut LocationMessage| { &mut m.degreesLatitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLongitude",
            |m: &LocationMessage| { &m.degreesLongitude },
            |m: &mut LocationMessage| { &mut m.degreesLongitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &LocationMessage| { &m.name },
            |m: &mut LocationMessage| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address",
            |m: &LocationMessage| { &m.address },
            |m: &mut LocationMessage| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &LocationMessage| { &m.url },
            |m: &mut LocationMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isLive",
            |m: &LocationMessage| { &m.isLive },
            |m: &mut LocationMessage| { &mut m.isLive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accuracyInMeters",
            |m: &LocationMessage| { &m.accuracyInMeters },
            |m: &mut LocationMessage| { &mut m.accuracyInMeters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speedInMps",
            |m: &LocationMessage| { &m.speedInMps },
            |m: &mut LocationMessage| { &mut m.speedInMps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesClockwiseFromMagneticNorth",
            |m: &LocationMessage| { &m.degreesClockwiseFromMagneticNorth },
            |m: &mut LocationMessage| { &mut m.degreesClockwiseFromMagneticNorth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment",
            |m: &LocationMessage| { &m.comment },
            |m: &mut LocationMessage| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &LocationMessage| { &m.jpegThumbnail },
            |m: &mut LocationMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &LocationMessage| { &m.contextInfo },
            |m: &mut LocationMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocationMessage>(
            "LocationMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocationMessage {
    const NAME: &'static str = "LocationMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.degreesLatitude = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.degreesLongitude = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.address = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.isLive = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.accuracyInMeters = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.speedInMps = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.degreesClockwiseFromMagneticNorth = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.degreesLatitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.degreesLongitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.isLive {
            my_size += 1 + 1;
        }
        if let Some(v) = self.accuracyInMeters {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.speedInMps {
            my_size += 1 + 4;
        }
        if let Some(v) = self.degreesClockwiseFromMagneticNorth {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.degreesLatitude {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.degreesLongitude {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.address.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.isLive {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.accuracyInMeters {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.speedInMps {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.degreesClockwiseFromMagneticNorth {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocationMessage {
        LocationMessage::new()
    }

    fn clear(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
        self.degreesLongitude = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.address = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.isLive = ::std::option::Option::None;
        self.accuracyInMeters = ::std::option::Option::None;
        self.speedInMps = ::std::option::Option::None;
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocationMessage {
        static instance: LocationMessage = LocationMessage {
            degreesLatitude: ::std::option::Option::None,
            degreesLongitude: ::std::option::Option::None,
            name: ::std::option::Option::None,
            address: ::std::option::Option::None,
            url: ::std::option::Option::None,
            isLive: ::std::option::Option::None,
            accuracyInMeters: ::std::option::Option::None,
            speedInMps: ::std::option::Option::None,
            degreesClockwiseFromMagneticNorth: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocationMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocationMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.LiveLocationMessage)
pub struct LiveLocationMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.degreesLatitude)
    pub degreesLatitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.degreesLongitude)
    pub degreesLongitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.accuracyInMeters)
    pub accuracyInMeters: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.speedInMps)
    pub speedInMps: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.degreesClockwiseFromMagneticNorth)
    pub degreesClockwiseFromMagneticNorth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.sequenceNumber)
    pub sequenceNumber: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.timeOffset)
    pub timeOffset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.LiveLocationMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.LiveLocationMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LiveLocationMessage {
    fn default() -> &'a LiveLocationMessage {
        <LiveLocationMessage as ::protobuf::Message>::default_instance()
    }
}

impl LiveLocationMessage {
    pub fn new() -> LiveLocationMessage {
        ::std::default::Default::default()
    }

    // optional double degreesLatitude = 1;

    pub fn degreesLatitude(&self) -> f64 {
        self.degreesLatitude.unwrap_or(0.)
    }

    pub fn clear_degreesLatitude(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
    }

    pub fn has_degreesLatitude(&self) -> bool {
        self.degreesLatitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLatitude(&mut self, v: f64) {
        self.degreesLatitude = ::std::option::Option::Some(v);
    }

    // optional double degreesLongitude = 2;

    pub fn degreesLongitude(&self) -> f64 {
        self.degreesLongitude.unwrap_or(0.)
    }

    pub fn clear_degreesLongitude(&mut self) {
        self.degreesLongitude = ::std::option::Option::None;
    }

    pub fn has_degreesLongitude(&self) -> bool {
        self.degreesLongitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLongitude(&mut self, v: f64) {
        self.degreesLongitude = ::std::option::Option::Some(v);
    }

    // optional uint32 accuracyInMeters = 3;

    pub fn accuracyInMeters(&self) -> u32 {
        self.accuracyInMeters.unwrap_or(0)
    }

    pub fn clear_accuracyInMeters(&mut self) {
        self.accuracyInMeters = ::std::option::Option::None;
    }

    pub fn has_accuracyInMeters(&self) -> bool {
        self.accuracyInMeters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accuracyInMeters(&mut self, v: u32) {
        self.accuracyInMeters = ::std::option::Option::Some(v);
    }

    // optional float speedInMps = 4;

    pub fn speedInMps(&self) -> f32 {
        self.speedInMps.unwrap_or(0.)
    }

    pub fn clear_speedInMps(&mut self) {
        self.speedInMps = ::std::option::Option::None;
    }

    pub fn has_speedInMps(&self) -> bool {
        self.speedInMps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speedInMps(&mut self, v: f32) {
        self.speedInMps = ::std::option::Option::Some(v);
    }

    // optional uint32 degreesClockwiseFromMagneticNorth = 5;

    pub fn degreesClockwiseFromMagneticNorth(&self) -> u32 {
        self.degreesClockwiseFromMagneticNorth.unwrap_or(0)
    }

    pub fn clear_degreesClockwiseFromMagneticNorth(&mut self) {
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::None;
    }

    pub fn has_degreesClockwiseFromMagneticNorth(&self) -> bool {
        self.degreesClockwiseFromMagneticNorth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesClockwiseFromMagneticNorth(&mut self, v: u32) {
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::Some(v);
    }

    // optional string caption = 6;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 sequenceNumber = 7;

    pub fn sequenceNumber(&self) -> i64 {
        self.sequenceNumber.unwrap_or(0)
    }

    pub fn clear_sequenceNumber(&mut self) {
        self.sequenceNumber = ::std::option::Option::None;
    }

    pub fn has_sequenceNumber(&self) -> bool {
        self.sequenceNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequenceNumber(&mut self, v: i64) {
        self.sequenceNumber = ::std::option::Option::Some(v);
    }

    // optional uint32 timeOffset = 8;

    pub fn timeOffset(&self) -> u32 {
        self.timeOffset.unwrap_or(0)
    }

    pub fn clear_timeOffset(&mut self) {
        self.timeOffset = ::std::option::Option::None;
    }

    pub fn has_timeOffset(&self) -> bool {
        self.timeOffset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeOffset(&mut self, v: u32) {
        self.timeOffset = ::std::option::Option::Some(v);
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLatitude",
            |m: &LiveLocationMessage| { &m.degreesLatitude },
            |m: &mut LiveLocationMessage| { &mut m.degreesLatitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLongitude",
            |m: &LiveLocationMessage| { &m.degreesLongitude },
            |m: &mut LiveLocationMessage| { &mut m.degreesLongitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accuracyInMeters",
            |m: &LiveLocationMessage| { &m.accuracyInMeters },
            |m: &mut LiveLocationMessage| { &mut m.accuracyInMeters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speedInMps",
            |m: &LiveLocationMessage| { &m.speedInMps },
            |m: &mut LiveLocationMessage| { &mut m.speedInMps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesClockwiseFromMagneticNorth",
            |m: &LiveLocationMessage| { &m.degreesClockwiseFromMagneticNorth },
            |m: &mut LiveLocationMessage| { &mut m.degreesClockwiseFromMagneticNorth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &LiveLocationMessage| { &m.caption },
            |m: &mut LiveLocationMessage| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequenceNumber",
            |m: &LiveLocationMessage| { &m.sequenceNumber },
            |m: &mut LiveLocationMessage| { &mut m.sequenceNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeOffset",
            |m: &LiveLocationMessage| { &m.timeOffset },
            |m: &mut LiveLocationMessage| { &mut m.timeOffset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &LiveLocationMessage| { &m.jpegThumbnail },
            |m: &mut LiveLocationMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &LiveLocationMessage| { &m.contextInfo },
            |m: &mut LiveLocationMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LiveLocationMessage>(
            "LiveLocationMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LiveLocationMessage {
    const NAME: &'static str = "LiveLocationMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.degreesLatitude = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.degreesLongitude = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.accuracyInMeters = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.speedInMps = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.degreesClockwiseFromMagneticNorth = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.sequenceNumber = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.timeOffset = ::std::option::Option::Some(is.read_uint32()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.degreesLatitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.degreesLongitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.accuracyInMeters {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.speedInMps {
            my_size += 1 + 4;
        }
        if let Some(v) = self.degreesClockwiseFromMagneticNorth {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.sequenceNumber {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.timeOffset {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.degreesLatitude {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.degreesLongitude {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.accuracyInMeters {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.speedInMps {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.degreesClockwiseFromMagneticNorth {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.sequenceNumber {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.timeOffset {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LiveLocationMessage {
        LiveLocationMessage::new()
    }

    fn clear(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
        self.degreesLongitude = ::std::option::Option::None;
        self.accuracyInMeters = ::std::option::Option::None;
        self.speedInMps = ::std::option::Option::None;
        self.degreesClockwiseFromMagneticNorth = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.sequenceNumber = ::std::option::Option::None;
        self.timeOffset = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LiveLocationMessage {
        static instance: LiveLocationMessage = LiveLocationMessage {
            degreesLatitude: ::std::option::Option::None,
            degreesLongitude: ::std::option::Option::None,
            accuracyInMeters: ::std::option::Option::None,
            speedInMps: ::std::option::Option::None,
            degreesClockwiseFromMagneticNorth: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            sequenceNumber: ::std::option::Option::None,
            timeOffset: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LiveLocationMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LiveLocationMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LiveLocationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LiveLocationMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ListResponseMessage)
pub struct ListResponseMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ListResponseMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ListResponseMessage.listType)
    pub listType: ::std::option::Option<::protobuf::EnumOrUnknown<list_response_message::ListType>>,
    // @@protoc_insertion_point(field:proto.ListResponseMessage.singleSelectReply)
    pub singleSelectReply: ::protobuf::MessageField<list_response_message::SingleSelectReply>,
    // @@protoc_insertion_point(field:proto.ListResponseMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.ListResponseMessage.description)
    pub description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ListResponseMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListResponseMessage {
    fn default() -> &'a ListResponseMessage {
        <ListResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl ListResponseMessage {
    pub fn new() -> ListResponseMessage {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.ListResponseMessage.ListType listType = 2;

    pub fn listType(&self) -> list_response_message::ListType {
        match self.listType {
            Some(e) => e.enum_value_or(list_response_message::ListType::UNKNOWN),
            None => list_response_message::ListType::UNKNOWN,
        }
    }

    pub fn clear_listType(&mut self) {
        self.listType = ::std::option::Option::None;
    }

    pub fn has_listType(&self) -> bool {
        self.listType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listType(&mut self, v: list_response_message::ListType) {
        self.listType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string description = 5;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ListResponseMessage| { &m.title },
            |m: &mut ListResponseMessage| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "listType",
            |m: &ListResponseMessage| { &m.listType },
            |m: &mut ListResponseMessage| { &mut m.listType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_response_message::SingleSelectReply>(
            "singleSelectReply",
            |m: &ListResponseMessage| { &m.singleSelectReply },
            |m: &mut ListResponseMessage| { &mut m.singleSelectReply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ListResponseMessage| { &m.contextInfo },
            |m: &mut ListResponseMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ListResponseMessage| { &m.description },
            |m: &mut ListResponseMessage| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListResponseMessage>(
            "ListResponseMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListResponseMessage {
    const NAME: &'static str = "ListResponseMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.listType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.singleSelectReply)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                42 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.listType {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.singleSelectReply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.listType {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.singleSelectReply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListResponseMessage {
        ListResponseMessage::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.listType = ::std::option::Option::None;
        self.singleSelectReply.clear();
        self.contextInfo.clear();
        self.description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListResponseMessage {
        static instance: ListResponseMessage = ListResponseMessage {
            title: ::std::option::Option::None,
            listType: ::std::option::Option::None,
            singleSelectReply: ::protobuf::MessageField::none(),
            contextInfo: ::protobuf::MessageField::none(),
            description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListResponseMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListResponseMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponseMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListResponseMessage`
pub mod list_response_message {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ListResponseMessage.SingleSelectReply)
    pub struct SingleSelectReply {
        // message fields
        // @@protoc_insertion_point(field:proto.ListResponseMessage.SingleSelectReply.selectedRowId)
        pub selectedRowId: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ListResponseMessage.SingleSelectReply.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleSelectReply {
        fn default() -> &'a SingleSelectReply {
            <SingleSelectReply as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleSelectReply {
        pub fn new() -> SingleSelectReply {
            ::std::default::Default::default()
        }

        // optional string selectedRowId = 1;

        pub fn selectedRowId(&self) -> &str {
            match self.selectedRowId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_selectedRowId(&mut self) {
            self.selectedRowId = ::std::option::Option::None;
        }

        pub fn has_selectedRowId(&self) -> bool {
            self.selectedRowId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selectedRowId(&mut self, v: ::std::string::String) {
            self.selectedRowId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_selectedRowId(&mut self) -> &mut ::std::string::String {
            if self.selectedRowId.is_none() {
                self.selectedRowId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.selectedRowId.as_mut().unwrap()
        }

        // Take field
        pub fn take_selectedRowId(&mut self) -> ::std::string::String {
            self.selectedRowId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "selectedRowId",
                |m: &SingleSelectReply| { &m.selectedRowId },
                |m: &mut SingleSelectReply| { &mut m.selectedRowId },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleSelectReply>(
                "ListResponseMessage.SingleSelectReply",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleSelectReply {
        const NAME: &'static str = "SingleSelectReply";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.selectedRowId = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.selectedRowId.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.selectedRowId.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleSelectReply {
            SingleSelectReply::new()
        }

        fn clear(&mut self) {
            self.selectedRowId = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleSelectReply {
            static instance: SingleSelectReply = SingleSelectReply {
                selectedRowId: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleSelectReply {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListResponseMessage.SingleSelectReply").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleSelectReply {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleSelectReply {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ListResponseMessage.ListType)
    pub enum ListType {
        // @@protoc_insertion_point(enum_value:proto.ListResponseMessage.ListType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.ListResponseMessage.ListType.SINGLE_SELECT)
        SINGLE_SELECT = 1,
    }

    impl ::protobuf::Enum for ListType {
        const NAME: &'static str = "ListType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ListType> {
            match value {
                0 => ::std::option::Option::Some(ListType::UNKNOWN),
                1 => ::std::option::Option::Some(ListType::SINGLE_SELECT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ListType] = &[
            ListType::UNKNOWN,
            ListType::SINGLE_SELECT,
        ];
    }

    impl ::protobuf::EnumFull for ListType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ListResponseMessage.ListType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ListType {
        fn default() -> Self {
            ListType::UNKNOWN
        }
    }

    impl ListType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ListType>("ListResponseMessage.ListType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ListMessage)
pub struct ListMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ListMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ListMessage.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ListMessage.buttonText)
    pub buttonText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ListMessage.listType)
    pub listType: ::std::option::Option<::protobuf::EnumOrUnknown<list_message::ListType>>,
    // @@protoc_insertion_point(field:proto.ListMessage.sections)
    pub sections: ::std::vec::Vec<list_message::Section>,
    // @@protoc_insertion_point(field:proto.ListMessage.productListInfo)
    pub productListInfo: ::protobuf::MessageField<list_message::ProductListInfo>,
    // @@protoc_insertion_point(field:proto.ListMessage.footerText)
    pub footerText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ListMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ListMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListMessage {
    fn default() -> &'a ListMessage {
        <ListMessage as ::protobuf::Message>::default_instance()
    }
}

impl ListMessage {
    pub fn new() -> ListMessage {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 2;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string buttonText = 3;

    pub fn buttonText(&self) -> &str {
        match self.buttonText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_buttonText(&mut self) {
        self.buttonText = ::std::option::Option::None;
    }

    pub fn has_buttonText(&self) -> bool {
        self.buttonText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buttonText(&mut self, v: ::std::string::String) {
        self.buttonText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buttonText(&mut self) -> &mut ::std::string::String {
        if self.buttonText.is_none() {
            self.buttonText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.buttonText.as_mut().unwrap()
    }

    // Take field
    pub fn take_buttonText(&mut self) -> ::std::string::String {
        self.buttonText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.ListMessage.ListType listType = 4;

    pub fn listType(&self) -> list_message::ListType {
        match self.listType {
            Some(e) => e.enum_value_or(list_message::ListType::UNKNOWN),
            None => list_message::ListType::UNKNOWN,
        }
    }

    pub fn clear_listType(&mut self) {
        self.listType = ::std::option::Option::None;
    }

    pub fn has_listType(&self) -> bool {
        self.listType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listType(&mut self, v: list_message::ListType) {
        self.listType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string footerText = 7;

    pub fn footerText(&self) -> &str {
        match self.footerText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_footerText(&mut self) {
        self.footerText = ::std::option::Option::None;
    }

    pub fn has_footerText(&self) -> bool {
        self.footerText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerText(&mut self, v: ::std::string::String) {
        self.footerText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_footerText(&mut self) -> &mut ::std::string::String {
        if self.footerText.is_none() {
            self.footerText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.footerText.as_mut().unwrap()
    }

    // Take field
    pub fn take_footerText(&mut self) -> ::std::string::String {
        self.footerText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ListMessage| { &m.title },
            |m: &mut ListMessage| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ListMessage| { &m.description },
            |m: &mut ListMessage| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buttonText",
            |m: &ListMessage| { &m.buttonText },
            |m: &mut ListMessage| { &mut m.buttonText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "listType",
            |m: &ListMessage| { &m.listType },
            |m: &mut ListMessage| { &mut m.listType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sections",
            |m: &ListMessage| { &m.sections },
            |m: &mut ListMessage| { &mut m.sections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, list_message::ProductListInfo>(
            "productListInfo",
            |m: &ListMessage| { &m.productListInfo },
            |m: &mut ListMessage| { &mut m.productListInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "footerText",
            |m: &ListMessage| { &m.footerText },
            |m: &mut ListMessage| { &mut m.footerText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ListMessage| { &m.contextInfo },
            |m: &mut ListMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListMessage>(
            "ListMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListMessage {
    const NAME: &'static str = "ListMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.buttonText = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.listType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.sections.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.productListInfo)?;
                },
                58 => {
                    self.footerText = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.buttonText.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.listType {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.productListInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.footerText.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.buttonText.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.listType {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.sections {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.productListInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.footerText.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListMessage {
        ListMessage::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.buttonText = ::std::option::Option::None;
        self.listType = ::std::option::Option::None;
        self.sections.clear();
        self.productListInfo.clear();
        self.footerText = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListMessage {
        static instance: ListMessage = ListMessage {
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            buttonText: ::std::option::Option::None,
            listType: ::std::option::Option::None,
            sections: ::std::vec::Vec::new(),
            productListInfo: ::protobuf::MessageField::none(),
            footerText: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ListMessage`
pub mod list_message {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ListMessage.Section)
    pub struct Section {
        // message fields
        // @@protoc_insertion_point(field:proto.ListMessage.Section.title)
        pub title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ListMessage.Section.rows)
        pub rows: ::std::vec::Vec<Row>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ListMessage.Section.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Section {
        fn default() -> &'a Section {
            <Section as ::protobuf::Message>::default_instance()
        }
    }

    impl Section {
        pub fn new() -> Section {
            ::std::default::Default::default()
        }

        // optional string title = 1;

        pub fn title(&self) -> &str {
            match self.title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_title(&self) -> bool {
            self.title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            if self.title.is_none() {
                self.title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title.as_mut().unwrap()
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            self.title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "title",
                |m: &Section| { &m.title },
                |m: &mut Section| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "rows",
                |m: &Section| { &m.rows },
                |m: &mut Section| { &mut m.rows },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Section>(
                "ListMessage.Section",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Section {
        const NAME: &'static str = "Section";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.rows.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.title.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.rows {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.title.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.rows {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Section {
            Section::new()
        }

        fn clear(&mut self) {
            self.title = ::std::option::Option::None;
            self.rows.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Section {
            static instance: Section = Section {
                title: ::std::option::Option::None,
                rows: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Section {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListMessage.Section").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Section {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Section {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ListMessage.Row)
    pub struct Row {
        // message fields
        // @@protoc_insertion_point(field:proto.ListMessage.Row.title)
        pub title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ListMessage.Row.description)
        pub description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ListMessage.Row.rowId)
        pub rowId: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ListMessage.Row.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Row {
        fn default() -> &'a Row {
            <Row as ::protobuf::Message>::default_instance()
        }
    }

    impl Row {
        pub fn new() -> Row {
            ::std::default::Default::default()
        }

        // optional string title = 1;

        pub fn title(&self) -> &str {
            match self.title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_title(&self) -> bool {
            self.title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            if self.title.is_none() {
                self.title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title.as_mut().unwrap()
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            self.title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description = 2;

        pub fn description(&self) -> &str {
            match self.description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description(&mut self) {
            self.description = ::std::option::Option::None;
        }

        pub fn has_description(&self) -> bool {
            self.description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            if self.description.is_none() {
                self.description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description.as_mut().unwrap()
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            self.description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string rowId = 3;

        pub fn rowId(&self) -> &str {
            match self.rowId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rowId(&mut self) {
            self.rowId = ::std::option::Option::None;
        }

        pub fn has_rowId(&self) -> bool {
            self.rowId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rowId(&mut self, v: ::std::string::String) {
            self.rowId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rowId(&mut self) -> &mut ::std::string::String {
            if self.rowId.is_none() {
                self.rowId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rowId.as_mut().unwrap()
        }

        // Take field
        pub fn take_rowId(&mut self) -> ::std::string::String {
            self.rowId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "title",
                |m: &Row| { &m.title },
                |m: &mut Row| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "description",
                |m: &Row| { &m.description },
                |m: &mut Row| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rowId",
                |m: &Row| { &m.rowId },
                |m: &mut Row| { &mut m.rowId },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Row>(
                "ListMessage.Row",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Row {
        const NAME: &'static str = "Row";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.description = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.rowId = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.title.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.rowId.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.title.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.description.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.rowId.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Row {
            Row::new()
        }

        fn clear(&mut self) {
            self.title = ::std::option::Option::None;
            self.description = ::std::option::Option::None;
            self.rowId = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Row {
            static instance: Row = Row {
                title: ::std::option::Option::None,
                description: ::std::option::Option::None,
                rowId: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Row {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListMessage.Row").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Row {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Row {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ListMessage.Product)
    pub struct Product {
        // message fields
        // @@protoc_insertion_point(field:proto.ListMessage.Product.productId)
        pub productId: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ListMessage.Product.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Product {
        fn default() -> &'a Product {
            <Product as ::protobuf::Message>::default_instance()
        }
    }

    impl Product {
        pub fn new() -> Product {
            ::std::default::Default::default()
        }

        // optional string productId = 1;

        pub fn productId(&self) -> &str {
            match self.productId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_productId(&mut self) {
            self.productId = ::std::option::Option::None;
        }

        pub fn has_productId(&self) -> bool {
            self.productId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_productId(&mut self, v: ::std::string::String) {
            self.productId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_productId(&mut self) -> &mut ::std::string::String {
            if self.productId.is_none() {
                self.productId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.productId.as_mut().unwrap()
        }

        // Take field
        pub fn take_productId(&mut self) -> ::std::string::String {
            self.productId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "productId",
                |m: &Product| { &m.productId },
                |m: &mut Product| { &mut m.productId },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Product>(
                "ListMessage.Product",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Product {
        const NAME: &'static str = "Product";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.productId = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.productId.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.productId.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Product {
            Product::new()
        }

        fn clear(&mut self) {
            self.productId = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Product {
            static instance: Product = Product {
                productId: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Product {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListMessage.Product").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Product {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Product {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ListMessage.ProductSection)
    pub struct ProductSection {
        // message fields
        // @@protoc_insertion_point(field:proto.ListMessage.ProductSection.title)
        pub title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ListMessage.ProductSection.products)
        pub products: ::std::vec::Vec<Product>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ListMessage.ProductSection.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProductSection {
        fn default() -> &'a ProductSection {
            <ProductSection as ::protobuf::Message>::default_instance()
        }
    }

    impl ProductSection {
        pub fn new() -> ProductSection {
            ::std::default::Default::default()
        }

        // optional string title = 1;

        pub fn title(&self) -> &str {
            match self.title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_title(&self) -> bool {
            self.title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            if self.title.is_none() {
                self.title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title.as_mut().unwrap()
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            self.title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "title",
                |m: &ProductSection| { &m.title },
                |m: &mut ProductSection| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "products",
                |m: &ProductSection| { &m.products },
                |m: &mut ProductSection| { &mut m.products },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSection>(
                "ListMessage.ProductSection",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProductSection {
        const NAME: &'static str = "ProductSection";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.products.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.title.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.products {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.title.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.products {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProductSection {
            ProductSection::new()
        }

        fn clear(&mut self) {
            self.title = ::std::option::Option::None;
            self.products.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProductSection {
            static instance: ProductSection = ProductSection {
                title: ::std::option::Option::None,
                products: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProductSection {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListMessage.ProductSection").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProductSection {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProductSection {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ListMessage.ProductListInfo)
    pub struct ProductListInfo {
        // message fields
        // @@protoc_insertion_point(field:proto.ListMessage.ProductListInfo.productSections)
        pub productSections: ::std::vec::Vec<ProductSection>,
        // @@protoc_insertion_point(field:proto.ListMessage.ProductListInfo.headerImage)
        pub headerImage: ::protobuf::MessageField<ProductListHeaderImage>,
        // @@protoc_insertion_point(field:proto.ListMessage.ProductListInfo.businessOwnerJid)
        pub businessOwnerJid: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ListMessage.ProductListInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProductListInfo {
        fn default() -> &'a ProductListInfo {
            <ProductListInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ProductListInfo {
        pub fn new() -> ProductListInfo {
            ::std::default::Default::default()
        }

        // optional string businessOwnerJid = 3;

        pub fn businessOwnerJid(&self) -> &str {
            match self.businessOwnerJid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_businessOwnerJid(&mut self) {
            self.businessOwnerJid = ::std::option::Option::None;
        }

        pub fn has_businessOwnerJid(&self) -> bool {
            self.businessOwnerJid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_businessOwnerJid(&mut self, v: ::std::string::String) {
            self.businessOwnerJid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_businessOwnerJid(&mut self) -> &mut ::std::string::String {
            if self.businessOwnerJid.is_none() {
                self.businessOwnerJid = ::std::option::Option::Some(::std::string::String::new());
            }
            self.businessOwnerJid.as_mut().unwrap()
        }

        // Take field
        pub fn take_businessOwnerJid(&mut self) -> ::std::string::String {
            self.businessOwnerJid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "productSections",
                |m: &ProductListInfo| { &m.productSections },
                |m: &mut ProductListInfo| { &mut m.productSections },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductListHeaderImage>(
                "headerImage",
                |m: &ProductListInfo| { &m.headerImage },
                |m: &mut ProductListInfo| { &mut m.headerImage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "businessOwnerJid",
                |m: &ProductListInfo| { &m.businessOwnerJid },
                |m: &mut ProductListInfo| { &mut m.businessOwnerJid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductListInfo>(
                "ListMessage.ProductListInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProductListInfo {
        const NAME: &'static str = "ProductListInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.productSections.push(is.read_message()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.headerImage)?;
                    },
                    26 => {
                        self.businessOwnerJid = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.productSections {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.headerImage.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.businessOwnerJid.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.productSections {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.headerImage.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.businessOwnerJid.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProductListInfo {
            ProductListInfo::new()
        }

        fn clear(&mut self) {
            self.productSections.clear();
            self.headerImage.clear();
            self.businessOwnerJid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProductListInfo {
            static instance: ProductListInfo = ProductListInfo {
                productSections: ::std::vec::Vec::new(),
                headerImage: ::protobuf::MessageField::none(),
                businessOwnerJid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProductListInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListMessage.ProductListInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProductListInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProductListInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ListMessage.ProductListHeaderImage)
    pub struct ProductListHeaderImage {
        // message fields
        // @@protoc_insertion_point(field:proto.ListMessage.ProductListHeaderImage.productId)
        pub productId: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ListMessage.ProductListHeaderImage.jpegThumbnail)
        pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ListMessage.ProductListHeaderImage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProductListHeaderImage {
        fn default() -> &'a ProductListHeaderImage {
            <ProductListHeaderImage as ::protobuf::Message>::default_instance()
        }
    }

    impl ProductListHeaderImage {
        pub fn new() -> ProductListHeaderImage {
            ::std::default::Default::default()
        }

        // optional string productId = 1;

        pub fn productId(&self) -> &str {
            match self.productId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_productId(&mut self) {
            self.productId = ::std::option::Option::None;
        }

        pub fn has_productId(&self) -> bool {
            self.productId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_productId(&mut self, v: ::std::string::String) {
            self.productId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_productId(&mut self) -> &mut ::std::string::String {
            if self.productId.is_none() {
                self.productId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.productId.as_mut().unwrap()
        }

        // Take field
        pub fn take_productId(&mut self) -> ::std::string::String {
            self.productId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes jpegThumbnail = 2;

        pub fn jpegThumbnail(&self) -> &[u8] {
            match self.jpegThumbnail.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_jpegThumbnail(&mut self) {
            self.jpegThumbnail = ::std::option::Option::None;
        }

        pub fn has_jpegThumbnail(&self) -> bool {
            self.jpegThumbnail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
            self.jpegThumbnail = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.jpegThumbnail.is_none() {
                self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.jpegThumbnail.as_mut().unwrap()
        }

        // Take field
        pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
            self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "productId",
                |m: &ProductListHeaderImage| { &m.productId },
                |m: &mut ProductListHeaderImage| { &mut m.productId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "jpegThumbnail",
                |m: &ProductListHeaderImage| { &m.jpegThumbnail },
                |m: &mut ProductListHeaderImage| { &mut m.jpegThumbnail },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductListHeaderImage>(
                "ListMessage.ProductListHeaderImage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProductListHeaderImage {
        const NAME: &'static str = "ProductListHeaderImage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.productId = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.productId.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.jpegThumbnail.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.productId.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.jpegThumbnail.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProductListHeaderImage {
            ProductListHeaderImage::new()
        }

        fn clear(&mut self) {
            self.productId = ::std::option::Option::None;
            self.jpegThumbnail = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProductListHeaderImage {
            static instance: ProductListHeaderImage = ProductListHeaderImage {
                productId: ::std::option::Option::None,
                jpegThumbnail: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProductListHeaderImage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ListMessage.ProductListHeaderImage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProductListHeaderImage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProductListHeaderImage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ListMessage.ListType)
    pub enum ListType {
        // @@protoc_insertion_point(enum_value:proto.ListMessage.ListType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.ListMessage.ListType.SINGLE_SELECT)
        SINGLE_SELECT = 1,
        // @@protoc_insertion_point(enum_value:proto.ListMessage.ListType.PRODUCT_LIST)
        PRODUCT_LIST = 2,
    }

    impl ::protobuf::Enum for ListType {
        const NAME: &'static str = "ListType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ListType> {
            match value {
                0 => ::std::option::Option::Some(ListType::UNKNOWN),
                1 => ::std::option::Option::Some(ListType::SINGLE_SELECT),
                2 => ::std::option::Option::Some(ListType::PRODUCT_LIST),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ListType] = &[
            ListType::UNKNOWN,
            ListType::SINGLE_SELECT,
            ListType::PRODUCT_LIST,
        ];
    }

    impl ::protobuf::EnumFull for ListType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ListMessage.ListType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ListType {
        fn default() -> Self {
            ListType::UNKNOWN
        }
    }

    impl ListType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ListType>("ListMessage.ListType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.KeepInChatMessage)
pub struct KeepInChatMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.KeepInChatMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.KeepInChatMessage.keepType)
    pub keepType: ::std::option::Option<::protobuf::EnumOrUnknown<KeepType>>,
    // @@protoc_insertion_point(field:proto.KeepInChatMessage.timestampMs)
    pub timestampMs: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.KeepInChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeepInChatMessage {
    fn default() -> &'a KeepInChatMessage {
        <KeepInChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl KeepInChatMessage {
    pub fn new() -> KeepInChatMessage {
        ::std::default::Default::default()
    }

    // optional .proto.KeepType keepType = 2;

    pub fn keepType(&self) -> KeepType {
        match self.keepType {
            Some(e) => e.enum_value_or(KeepType::UNKNOWN),
            None => KeepType::UNKNOWN,
        }
    }

    pub fn clear_keepType(&mut self) {
        self.keepType = ::std::option::Option::None;
    }

    pub fn has_keepType(&self) -> bool {
        self.keepType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keepType(&mut self, v: KeepType) {
        self.keepType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 timestampMs = 3;

    pub fn timestampMs(&self) -> i64 {
        self.timestampMs.unwrap_or(0)
    }

    pub fn clear_timestampMs(&mut self) {
        self.timestampMs = ::std::option::Option::None;
    }

    pub fn has_timestampMs(&self) -> bool {
        self.timestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestampMs(&mut self, v: i64) {
        self.timestampMs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &KeepInChatMessage| { &m.key },
            |m: &mut KeepInChatMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keepType",
            |m: &KeepInChatMessage| { &m.keepType },
            |m: &mut KeepInChatMessage| { &mut m.keepType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestampMs",
            |m: &KeepInChatMessage| { &m.timestampMs },
            |m: &mut KeepInChatMessage| { &mut m.timestampMs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeepInChatMessage>(
            "KeepInChatMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeepInChatMessage {
    const NAME: &'static str = "KeepInChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.keepType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.timestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keepType {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.timestampMs {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.keepType {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestampMs {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeepInChatMessage {
        KeepInChatMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.keepType = ::std::option::Option::None;
        self.timestampMs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeepInChatMessage {
        static instance: KeepInChatMessage = KeepInChatMessage {
            key: ::protobuf::MessageField::none(),
            keepType: ::std::option::Option::None,
            timestampMs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeepInChatMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeepInChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeepInChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeepInChatMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.InvoiceMessage)
pub struct InvoiceMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.InvoiceMessage.note)
    pub note: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.token)
    pub token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.attachmentType)
    pub attachmentType: ::std::option::Option<::protobuf::EnumOrUnknown<invoice_message::AttachmentType>>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.attachmentMimetype)
    pub attachmentMimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.attachmentMediaKey)
    pub attachmentMediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.attachmentMediaKeyTimestamp)
    pub attachmentMediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.attachmentFileSha256)
    pub attachmentFileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.attachmentFileEncSha256)
    pub attachmentFileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.attachmentDirectPath)
    pub attachmentDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.InvoiceMessage.attachmentJpegThumbnail)
    pub attachmentJpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.InvoiceMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InvoiceMessage {
    fn default() -> &'a InvoiceMessage {
        <InvoiceMessage as ::protobuf::Message>::default_instance()
    }
}

impl InvoiceMessage {
    pub fn new() -> InvoiceMessage {
        ::std::default::Default::default()
    }

    // optional string note = 1;

    pub fn note(&self) -> &str {
        match self.note.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_note(&mut self) {
        self.note = ::std::option::Option::None;
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::string::String) {
        self.note = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::string::String {
        if self.note.is_none() {
            self.note = ::std::option::Option::Some(::std::string::String::new());
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::string::String {
        self.note.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string token = 2;

    pub fn token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.InvoiceMessage.AttachmentType attachmentType = 3;

    pub fn attachmentType(&self) -> invoice_message::AttachmentType {
        match self.attachmentType {
            Some(e) => e.enum_value_or(invoice_message::AttachmentType::IMAGE),
            None => invoice_message::AttachmentType::IMAGE,
        }
    }

    pub fn clear_attachmentType(&mut self) {
        self.attachmentType = ::std::option::Option::None;
    }

    pub fn has_attachmentType(&self) -> bool {
        self.attachmentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentType(&mut self, v: invoice_message::AttachmentType) {
        self.attachmentType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string attachmentMimetype = 4;

    pub fn attachmentMimetype(&self) -> &str {
        match self.attachmentMimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attachmentMimetype(&mut self) {
        self.attachmentMimetype = ::std::option::Option::None;
    }

    pub fn has_attachmentMimetype(&self) -> bool {
        self.attachmentMimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentMimetype(&mut self, v: ::std::string::String) {
        self.attachmentMimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentMimetype(&mut self) -> &mut ::std::string::String {
        if self.attachmentMimetype.is_none() {
            self.attachmentMimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attachmentMimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentMimetype(&mut self) -> ::std::string::String {
        self.attachmentMimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes attachmentMediaKey = 5;

    pub fn attachmentMediaKey(&self) -> &[u8] {
        match self.attachmentMediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_attachmentMediaKey(&mut self) {
        self.attachmentMediaKey = ::std::option::Option::None;
    }

    pub fn has_attachmentMediaKey(&self) -> bool {
        self.attachmentMediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentMediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.attachmentMediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentMediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attachmentMediaKey.is_none() {
            self.attachmentMediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.attachmentMediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentMediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.attachmentMediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 attachmentMediaKeyTimestamp = 6;

    pub fn attachmentMediaKeyTimestamp(&self) -> i64 {
        self.attachmentMediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_attachmentMediaKeyTimestamp(&mut self) {
        self.attachmentMediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_attachmentMediaKeyTimestamp(&self) -> bool {
        self.attachmentMediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentMediaKeyTimestamp(&mut self, v: i64) {
        self.attachmentMediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes attachmentFileSha256 = 7;

    pub fn attachmentFileSha256(&self) -> &[u8] {
        match self.attachmentFileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_attachmentFileSha256(&mut self) {
        self.attachmentFileSha256 = ::std::option::Option::None;
    }

    pub fn has_attachmentFileSha256(&self) -> bool {
        self.attachmentFileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentFileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.attachmentFileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentFileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attachmentFileSha256.is_none() {
            self.attachmentFileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.attachmentFileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentFileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.attachmentFileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes attachmentFileEncSha256 = 8;

    pub fn attachmentFileEncSha256(&self) -> &[u8] {
        match self.attachmentFileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_attachmentFileEncSha256(&mut self) {
        self.attachmentFileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_attachmentFileEncSha256(&self) -> bool {
        self.attachmentFileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentFileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.attachmentFileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentFileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attachmentFileEncSha256.is_none() {
            self.attachmentFileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.attachmentFileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentFileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.attachmentFileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string attachmentDirectPath = 9;

    pub fn attachmentDirectPath(&self) -> &str {
        match self.attachmentDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attachmentDirectPath(&mut self) {
        self.attachmentDirectPath = ::std::option::Option::None;
    }

    pub fn has_attachmentDirectPath(&self) -> bool {
        self.attachmentDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentDirectPath(&mut self, v: ::std::string::String) {
        self.attachmentDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentDirectPath(&mut self) -> &mut ::std::string::String {
        if self.attachmentDirectPath.is_none() {
            self.attachmentDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attachmentDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentDirectPath(&mut self) -> ::std::string::String {
        self.attachmentDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes attachmentJpegThumbnail = 10;

    pub fn attachmentJpegThumbnail(&self) -> &[u8] {
        match self.attachmentJpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_attachmentJpegThumbnail(&mut self) {
        self.attachmentJpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_attachmentJpegThumbnail(&self) -> bool {
        self.attachmentJpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentJpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.attachmentJpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attachmentJpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.attachmentJpegThumbnail.is_none() {
            self.attachmentJpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.attachmentJpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_attachmentJpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.attachmentJpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "note",
            |m: &InvoiceMessage| { &m.note },
            |m: &mut InvoiceMessage| { &mut m.note },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &InvoiceMessage| { &m.token },
            |m: &mut InvoiceMessage| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentType",
            |m: &InvoiceMessage| { &m.attachmentType },
            |m: &mut InvoiceMessage| { &mut m.attachmentType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentMimetype",
            |m: &InvoiceMessage| { &m.attachmentMimetype },
            |m: &mut InvoiceMessage| { &mut m.attachmentMimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentMediaKey",
            |m: &InvoiceMessage| { &m.attachmentMediaKey },
            |m: &mut InvoiceMessage| { &mut m.attachmentMediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentMediaKeyTimestamp",
            |m: &InvoiceMessage| { &m.attachmentMediaKeyTimestamp },
            |m: &mut InvoiceMessage| { &mut m.attachmentMediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentFileSha256",
            |m: &InvoiceMessage| { &m.attachmentFileSha256 },
            |m: &mut InvoiceMessage| { &mut m.attachmentFileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentFileEncSha256",
            |m: &InvoiceMessage| { &m.attachmentFileEncSha256 },
            |m: &mut InvoiceMessage| { &mut m.attachmentFileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentDirectPath",
            |m: &InvoiceMessage| { &m.attachmentDirectPath },
            |m: &mut InvoiceMessage| { &mut m.attachmentDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentJpegThumbnail",
            |m: &InvoiceMessage| { &m.attachmentJpegThumbnail },
            |m: &mut InvoiceMessage| { &mut m.attachmentJpegThumbnail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InvoiceMessage>(
            "InvoiceMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InvoiceMessage {
    const NAME: &'static str = "InvoiceMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.note = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.token = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.attachmentType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.attachmentMimetype = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.attachmentMediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.attachmentMediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                58 => {
                    self.attachmentFileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.attachmentFileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.attachmentDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.attachmentJpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.note.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.attachmentType {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.attachmentMimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.attachmentMediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.attachmentMediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.attachmentFileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.attachmentFileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.attachmentDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.attachmentJpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.note.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.token.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.attachmentType {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.attachmentMimetype.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.attachmentMediaKey.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.attachmentMediaKeyTimestamp {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.attachmentFileSha256.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.attachmentFileEncSha256.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.attachmentDirectPath.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.attachmentJpegThumbnail.as_ref() {
            os.write_bytes(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InvoiceMessage {
        InvoiceMessage::new()
    }

    fn clear(&mut self) {
        self.note = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.attachmentType = ::std::option::Option::None;
        self.attachmentMimetype = ::std::option::Option::None;
        self.attachmentMediaKey = ::std::option::Option::None;
        self.attachmentMediaKeyTimestamp = ::std::option::Option::None;
        self.attachmentFileSha256 = ::std::option::Option::None;
        self.attachmentFileEncSha256 = ::std::option::Option::None;
        self.attachmentDirectPath = ::std::option::Option::None;
        self.attachmentJpegThumbnail = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InvoiceMessage {
        static instance: InvoiceMessage = InvoiceMessage {
            note: ::std::option::Option::None,
            token: ::std::option::Option::None,
            attachmentType: ::std::option::Option::None,
            attachmentMimetype: ::std::option::Option::None,
            attachmentMediaKey: ::std::option::Option::None,
            attachmentMediaKeyTimestamp: ::std::option::Option::None,
            attachmentFileSha256: ::std::option::Option::None,
            attachmentFileEncSha256: ::std::option::Option::None,
            attachmentDirectPath: ::std::option::Option::None,
            attachmentJpegThumbnail: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InvoiceMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InvoiceMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InvoiceMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvoiceMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InvoiceMessage`
pub mod invoice_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.InvoiceMessage.AttachmentType)
    pub enum AttachmentType {
        // @@protoc_insertion_point(enum_value:proto.InvoiceMessage.AttachmentType.IMAGE)
        IMAGE = 0,
        // @@protoc_insertion_point(enum_value:proto.InvoiceMessage.AttachmentType.PDF)
        PDF = 1,
    }

    impl ::protobuf::Enum for AttachmentType {
        const NAME: &'static str = "AttachmentType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AttachmentType> {
            match value {
                0 => ::std::option::Option::Some(AttachmentType::IMAGE),
                1 => ::std::option::Option::Some(AttachmentType::PDF),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AttachmentType] = &[
            AttachmentType::IMAGE,
            AttachmentType::PDF,
        ];
    }

    impl ::protobuf::EnumFull for AttachmentType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("InvoiceMessage.AttachmentType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for AttachmentType {
        fn default() -> Self {
            AttachmentType::IMAGE
        }
    }

    impl AttachmentType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AttachmentType>("InvoiceMessage.AttachmentType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.InteractiveResponseMessage)
pub struct InteractiveResponseMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.InteractiveResponseMessage.body)
    pub body: ::protobuf::MessageField<interactive_response_message::Body>,
    // @@protoc_insertion_point(field:proto.InteractiveResponseMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // message oneof groups
    pub interactiveResponseMessage: ::std::option::Option<interactive_response_message::InteractiveResponseMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.InteractiveResponseMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractiveResponseMessage {
    fn default() -> &'a InteractiveResponseMessage {
        <InteractiveResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl InteractiveResponseMessage {
    pub fn new() -> InteractiveResponseMessage {
        ::std::default::Default::default()
    }

    // optional .proto.InteractiveResponseMessage.NativeFlowResponseMessage nativeFlowResponseMessage = 2;

    pub fn nativeFlowResponseMessage(&self) -> &interactive_response_message::NativeFlowResponseMessage {
        match self.interactiveResponseMessage {
            ::std::option::Option::Some(interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(ref v)) => v,
            _ => <interactive_response_message::NativeFlowResponseMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_nativeFlowResponseMessage(&mut self) {
        self.interactiveResponseMessage = ::std::option::Option::None;
    }

    pub fn has_nativeFlowResponseMessage(&self) -> bool {
        match self.interactiveResponseMessage {
            ::std::option::Option::Some(interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nativeFlowResponseMessage(&mut self, v: interactive_response_message::NativeFlowResponseMessage) {
        self.interactiveResponseMessage = ::std::option::Option::Some(interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nativeFlowResponseMessage(&mut self) -> &mut interactive_response_message::NativeFlowResponseMessage {
        if let ::std::option::Option::Some(interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(_)) = self.interactiveResponseMessage {
        } else {
            self.interactiveResponseMessage = ::std::option::Option::Some(interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(interactive_response_message::NativeFlowResponseMessage::new()));
        }
        match self.interactiveResponseMessage {
            ::std::option::Option::Some(interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nativeFlowResponseMessage(&mut self) -> interactive_response_message::NativeFlowResponseMessage {
        if self.has_nativeFlowResponseMessage() {
            match self.interactiveResponseMessage.take() {
                ::std::option::Option::Some(interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            interactive_response_message::NativeFlowResponseMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, interactive_response_message::Body>(
            "body",
            |m: &InteractiveResponseMessage| { &m.body },
            |m: &mut InteractiveResponseMessage| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &InteractiveResponseMessage| { &m.contextInfo },
            |m: &mut InteractiveResponseMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, interactive_response_message::NativeFlowResponseMessage>(
            "nativeFlowResponseMessage",
            InteractiveResponseMessage::has_nativeFlowResponseMessage,
            InteractiveResponseMessage::nativeFlowResponseMessage,
            InteractiveResponseMessage::mut_nativeFlowResponseMessage,
            InteractiveResponseMessage::set_nativeFlowResponseMessage,
        ));
        oneofs.push(interactive_response_message::InteractiveResponseMessage::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractiveResponseMessage>(
            "InteractiveResponseMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractiveResponseMessage {
    const NAME: &'static str = "InteractiveResponseMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.body)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                18 => {
                    self.interactiveResponseMessage = ::std::option::Option::Some(interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.interactiveResponseMessage {
            match v {
                &interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.body.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.interactiveResponseMessage {
            match v {
                &interactive_response_message::InteractiveResponseMessage::NativeFlowResponseMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractiveResponseMessage {
        InteractiveResponseMessage::new()
    }

    fn clear(&mut self) {
        self.body.clear();
        self.contextInfo.clear();
        self.interactiveResponseMessage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractiveResponseMessage {
        static instance: InteractiveResponseMessage = InteractiveResponseMessage {
            body: ::protobuf::MessageField::none(),
            contextInfo: ::protobuf::MessageField::none(),
            interactiveResponseMessage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractiveResponseMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractiveResponseMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractiveResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractiveResponseMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InteractiveResponseMessage`
pub mod interactive_response_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:proto.InteractiveResponseMessage.interactiveResponseMessage)
    pub enum InteractiveResponseMessage {
        // @@protoc_insertion_point(oneof_field:proto.InteractiveResponseMessage.nativeFlowResponseMessage)
        NativeFlowResponseMessage(NativeFlowResponseMessage),
    }

    impl ::protobuf::Oneof for InteractiveResponseMessage {
    }

    impl ::protobuf::OneofFull for InteractiveResponseMessage {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InteractiveResponseMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("interactiveResponseMessage").unwrap()).clone()
        }
    }

    impl InteractiveResponseMessage {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<InteractiveResponseMessage>("interactiveResponseMessage")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.InteractiveResponseMessage.NativeFlowResponseMessage)
    pub struct NativeFlowResponseMessage {
        // message fields
        // @@protoc_insertion_point(field:proto.InteractiveResponseMessage.NativeFlowResponseMessage.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.InteractiveResponseMessage.NativeFlowResponseMessage.paramsJson)
        pub paramsJson: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.InteractiveResponseMessage.NativeFlowResponseMessage.version)
        pub version: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.InteractiveResponseMessage.NativeFlowResponseMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NativeFlowResponseMessage {
        fn default() -> &'a NativeFlowResponseMessage {
            <NativeFlowResponseMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl NativeFlowResponseMessage {
        pub fn new() -> NativeFlowResponseMessage {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string paramsJson = 2;

        pub fn paramsJson(&self) -> &str {
            match self.paramsJson.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_paramsJson(&mut self) {
            self.paramsJson = ::std::option::Option::None;
        }

        pub fn has_paramsJson(&self) -> bool {
            self.paramsJson.is_some()
        }

        // Param is passed by value, moved
        pub fn set_paramsJson(&mut self, v: ::std::string::String) {
            self.paramsJson = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_paramsJson(&mut self) -> &mut ::std::string::String {
            if self.paramsJson.is_none() {
                self.paramsJson = ::std::option::Option::Some(::std::string::String::new());
            }
            self.paramsJson.as_mut().unwrap()
        }

        // Take field
        pub fn take_paramsJson(&mut self) -> ::std::string::String {
            self.paramsJson.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 version = 3;

        pub fn version(&self) -> i32 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: i32) {
            self.version = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &NativeFlowResponseMessage| { &m.name },
                |m: &mut NativeFlowResponseMessage| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "paramsJson",
                |m: &NativeFlowResponseMessage| { &m.paramsJson },
                |m: &mut NativeFlowResponseMessage| { &mut m.paramsJson },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &NativeFlowResponseMessage| { &m.version },
                |m: &mut NativeFlowResponseMessage| { &mut m.version },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeFlowResponseMessage>(
                "InteractiveResponseMessage.NativeFlowResponseMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NativeFlowResponseMessage {
        const NAME: &'static str = "NativeFlowResponseMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.paramsJson = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.version = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.paramsJson.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.version {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.paramsJson.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.version {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NativeFlowResponseMessage {
            NativeFlowResponseMessage::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.paramsJson = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NativeFlowResponseMessage {
            static instance: NativeFlowResponseMessage = NativeFlowResponseMessage {
                name: ::std::option::Option::None,
                paramsJson: ::std::option::Option::None,
                version: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NativeFlowResponseMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InteractiveResponseMessage.NativeFlowResponseMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NativeFlowResponseMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NativeFlowResponseMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.InteractiveResponseMessage.Body)
    pub struct Body {
        // message fields
        // @@protoc_insertion_point(field:proto.InteractiveResponseMessage.Body.text)
        pub text: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.InteractiveResponseMessage.Body.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Body {
        fn default() -> &'a Body {
            <Body as ::protobuf::Message>::default_instance()
        }
    }

    impl Body {
        pub fn new() -> Body {
            ::std::default::Default::default()
        }

        // optional string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "text",
                |m: &Body| { &m.text },
                |m: &mut Body| { &mut m.text },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Body>(
                "InteractiveResponseMessage.Body",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Body {
        const NAME: &'static str = "Body";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Body {
            Body::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Body {
            static instance: Body = Body {
                text: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Body {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InteractiveResponseMessage.Body").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Body {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Body {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.InteractiveMessage)
pub struct InteractiveMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.InteractiveMessage.header)
    pub header: ::protobuf::MessageField<interactive_message::Header>,
    // @@protoc_insertion_point(field:proto.InteractiveMessage.body)
    pub body: ::protobuf::MessageField<interactive_message::Body>,
    // @@protoc_insertion_point(field:proto.InteractiveMessage.footer)
    pub footer: ::protobuf::MessageField<interactive_message::Footer>,
    // @@protoc_insertion_point(field:proto.InteractiveMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // message oneof groups
    pub interactiveMessage: ::std::option::Option<interactive_message::InteractiveMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.InteractiveMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractiveMessage {
    fn default() -> &'a InteractiveMessage {
        <InteractiveMessage as ::protobuf::Message>::default_instance()
    }
}

impl InteractiveMessage {
    pub fn new() -> InteractiveMessage {
        ::std::default::Default::default()
    }

    // optional .proto.InteractiveMessage.ShopMessage shopStorefrontMessage = 4;

    pub fn shopStorefrontMessage(&self) -> &interactive_message::ShopMessage {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(ref v)) => v,
            _ => <interactive_message::ShopMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_shopStorefrontMessage(&mut self) {
        self.interactiveMessage = ::std::option::Option::None;
    }

    pub fn has_shopStorefrontMessage(&self) -> bool {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shopStorefrontMessage(&mut self, v: interactive_message::ShopMessage) {
        self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shopStorefrontMessage(&mut self) -> &mut interactive_message::ShopMessage {
        if let ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(_)) = self.interactiveMessage {
        } else {
            self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(interactive_message::ShopMessage::new()));
        }
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shopStorefrontMessage(&mut self) -> interactive_message::ShopMessage {
        if self.has_shopStorefrontMessage() {
            match self.interactiveMessage.take() {
                ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            interactive_message::ShopMessage::new()
        }
    }

    // optional .proto.InteractiveMessage.CollectionMessage collectionMessage = 5;

    pub fn collectionMessage(&self) -> &interactive_message::CollectionMessage {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(ref v)) => v,
            _ => <interactive_message::CollectionMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_collectionMessage(&mut self) {
        self.interactiveMessage = ::std::option::Option::None;
    }

    pub fn has_collectionMessage(&self) -> bool {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_collectionMessage(&mut self, v: interactive_message::CollectionMessage) {
        self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_collectionMessage(&mut self) -> &mut interactive_message::CollectionMessage {
        if let ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(_)) = self.interactiveMessage {
        } else {
            self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(interactive_message::CollectionMessage::new()));
        }
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_collectionMessage(&mut self) -> interactive_message::CollectionMessage {
        if self.has_collectionMessage() {
            match self.interactiveMessage.take() {
                ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            interactive_message::CollectionMessage::new()
        }
    }

    // optional .proto.InteractiveMessage.NativeFlowMessage nativeFlowMessage = 6;

    pub fn nativeFlowMessage(&self) -> &interactive_message::NativeFlowMessage {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(ref v)) => v,
            _ => <interactive_message::NativeFlowMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_nativeFlowMessage(&mut self) {
        self.interactiveMessage = ::std::option::Option::None;
    }

    pub fn has_nativeFlowMessage(&self) -> bool {
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nativeFlowMessage(&mut self, v: interactive_message::NativeFlowMessage) {
        self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nativeFlowMessage(&mut self) -> &mut interactive_message::NativeFlowMessage {
        if let ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(_)) = self.interactiveMessage {
        } else {
            self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(interactive_message::NativeFlowMessage::new()));
        }
        match self.interactiveMessage {
            ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nativeFlowMessage(&mut self) -> interactive_message::NativeFlowMessage {
        if self.has_nativeFlowMessage() {
            match self.interactiveMessage.take() {
                ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            interactive_message::NativeFlowMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, interactive_message::Header>(
            "header",
            |m: &InteractiveMessage| { &m.header },
            |m: &mut InteractiveMessage| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, interactive_message::Body>(
            "body",
            |m: &InteractiveMessage| { &m.body },
            |m: &mut InteractiveMessage| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, interactive_message::Footer>(
            "footer",
            |m: &InteractiveMessage| { &m.footer },
            |m: &mut InteractiveMessage| { &mut m.footer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &InteractiveMessage| { &m.contextInfo },
            |m: &mut InteractiveMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, interactive_message::ShopMessage>(
            "shopStorefrontMessage",
            InteractiveMessage::has_shopStorefrontMessage,
            InteractiveMessage::shopStorefrontMessage,
            InteractiveMessage::mut_shopStorefrontMessage,
            InteractiveMessage::set_shopStorefrontMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, interactive_message::CollectionMessage>(
            "collectionMessage",
            InteractiveMessage::has_collectionMessage,
            InteractiveMessage::collectionMessage,
            InteractiveMessage::mut_collectionMessage,
            InteractiveMessage::set_collectionMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, interactive_message::NativeFlowMessage>(
            "nativeFlowMessage",
            InteractiveMessage::has_nativeFlowMessage,
            InteractiveMessage::nativeFlowMessage,
            InteractiveMessage::mut_nativeFlowMessage,
            InteractiveMessage::set_nativeFlowMessage,
        ));
        oneofs.push(interactive_message::InteractiveMessage::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractiveMessage>(
            "InteractiveMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractiveMessage {
    const NAME: &'static str = "InteractiveMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.body)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.footer)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                34 => {
                    self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::ShopStorefrontMessage(is.read_message()?));
                },
                42 => {
                    self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::CollectionMessage(is.read_message()?));
                },
                50 => {
                    self.interactiveMessage = ::std::option::Option::Some(interactive_message::InteractiveMessage::NativeFlowMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.footer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.interactiveMessage {
            match v {
                &interactive_message::InteractiveMessage::ShopStorefrontMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &interactive_message::InteractiveMessage::CollectionMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &interactive_message::InteractiveMessage::NativeFlowMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.body.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.footer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.interactiveMessage {
            match v {
                &interactive_message::InteractiveMessage::ShopStorefrontMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &interactive_message::InteractiveMessage::CollectionMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &interactive_message::InteractiveMessage::NativeFlowMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractiveMessage {
        InteractiveMessage::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.body.clear();
        self.footer.clear();
        self.contextInfo.clear();
        self.interactiveMessage = ::std::option::Option::None;
        self.interactiveMessage = ::std::option::Option::None;
        self.interactiveMessage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractiveMessage {
        static instance: InteractiveMessage = InteractiveMessage {
            header: ::protobuf::MessageField::none(),
            body: ::protobuf::MessageField::none(),
            footer: ::protobuf::MessageField::none(),
            contextInfo: ::protobuf::MessageField::none(),
            interactiveMessage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractiveMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractiveMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractiveMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractiveMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InteractiveMessage`
pub mod interactive_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:proto.InteractiveMessage.interactiveMessage)
    pub enum InteractiveMessage {
        // @@protoc_insertion_point(oneof_field:proto.InteractiveMessage.shopStorefrontMessage)
        ShopStorefrontMessage(ShopMessage),
        // @@protoc_insertion_point(oneof_field:proto.InteractiveMessage.collectionMessage)
        CollectionMessage(CollectionMessage),
        // @@protoc_insertion_point(oneof_field:proto.InteractiveMessage.nativeFlowMessage)
        NativeFlowMessage(NativeFlowMessage),
    }

    impl ::protobuf::Oneof for InteractiveMessage {
    }

    impl ::protobuf::OneofFull for InteractiveMessage {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InteractiveMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("interactiveMessage").unwrap()).clone()
        }
    }

    impl InteractiveMessage {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<InteractiveMessage>("interactiveMessage")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.InteractiveMessage.ShopMessage)
    pub struct ShopMessage {
        // message fields
        // @@protoc_insertion_point(field:proto.InteractiveMessage.ShopMessage.id)
        pub id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.InteractiveMessage.ShopMessage.surface)
        pub surface: ::std::option::Option<::protobuf::EnumOrUnknown<shop_message::Surface>>,
        // @@protoc_insertion_point(field:proto.InteractiveMessage.ShopMessage.messageVersion)
        pub messageVersion: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.InteractiveMessage.ShopMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ShopMessage {
        fn default() -> &'a ShopMessage {
            <ShopMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl ShopMessage {
        pub fn new() -> ShopMessage {
            ::std::default::Default::default()
        }

        // optional string id = 1;

        pub fn id(&self) -> &str {
            match self.id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: ::std::string::String) {
            self.id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_id(&mut self) -> &mut ::std::string::String {
            if self.id.is_none() {
                self.id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.id.as_mut().unwrap()
        }

        // Take field
        pub fn take_id(&mut self) -> ::std::string::String {
            self.id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .proto.InteractiveMessage.ShopMessage.Surface surface = 2;

        pub fn surface(&self) -> shop_message::Surface {
            match self.surface {
                Some(e) => e.enum_value_or(shop_message::Surface::UNKNOWN_SURFACE),
                None => shop_message::Surface::UNKNOWN_SURFACE,
            }
        }

        pub fn clear_surface(&mut self) {
            self.surface = ::std::option::Option::None;
        }

        pub fn has_surface(&self) -> bool {
            self.surface.is_some()
        }

        // Param is passed by value, moved
        pub fn set_surface(&mut self, v: shop_message::Surface) {
            self.surface = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional int32 messageVersion = 3;

        pub fn messageVersion(&self) -> i32 {
            self.messageVersion.unwrap_or(0)
        }

        pub fn clear_messageVersion(&mut self) {
            self.messageVersion = ::std::option::Option::None;
        }

        pub fn has_messageVersion(&self) -> bool {
            self.messageVersion.is_some()
        }

        // Param is passed by value, moved
        pub fn set_messageVersion(&mut self, v: i32) {
            self.messageVersion = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &ShopMessage| { &m.id },
                |m: &mut ShopMessage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "surface",
                |m: &ShopMessage| { &m.surface },
                |m: &mut ShopMessage| { &mut m.surface },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "messageVersion",
                |m: &ShopMessage| { &m.messageVersion },
                |m: &mut ShopMessage| { &mut m.messageVersion },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ShopMessage>(
                "InteractiveMessage.ShopMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ShopMessage {
        const NAME: &'static str = "ShopMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.surface = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.messageVersion = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.surface {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.messageVersion {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.surface {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.messageVersion {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ShopMessage {
            ShopMessage::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.surface = ::std::option::Option::None;
            self.messageVersion = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ShopMessage {
            static instance: ShopMessage = ShopMessage {
                id: ::std::option::Option::None,
                surface: ::std::option::Option::None,
                messageVersion: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ShopMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InteractiveMessage.ShopMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ShopMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ShopMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ShopMessage`
    pub mod shop_message {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:proto.InteractiveMessage.ShopMessage.Surface)
        pub enum Surface {
            // @@protoc_insertion_point(enum_value:proto.InteractiveMessage.ShopMessage.Surface.UNKNOWN_SURFACE)
            UNKNOWN_SURFACE = 0,
            // @@protoc_insertion_point(enum_value:proto.InteractiveMessage.ShopMessage.Surface.FB)
            FB = 1,
            // @@protoc_insertion_point(enum_value:proto.InteractiveMessage.ShopMessage.Surface.IG)
            IG = 2,
            // @@protoc_insertion_point(enum_value:proto.InteractiveMessage.ShopMessage.Surface.WA)
            WA = 3,
        }

        impl ::protobuf::Enum for Surface {
            const NAME: &'static str = "Surface";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Surface> {
                match value {
                    0 => ::std::option::Option::Some(Surface::UNKNOWN_SURFACE),
                    1 => ::std::option::Option::Some(Surface::FB),
                    2 => ::std::option::Option::Some(Surface::IG),
                    3 => ::std::option::Option::Some(Surface::WA),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Surface] = &[
                Surface::UNKNOWN_SURFACE,
                Surface::FB,
                Surface::IG,
                Surface::WA,
            ];
        }

        impl ::protobuf::EnumFull for Surface {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("InteractiveMessage.ShopMessage.Surface").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Surface {
            fn default() -> Self {
                Surface::UNKNOWN_SURFACE
            }
        }

        impl Surface {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Surface>("InteractiveMessage.ShopMessage.Surface")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.InteractiveMessage.NativeFlowMessage)
    pub struct NativeFlowMessage {
        // message fields
        // @@protoc_insertion_point(field:proto.InteractiveMessage.NativeFlowMessage.buttons)
        pub buttons: ::std::vec::Vec<native_flow_message::NativeFlowButton>,
        // @@protoc_insertion_point(field:proto.InteractiveMessage.NativeFlowMessage.messageParamsJson)
        pub messageParamsJson: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.InteractiveMessage.NativeFlowMessage.messageVersion)
        pub messageVersion: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.InteractiveMessage.NativeFlowMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NativeFlowMessage {
        fn default() -> &'a NativeFlowMessage {
            <NativeFlowMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl NativeFlowMessage {
        pub fn new() -> NativeFlowMessage {
            ::std::default::Default::default()
        }

        // optional string messageParamsJson = 2;

        pub fn messageParamsJson(&self) -> &str {
            match self.messageParamsJson.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_messageParamsJson(&mut self) {
            self.messageParamsJson = ::std::option::Option::None;
        }

        pub fn has_messageParamsJson(&self) -> bool {
            self.messageParamsJson.is_some()
        }

        // Param is passed by value, moved
        pub fn set_messageParamsJson(&mut self, v: ::std::string::String) {
            self.messageParamsJson = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_messageParamsJson(&mut self) -> &mut ::std::string::String {
            if self.messageParamsJson.is_none() {
                self.messageParamsJson = ::std::option::Option::Some(::std::string::String::new());
            }
            self.messageParamsJson.as_mut().unwrap()
        }

        // Take field
        pub fn take_messageParamsJson(&mut self) -> ::std::string::String {
            self.messageParamsJson.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 messageVersion = 3;

        pub fn messageVersion(&self) -> i32 {
            self.messageVersion.unwrap_or(0)
        }

        pub fn clear_messageVersion(&mut self) {
            self.messageVersion = ::std::option::Option::None;
        }

        pub fn has_messageVersion(&self) -> bool {
            self.messageVersion.is_some()
        }

        // Param is passed by value, moved
        pub fn set_messageVersion(&mut self, v: i32) {
            self.messageVersion = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "buttons",
                |m: &NativeFlowMessage| { &m.buttons },
                |m: &mut NativeFlowMessage| { &mut m.buttons },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "messageParamsJson",
                |m: &NativeFlowMessage| { &m.messageParamsJson },
                |m: &mut NativeFlowMessage| { &mut m.messageParamsJson },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "messageVersion",
                |m: &NativeFlowMessage| { &m.messageVersion },
                |m: &mut NativeFlowMessage| { &mut m.messageVersion },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeFlowMessage>(
                "InteractiveMessage.NativeFlowMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NativeFlowMessage {
        const NAME: &'static str = "NativeFlowMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.buttons.push(is.read_message()?);
                    },
                    18 => {
                        self.messageParamsJson = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.messageVersion = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.buttons {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.messageParamsJson.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.messageVersion {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.buttons {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.messageParamsJson.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.messageVersion {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NativeFlowMessage {
            NativeFlowMessage::new()
        }

        fn clear(&mut self) {
            self.buttons.clear();
            self.messageParamsJson = ::std::option::Option::None;
            self.messageVersion = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NativeFlowMessage {
            static instance: NativeFlowMessage = NativeFlowMessage {
                buttons: ::std::vec::Vec::new(),
                messageParamsJson: ::std::option::Option::None,
                messageVersion: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NativeFlowMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InteractiveMessage.NativeFlowMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NativeFlowMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NativeFlowMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `NativeFlowMessage`
    pub mod native_flow_message {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.InteractiveMessage.NativeFlowMessage.NativeFlowButton)
        pub struct NativeFlowButton {
            // message fields
            // @@protoc_insertion_point(field:proto.InteractiveMessage.NativeFlowMessage.NativeFlowButton.name)
            pub name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.InteractiveMessage.NativeFlowMessage.NativeFlowButton.buttonParamsJson)
            pub buttonParamsJson: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.InteractiveMessage.NativeFlowMessage.NativeFlowButton.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a NativeFlowButton {
            fn default() -> &'a NativeFlowButton {
                <NativeFlowButton as ::protobuf::Message>::default_instance()
            }
        }

        impl NativeFlowButton {
            pub fn new() -> NativeFlowButton {
                ::std::default::Default::default()
            }

            // optional string name = 1;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string buttonParamsJson = 2;

            pub fn buttonParamsJson(&self) -> &str {
                match self.buttonParamsJson.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_buttonParamsJson(&mut self) {
                self.buttonParamsJson = ::std::option::Option::None;
            }

            pub fn has_buttonParamsJson(&self) -> bool {
                self.buttonParamsJson.is_some()
            }

            // Param is passed by value, moved
            pub fn set_buttonParamsJson(&mut self, v: ::std::string::String) {
                self.buttonParamsJson = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_buttonParamsJson(&mut self) -> &mut ::std::string::String {
                if self.buttonParamsJson.is_none() {
                    self.buttonParamsJson = ::std::option::Option::Some(::std::string::String::new());
                }
                self.buttonParamsJson.as_mut().unwrap()
            }

            // Take field
            pub fn take_buttonParamsJson(&mut self) -> ::std::string::String {
                self.buttonParamsJson.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name",
                    |m: &NativeFlowButton| { &m.name },
                    |m: &mut NativeFlowButton| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "buttonParamsJson",
                    |m: &NativeFlowButton| { &m.buttonParamsJson },
                    |m: &mut NativeFlowButton| { &mut m.buttonParamsJson },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeFlowButton>(
                    "InteractiveMessage.NativeFlowMessage.NativeFlowButton",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for NativeFlowButton {
            const NAME: &'static str = "NativeFlowButton";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.buttonParamsJson = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.buttonParamsJson.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.buttonParamsJson.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> NativeFlowButton {
                NativeFlowButton::new()
            }

            fn clear(&mut self) {
                self.name = ::std::option::Option::None;
                self.buttonParamsJson = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static NativeFlowButton {
                static instance: NativeFlowButton = NativeFlowButton {
                    name: ::std::option::Option::None,
                    buttonParamsJson: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for NativeFlowButton {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("InteractiveMessage.NativeFlowMessage.NativeFlowButton").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for NativeFlowButton {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for NativeFlowButton {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.InteractiveMessage.Header)
    pub struct Header {
        // message fields
        // @@protoc_insertion_point(field:proto.InteractiveMessage.Header.title)
        pub title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.InteractiveMessage.Header.subtitle)
        pub subtitle: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.InteractiveMessage.Header.hasMediaAttachment)
        pub hasMediaAttachment: ::std::option::Option<bool>,
        // message oneof groups
        pub media: ::std::option::Option<header::Media>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.InteractiveMessage.Header.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Header {
        fn default() -> &'a Header {
            <Header as ::protobuf::Message>::default_instance()
        }
    }

    impl Header {
        pub fn new() -> Header {
            ::std::default::Default::default()
        }

        // optional string title = 1;

        pub fn title(&self) -> &str {
            match self.title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_title(&self) -> bool {
            self.title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            if self.title.is_none() {
                self.title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title.as_mut().unwrap()
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            self.title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string subtitle = 2;

        pub fn subtitle(&self) -> &str {
            match self.subtitle.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_subtitle(&mut self) {
            self.subtitle = ::std::option::Option::None;
        }

        pub fn has_subtitle(&self) -> bool {
            self.subtitle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_subtitle(&mut self, v: ::std::string::String) {
            self.subtitle = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_subtitle(&mut self) -> &mut ::std::string::String {
            if self.subtitle.is_none() {
                self.subtitle = ::std::option::Option::Some(::std::string::String::new());
            }
            self.subtitle.as_mut().unwrap()
        }

        // Take field
        pub fn take_subtitle(&mut self) -> ::std::string::String {
            self.subtitle.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool hasMediaAttachment = 5;

        pub fn hasMediaAttachment(&self) -> bool {
            self.hasMediaAttachment.unwrap_or(false)
        }

        pub fn clear_hasMediaAttachment(&mut self) {
            self.hasMediaAttachment = ::std::option::Option::None;
        }

        pub fn has_hasMediaAttachment(&self) -> bool {
            self.hasMediaAttachment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hasMediaAttachment(&mut self, v: bool) {
            self.hasMediaAttachment = ::std::option::Option::Some(v);
        }

        // optional .proto.DocumentMessage documentMessage = 3;

        pub fn documentMessage(&self) -> &super::DocumentMessage {
            match self.media {
                ::std::option::Option::Some(header::Media::DocumentMessage(ref v)) => v,
                _ => <super::DocumentMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_documentMessage(&mut self) {
            self.media = ::std::option::Option::None;
        }

        pub fn has_documentMessage(&self) -> bool {
            match self.media {
                ::std::option::Option::Some(header::Media::DocumentMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_documentMessage(&mut self, v: super::DocumentMessage) {
            self.media = ::std::option::Option::Some(header::Media::DocumentMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_documentMessage(&mut self) -> &mut super::DocumentMessage {
            if let ::std::option::Option::Some(header::Media::DocumentMessage(_)) = self.media {
            } else {
                self.media = ::std::option::Option::Some(header::Media::DocumentMessage(super::DocumentMessage::new()));
            }
            match self.media {
                ::std::option::Option::Some(header::Media::DocumentMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_documentMessage(&mut self) -> super::DocumentMessage {
            if self.has_documentMessage() {
                match self.media.take() {
                    ::std::option::Option::Some(header::Media::DocumentMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::DocumentMessage::new()
            }
        }

        // optional .proto.ImageMessage imageMessage = 4;

        pub fn imageMessage(&self) -> &super::ImageMessage {
            match self.media {
                ::std::option::Option::Some(header::Media::ImageMessage(ref v)) => v,
                _ => <super::ImageMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_imageMessage(&mut self) {
            self.media = ::std::option::Option::None;
        }

        pub fn has_imageMessage(&self) -> bool {
            match self.media {
                ::std::option::Option::Some(header::Media::ImageMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_imageMessage(&mut self, v: super::ImageMessage) {
            self.media = ::std::option::Option::Some(header::Media::ImageMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_imageMessage(&mut self) -> &mut super::ImageMessage {
            if let ::std::option::Option::Some(header::Media::ImageMessage(_)) = self.media {
            } else {
                self.media = ::std::option::Option::Some(header::Media::ImageMessage(super::ImageMessage::new()));
            }
            match self.media {
                ::std::option::Option::Some(header::Media::ImageMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_imageMessage(&mut self) -> super::ImageMessage {
            if self.has_imageMessage() {
                match self.media.take() {
                    ::std::option::Option::Some(header::Media::ImageMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::ImageMessage::new()
            }
        }

        // optional bytes jpegThumbnail = 6;

        pub fn jpegThumbnail(&self) -> &[u8] {
            match self.media {
                ::std::option::Option::Some(header::Media::JpegThumbnail(ref v)) => v,
                _ => &[],
            }
        }

        pub fn clear_jpegThumbnail(&mut self) {
            self.media = ::std::option::Option::None;
        }

        pub fn has_jpegThumbnail(&self) -> bool {
            match self.media {
                ::std::option::Option::Some(header::Media::JpegThumbnail(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
            self.media = ::std::option::Option::Some(header::Media::JpegThumbnail(v))
        }

        // Mutable pointer to the field.
        pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
            if let ::std::option::Option::Some(header::Media::JpegThumbnail(_)) = self.media {
            } else {
                self.media = ::std::option::Option::Some(header::Media::JpegThumbnail(::std::vec::Vec::new()));
            }
            match self.media {
                ::std::option::Option::Some(header::Media::JpegThumbnail(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
            if self.has_jpegThumbnail() {
                match self.media.take() {
                    ::std::option::Option::Some(header::Media::JpegThumbnail(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::vec::Vec::new()
            }
        }

        // optional .proto.VideoMessage videoMessage = 7;

        pub fn videoMessage(&self) -> &super::VideoMessage {
            match self.media {
                ::std::option::Option::Some(header::Media::VideoMessage(ref v)) => v,
                _ => <super::VideoMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_videoMessage(&mut self) {
            self.media = ::std::option::Option::None;
        }

        pub fn has_videoMessage(&self) -> bool {
            match self.media {
                ::std::option::Option::Some(header::Media::VideoMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_videoMessage(&mut self, v: super::VideoMessage) {
            self.media = ::std::option::Option::Some(header::Media::VideoMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_videoMessage(&mut self) -> &mut super::VideoMessage {
            if let ::std::option::Option::Some(header::Media::VideoMessage(_)) = self.media {
            } else {
                self.media = ::std::option::Option::Some(header::Media::VideoMessage(super::VideoMessage::new()));
            }
            match self.media {
                ::std::option::Option::Some(header::Media::VideoMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_videoMessage(&mut self) -> super::VideoMessage {
            if self.has_videoMessage() {
                match self.media.take() {
                    ::std::option::Option::Some(header::Media::VideoMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::VideoMessage::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "title",
                |m: &Header| { &m.title },
                |m: &mut Header| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "subtitle",
                |m: &Header| { &m.subtitle },
                |m: &mut Header| { &mut m.subtitle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hasMediaAttachment",
                |m: &Header| { &m.hasMediaAttachment },
                |m: &mut Header| { &mut m.hasMediaAttachment },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::DocumentMessage>(
                "documentMessage",
                Header::has_documentMessage,
                Header::documentMessage,
                Header::mut_documentMessage,
                Header::set_documentMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::ImageMessage>(
                "imageMessage",
                Header::has_imageMessage,
                Header::imageMessage,
                Header::mut_imageMessage,
                Header::set_imageMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                "jpegThumbnail",
                Header::has_jpegThumbnail,
                Header::jpegThumbnail,
                Header::set_jpegThumbnail,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::VideoMessage>(
                "videoMessage",
                Header::has_videoMessage,
                Header::videoMessage,
                Header::mut_videoMessage,
                Header::set_videoMessage,
            ));
            oneofs.push(header::Media::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Header>(
                "InteractiveMessage.Header",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Header {
        const NAME: &'static str = "Header";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.subtitle = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.hasMediaAttachment = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.media = ::std::option::Option::Some(header::Media::DocumentMessage(is.read_message()?));
                    },
                    34 => {
                        self.media = ::std::option::Option::Some(header::Media::ImageMessage(is.read_message()?));
                    },
                    50 => {
                        self.media = ::std::option::Option::Some(header::Media::JpegThumbnail(is.read_bytes()?));
                    },
                    58 => {
                        self.media = ::std::option::Option::Some(header::Media::VideoMessage(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.title.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.subtitle.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.hasMediaAttachment {
                my_size += 1 + 1;
            }
            if let ::std::option::Option::Some(ref v) = self.media {
                match v {
                    &header::Media::DocumentMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &header::Media::ImageMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &header::Media::JpegThumbnail(ref v) => {
                        my_size += ::protobuf::rt::bytes_size(6, &v);
                    },
                    &header::Media::VideoMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.title.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.subtitle.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.hasMediaAttachment {
                os.write_bool(5, v)?;
            }
            if let ::std::option::Option::Some(ref v) = self.media {
                match v {
                    &header::Media::DocumentMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &header::Media::ImageMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                    &header::Media::JpegThumbnail(ref v) => {
                        os.write_bytes(6, v)?;
                    },
                    &header::Media::VideoMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Header {
            Header::new()
        }

        fn clear(&mut self) {
            self.title = ::std::option::Option::None;
            self.subtitle = ::std::option::Option::None;
            self.hasMediaAttachment = ::std::option::Option::None;
            self.media = ::std::option::Option::None;
            self.media = ::std::option::Option::None;
            self.media = ::std::option::Option::None;
            self.media = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Header {
            static instance: Header = Header {
                title: ::std::option::Option::None,
                subtitle: ::std::option::Option::None,
                hasMediaAttachment: ::std::option::Option::None,
                media: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Header {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InteractiveMessage.Header").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Header {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Header {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Header`
    pub mod header {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:proto.InteractiveMessage.Header.media)
        pub enum Media {
            // @@protoc_insertion_point(oneof_field:proto.InteractiveMessage.Header.documentMessage)
            DocumentMessage(super::super::DocumentMessage),
            // @@protoc_insertion_point(oneof_field:proto.InteractiveMessage.Header.imageMessage)
            ImageMessage(super::super::ImageMessage),
            // @@protoc_insertion_point(oneof_field:proto.InteractiveMessage.Header.jpegThumbnail)
            JpegThumbnail(::std::vec::Vec<u8>),
            // @@protoc_insertion_point(oneof_field:proto.InteractiveMessage.Header.videoMessage)
            VideoMessage(super::super::VideoMessage),
        }

        impl ::protobuf::Oneof for Media {
        }

        impl ::protobuf::OneofFull for Media {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Header as ::protobuf::MessageFull>::descriptor().oneof_by_name("media").unwrap()).clone()
            }
        }

        impl Media {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Media>("media")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.InteractiveMessage.Footer)
    pub struct Footer {
        // message fields
        // @@protoc_insertion_point(field:proto.InteractiveMessage.Footer.text)
        pub text: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.InteractiveMessage.Footer.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Footer {
        fn default() -> &'a Footer {
            <Footer as ::protobuf::Message>::default_instance()
        }
    }

    impl Footer {
        pub fn new() -> Footer {
            ::std::default::Default::default()
        }

        // optional string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "text",
                |m: &Footer| { &m.text },
                |m: &mut Footer| { &mut m.text },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Footer>(
                "InteractiveMessage.Footer",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Footer {
        const NAME: &'static str = "Footer";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Footer {
            Footer::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Footer {
            static instance: Footer = Footer {
                text: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Footer {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InteractiveMessage.Footer").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Footer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Footer {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.InteractiveMessage.CollectionMessage)
    pub struct CollectionMessage {
        // message fields
        // @@protoc_insertion_point(field:proto.InteractiveMessage.CollectionMessage.bizJid)
        pub bizJid: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.InteractiveMessage.CollectionMessage.id)
        pub id: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.InteractiveMessage.CollectionMessage.messageVersion)
        pub messageVersion: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.InteractiveMessage.CollectionMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CollectionMessage {
        fn default() -> &'a CollectionMessage {
            <CollectionMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl CollectionMessage {
        pub fn new() -> CollectionMessage {
            ::std::default::Default::default()
        }

        // optional string bizJid = 1;

        pub fn bizJid(&self) -> &str {
            match self.bizJid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_bizJid(&mut self) {
            self.bizJid = ::std::option::Option::None;
        }

        pub fn has_bizJid(&self) -> bool {
            self.bizJid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bizJid(&mut self, v: ::std::string::String) {
            self.bizJid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_bizJid(&mut self) -> &mut ::std::string::String {
            if self.bizJid.is_none() {
                self.bizJid = ::std::option::Option::Some(::std::string::String::new());
            }
            self.bizJid.as_mut().unwrap()
        }

        // Take field
        pub fn take_bizJid(&mut self) -> ::std::string::String {
            self.bizJid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string id = 2;

        pub fn id(&self) -> &str {
            match self.id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: ::std::string::String) {
            self.id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_id(&mut self) -> &mut ::std::string::String {
            if self.id.is_none() {
                self.id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.id.as_mut().unwrap()
        }

        // Take field
        pub fn take_id(&mut self) -> ::std::string::String {
            self.id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 messageVersion = 3;

        pub fn messageVersion(&self) -> i32 {
            self.messageVersion.unwrap_or(0)
        }

        pub fn clear_messageVersion(&mut self) {
            self.messageVersion = ::std::option::Option::None;
        }

        pub fn has_messageVersion(&self) -> bool {
            self.messageVersion.is_some()
        }

        // Param is passed by value, moved
        pub fn set_messageVersion(&mut self, v: i32) {
            self.messageVersion = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "bizJid",
                |m: &CollectionMessage| { &m.bizJid },
                |m: &mut CollectionMessage| { &mut m.bizJid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &CollectionMessage| { &m.id },
                |m: &mut CollectionMessage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "messageVersion",
                |m: &CollectionMessage| { &m.messageVersion },
                |m: &mut CollectionMessage| { &mut m.messageVersion },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectionMessage>(
                "InteractiveMessage.CollectionMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CollectionMessage {
        const NAME: &'static str = "CollectionMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.bizJid = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.id = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.messageVersion = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.bizJid.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.messageVersion {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.bizJid.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.id.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.messageVersion {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CollectionMessage {
            CollectionMessage::new()
        }

        fn clear(&mut self) {
            self.bizJid = ::std::option::Option::None;
            self.id = ::std::option::Option::None;
            self.messageVersion = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CollectionMessage {
            static instance: CollectionMessage = CollectionMessage {
                bizJid: ::std::option::Option::None,
                id: ::std::option::Option::None,
                messageVersion: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CollectionMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InteractiveMessage.CollectionMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CollectionMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CollectionMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.InteractiveMessage.Body)
    pub struct Body {
        // message fields
        // @@protoc_insertion_point(field:proto.InteractiveMessage.Body.text)
        pub text: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.InteractiveMessage.Body.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Body {
        fn default() -> &'a Body {
            <Body as ::protobuf::Message>::default_instance()
        }
    }

    impl Body {
        pub fn new() -> Body {
            ::std::default::Default::default()
        }

        // optional string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "text",
                |m: &Body| { &m.text },
                |m: &mut Body| { &mut m.text },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Body>(
                "InteractiveMessage.Body",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Body {
        const NAME: &'static str = "Body";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Body {
            Body::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Body {
            static instance: Body = Body {
                text: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Body {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("InteractiveMessage.Body").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Body {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Body {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.InitialSecurityNotificationSettingSync)
pub struct InitialSecurityNotificationSettingSync {
    // message fields
    // @@protoc_insertion_point(field:proto.InitialSecurityNotificationSettingSync.securityNotificationEnabled)
    pub securityNotificationEnabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.InitialSecurityNotificationSettingSync.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InitialSecurityNotificationSettingSync {
    fn default() -> &'a InitialSecurityNotificationSettingSync {
        <InitialSecurityNotificationSettingSync as ::protobuf::Message>::default_instance()
    }
}

impl InitialSecurityNotificationSettingSync {
    pub fn new() -> InitialSecurityNotificationSettingSync {
        ::std::default::Default::default()
    }

    // optional bool securityNotificationEnabled = 1;

    pub fn securityNotificationEnabled(&self) -> bool {
        self.securityNotificationEnabled.unwrap_or(false)
    }

    pub fn clear_securityNotificationEnabled(&mut self) {
        self.securityNotificationEnabled = ::std::option::Option::None;
    }

    pub fn has_securityNotificationEnabled(&self) -> bool {
        self.securityNotificationEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityNotificationEnabled(&mut self, v: bool) {
        self.securityNotificationEnabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "securityNotificationEnabled",
            |m: &InitialSecurityNotificationSettingSync| { &m.securityNotificationEnabled },
            |m: &mut InitialSecurityNotificationSettingSync| { &mut m.securityNotificationEnabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitialSecurityNotificationSettingSync>(
            "InitialSecurityNotificationSettingSync",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InitialSecurityNotificationSettingSync {
    const NAME: &'static str = "InitialSecurityNotificationSettingSync";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.securityNotificationEnabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.securityNotificationEnabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.securityNotificationEnabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InitialSecurityNotificationSettingSync {
        InitialSecurityNotificationSettingSync::new()
    }

    fn clear(&mut self) {
        self.securityNotificationEnabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InitialSecurityNotificationSettingSync {
        static instance: InitialSecurityNotificationSettingSync = InitialSecurityNotificationSettingSync {
            securityNotificationEnabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InitialSecurityNotificationSettingSync {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InitialSecurityNotificationSettingSync").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InitialSecurityNotificationSettingSync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitialSecurityNotificationSettingSync {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ImageMessage)
pub struct ImageMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ImageMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ImageMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ImageMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ImageMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.ImageMessage.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ImageMessage.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ImageMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.interactiveAnnotations)
    pub interactiveAnnotations: ::std::vec::Vec<InteractiveAnnotation>,
    // @@protoc_insertion_point(field:proto.ImageMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ImageMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.ImageMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.ImageMessage.firstScanSidecar)
    pub firstScanSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.firstScanLength)
    pub firstScanLength: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ImageMessage.experimentGroupId)
    pub experimentGroupId: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ImageMessage.scansSidecar)
    pub scansSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.scanLengths)
    pub scanLengths: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:proto.ImageMessage.midQualityFileSha256)
    pub midQualityFileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.midQualityFileEncSha256)
    pub midQualityFileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.viewOnce)
    pub viewOnce: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ImageMessage.thumbnailDirectPath)
    pub thumbnailDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ImageMessage.thumbnailSha256)
    pub thumbnailSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.thumbnailEncSha256)
    pub thumbnailEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ImageMessage.staticUrl)
    pub staticUrl: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ImageMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ImageMessage {
    fn default() -> &'a ImageMessage {
        <ImageMessage as ::protobuf::Message>::default_instance()
    }
}

impl ImageMessage {
    pub fn new() -> ImageMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mimetype = 2;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 4;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 5;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 6;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 7;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 8;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 9;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 11;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 12;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes firstScanSidecar = 18;

    pub fn firstScanSidecar(&self) -> &[u8] {
        match self.firstScanSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_firstScanSidecar(&mut self) {
        self.firstScanSidecar = ::std::option::Option::None;
    }

    pub fn has_firstScanSidecar(&self) -> bool {
        self.firstScanSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstScanSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.firstScanSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstScanSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.firstScanSidecar.is_none() {
            self.firstScanSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.firstScanSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstScanSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.firstScanSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 firstScanLength = 19;

    pub fn firstScanLength(&self) -> u32 {
        self.firstScanLength.unwrap_or(0)
    }

    pub fn clear_firstScanLength(&mut self) {
        self.firstScanLength = ::std::option::Option::None;
    }

    pub fn has_firstScanLength(&self) -> bool {
        self.firstScanLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstScanLength(&mut self, v: u32) {
        self.firstScanLength = ::std::option::Option::Some(v);
    }

    // optional uint32 experimentGroupId = 20;

    pub fn experimentGroupId(&self) -> u32 {
        self.experimentGroupId.unwrap_or(0)
    }

    pub fn clear_experimentGroupId(&mut self) {
        self.experimentGroupId = ::std::option::Option::None;
    }

    pub fn has_experimentGroupId(&self) -> bool {
        self.experimentGroupId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experimentGroupId(&mut self, v: u32) {
        self.experimentGroupId = ::std::option::Option::Some(v);
    }

    // optional bytes scansSidecar = 21;

    pub fn scansSidecar(&self) -> &[u8] {
        match self.scansSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_scansSidecar(&mut self) {
        self.scansSidecar = ::std::option::Option::None;
    }

    pub fn has_scansSidecar(&self) -> bool {
        self.scansSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scansSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.scansSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scansSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.scansSidecar.is_none() {
            self.scansSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.scansSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scansSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.scansSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes midQualityFileSha256 = 23;

    pub fn midQualityFileSha256(&self) -> &[u8] {
        match self.midQualityFileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_midQualityFileSha256(&mut self) {
        self.midQualityFileSha256 = ::std::option::Option::None;
    }

    pub fn has_midQualityFileSha256(&self) -> bool {
        self.midQualityFileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_midQualityFileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.midQualityFileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_midQualityFileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.midQualityFileSha256.is_none() {
            self.midQualityFileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.midQualityFileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_midQualityFileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.midQualityFileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes midQualityFileEncSha256 = 24;

    pub fn midQualityFileEncSha256(&self) -> &[u8] {
        match self.midQualityFileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_midQualityFileEncSha256(&mut self) {
        self.midQualityFileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_midQualityFileEncSha256(&self) -> bool {
        self.midQualityFileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_midQualityFileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.midQualityFileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_midQualityFileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.midQualityFileEncSha256.is_none() {
            self.midQualityFileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.midQualityFileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_midQualityFileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.midQualityFileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool viewOnce = 25;

    pub fn viewOnce(&self) -> bool {
        self.viewOnce.unwrap_or(false)
    }

    pub fn clear_viewOnce(&mut self) {
        self.viewOnce = ::std::option::Option::None;
    }

    pub fn has_viewOnce(&self) -> bool {
        self.viewOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewOnce(&mut self, v: bool) {
        self.viewOnce = ::std::option::Option::Some(v);
    }

    // optional string thumbnailDirectPath = 26;

    pub fn thumbnailDirectPath(&self) -> &str {
        match self.thumbnailDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailDirectPath(&mut self) {
        self.thumbnailDirectPath = ::std::option::Option::None;
    }

    pub fn has_thumbnailDirectPath(&self) -> bool {
        self.thumbnailDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailDirectPath(&mut self, v: ::std::string::String) {
        self.thumbnailDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailDirectPath(&mut self) -> &mut ::std::string::String {
        if self.thumbnailDirectPath.is_none() {
            self.thumbnailDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailDirectPath(&mut self) -> ::std::string::String {
        self.thumbnailDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnailSha256 = 27;

    pub fn thumbnailSha256(&self) -> &[u8] {
        match self.thumbnailSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailSha256(&mut self) {
        self.thumbnailSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailSha256(&self) -> bool {
        self.thumbnailSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailSha256.is_none() {
            self.thumbnailSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes thumbnailEncSha256 = 28;

    pub fn thumbnailEncSha256(&self) -> &[u8] {
        match self.thumbnailEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailEncSha256(&mut self) {
        self.thumbnailEncSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailEncSha256(&self) -> bool {
        self.thumbnailEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailEncSha256.is_none() {
            self.thumbnailEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string staticUrl = 29;

    pub fn staticUrl(&self) -> &str {
        match self.staticUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_staticUrl(&mut self) {
        self.staticUrl = ::std::option::Option::None;
    }

    pub fn has_staticUrl(&self) -> bool {
        self.staticUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staticUrl(&mut self, v: ::std::string::String) {
        self.staticUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_staticUrl(&mut self) -> &mut ::std::string::String {
        if self.staticUrl.is_none() {
            self.staticUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.staticUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_staticUrl(&mut self) -> ::std::string::String {
        self.staticUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &ImageMessage| { &m.url },
            |m: &mut ImageMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &ImageMessage| { &m.mimetype },
            |m: &mut ImageMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &ImageMessage| { &m.caption },
            |m: &mut ImageMessage| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &ImageMessage| { &m.fileSha256 },
            |m: &mut ImageMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &ImageMessage| { &m.fileLength },
            |m: &mut ImageMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &ImageMessage| { &m.height },
            |m: &mut ImageMessage| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &ImageMessage| { &m.width },
            |m: &mut ImageMessage| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &ImageMessage| { &m.mediaKey },
            |m: &mut ImageMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &ImageMessage| { &m.fileEncSha256 },
            |m: &mut ImageMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interactiveAnnotations",
            |m: &ImageMessage| { &m.interactiveAnnotations },
            |m: &mut ImageMessage| { &mut m.interactiveAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &ImageMessage| { &m.directPath },
            |m: &mut ImageMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &ImageMessage| { &m.mediaKeyTimestamp },
            |m: &mut ImageMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &ImageMessage| { &m.jpegThumbnail },
            |m: &mut ImageMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ImageMessage| { &m.contextInfo },
            |m: &mut ImageMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstScanSidecar",
            |m: &ImageMessage| { &m.firstScanSidecar },
            |m: &mut ImageMessage| { &mut m.firstScanSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstScanLength",
            |m: &ImageMessage| { &m.firstScanLength },
            |m: &mut ImageMessage| { &mut m.firstScanLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "experimentGroupId",
            |m: &ImageMessage| { &m.experimentGroupId },
            |m: &mut ImageMessage| { &mut m.experimentGroupId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scansSidecar",
            |m: &ImageMessage| { &m.scansSidecar },
            |m: &mut ImageMessage| { &mut m.scansSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scanLengths",
            |m: &ImageMessage| { &m.scanLengths },
            |m: &mut ImageMessage| { &mut m.scanLengths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "midQualityFileSha256",
            |m: &ImageMessage| { &m.midQualityFileSha256 },
            |m: &mut ImageMessage| { &mut m.midQualityFileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "midQualityFileEncSha256",
            |m: &ImageMessage| { &m.midQualityFileEncSha256 },
            |m: &mut ImageMessage| { &mut m.midQualityFileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewOnce",
            |m: &ImageMessage| { &m.viewOnce },
            |m: &mut ImageMessage| { &mut m.viewOnce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailDirectPath",
            |m: &ImageMessage| { &m.thumbnailDirectPath },
            |m: &mut ImageMessage| { &mut m.thumbnailDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailSha256",
            |m: &ImageMessage| { &m.thumbnailSha256 },
            |m: &mut ImageMessage| { &mut m.thumbnailSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailEncSha256",
            |m: &ImageMessage| { &m.thumbnailEncSha256 },
            |m: &mut ImageMessage| { &mut m.thumbnailEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "staticUrl",
            |m: &ImageMessage| { &m.staticUrl },
            |m: &mut ImageMessage| { &mut m.staticUrl },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImageMessage>(
            "ImageMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ImageMessage {
    const NAME: &'static str = "ImageMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                82 => {
                    self.interactiveAnnotations.push(is.read_message()?);
                },
                90 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                146 => {
                    self.firstScanSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                152 => {
                    self.firstScanLength = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.experimentGroupId = ::std::option::Option::Some(is.read_uint32()?);
                },
                170 => {
                    self.scansSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                178 => {
                    is.read_repeated_packed_uint32_into(&mut self.scanLengths)?;
                },
                176 => {
                    self.scanLengths.push(is.read_uint32()?);
                },
                186 => {
                    self.midQualityFileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                194 => {
                    self.midQualityFileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                200 => {
                    self.viewOnce = ::std::option::Option::Some(is.read_bool()?);
                },
                210 => {
                    self.thumbnailDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                218 => {
                    self.thumbnailSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                226 => {
                    self.thumbnailEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                234 => {
                    self.staticUrl = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        for value in &self.interactiveAnnotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(12, v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.firstScanSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.firstScanLength {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.experimentGroupId {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.scansSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        for value in &self.scanLengths {
            my_size += ::protobuf::rt::uint32_size(22, *value);
        };
        if let Some(v) = self.midQualityFileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(23, &v);
        }
        if let Some(v) = self.midQualityFileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(24, &v);
        }
        if let Some(v) = self.viewOnce {
            my_size += 2 + 1;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(27, &v);
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(28, &v);
        }
        if let Some(v) = self.staticUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(9, v)?;
        }
        for v in &self.interactiveAnnotations {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.firstScanSidecar.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.firstScanLength {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.experimentGroupId {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.scansSidecar.as_ref() {
            os.write_bytes(21, v)?;
        }
        for v in &self.scanLengths {
            os.write_uint32(22, *v)?;
        };
        if let Some(v) = self.midQualityFileSha256.as_ref() {
            os.write_bytes(23, v)?;
        }
        if let Some(v) = self.midQualityFileEncSha256.as_ref() {
            os.write_bytes(24, v)?;
        }
        if let Some(v) = self.viewOnce {
            os.write_bool(25, v)?;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            os.write_string(26, v)?;
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            os.write_bytes(27, v)?;
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            os.write_bytes(28, v)?;
        }
        if let Some(v) = self.staticUrl.as_ref() {
            os.write_string(29, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ImageMessage {
        ImageMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.interactiveAnnotations.clear();
        self.directPath = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.firstScanSidecar = ::std::option::Option::None;
        self.firstScanLength = ::std::option::Option::None;
        self.experimentGroupId = ::std::option::Option::None;
        self.scansSidecar = ::std::option::Option::None;
        self.scanLengths.clear();
        self.midQualityFileSha256 = ::std::option::Option::None;
        self.midQualityFileEncSha256 = ::std::option::Option::None;
        self.viewOnce = ::std::option::Option::None;
        self.thumbnailDirectPath = ::std::option::Option::None;
        self.thumbnailSha256 = ::std::option::Option::None;
        self.thumbnailEncSha256 = ::std::option::Option::None;
        self.staticUrl = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ImageMessage {
        static instance: ImageMessage = ImageMessage {
            url: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            height: ::std::option::Option::None,
            width: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            interactiveAnnotations: ::std::vec::Vec::new(),
            directPath: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            firstScanSidecar: ::std::option::Option::None,
            firstScanLength: ::std::option::Option::None,
            experimentGroupId: ::std::option::Option::None,
            scansSidecar: ::std::option::Option::None,
            scanLengths: ::std::vec::Vec::new(),
            midQualityFileSha256: ::std::option::Option::None,
            midQualityFileEncSha256: ::std::option::Option::None,
            viewOnce: ::std::option::Option::None,
            thumbnailDirectPath: ::std::option::Option::None,
            thumbnailSha256: ::std::option::Option::None,
            thumbnailEncSha256: ::std::option::Option::None,
            staticUrl: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ImageMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ImageMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ImageMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImageMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HistorySyncNotification)
pub struct HistorySyncNotification {
    // message fields
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.syncType)
    pub syncType: ::std::option::Option<::protobuf::EnumOrUnknown<history_sync_notification::HistorySyncType>>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.chunkOrder)
    pub chunkOrder: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.originalMessageId)
    pub originalMessageId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.progress)
    pub progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.HistorySyncNotification.oldestMsgInChunkTimestampSec)
    pub oldestMsgInChunkTimestampSec: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HistorySyncNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HistorySyncNotification {
    fn default() -> &'a HistorySyncNotification {
        <HistorySyncNotification as ::protobuf::Message>::default_instance()
    }
}

impl HistorySyncNotification {
    pub fn new() -> HistorySyncNotification {
        ::std::default::Default::default()
    }

    // optional bytes fileSha256 = 1;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 2;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 3;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 4;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 5;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.HistorySyncNotification.HistorySyncType syncType = 6;

    pub fn syncType(&self) -> history_sync_notification::HistorySyncType {
        match self.syncType {
            Some(e) => e.enum_value_or(history_sync_notification::HistorySyncType::INITIAL_BOOTSTRAP),
            None => history_sync_notification::HistorySyncType::INITIAL_BOOTSTRAP,
        }
    }

    pub fn clear_syncType(&mut self) {
        self.syncType = ::std::option::Option::None;
    }

    pub fn has_syncType(&self) -> bool {
        self.syncType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncType(&mut self, v: history_sync_notification::HistorySyncType) {
        self.syncType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 chunkOrder = 7;

    pub fn chunkOrder(&self) -> u32 {
        self.chunkOrder.unwrap_or(0)
    }

    pub fn clear_chunkOrder(&mut self) {
        self.chunkOrder = ::std::option::Option::None;
    }

    pub fn has_chunkOrder(&self) -> bool {
        self.chunkOrder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunkOrder(&mut self, v: u32) {
        self.chunkOrder = ::std::option::Option::Some(v);
    }

    // optional string originalMessageId = 8;

    pub fn originalMessageId(&self) -> &str {
        match self.originalMessageId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_originalMessageId(&mut self) {
        self.originalMessageId = ::std::option::Option::None;
    }

    pub fn has_originalMessageId(&self) -> bool {
        self.originalMessageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_originalMessageId(&mut self, v: ::std::string::String) {
        self.originalMessageId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originalMessageId(&mut self) -> &mut ::std::string::String {
        if self.originalMessageId.is_none() {
            self.originalMessageId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.originalMessageId.as_mut().unwrap()
    }

    // Take field
    pub fn take_originalMessageId(&mut self) -> ::std::string::String {
        self.originalMessageId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 progress = 9;

    pub fn progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional int64 oldestMsgInChunkTimestampSec = 10;

    pub fn oldestMsgInChunkTimestampSec(&self) -> i64 {
        self.oldestMsgInChunkTimestampSec.unwrap_or(0)
    }

    pub fn clear_oldestMsgInChunkTimestampSec(&mut self) {
        self.oldestMsgInChunkTimestampSec = ::std::option::Option::None;
    }

    pub fn has_oldestMsgInChunkTimestampSec(&self) -> bool {
        self.oldestMsgInChunkTimestampSec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldestMsgInChunkTimestampSec(&mut self, v: i64) {
        self.oldestMsgInChunkTimestampSec = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &HistorySyncNotification| { &m.fileSha256 },
            |m: &mut HistorySyncNotification| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &HistorySyncNotification| { &m.fileLength },
            |m: &mut HistorySyncNotification| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &HistorySyncNotification| { &m.mediaKey },
            |m: &mut HistorySyncNotification| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &HistorySyncNotification| { &m.fileEncSha256 },
            |m: &mut HistorySyncNotification| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &HistorySyncNotification| { &m.directPath },
            |m: &mut HistorySyncNotification| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "syncType",
            |m: &HistorySyncNotification| { &m.syncType },
            |m: &mut HistorySyncNotification| { &mut m.syncType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chunkOrder",
            |m: &HistorySyncNotification| { &m.chunkOrder },
            |m: &mut HistorySyncNotification| { &mut m.chunkOrder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "originalMessageId",
            |m: &HistorySyncNotification| { &m.originalMessageId },
            |m: &mut HistorySyncNotification| { &mut m.originalMessageId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &HistorySyncNotification| { &m.progress },
            |m: &mut HistorySyncNotification| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oldestMsgInChunkTimestampSec",
            |m: &HistorySyncNotification| { &m.oldestMsgInChunkTimestampSec },
            |m: &mut HistorySyncNotification| { &mut m.oldestMsgInChunkTimestampSec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistorySyncNotification>(
            "HistorySyncNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HistorySyncNotification {
    const NAME: &'static str = "HistorySyncNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.syncType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.chunkOrder = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.originalMessageId = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.oldestMsgInChunkTimestampSec = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.syncType {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.chunkOrder {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.originalMessageId.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.oldestMsgInChunkTimestampSec {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.syncType {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.chunkOrder {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.originalMessageId.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.oldestMsgInChunkTimestampSec {
            os.write_int64(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HistorySyncNotification {
        HistorySyncNotification::new()
    }

    fn clear(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.syncType = ::std::option::Option::None;
        self.chunkOrder = ::std::option::Option::None;
        self.originalMessageId = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.oldestMsgInChunkTimestampSec = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HistorySyncNotification {
        static instance: HistorySyncNotification = HistorySyncNotification {
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            syncType: ::std::option::Option::None,
            chunkOrder: ::std::option::Option::None,
            originalMessageId: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            oldestMsgInChunkTimestampSec: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HistorySyncNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HistorySyncNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HistorySyncNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistorySyncNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HistorySyncNotification`
pub mod history_sync_notification {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.HistorySyncNotification.HistorySyncType)
    pub enum HistorySyncType {
        // @@protoc_insertion_point(enum_value:proto.HistorySyncNotification.HistorySyncType.INITIAL_BOOTSTRAP)
        INITIAL_BOOTSTRAP = 0,
        // @@protoc_insertion_point(enum_value:proto.HistorySyncNotification.HistorySyncType.INITIAL_STATUS_V3)
        INITIAL_STATUS_V3 = 1,
        // @@protoc_insertion_point(enum_value:proto.HistorySyncNotification.HistorySyncType.FULL)
        FULL = 2,
        // @@protoc_insertion_point(enum_value:proto.HistorySyncNotification.HistorySyncType.RECENT)
        RECENT = 3,
        // @@protoc_insertion_point(enum_value:proto.HistorySyncNotification.HistorySyncType.PUSH_NAME)
        PUSH_NAME = 4,
        // @@protoc_insertion_point(enum_value:proto.HistorySyncNotification.HistorySyncType.NON_BLOCKING_DATA)
        NON_BLOCKING_DATA = 5,
    }

    impl ::protobuf::Enum for HistorySyncType {
        const NAME: &'static str = "HistorySyncType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HistorySyncType> {
            match value {
                0 => ::std::option::Option::Some(HistorySyncType::INITIAL_BOOTSTRAP),
                1 => ::std::option::Option::Some(HistorySyncType::INITIAL_STATUS_V3),
                2 => ::std::option::Option::Some(HistorySyncType::FULL),
                3 => ::std::option::Option::Some(HistorySyncType::RECENT),
                4 => ::std::option::Option::Some(HistorySyncType::PUSH_NAME),
                5 => ::std::option::Option::Some(HistorySyncType::NON_BLOCKING_DATA),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HistorySyncType] = &[
            HistorySyncType::INITIAL_BOOTSTRAP,
            HistorySyncType::INITIAL_STATUS_V3,
            HistorySyncType::FULL,
            HistorySyncType::RECENT,
            HistorySyncType::PUSH_NAME,
            HistorySyncType::NON_BLOCKING_DATA,
        ];
    }

    impl ::protobuf::EnumFull for HistorySyncType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("HistorySyncNotification.HistorySyncType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for HistorySyncType {
        fn default() -> Self {
            HistorySyncType::INITIAL_BOOTSTRAP
        }
    }

    impl HistorySyncType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HistorySyncType>("HistorySyncNotification.HistorySyncType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HighlyStructuredMessage)
pub struct HighlyStructuredMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.namespace)
    pub namespace: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.elementName)
    pub elementName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.params)
    pub params: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.fallbackLg)
    pub fallbackLg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.fallbackLc)
    pub fallbackLc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.localizableParams)
    pub localizableParams: ::std::vec::Vec<highly_structured_message::HSMLocalizableParameter>,
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.deterministicLg)
    pub deterministicLg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.deterministicLc)
    pub deterministicLc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.hydratedHsm)
    pub hydratedHsm: ::protobuf::MessageField<TemplateMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HighlyStructuredMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HighlyStructuredMessage {
    fn default() -> &'a HighlyStructuredMessage {
        <HighlyStructuredMessage as ::protobuf::Message>::default_instance()
    }
}

impl HighlyStructuredMessage {
    pub fn new() -> HighlyStructuredMessage {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;

    pub fn namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_namespace(&mut self) {
        self.namespace = ::std::option::Option::None;
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string elementName = 2;

    pub fn elementName(&self) -> &str {
        match self.elementName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_elementName(&mut self) {
        self.elementName = ::std::option::Option::None;
    }

    pub fn has_elementName(&self) -> bool {
        self.elementName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elementName(&mut self, v: ::std::string::String) {
        self.elementName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elementName(&mut self) -> &mut ::std::string::String {
        if self.elementName.is_none() {
            self.elementName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.elementName.as_mut().unwrap()
    }

    // Take field
    pub fn take_elementName(&mut self) -> ::std::string::String {
        self.elementName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fallbackLg = 4;

    pub fn fallbackLg(&self) -> &str {
        match self.fallbackLg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fallbackLg(&mut self) {
        self.fallbackLg = ::std::option::Option::None;
    }

    pub fn has_fallbackLg(&self) -> bool {
        self.fallbackLg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallbackLg(&mut self, v: ::std::string::String) {
        self.fallbackLg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallbackLg(&mut self) -> &mut ::std::string::String {
        if self.fallbackLg.is_none() {
            self.fallbackLg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fallbackLg.as_mut().unwrap()
    }

    // Take field
    pub fn take_fallbackLg(&mut self) -> ::std::string::String {
        self.fallbackLg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fallbackLc = 5;

    pub fn fallbackLc(&self) -> &str {
        match self.fallbackLc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fallbackLc(&mut self) {
        self.fallbackLc = ::std::option::Option::None;
    }

    pub fn has_fallbackLc(&self) -> bool {
        self.fallbackLc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fallbackLc(&mut self, v: ::std::string::String) {
        self.fallbackLc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fallbackLc(&mut self) -> &mut ::std::string::String {
        if self.fallbackLc.is_none() {
            self.fallbackLc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fallbackLc.as_mut().unwrap()
    }

    // Take field
    pub fn take_fallbackLc(&mut self) -> ::std::string::String {
        self.fallbackLc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string deterministicLg = 7;

    pub fn deterministicLg(&self) -> &str {
        match self.deterministicLg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deterministicLg(&mut self) {
        self.deterministicLg = ::std::option::Option::None;
    }

    pub fn has_deterministicLg(&self) -> bool {
        self.deterministicLg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deterministicLg(&mut self, v: ::std::string::String) {
        self.deterministicLg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deterministicLg(&mut self) -> &mut ::std::string::String {
        if self.deterministicLg.is_none() {
            self.deterministicLg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deterministicLg.as_mut().unwrap()
    }

    // Take field
    pub fn take_deterministicLg(&mut self) -> ::std::string::String {
        self.deterministicLg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string deterministicLc = 8;

    pub fn deterministicLc(&self) -> &str {
        match self.deterministicLc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deterministicLc(&mut self) {
        self.deterministicLc = ::std::option::Option::None;
    }

    pub fn has_deterministicLc(&self) -> bool {
        self.deterministicLc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deterministicLc(&mut self, v: ::std::string::String) {
        self.deterministicLc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deterministicLc(&mut self) -> &mut ::std::string::String {
        if self.deterministicLc.is_none() {
            self.deterministicLc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deterministicLc.as_mut().unwrap()
    }

    // Take field
    pub fn take_deterministicLc(&mut self) -> ::std::string::String {
        self.deterministicLc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "namespace",
            |m: &HighlyStructuredMessage| { &m.namespace },
            |m: &mut HighlyStructuredMessage| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elementName",
            |m: &HighlyStructuredMessage| { &m.elementName },
            |m: &mut HighlyStructuredMessage| { &mut m.elementName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &HighlyStructuredMessage| { &m.params },
            |m: &mut HighlyStructuredMessage| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fallbackLg",
            |m: &HighlyStructuredMessage| { &m.fallbackLg },
            |m: &mut HighlyStructuredMessage| { &mut m.fallbackLg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fallbackLc",
            |m: &HighlyStructuredMessage| { &m.fallbackLc },
            |m: &mut HighlyStructuredMessage| { &mut m.fallbackLc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "localizableParams",
            |m: &HighlyStructuredMessage| { &m.localizableParams },
            |m: &mut HighlyStructuredMessage| { &mut m.localizableParams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deterministicLg",
            |m: &HighlyStructuredMessage| { &m.deterministicLg },
            |m: &mut HighlyStructuredMessage| { &mut m.deterministicLg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deterministicLc",
            |m: &HighlyStructuredMessage| { &m.deterministicLc },
            |m: &mut HighlyStructuredMessage| { &mut m.deterministicLc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TemplateMessage>(
            "hydratedHsm",
            |m: &HighlyStructuredMessage| { &m.hydratedHsm },
            |m: &mut HighlyStructuredMessage| { &mut m.hydratedHsm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HighlyStructuredMessage>(
            "HighlyStructuredMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HighlyStructuredMessage {
    const NAME: &'static str = "HighlyStructuredMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.elementName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.params.push(is.read_string()?);
                },
                34 => {
                    self.fallbackLg = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.fallbackLc = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.localizableParams.push(is.read_message()?);
                },
                58 => {
                    self.deterministicLg = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.deterministicLc = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hydratedHsm)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.elementName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.fallbackLg.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.fallbackLc.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.localizableParams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.deterministicLg.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.deterministicLc.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.hydratedHsm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.namespace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.elementName.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.params {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.fallbackLg.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.fallbackLc.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.localizableParams {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.deterministicLg.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.deterministicLc.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.hydratedHsm.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HighlyStructuredMessage {
        HighlyStructuredMessage::new()
    }

    fn clear(&mut self) {
        self.namespace = ::std::option::Option::None;
        self.elementName = ::std::option::Option::None;
        self.params.clear();
        self.fallbackLg = ::std::option::Option::None;
        self.fallbackLc = ::std::option::Option::None;
        self.localizableParams.clear();
        self.deterministicLg = ::std::option::Option::None;
        self.deterministicLc = ::std::option::Option::None;
        self.hydratedHsm.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HighlyStructuredMessage {
        static instance: HighlyStructuredMessage = HighlyStructuredMessage {
            namespace: ::std::option::Option::None,
            elementName: ::std::option::Option::None,
            params: ::std::vec::Vec::new(),
            fallbackLg: ::std::option::Option::None,
            fallbackLc: ::std::option::Option::None,
            localizableParams: ::std::vec::Vec::new(),
            deterministicLg: ::std::option::Option::None,
            deterministicLc: ::std::option::Option::None,
            hydratedHsm: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HighlyStructuredMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HighlyStructuredMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HighlyStructuredMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HighlyStructuredMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HighlyStructuredMessage`
pub mod highly_structured_message {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.HighlyStructuredMessage.HSMLocalizableParameter)
    pub struct HSMLocalizableParameter {
        // message fields
        // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.default)
        pub default: ::std::option::Option<::std::string::String>,
        // message oneof groups
        pub paramOneof: ::std::option::Option<hsmlocalizable_parameter::ParamOneof>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HSMLocalizableParameter {
        fn default() -> &'a HSMLocalizableParameter {
            <HSMLocalizableParameter as ::protobuf::Message>::default_instance()
        }
    }

    impl HSMLocalizableParameter {
        pub fn new() -> HSMLocalizableParameter {
            ::std::default::Default::default()
        }

        // optional string default = 1;

        pub fn default(&self) -> &str {
            match self.default.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_default(&mut self) {
            self.default = ::std::option::Option::None;
        }

        pub fn has_default(&self) -> bool {
            self.default.is_some()
        }

        // Param is passed by value, moved
        pub fn set_default(&mut self, v: ::std::string::String) {
            self.default = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_default(&mut self) -> &mut ::std::string::String {
            if self.default.is_none() {
                self.default = ::std::option::Option::Some(::std::string::String::new());
            }
            self.default.as_mut().unwrap()
        }

        // Take field
        pub fn take_default(&mut self) -> ::std::string::String {
            self.default.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency currency = 2;

        pub fn currency(&self) -> &hsmlocalizable_parameter::HSMCurrency {
            match self.paramOneof {
                ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(ref v)) => v,
                _ => <hsmlocalizable_parameter::HSMCurrency as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_currency(&mut self) {
            self.paramOneof = ::std::option::Option::None;
        }

        pub fn has_currency(&self) -> bool {
            match self.paramOneof {
                ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_currency(&mut self, v: hsmlocalizable_parameter::HSMCurrency) {
            self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(v))
        }

        // Mutable pointer to the field.
        pub fn mut_currency(&mut self) -> &mut hsmlocalizable_parameter::HSMCurrency {
            if let ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(_)) = self.paramOneof {
            } else {
                self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(hsmlocalizable_parameter::HSMCurrency::new()));
            }
            match self.paramOneof {
                ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_currency(&mut self) -> hsmlocalizable_parameter::HSMCurrency {
            if self.has_currency() {
                match self.paramOneof.take() {
                    ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(v)) => v,
                    _ => panic!(),
                }
            } else {
                hsmlocalizable_parameter::HSMCurrency::new()
            }
        }

        // optional .proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime dateTime = 3;

        pub fn dateTime(&self) -> &hsmlocalizable_parameter::HSMDateTime {
            match self.paramOneof {
                ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(ref v)) => v,
                _ => <hsmlocalizable_parameter::HSMDateTime as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_dateTime(&mut self) {
            self.paramOneof = ::std::option::Option::None;
        }

        pub fn has_dateTime(&self) -> bool {
            match self.paramOneof {
                ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_dateTime(&mut self, v: hsmlocalizable_parameter::HSMDateTime) {
            self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(v))
        }

        // Mutable pointer to the field.
        pub fn mut_dateTime(&mut self) -> &mut hsmlocalizable_parameter::HSMDateTime {
            if let ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(_)) = self.paramOneof {
            } else {
                self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(hsmlocalizable_parameter::HSMDateTime::new()));
            }
            match self.paramOneof {
                ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_dateTime(&mut self) -> hsmlocalizable_parameter::HSMDateTime {
            if self.has_dateTime() {
                match self.paramOneof.take() {
                    ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(v)) => v,
                    _ => panic!(),
                }
            } else {
                hsmlocalizable_parameter::HSMDateTime::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "default",
                |m: &HSMLocalizableParameter| { &m.default },
                |m: &mut HSMLocalizableParameter| { &mut m.default },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, hsmlocalizable_parameter::HSMCurrency>(
                "currency",
                HSMLocalizableParameter::has_currency,
                HSMLocalizableParameter::currency,
                HSMLocalizableParameter::mut_currency,
                HSMLocalizableParameter::set_currency,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, hsmlocalizable_parameter::HSMDateTime>(
                "dateTime",
                HSMLocalizableParameter::has_dateTime,
                HSMLocalizableParameter::dateTime,
                HSMLocalizableParameter::mut_dateTime,
                HSMLocalizableParameter::set_dateTime,
            ));
            oneofs.push(hsmlocalizable_parameter::ParamOneof::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMLocalizableParameter>(
                "HighlyStructuredMessage.HSMLocalizableParameter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HSMLocalizableParameter {
        const NAME: &'static str = "HSMLocalizableParameter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.default = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::Currency(is.read_message()?));
                    },
                    26 => {
                        self.paramOneof = ::std::option::Option::Some(hsmlocalizable_parameter::ParamOneof::DateTime(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.default.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let ::std::option::Option::Some(ref v) = self.paramOneof {
                match v {
                    &hsmlocalizable_parameter::ParamOneof::Currency(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &hsmlocalizable_parameter::ParamOneof::DateTime(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.default.as_ref() {
                os.write_string(1, v)?;
            }
            if let ::std::option::Option::Some(ref v) = self.paramOneof {
                match v {
                    &hsmlocalizable_parameter::ParamOneof::Currency(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &hsmlocalizable_parameter::ParamOneof::DateTime(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HSMLocalizableParameter {
            HSMLocalizableParameter::new()
        }

        fn clear(&mut self) {
            self.default = ::std::option::Option::None;
            self.paramOneof = ::std::option::Option::None;
            self.paramOneof = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HSMLocalizableParameter {
            static instance: HSMLocalizableParameter = HSMLocalizableParameter {
                default: ::std::option::Option::None,
                paramOneof: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HSMLocalizableParameter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HighlyStructuredMessage.HSMLocalizableParameter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HSMLocalizableParameter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HSMLocalizableParameter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `HSMLocalizableParameter`
    pub mod hsmlocalizable_parameter {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:proto.HighlyStructuredMessage.HSMLocalizableParameter.paramOneof)
        pub enum ParamOneof {
            // @@protoc_insertion_point(oneof_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.currency)
            Currency(HSMCurrency),
            // @@protoc_insertion_point(oneof_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.dateTime)
            DateTime(HSMDateTime),
        }

        impl ::protobuf::Oneof for ParamOneof {
        }

        impl ::protobuf::OneofFull for ParamOneof {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::HSMLocalizableParameter as ::protobuf::MessageFull>::descriptor().oneof_by_name("paramOneof").unwrap()).clone()
            }
        }

        impl ParamOneof {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<ParamOneof>("paramOneof")
            }
        }
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime)
        pub struct HSMDateTime {
            // message oneof groups
            pub datetimeOneof: ::std::option::Option<hsmdate_time::DatetimeOneof>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a HSMDateTime {
            fn default() -> &'a HSMDateTime {
                <HSMDateTime as ::protobuf::Message>::default_instance()
            }
        }

        impl HSMDateTime {
            pub fn new() -> HSMDateTime {
                ::std::default::Default::default()
            }

            // optional .proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent component = 1;

            pub fn component(&self) -> &hsmdate_time::HSMDateTimeComponent {
                match self.datetimeOneof {
                    ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(ref v)) => v,
                    _ => <hsmdate_time::HSMDateTimeComponent as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_component(&mut self) {
                self.datetimeOneof = ::std::option::Option::None;
            }

            pub fn has_component(&self) -> bool {
                match self.datetimeOneof {
                    ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_component(&mut self, v: hsmdate_time::HSMDateTimeComponent) {
                self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(v))
            }

            // Mutable pointer to the field.
            pub fn mut_component(&mut self) -> &mut hsmdate_time::HSMDateTimeComponent {
                if let ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(_)) = self.datetimeOneof {
                } else {
                    self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(hsmdate_time::HSMDateTimeComponent::new()));
                }
                match self.datetimeOneof {
                    ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_component(&mut self) -> hsmdate_time::HSMDateTimeComponent {
                if self.has_component() {
                    match self.datetimeOneof.take() {
                        ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    hsmdate_time::HSMDateTimeComponent::new()
                }
            }

            // optional .proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch unixEpoch = 2;

            pub fn unixEpoch(&self) -> &hsmdate_time::HSMDateTimeUnixEpoch {
                match self.datetimeOneof {
                    ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(ref v)) => v,
                    _ => <hsmdate_time::HSMDateTimeUnixEpoch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_unixEpoch(&mut self) {
                self.datetimeOneof = ::std::option::Option::None;
            }

            pub fn has_unixEpoch(&self) -> bool {
                match self.datetimeOneof {
                    ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_unixEpoch(&mut self, v: hsmdate_time::HSMDateTimeUnixEpoch) {
                self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_unixEpoch(&mut self) -> &mut hsmdate_time::HSMDateTimeUnixEpoch {
                if let ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(_)) = self.datetimeOneof {
                } else {
                    self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(hsmdate_time::HSMDateTimeUnixEpoch::new()));
                }
                match self.datetimeOneof {
                    ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_unixEpoch(&mut self) -> hsmdate_time::HSMDateTimeUnixEpoch {
                if self.has_unixEpoch() {
                    match self.datetimeOneof.take() {
                        ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    hsmdate_time::HSMDateTimeUnixEpoch::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(1);
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, hsmdate_time::HSMDateTimeComponent>(
                    "component",
                    HSMDateTime::has_component,
                    HSMDateTime::component,
                    HSMDateTime::mut_component,
                    HSMDateTime::set_component,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, hsmdate_time::HSMDateTimeUnixEpoch>(
                    "unixEpoch",
                    HSMDateTime::has_unixEpoch,
                    HSMDateTime::unixEpoch,
                    HSMDateTime::mut_unixEpoch,
                    HSMDateTime::set_unixEpoch,
                ));
                oneofs.push(hsmdate_time::DatetimeOneof::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMDateTime>(
                    "HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for HSMDateTime {
            const NAME: &'static str = "HSMDateTime";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::Component(is.read_message()?));
                        },
                        18 => {
                            self.datetimeOneof = ::std::option::Option::Some(hsmdate_time::DatetimeOneof::UnixEpoch(is.read_message()?));
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let ::std::option::Option::Some(ref v) = self.datetimeOneof {
                    match v {
                        &hsmdate_time::DatetimeOneof::Component(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &hsmdate_time::DatetimeOneof::UnixEpoch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let ::std::option::Option::Some(ref v) = self.datetimeOneof {
                    match v {
                        &hsmdate_time::DatetimeOneof::Component(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                        },
                        &hsmdate_time::DatetimeOneof::UnixEpoch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> HSMDateTime {
                HSMDateTime::new()
            }

            fn clear(&mut self) {
                self.datetimeOneof = ::std::option::Option::None;
                self.datetimeOneof = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static HSMDateTime {
                static instance: HSMDateTime = HSMDateTime {
                    datetimeOneof: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for HSMDateTime {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for HSMDateTime {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for HSMDateTime {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `HSMDateTime`
        pub mod hsmdate_time {

            #[derive(Clone,PartialEq,Debug)]
            #[non_exhaustive]
            // @@protoc_insertion_point(oneof:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.datetimeOneof)
            pub enum DatetimeOneof {
                // @@protoc_insertion_point(oneof_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.component)
                Component(HSMDateTimeComponent),
                // @@protoc_insertion_point(oneof_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.unixEpoch)
                UnixEpoch(HSMDateTimeUnixEpoch),
            }

            impl ::protobuf::Oneof for DatetimeOneof {
            }

            impl ::protobuf::OneofFull for DatetimeOneof {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::HSMDateTime as ::protobuf::MessageFull>::descriptor().oneof_by_name("datetimeOneof").unwrap()).clone()
                }
            }

            impl DatetimeOneof {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<DatetimeOneof>("datetimeOneof")
                }
            }
            #[derive(PartialEq,Clone,Default,Debug)]
            // @@protoc_insertion_point(message:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch)
            pub struct HSMDateTimeUnixEpoch {
                // message fields
                // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.timestamp)
                pub timestamp: ::std::option::Option<i64>,
                // special fields
                // @@protoc_insertion_point(special_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a HSMDateTimeUnixEpoch {
                fn default() -> &'a HSMDateTimeUnixEpoch {
                    <HSMDateTimeUnixEpoch as ::protobuf::Message>::default_instance()
                }
            }

            impl HSMDateTimeUnixEpoch {
                pub fn new() -> HSMDateTimeUnixEpoch {
                    ::std::default::Default::default()
                }

                // optional int64 timestamp = 1;

                pub fn timestamp(&self) -> i64 {
                    self.timestamp.unwrap_or(0)
                }

                pub fn clear_timestamp(&mut self) {
                    self.timestamp = ::std::option::Option::None;
                }

                pub fn has_timestamp(&self) -> bool {
                    self.timestamp.is_some()
                }

                // Param is passed by value, moved
                pub fn set_timestamp(&mut self, v: i64) {
                    self.timestamp = ::std::option::Option::Some(v);
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(1);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "timestamp",
                        |m: &HSMDateTimeUnixEpoch| { &m.timestamp },
                        |m: &mut HSMDateTimeUnixEpoch| { &mut m.timestamp },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMDateTimeUnixEpoch>(
                        "HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for HSMDateTimeUnixEpoch {
                const NAME: &'static str = "HSMDateTimeUnixEpoch";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.timestamp {
                        my_size += ::protobuf::rt::int64_size(1, v);
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.timestamp {
                        os.write_int64(1, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> HSMDateTimeUnixEpoch {
                    HSMDateTimeUnixEpoch::new()
                }

                fn clear(&mut self) {
                    self.timestamp = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static HSMDateTimeUnixEpoch {
                    static instance: HSMDateTimeUnixEpoch = HSMDateTimeUnixEpoch {
                        timestamp: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for HSMDateTimeUnixEpoch {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpoch").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for HSMDateTimeUnixEpoch {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for HSMDateTimeUnixEpoch {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            #[derive(PartialEq,Clone,Default,Debug)]
            // @@protoc_insertion_point(message:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent)
            pub struct HSMDateTimeComponent {
                // message fields
                // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.dayOfWeek)
                pub dayOfWeek: ::std::option::Option<::protobuf::EnumOrUnknown<hsmdate_time_component::DayOfWeekType>>,
                // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.year)
                pub year: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.month)
                pub month: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.dayOfMonth)
                pub dayOfMonth: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.hour)
                pub hour: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.minute)
                pub minute: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.calendar)
                pub calendar: ::std::option::Option<::protobuf::EnumOrUnknown<hsmdate_time_component::CalendarType>>,
                // special fields
                // @@protoc_insertion_point(special_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a HSMDateTimeComponent {
                fn default() -> &'a HSMDateTimeComponent {
                    <HSMDateTimeComponent as ::protobuf::Message>::default_instance()
                }
            }

            impl HSMDateTimeComponent {
                pub fn new() -> HSMDateTimeComponent {
                    ::std::default::Default::default()
                }

                // optional .proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType dayOfWeek = 1;

                pub fn dayOfWeek(&self) -> hsmdate_time_component::DayOfWeekType {
                    match self.dayOfWeek {
                        Some(e) => e.enum_value_or(hsmdate_time_component::DayOfWeekType::MONDAY),
                        None => hsmdate_time_component::DayOfWeekType::MONDAY,
                    }
                }

                pub fn clear_dayOfWeek(&mut self) {
                    self.dayOfWeek = ::std::option::Option::None;
                }

                pub fn has_dayOfWeek(&self) -> bool {
                    self.dayOfWeek.is_some()
                }

                // Param is passed by value, moved
                pub fn set_dayOfWeek(&mut self, v: hsmdate_time_component::DayOfWeekType) {
                    self.dayOfWeek = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
                }

                // optional uint32 year = 2;

                pub fn year(&self) -> u32 {
                    self.year.unwrap_or(0)
                }

                pub fn clear_year(&mut self) {
                    self.year = ::std::option::Option::None;
                }

                pub fn has_year(&self) -> bool {
                    self.year.is_some()
                }

                // Param is passed by value, moved
                pub fn set_year(&mut self, v: u32) {
                    self.year = ::std::option::Option::Some(v);
                }

                // optional uint32 month = 3;

                pub fn month(&self) -> u32 {
                    self.month.unwrap_or(0)
                }

                pub fn clear_month(&mut self) {
                    self.month = ::std::option::Option::None;
                }

                pub fn has_month(&self) -> bool {
                    self.month.is_some()
                }

                // Param is passed by value, moved
                pub fn set_month(&mut self, v: u32) {
                    self.month = ::std::option::Option::Some(v);
                }

                // optional uint32 dayOfMonth = 4;

                pub fn dayOfMonth(&self) -> u32 {
                    self.dayOfMonth.unwrap_or(0)
                }

                pub fn clear_dayOfMonth(&mut self) {
                    self.dayOfMonth = ::std::option::Option::None;
                }

                pub fn has_dayOfMonth(&self) -> bool {
                    self.dayOfMonth.is_some()
                }

                // Param is passed by value, moved
                pub fn set_dayOfMonth(&mut self, v: u32) {
                    self.dayOfMonth = ::std::option::Option::Some(v);
                }

                // optional uint32 hour = 5;

                pub fn hour(&self) -> u32 {
                    self.hour.unwrap_or(0)
                }

                pub fn clear_hour(&mut self) {
                    self.hour = ::std::option::Option::None;
                }

                pub fn has_hour(&self) -> bool {
                    self.hour.is_some()
                }

                // Param is passed by value, moved
                pub fn set_hour(&mut self, v: u32) {
                    self.hour = ::std::option::Option::Some(v);
                }

                // optional uint32 minute = 6;

                pub fn minute(&self) -> u32 {
                    self.minute.unwrap_or(0)
                }

                pub fn clear_minute(&mut self) {
                    self.minute = ::std::option::Option::None;
                }

                pub fn has_minute(&self) -> bool {
                    self.minute.is_some()
                }

                // Param is passed by value, moved
                pub fn set_minute(&mut self, v: u32) {
                    self.minute = ::std::option::Option::Some(v);
                }

                // optional .proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType calendar = 7;

                pub fn calendar(&self) -> hsmdate_time_component::CalendarType {
                    match self.calendar {
                        Some(e) => e.enum_value_or(hsmdate_time_component::CalendarType::GREGORIAN),
                        None => hsmdate_time_component::CalendarType::GREGORIAN,
                    }
                }

                pub fn clear_calendar(&mut self) {
                    self.calendar = ::std::option::Option::None;
                }

                pub fn has_calendar(&self) -> bool {
                    self.calendar.is_some()
                }

                // Param is passed by value, moved
                pub fn set_calendar(&mut self, v: hsmdate_time_component::CalendarType) {
                    self.calendar = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(7);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "dayOfWeek",
                        |m: &HSMDateTimeComponent| { &m.dayOfWeek },
                        |m: &mut HSMDateTimeComponent| { &mut m.dayOfWeek },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "year",
                        |m: &HSMDateTimeComponent| { &m.year },
                        |m: &mut HSMDateTimeComponent| { &mut m.year },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "month",
                        |m: &HSMDateTimeComponent| { &m.month },
                        |m: &mut HSMDateTimeComponent| { &mut m.month },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "dayOfMonth",
                        |m: &HSMDateTimeComponent| { &m.dayOfMonth },
                        |m: &mut HSMDateTimeComponent| { &mut m.dayOfMonth },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "hour",
                        |m: &HSMDateTimeComponent| { &m.hour },
                        |m: &mut HSMDateTimeComponent| { &mut m.hour },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "minute",
                        |m: &HSMDateTimeComponent| { &m.minute },
                        |m: &mut HSMDateTimeComponent| { &mut m.minute },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                        "calendar",
                        |m: &HSMDateTimeComponent| { &m.calendar },
                        |m: &mut HSMDateTimeComponent| { &mut m.calendar },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMDateTimeComponent>(
                        "HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for HSMDateTimeComponent {
                const NAME: &'static str = "HSMDateTimeComponent";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.dayOfWeek = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                            },
                            16 => {
                                self.year = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.month = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            32 => {
                                self.dayOfMonth = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            40 => {
                                self.hour = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            48 => {
                                self.minute = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            56 => {
                                self.calendar = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.dayOfWeek {
                        my_size += ::protobuf::rt::int32_size(1, v.value());
                    }
                    if let Some(v) = self.year {
                        my_size += ::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.month {
                        my_size += ::protobuf::rt::uint32_size(3, v);
                    }
                    if let Some(v) = self.dayOfMonth {
                        my_size += ::protobuf::rt::uint32_size(4, v);
                    }
                    if let Some(v) = self.hour {
                        my_size += ::protobuf::rt::uint32_size(5, v);
                    }
                    if let Some(v) = self.minute {
                        my_size += ::protobuf::rt::uint32_size(6, v);
                    }
                    if let Some(v) = self.calendar {
                        my_size += ::protobuf::rt::int32_size(7, v.value());
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.dayOfWeek {
                        os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                    }
                    if let Some(v) = self.year {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.month {
                        os.write_uint32(3, v)?;
                    }
                    if let Some(v) = self.dayOfMonth {
                        os.write_uint32(4, v)?;
                    }
                    if let Some(v) = self.hour {
                        os.write_uint32(5, v)?;
                    }
                    if let Some(v) = self.minute {
                        os.write_uint32(6, v)?;
                    }
                    if let Some(v) = self.calendar {
                        os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> HSMDateTimeComponent {
                    HSMDateTimeComponent::new()
                }

                fn clear(&mut self) {
                    self.dayOfWeek = ::std::option::Option::None;
                    self.year = ::std::option::Option::None;
                    self.month = ::std::option::Option::None;
                    self.dayOfMonth = ::std::option::Option::None;
                    self.hour = ::std::option::Option::None;
                    self.minute = ::std::option::Option::None;
                    self.calendar = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static HSMDateTimeComponent {
                    static instance: HSMDateTimeComponent = HSMDateTimeComponent {
                        dayOfWeek: ::std::option::Option::None,
                        year: ::std::option::Option::None,
                        month: ::std::option::Option::None,
                        dayOfMonth: ::std::option::Option::None,
                        hour: ::std::option::Option::None,
                        minute: ::std::option::Option::None,
                        calendar: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for HSMDateTimeComponent {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for HSMDateTimeComponent {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for HSMDateTimeComponent {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `HSMDateTimeComponent`
            pub mod hsmdate_time_component {
                #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
                // @@protoc_insertion_point(enum:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType)
                pub enum DayOfWeekType {
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType.MONDAY)
                    MONDAY = 1,
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType.TUESDAY)
                    TUESDAY = 2,
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType.WEDNESDAY)
                    WEDNESDAY = 3,
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType.THURSDAY)
                    THURSDAY = 4,
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType.FRIDAY)
                    FRIDAY = 5,
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType.SATURDAY)
                    SATURDAY = 6,
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType.SUNDAY)
                    SUNDAY = 7,
                }

                impl ::protobuf::Enum for DayOfWeekType {
                    const NAME: &'static str = "DayOfWeekType";

                    fn value(&self) -> i32 {
                        *self as i32
                    }

                    fn from_i32(value: i32) -> ::std::option::Option<DayOfWeekType> {
                        match value {
                            1 => ::std::option::Option::Some(DayOfWeekType::MONDAY),
                            2 => ::std::option::Option::Some(DayOfWeekType::TUESDAY),
                            3 => ::std::option::Option::Some(DayOfWeekType::WEDNESDAY),
                            4 => ::std::option::Option::Some(DayOfWeekType::THURSDAY),
                            5 => ::std::option::Option::Some(DayOfWeekType::FRIDAY),
                            6 => ::std::option::Option::Some(DayOfWeekType::SATURDAY),
                            7 => ::std::option::Option::Some(DayOfWeekType::SUNDAY),
                            _ => ::std::option::Option::None
                        }
                    }

                    const VALUES: &'static [DayOfWeekType] = &[
                        DayOfWeekType::MONDAY,
                        DayOfWeekType::TUESDAY,
                        DayOfWeekType::WEDNESDAY,
                        DayOfWeekType::THURSDAY,
                        DayOfWeekType::FRIDAY,
                        DayOfWeekType::SATURDAY,
                        DayOfWeekType::SUNDAY,
                    ];
                }

                impl ::protobuf::EnumFull for DayOfWeekType {
                    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().enum_by_package_relative_name("HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType").unwrap()).clone()
                    }

                    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                        let index = match self {
                            DayOfWeekType::MONDAY => 0,
                            DayOfWeekType::TUESDAY => 1,
                            DayOfWeekType::WEDNESDAY => 2,
                            DayOfWeekType::THURSDAY => 3,
                            DayOfWeekType::FRIDAY => 4,
                            DayOfWeekType::SATURDAY => 5,
                            DayOfWeekType::SUNDAY => 6,
                        };
                        Self::enum_descriptor().value_by_index(index)
                    }
                }

                // Note, `Default` is implemented although default value is not 0
                impl ::std::default::Default for DayOfWeekType {
                    fn default() -> Self {
                        DayOfWeekType::MONDAY
                    }
                }

                impl DayOfWeekType {
                    pub(in super::super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DayOfWeekType>("HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekType")
                    }
                }

                #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
                // @@protoc_insertion_point(enum:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType)
                pub enum CalendarType {
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType.GREGORIAN)
                    GREGORIAN = 1,
                    // @@protoc_insertion_point(enum_value:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType.SOLAR_HIJRI)
                    SOLAR_HIJRI = 2,
                }

                impl ::protobuf::Enum for CalendarType {
                    const NAME: &'static str = "CalendarType";

                    fn value(&self) -> i32 {
                        *self as i32
                    }

                    fn from_i32(value: i32) -> ::std::option::Option<CalendarType> {
                        match value {
                            1 => ::std::option::Option::Some(CalendarType::GREGORIAN),
                            2 => ::std::option::Option::Some(CalendarType::SOLAR_HIJRI),
                            _ => ::std::option::Option::None
                        }
                    }

                    const VALUES: &'static [CalendarType] = &[
                        CalendarType::GREGORIAN,
                        CalendarType::SOLAR_HIJRI,
                    ];
                }

                impl ::protobuf::EnumFull for CalendarType {
                    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().enum_by_package_relative_name("HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType").unwrap()).clone()
                    }

                    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                        let index = match self {
                            CalendarType::GREGORIAN => 0,
                            CalendarType::SOLAR_HIJRI => 1,
                        };
                        Self::enum_descriptor().value_by_index(index)
                    }
                }

                // Note, `Default` is implemented although default value is not 0
                impl ::std::default::Default for CalendarType {
                    fn default() -> Self {
                        CalendarType::GREGORIAN
                    }
                }

                impl CalendarType {
                    pub(in super::super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CalendarType>("HighlyStructuredMessage.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponent.CalendarType")
                    }
                }
            }
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency)
        pub struct HSMCurrency {
            // message fields
            // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.currencyCode)
            pub currencyCode: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.amount1000)
            pub amount1000: ::std::option::Option<i64>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a HSMCurrency {
            fn default() -> &'a HSMCurrency {
                <HSMCurrency as ::protobuf::Message>::default_instance()
            }
        }

        impl HSMCurrency {
            pub fn new() -> HSMCurrency {
                ::std::default::Default::default()
            }

            // optional string currencyCode = 1;

            pub fn currencyCode(&self) -> &str {
                match self.currencyCode.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_currencyCode(&mut self) {
                self.currencyCode = ::std::option::Option::None;
            }

            pub fn has_currencyCode(&self) -> bool {
                self.currencyCode.is_some()
            }

            // Param is passed by value, moved
            pub fn set_currencyCode(&mut self, v: ::std::string::String) {
                self.currencyCode = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_currencyCode(&mut self) -> &mut ::std::string::String {
                if self.currencyCode.is_none() {
                    self.currencyCode = ::std::option::Option::Some(::std::string::String::new());
                }
                self.currencyCode.as_mut().unwrap()
            }

            // Take field
            pub fn take_currencyCode(&mut self) -> ::std::string::String {
                self.currencyCode.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int64 amount1000 = 2;

            pub fn amount1000(&self) -> i64 {
                self.amount1000.unwrap_or(0)
            }

            pub fn clear_amount1000(&mut self) {
                self.amount1000 = ::std::option::Option::None;
            }

            pub fn has_amount1000(&self) -> bool {
                self.amount1000.is_some()
            }

            // Param is passed by value, moved
            pub fn set_amount1000(&mut self, v: i64) {
                self.amount1000 = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "currencyCode",
                    |m: &HSMCurrency| { &m.currencyCode },
                    |m: &mut HSMCurrency| { &mut m.currencyCode },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "amount1000",
                    |m: &HSMCurrency| { &m.amount1000 },
                    |m: &mut HSMCurrency| { &mut m.amount1000 },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HSMCurrency>(
                    "HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for HSMCurrency {
            const NAME: &'static str = "HSMCurrency";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.currencyCode = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.amount1000 = ::std::option::Option::Some(is.read_int64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.currencyCode.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.amount1000 {
                    my_size += ::protobuf::rt::int64_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.currencyCode.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.amount1000 {
                    os.write_int64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> HSMCurrency {
                HSMCurrency::new()
            }

            fn clear(&mut self) {
                self.currencyCode = ::std::option::Option::None;
                self.amount1000 = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static HSMCurrency {
                static instance: HSMCurrency = HSMCurrency {
                    currencyCode: ::std::option::Option::None,
                    amount1000: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for HSMCurrency {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("HighlyStructuredMessage.HSMLocalizableParameter.HSMCurrency").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for HSMCurrency {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for HSMCurrency {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.GroupInviteMessage)
pub struct GroupInviteMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.GroupInviteMessage.groupJid)
    pub groupJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.GroupInviteMessage.inviteCode)
    pub inviteCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.GroupInviteMessage.inviteExpiration)
    pub inviteExpiration: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.GroupInviteMessage.groupName)
    pub groupName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.GroupInviteMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.GroupInviteMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.GroupInviteMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.GroupInviteMessage.groupType)
    pub groupType: ::std::option::Option<::protobuf::EnumOrUnknown<group_invite_message::GroupType>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.GroupInviteMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupInviteMessage {
    fn default() -> &'a GroupInviteMessage {
        <GroupInviteMessage as ::protobuf::Message>::default_instance()
    }
}

impl GroupInviteMessage {
    pub fn new() -> GroupInviteMessage {
        ::std::default::Default::default()
    }

    // optional string groupJid = 1;

    pub fn groupJid(&self) -> &str {
        match self.groupJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupJid(&mut self) {
        self.groupJid = ::std::option::Option::None;
    }

    pub fn has_groupJid(&self) -> bool {
        self.groupJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupJid(&mut self, v: ::std::string::String) {
        self.groupJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupJid(&mut self) -> &mut ::std::string::String {
        if self.groupJid.is_none() {
            self.groupJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupJid(&mut self) -> ::std::string::String {
        self.groupJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string inviteCode = 2;

    pub fn inviteCode(&self) -> &str {
        match self.inviteCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_inviteCode(&mut self) {
        self.inviteCode = ::std::option::Option::None;
    }

    pub fn has_inviteCode(&self) -> bool {
        self.inviteCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteCode(&mut self, v: ::std::string::String) {
        self.inviteCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inviteCode(&mut self) -> &mut ::std::string::String {
        if self.inviteCode.is_none() {
            self.inviteCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.inviteCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_inviteCode(&mut self) -> ::std::string::String {
        self.inviteCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 inviteExpiration = 3;

    pub fn inviteExpiration(&self) -> i64 {
        self.inviteExpiration.unwrap_or(0)
    }

    pub fn clear_inviteExpiration(&mut self) {
        self.inviteExpiration = ::std::option::Option::None;
    }

    pub fn has_inviteExpiration(&self) -> bool {
        self.inviteExpiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteExpiration(&mut self, v: i64) {
        self.inviteExpiration = ::std::option::Option::Some(v);
    }

    // optional string groupName = 4;

    pub fn groupName(&self) -> &str {
        match self.groupName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupName(&mut self) {
        self.groupName = ::std::option::Option::None;
    }

    pub fn has_groupName(&self) -> bool {
        self.groupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupName(&mut self, v: ::std::string::String) {
        self.groupName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupName(&mut self) -> &mut ::std::string::String {
        if self.groupName.is_none() {
            self.groupName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupName(&mut self) -> ::std::string::String {
        self.groupName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes jpegThumbnail = 5;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string caption = 6;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.GroupInviteMessage.GroupType groupType = 8;

    pub fn groupType(&self) -> group_invite_message::GroupType {
        match self.groupType {
            Some(e) => e.enum_value_or(group_invite_message::GroupType::DEFAULT),
            None => group_invite_message::GroupType::DEFAULT,
        }
    }

    pub fn clear_groupType(&mut self) {
        self.groupType = ::std::option::Option::None;
    }

    pub fn has_groupType(&self) -> bool {
        self.groupType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupType(&mut self, v: group_invite_message::GroupType) {
        self.groupType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupJid",
            |m: &GroupInviteMessage| { &m.groupJid },
            |m: &mut GroupInviteMessage| { &mut m.groupJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteCode",
            |m: &GroupInviteMessage| { &m.inviteCode },
            |m: &mut GroupInviteMessage| { &mut m.inviteCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteExpiration",
            |m: &GroupInviteMessage| { &m.inviteExpiration },
            |m: &mut GroupInviteMessage| { &mut m.inviteExpiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupName",
            |m: &GroupInviteMessage| { &m.groupName },
            |m: &mut GroupInviteMessage| { &mut m.groupName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &GroupInviteMessage| { &m.jpegThumbnail },
            |m: &mut GroupInviteMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &GroupInviteMessage| { &m.caption },
            |m: &mut GroupInviteMessage| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &GroupInviteMessage| { &m.contextInfo },
            |m: &mut GroupInviteMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupType",
            |m: &GroupInviteMessage| { &m.groupType },
            |m: &mut GroupInviteMessage| { &mut m.groupType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupInviteMessage>(
            "GroupInviteMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupInviteMessage {
    const NAME: &'static str = "GroupInviteMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupJid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.inviteCode = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.inviteExpiration = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.groupName = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                64 => {
                    self.groupType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.inviteCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.inviteExpiration {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.groupName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.groupType {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.inviteCode.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.inviteExpiration {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.groupName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.groupType {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupInviteMessage {
        GroupInviteMessage::new()
    }

    fn clear(&mut self) {
        self.groupJid = ::std::option::Option::None;
        self.inviteCode = ::std::option::Option::None;
        self.inviteExpiration = ::std::option::Option::None;
        self.groupName = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.contextInfo.clear();
        self.groupType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupInviteMessage {
        static instance: GroupInviteMessage = GroupInviteMessage {
            groupJid: ::std::option::Option::None,
            inviteCode: ::std::option::Option::None,
            inviteExpiration: ::std::option::Option::None,
            groupName: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            groupType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupInviteMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupInviteMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupInviteMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupInviteMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GroupInviteMessage`
pub mod group_invite_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.GroupInviteMessage.GroupType)
    pub enum GroupType {
        // @@protoc_insertion_point(enum_value:proto.GroupInviteMessage.GroupType.DEFAULT)
        DEFAULT = 0,
        // @@protoc_insertion_point(enum_value:proto.GroupInviteMessage.GroupType.PARENT)
        PARENT = 1,
    }

    impl ::protobuf::Enum for GroupType {
        const NAME: &'static str = "GroupType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<GroupType> {
            match value {
                0 => ::std::option::Option::Some(GroupType::DEFAULT),
                1 => ::std::option::Option::Some(GroupType::PARENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [GroupType] = &[
            GroupType::DEFAULT,
            GroupType::PARENT,
        ];
    }

    impl ::protobuf::EnumFull for GroupType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GroupInviteMessage.GroupType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for GroupType {
        fn default() -> Self {
            GroupType::DEFAULT
        }
    }

    impl GroupType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GroupType>("GroupInviteMessage.GroupType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.FutureProofMessage)
pub struct FutureProofMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.FutureProofMessage.message)
    pub message: ::protobuf::MessageField<Message>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.FutureProofMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FutureProofMessage {
    fn default() -> &'a FutureProofMessage {
        <FutureProofMessage as ::protobuf::Message>::default_instance()
    }
}

impl FutureProofMessage {
    pub fn new() -> FutureProofMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "message",
            |m: &FutureProofMessage| { &m.message },
            |m: &mut FutureProofMessage| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FutureProofMessage>(
            "FutureProofMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FutureProofMessage {
    const NAME: &'static str = "FutureProofMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FutureProofMessage {
        FutureProofMessage::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FutureProofMessage {
        static instance: FutureProofMessage = FutureProofMessage {
            message: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FutureProofMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FutureProofMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FutureProofMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FutureProofMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ExtendedTextMessage)
pub struct ExtendedTextMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.matchedText)
    pub matchedText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.canonicalUrl)
    pub canonicalUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.textArgb)
    pub textArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.backgroundArgb)
    pub backgroundArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.font)
    pub font: ::std::option::Option<::protobuf::EnumOrUnknown<extended_text_message::FontType>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.previewType)
    pub previewType: ::std::option::Option<::protobuf::EnumOrUnknown<extended_text_message::PreviewType>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.doNotPlayInline)
    pub doNotPlayInline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.thumbnailDirectPath)
    pub thumbnailDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.thumbnailSha256)
    pub thumbnailSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.thumbnailEncSha256)
    pub thumbnailEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.thumbnailHeight)
    pub thumbnailHeight: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.thumbnailWidth)
    pub thumbnailWidth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.inviteLinkGroupType)
    pub inviteLinkGroupType: ::std::option::Option<::protobuf::EnumOrUnknown<extended_text_message::InviteLinkGroupType>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.inviteLinkParentGroupSubjectV2)
    pub inviteLinkParentGroupSubjectV2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.inviteLinkParentGroupThumbnailV2)
    pub inviteLinkParentGroupThumbnailV2: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.inviteLinkGroupTypeV2)
    pub inviteLinkGroupTypeV2: ::std::option::Option<::protobuf::EnumOrUnknown<extended_text_message::InviteLinkGroupType>>,
    // @@protoc_insertion_point(field:proto.ExtendedTextMessage.viewOnce)
    pub viewOnce: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ExtendedTextMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtendedTextMessage {
    fn default() -> &'a ExtendedTextMessage {
        <ExtendedTextMessage as ::protobuf::Message>::default_instance()
    }
}

impl ExtendedTextMessage {
    pub fn new() -> ExtendedTextMessage {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string matchedText = 2;

    pub fn matchedText(&self) -> &str {
        match self.matchedText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchedText(&mut self) {
        self.matchedText = ::std::option::Option::None;
    }

    pub fn has_matchedText(&self) -> bool {
        self.matchedText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchedText(&mut self, v: ::std::string::String) {
        self.matchedText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchedText(&mut self) -> &mut ::std::string::String {
        if self.matchedText.is_none() {
            self.matchedText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchedText.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchedText(&mut self) -> ::std::string::String {
        self.matchedText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string canonicalUrl = 4;

    pub fn canonicalUrl(&self) -> &str {
        match self.canonicalUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_canonicalUrl(&mut self) {
        self.canonicalUrl = ::std::option::Option::None;
    }

    pub fn has_canonicalUrl(&self) -> bool {
        self.canonicalUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonicalUrl(&mut self, v: ::std::string::String) {
        self.canonicalUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonicalUrl(&mut self) -> &mut ::std::string::String {
        if self.canonicalUrl.is_none() {
            self.canonicalUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.canonicalUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_canonicalUrl(&mut self) -> ::std::string::String {
        self.canonicalUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 5;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 6;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 textArgb = 7;

    pub fn textArgb(&self) -> u32 {
        self.textArgb.unwrap_or(0)
    }

    pub fn clear_textArgb(&mut self) {
        self.textArgb = ::std::option::Option::None;
    }

    pub fn has_textArgb(&self) -> bool {
        self.textArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textArgb(&mut self, v: u32) {
        self.textArgb = ::std::option::Option::Some(v);
    }

    // optional fixed32 backgroundArgb = 8;

    pub fn backgroundArgb(&self) -> u32 {
        self.backgroundArgb.unwrap_or(0)
    }

    pub fn clear_backgroundArgb(&mut self) {
        self.backgroundArgb = ::std::option::Option::None;
    }

    pub fn has_backgroundArgb(&self) -> bool {
        self.backgroundArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backgroundArgb(&mut self, v: u32) {
        self.backgroundArgb = ::std::option::Option::Some(v);
    }

    // optional .proto.ExtendedTextMessage.FontType font = 9;

    pub fn font(&self) -> extended_text_message::FontType {
        match self.font {
            Some(e) => e.enum_value_or(extended_text_message::FontType::SANS_SERIF),
            None => extended_text_message::FontType::SANS_SERIF,
        }
    }

    pub fn clear_font(&mut self) {
        self.font = ::std::option::Option::None;
    }

    pub fn has_font(&self) -> bool {
        self.font.is_some()
    }

    // Param is passed by value, moved
    pub fn set_font(&mut self, v: extended_text_message::FontType) {
        self.font = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.ExtendedTextMessage.PreviewType previewType = 10;

    pub fn previewType(&self) -> extended_text_message::PreviewType {
        match self.previewType {
            Some(e) => e.enum_value_or(extended_text_message::PreviewType::NONE),
            None => extended_text_message::PreviewType::NONE,
        }
    }

    pub fn clear_previewType(&mut self) {
        self.previewType = ::std::option::Option::None;
    }

    pub fn has_previewType(&self) -> bool {
        self.previewType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previewType(&mut self, v: extended_text_message::PreviewType) {
        self.previewType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool doNotPlayInline = 18;

    pub fn doNotPlayInline(&self) -> bool {
        self.doNotPlayInline.unwrap_or(false)
    }

    pub fn clear_doNotPlayInline(&mut self) {
        self.doNotPlayInline = ::std::option::Option::None;
    }

    pub fn has_doNotPlayInline(&self) -> bool {
        self.doNotPlayInline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_doNotPlayInline(&mut self, v: bool) {
        self.doNotPlayInline = ::std::option::Option::Some(v);
    }

    // optional string thumbnailDirectPath = 19;

    pub fn thumbnailDirectPath(&self) -> &str {
        match self.thumbnailDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailDirectPath(&mut self) {
        self.thumbnailDirectPath = ::std::option::Option::None;
    }

    pub fn has_thumbnailDirectPath(&self) -> bool {
        self.thumbnailDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailDirectPath(&mut self, v: ::std::string::String) {
        self.thumbnailDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailDirectPath(&mut self) -> &mut ::std::string::String {
        if self.thumbnailDirectPath.is_none() {
            self.thumbnailDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailDirectPath(&mut self) -> ::std::string::String {
        self.thumbnailDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnailSha256 = 20;

    pub fn thumbnailSha256(&self) -> &[u8] {
        match self.thumbnailSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailSha256(&mut self) {
        self.thumbnailSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailSha256(&self) -> bool {
        self.thumbnailSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailSha256.is_none() {
            self.thumbnailSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes thumbnailEncSha256 = 21;

    pub fn thumbnailEncSha256(&self) -> &[u8] {
        match self.thumbnailEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailEncSha256(&mut self) {
        self.thumbnailEncSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailEncSha256(&self) -> bool {
        self.thumbnailEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailEncSha256.is_none() {
            self.thumbnailEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mediaKey = 22;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 mediaKeyTimestamp = 23;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnailHeight = 24;

    pub fn thumbnailHeight(&self) -> u32 {
        self.thumbnailHeight.unwrap_or(0)
    }

    pub fn clear_thumbnailHeight(&mut self) {
        self.thumbnailHeight = ::std::option::Option::None;
    }

    pub fn has_thumbnailHeight(&self) -> bool {
        self.thumbnailHeight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailHeight(&mut self, v: u32) {
        self.thumbnailHeight = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnailWidth = 25;

    pub fn thumbnailWidth(&self) -> u32 {
        self.thumbnailWidth.unwrap_or(0)
    }

    pub fn clear_thumbnailWidth(&mut self) {
        self.thumbnailWidth = ::std::option::Option::None;
    }

    pub fn has_thumbnailWidth(&self) -> bool {
        self.thumbnailWidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailWidth(&mut self, v: u32) {
        self.thumbnailWidth = ::std::option::Option::Some(v);
    }

    // optional .proto.ExtendedTextMessage.InviteLinkGroupType inviteLinkGroupType = 26;

    pub fn inviteLinkGroupType(&self) -> extended_text_message::InviteLinkGroupType {
        match self.inviteLinkGroupType {
            Some(e) => e.enum_value_or(extended_text_message::InviteLinkGroupType::DEFAULT),
            None => extended_text_message::InviteLinkGroupType::DEFAULT,
        }
    }

    pub fn clear_inviteLinkGroupType(&mut self) {
        self.inviteLinkGroupType = ::std::option::Option::None;
    }

    pub fn has_inviteLinkGroupType(&self) -> bool {
        self.inviteLinkGroupType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteLinkGroupType(&mut self, v: extended_text_message::InviteLinkGroupType) {
        self.inviteLinkGroupType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string inviteLinkParentGroupSubjectV2 = 27;

    pub fn inviteLinkParentGroupSubjectV2(&self) -> &str {
        match self.inviteLinkParentGroupSubjectV2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_inviteLinkParentGroupSubjectV2(&mut self) {
        self.inviteLinkParentGroupSubjectV2 = ::std::option::Option::None;
    }

    pub fn has_inviteLinkParentGroupSubjectV2(&self) -> bool {
        self.inviteLinkParentGroupSubjectV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteLinkParentGroupSubjectV2(&mut self, v: ::std::string::String) {
        self.inviteLinkParentGroupSubjectV2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inviteLinkParentGroupSubjectV2(&mut self) -> &mut ::std::string::String {
        if self.inviteLinkParentGroupSubjectV2.is_none() {
            self.inviteLinkParentGroupSubjectV2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.inviteLinkParentGroupSubjectV2.as_mut().unwrap()
    }

    // Take field
    pub fn take_inviteLinkParentGroupSubjectV2(&mut self) -> ::std::string::String {
        self.inviteLinkParentGroupSubjectV2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes inviteLinkParentGroupThumbnailV2 = 28;

    pub fn inviteLinkParentGroupThumbnailV2(&self) -> &[u8] {
        match self.inviteLinkParentGroupThumbnailV2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_inviteLinkParentGroupThumbnailV2(&mut self) {
        self.inviteLinkParentGroupThumbnailV2 = ::std::option::Option::None;
    }

    pub fn has_inviteLinkParentGroupThumbnailV2(&self) -> bool {
        self.inviteLinkParentGroupThumbnailV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteLinkParentGroupThumbnailV2(&mut self, v: ::std::vec::Vec<u8>) {
        self.inviteLinkParentGroupThumbnailV2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inviteLinkParentGroupThumbnailV2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.inviteLinkParentGroupThumbnailV2.is_none() {
            self.inviteLinkParentGroupThumbnailV2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.inviteLinkParentGroupThumbnailV2.as_mut().unwrap()
    }

    // Take field
    pub fn take_inviteLinkParentGroupThumbnailV2(&mut self) -> ::std::vec::Vec<u8> {
        self.inviteLinkParentGroupThumbnailV2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .proto.ExtendedTextMessage.InviteLinkGroupType inviteLinkGroupTypeV2 = 29;

    pub fn inviteLinkGroupTypeV2(&self) -> extended_text_message::InviteLinkGroupType {
        match self.inviteLinkGroupTypeV2 {
            Some(e) => e.enum_value_or(extended_text_message::InviteLinkGroupType::DEFAULT),
            None => extended_text_message::InviteLinkGroupType::DEFAULT,
        }
    }

    pub fn clear_inviteLinkGroupTypeV2(&mut self) {
        self.inviteLinkGroupTypeV2 = ::std::option::Option::None;
    }

    pub fn has_inviteLinkGroupTypeV2(&self) -> bool {
        self.inviteLinkGroupTypeV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviteLinkGroupTypeV2(&mut self, v: extended_text_message::InviteLinkGroupType) {
        self.inviteLinkGroupTypeV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool viewOnce = 30;

    pub fn viewOnce(&self) -> bool {
        self.viewOnce.unwrap_or(false)
    }

    pub fn clear_viewOnce(&mut self) {
        self.viewOnce = ::std::option::Option::None;
    }

    pub fn has_viewOnce(&self) -> bool {
        self.viewOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewOnce(&mut self, v: bool) {
        self.viewOnce = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &ExtendedTextMessage| { &m.text },
            |m: &mut ExtendedTextMessage| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchedText",
            |m: &ExtendedTextMessage| { &m.matchedText },
            |m: &mut ExtendedTextMessage| { &mut m.matchedText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "canonicalUrl",
            |m: &ExtendedTextMessage| { &m.canonicalUrl },
            |m: &mut ExtendedTextMessage| { &mut m.canonicalUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ExtendedTextMessage| { &m.description },
            |m: &mut ExtendedTextMessage| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ExtendedTextMessage| { &m.title },
            |m: &mut ExtendedTextMessage| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "textArgb",
            |m: &ExtendedTextMessage| { &m.textArgb },
            |m: &mut ExtendedTextMessage| { &mut m.textArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backgroundArgb",
            |m: &ExtendedTextMessage| { &m.backgroundArgb },
            |m: &mut ExtendedTextMessage| { &mut m.backgroundArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "font",
            |m: &ExtendedTextMessage| { &m.font },
            |m: &mut ExtendedTextMessage| { &mut m.font },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "previewType",
            |m: &ExtendedTextMessage| { &m.previewType },
            |m: &mut ExtendedTextMessage| { &mut m.previewType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &ExtendedTextMessage| { &m.jpegThumbnail },
            |m: &mut ExtendedTextMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ExtendedTextMessage| { &m.contextInfo },
            |m: &mut ExtendedTextMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "doNotPlayInline",
            |m: &ExtendedTextMessage| { &m.doNotPlayInline },
            |m: &mut ExtendedTextMessage| { &mut m.doNotPlayInline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailDirectPath",
            |m: &ExtendedTextMessage| { &m.thumbnailDirectPath },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailSha256",
            |m: &ExtendedTextMessage| { &m.thumbnailSha256 },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailEncSha256",
            |m: &ExtendedTextMessage| { &m.thumbnailEncSha256 },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &ExtendedTextMessage| { &m.mediaKey },
            |m: &mut ExtendedTextMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &ExtendedTextMessage| { &m.mediaKeyTimestamp },
            |m: &mut ExtendedTextMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailHeight",
            |m: &ExtendedTextMessage| { &m.thumbnailHeight },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailWidth",
            |m: &ExtendedTextMessage| { &m.thumbnailWidth },
            |m: &mut ExtendedTextMessage| { &mut m.thumbnailWidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteLinkGroupType",
            |m: &ExtendedTextMessage| { &m.inviteLinkGroupType },
            |m: &mut ExtendedTextMessage| { &mut m.inviteLinkGroupType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteLinkParentGroupSubjectV2",
            |m: &ExtendedTextMessage| { &m.inviteLinkParentGroupSubjectV2 },
            |m: &mut ExtendedTextMessage| { &mut m.inviteLinkParentGroupSubjectV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteLinkParentGroupThumbnailV2",
            |m: &ExtendedTextMessage| { &m.inviteLinkParentGroupThumbnailV2 },
            |m: &mut ExtendedTextMessage| { &mut m.inviteLinkParentGroupThumbnailV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inviteLinkGroupTypeV2",
            |m: &ExtendedTextMessage| { &m.inviteLinkGroupTypeV2 },
            |m: &mut ExtendedTextMessage| { &mut m.inviteLinkGroupTypeV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewOnce",
            |m: &ExtendedTextMessage| { &m.viewOnce },
            |m: &mut ExtendedTextMessage| { &mut m.viewOnce },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtendedTextMessage>(
            "ExtendedTextMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExtendedTextMessage {
    const NAME: &'static str = "ExtendedTextMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.matchedText = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.canonicalUrl = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                61 => {
                    self.textArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.backgroundArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.font = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.previewType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                144 => {
                    self.doNotPlayInline = ::std::option::Option::Some(is.read_bool()?);
                },
                154 => {
                    self.thumbnailDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.thumbnailSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                170 => {
                    self.thumbnailEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                178 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                184 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                192 => {
                    self.thumbnailHeight = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.thumbnailWidth = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.inviteLinkGroupType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                218 => {
                    self.inviteLinkParentGroupSubjectV2 = ::std::option::Option::Some(is.read_string()?);
                },
                226 => {
                    self.inviteLinkParentGroupThumbnailV2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                232 => {
                    self.inviteLinkGroupTypeV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                240 => {
                    self.viewOnce = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.matchedText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.canonicalUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.textArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.backgroundArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.font {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.previewType {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.doNotPlayInline {
            my_size += 2 + 1;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(22, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(23, v);
        }
        if let Some(v) = self.thumbnailHeight {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.thumbnailWidth {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.inviteLinkGroupType {
            my_size += ::protobuf::rt::int32_size(26, v.value());
        }
        if let Some(v) = self.inviteLinkParentGroupSubjectV2.as_ref() {
            my_size += ::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.inviteLinkParentGroupThumbnailV2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(28, &v);
        }
        if let Some(v) = self.inviteLinkGroupTypeV2 {
            my_size += ::protobuf::rt::int32_size(29, v.value());
        }
        if let Some(v) = self.viewOnce {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.matchedText.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.canonicalUrl.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.textArgb {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.backgroundArgb {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.font {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.previewType {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.doNotPlayInline {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            os.write_bytes(20, v)?;
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            os.write_bytes(21, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(22, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(23, v)?;
        }
        if let Some(v) = self.thumbnailHeight {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.thumbnailWidth {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.inviteLinkGroupType {
            os.write_enum(26, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.inviteLinkParentGroupSubjectV2.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.inviteLinkParentGroupThumbnailV2.as_ref() {
            os.write_bytes(28, v)?;
        }
        if let Some(v) = self.inviteLinkGroupTypeV2 {
            os.write_enum(29, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.viewOnce {
            os.write_bool(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtendedTextMessage {
        ExtendedTextMessage::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.matchedText = ::std::option::Option::None;
        self.canonicalUrl = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.textArgb = ::std::option::Option::None;
        self.backgroundArgb = ::std::option::Option::None;
        self.font = ::std::option::Option::None;
        self.previewType = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.doNotPlayInline = ::std::option::Option::None;
        self.thumbnailDirectPath = ::std::option::Option::None;
        self.thumbnailSha256 = ::std::option::Option::None;
        self.thumbnailEncSha256 = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.thumbnailHeight = ::std::option::Option::None;
        self.thumbnailWidth = ::std::option::Option::None;
        self.inviteLinkGroupType = ::std::option::Option::None;
        self.inviteLinkParentGroupSubjectV2 = ::std::option::Option::None;
        self.inviteLinkParentGroupThumbnailV2 = ::std::option::Option::None;
        self.inviteLinkGroupTypeV2 = ::std::option::Option::None;
        self.viewOnce = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtendedTextMessage {
        static instance: ExtendedTextMessage = ExtendedTextMessage {
            text: ::std::option::Option::None,
            matchedText: ::std::option::Option::None,
            canonicalUrl: ::std::option::Option::None,
            description: ::std::option::Option::None,
            title: ::std::option::Option::None,
            textArgb: ::std::option::Option::None,
            backgroundArgb: ::std::option::Option::None,
            font: ::std::option::Option::None,
            previewType: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            doNotPlayInline: ::std::option::Option::None,
            thumbnailDirectPath: ::std::option::Option::None,
            thumbnailSha256: ::std::option::Option::None,
            thumbnailEncSha256: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            thumbnailHeight: ::std::option::Option::None,
            thumbnailWidth: ::std::option::Option::None,
            inviteLinkGroupType: ::std::option::Option::None,
            inviteLinkParentGroupSubjectV2: ::std::option::Option::None,
            inviteLinkParentGroupThumbnailV2: ::std::option::Option::None,
            inviteLinkGroupTypeV2: ::std::option::Option::None,
            viewOnce: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExtendedTextMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtendedTextMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtendedTextMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendedTextMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExtendedTextMessage`
pub mod extended_text_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ExtendedTextMessage.PreviewType)
    pub enum PreviewType {
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.PreviewType.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.PreviewType.VIDEO)
        VIDEO = 1,
    }

    impl ::protobuf::Enum for PreviewType {
        const NAME: &'static str = "PreviewType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PreviewType> {
            match value {
                0 => ::std::option::Option::Some(PreviewType::NONE),
                1 => ::std::option::Option::Some(PreviewType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PreviewType] = &[
            PreviewType::NONE,
            PreviewType::VIDEO,
        ];
    }

    impl ::protobuf::EnumFull for PreviewType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ExtendedTextMessage.PreviewType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PreviewType {
        fn default() -> Self {
            PreviewType::NONE
        }
    }

    impl PreviewType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PreviewType>("ExtendedTextMessage.PreviewType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ExtendedTextMessage.InviteLinkGroupType)
    pub enum InviteLinkGroupType {
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.InviteLinkGroupType.DEFAULT)
        DEFAULT = 0,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.InviteLinkGroupType.PARENT)
        PARENT = 1,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.InviteLinkGroupType.SUB)
        SUB = 2,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.InviteLinkGroupType.DEFAULT_SUB)
        DEFAULT_SUB = 3,
    }

    impl ::protobuf::Enum for InviteLinkGroupType {
        const NAME: &'static str = "InviteLinkGroupType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<InviteLinkGroupType> {
            match value {
                0 => ::std::option::Option::Some(InviteLinkGroupType::DEFAULT),
                1 => ::std::option::Option::Some(InviteLinkGroupType::PARENT),
                2 => ::std::option::Option::Some(InviteLinkGroupType::SUB),
                3 => ::std::option::Option::Some(InviteLinkGroupType::DEFAULT_SUB),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [InviteLinkGroupType] = &[
            InviteLinkGroupType::DEFAULT,
            InviteLinkGroupType::PARENT,
            InviteLinkGroupType::SUB,
            InviteLinkGroupType::DEFAULT_SUB,
        ];
    }

    impl ::protobuf::EnumFull for InviteLinkGroupType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ExtendedTextMessage.InviteLinkGroupType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for InviteLinkGroupType {
        fn default() -> Self {
            InviteLinkGroupType::DEFAULT
        }
    }

    impl InviteLinkGroupType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<InviteLinkGroupType>("ExtendedTextMessage.InviteLinkGroupType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ExtendedTextMessage.FontType)
    pub enum FontType {
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.SANS_SERIF)
        SANS_SERIF = 0,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.SERIF)
        SERIF = 1,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.NORICAN_REGULAR)
        NORICAN_REGULAR = 2,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.BRYNDAN_WRITE)
        BRYNDAN_WRITE = 3,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.BEBASNEUE_REGULAR)
        BEBASNEUE_REGULAR = 4,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.OSWALD_HEAVY)
        OSWALD_HEAVY = 5,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.DAMION_REGULAR)
        DAMION_REGULAR = 6,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.MORNINGBREEZE_REGULAR)
        MORNINGBREEZE_REGULAR = 7,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.CALISTOGA_REGULAR)
        CALISTOGA_REGULAR = 8,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.EXO2_EXTRABOLD)
        EXO2_EXTRABOLD = 9,
        // @@protoc_insertion_point(enum_value:proto.ExtendedTextMessage.FontType.COURIERPRIME_BOLD)
        COURIERPRIME_BOLD = 10,
    }

    impl ::protobuf::Enum for FontType {
        const NAME: &'static str = "FontType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<FontType> {
            match value {
                0 => ::std::option::Option::Some(FontType::SANS_SERIF),
                1 => ::std::option::Option::Some(FontType::SERIF),
                2 => ::std::option::Option::Some(FontType::NORICAN_REGULAR),
                3 => ::std::option::Option::Some(FontType::BRYNDAN_WRITE),
                4 => ::std::option::Option::Some(FontType::BEBASNEUE_REGULAR),
                5 => ::std::option::Option::Some(FontType::OSWALD_HEAVY),
                6 => ::std::option::Option::Some(FontType::DAMION_REGULAR),
                7 => ::std::option::Option::Some(FontType::MORNINGBREEZE_REGULAR),
                8 => ::std::option::Option::Some(FontType::CALISTOGA_REGULAR),
                9 => ::std::option::Option::Some(FontType::EXO2_EXTRABOLD),
                10 => ::std::option::Option::Some(FontType::COURIERPRIME_BOLD),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [FontType] = &[
            FontType::SANS_SERIF,
            FontType::SERIF,
            FontType::NORICAN_REGULAR,
            FontType::BRYNDAN_WRITE,
            FontType::BEBASNEUE_REGULAR,
            FontType::OSWALD_HEAVY,
            FontType::DAMION_REGULAR,
            FontType::MORNINGBREEZE_REGULAR,
            FontType::CALISTOGA_REGULAR,
            FontType::EXO2_EXTRABOLD,
            FontType::COURIERPRIME_BOLD,
        ];
    }

    impl ::protobuf::EnumFull for FontType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ExtendedTextMessage.FontType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for FontType {
        fn default() -> Self {
            FontType::SANS_SERIF
        }
    }

    impl FontType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FontType>("ExtendedTextMessage.FontType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.EncReactionMessage)
pub struct EncReactionMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.EncReactionMessage.targetMessageKey)
    pub targetMessageKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.EncReactionMessage.encPayload)
    pub encPayload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.EncReactionMessage.encIv)
    pub encIv: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.EncReactionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EncReactionMessage {
    fn default() -> &'a EncReactionMessage {
        <EncReactionMessage as ::protobuf::Message>::default_instance()
    }
}

impl EncReactionMessage {
    pub fn new() -> EncReactionMessage {
        ::std::default::Default::default()
    }

    // optional bytes encPayload = 2;

    pub fn encPayload(&self) -> &[u8] {
        match self.encPayload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encPayload(&mut self) {
        self.encPayload = ::std::option::Option::None;
    }

    pub fn has_encPayload(&self) -> bool {
        self.encPayload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encPayload(&mut self, v: ::std::vec::Vec<u8>) {
        self.encPayload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encPayload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encPayload.is_none() {
            self.encPayload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encPayload.as_mut().unwrap()
    }

    // Take field
    pub fn take_encPayload(&mut self) -> ::std::vec::Vec<u8> {
        self.encPayload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes encIv = 3;

    pub fn encIv(&self) -> &[u8] {
        match self.encIv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encIv(&mut self) {
        self.encIv = ::std::option::Option::None;
    }

    pub fn has_encIv(&self) -> bool {
        self.encIv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encIv(&mut self, v: ::std::vec::Vec<u8>) {
        self.encIv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encIv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encIv.is_none() {
            self.encIv = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encIv.as_mut().unwrap()
    }

    // Take field
    pub fn take_encIv(&mut self) -> ::std::vec::Vec<u8> {
        self.encIv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "targetMessageKey",
            |m: &EncReactionMessage| { &m.targetMessageKey },
            |m: &mut EncReactionMessage| { &mut m.targetMessageKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encPayload",
            |m: &EncReactionMessage| { &m.encPayload },
            |m: &mut EncReactionMessage| { &mut m.encPayload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encIv",
            |m: &EncReactionMessage| { &m.encIv },
            |m: &mut EncReactionMessage| { &mut m.encIv },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EncReactionMessage>(
            "EncReactionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EncReactionMessage {
    const NAME: &'static str = "EncReactionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.targetMessageKey)?;
                },
                18 => {
                    self.encPayload = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.encIv = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.targetMessageKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.encPayload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.encIv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.targetMessageKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.encPayload.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.encIv.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EncReactionMessage {
        EncReactionMessage::new()
    }

    fn clear(&mut self) {
        self.targetMessageKey.clear();
        self.encPayload = ::std::option::Option::None;
        self.encIv = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EncReactionMessage {
        static instance: EncReactionMessage = EncReactionMessage {
            targetMessageKey: ::protobuf::MessageField::none(),
            encPayload: ::std::option::Option::None,
            encIv: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EncReactionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EncReactionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EncReactionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncReactionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DocumentMessage)
pub struct DocumentMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.DocumentMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.pageCount)
    pub pageCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.fileName)
    pub fileName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.contactVcard)
    pub contactVcard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.thumbnailDirectPath)
    pub thumbnailDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.thumbnailSha256)
    pub thumbnailSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.thumbnailEncSha256)
    pub thumbnailEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.thumbnailHeight)
    pub thumbnailHeight: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.thumbnailWidth)
    pub thumbnailWidth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.DocumentMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DocumentMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DocumentMessage {
    fn default() -> &'a DocumentMessage {
        <DocumentMessage as ::protobuf::Message>::default_instance()
    }
}

impl DocumentMessage {
    pub fn new() -> DocumentMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mimetype = 2;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 4;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 5;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 pageCount = 6;

    pub fn pageCount(&self) -> u32 {
        self.pageCount.unwrap_or(0)
    }

    pub fn clear_pageCount(&mut self) {
        self.pageCount = ::std::option::Option::None;
    }

    pub fn has_pageCount(&self) -> bool {
        self.pageCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pageCount(&mut self, v: u32) {
        self.pageCount = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 7;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string fileName = 8;

    pub fn fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fileName(&mut self) {
        self.fileName = ::std::option::Option::None;
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileEncSha256 = 9;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 10;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 11;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool contactVcard = 12;

    pub fn contactVcard(&self) -> bool {
        self.contactVcard.unwrap_or(false)
    }

    pub fn clear_contactVcard(&mut self) {
        self.contactVcard = ::std::option::Option::None;
    }

    pub fn has_contactVcard(&self) -> bool {
        self.contactVcard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contactVcard(&mut self, v: bool) {
        self.contactVcard = ::std::option::Option::Some(v);
    }

    // optional string thumbnailDirectPath = 13;

    pub fn thumbnailDirectPath(&self) -> &str {
        match self.thumbnailDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailDirectPath(&mut self) {
        self.thumbnailDirectPath = ::std::option::Option::None;
    }

    pub fn has_thumbnailDirectPath(&self) -> bool {
        self.thumbnailDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailDirectPath(&mut self, v: ::std::string::String) {
        self.thumbnailDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailDirectPath(&mut self) -> &mut ::std::string::String {
        if self.thumbnailDirectPath.is_none() {
            self.thumbnailDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailDirectPath(&mut self) -> ::std::string::String {
        self.thumbnailDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnailSha256 = 14;

    pub fn thumbnailSha256(&self) -> &[u8] {
        match self.thumbnailSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailSha256(&mut self) {
        self.thumbnailSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailSha256(&self) -> bool {
        self.thumbnailSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailSha256.is_none() {
            self.thumbnailSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes thumbnailEncSha256 = 15;

    pub fn thumbnailEncSha256(&self) -> &[u8] {
        match self.thumbnailEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailEncSha256(&mut self) {
        self.thumbnailEncSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailEncSha256(&self) -> bool {
        self.thumbnailEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailEncSha256.is_none() {
            self.thumbnailEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 thumbnailHeight = 18;

    pub fn thumbnailHeight(&self) -> u32 {
        self.thumbnailHeight.unwrap_or(0)
    }

    pub fn clear_thumbnailHeight(&mut self) {
        self.thumbnailHeight = ::std::option::Option::None;
    }

    pub fn has_thumbnailHeight(&self) -> bool {
        self.thumbnailHeight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailHeight(&mut self, v: u32) {
        self.thumbnailHeight = ::std::option::Option::Some(v);
    }

    // optional uint32 thumbnailWidth = 19;

    pub fn thumbnailWidth(&self) -> u32 {
        self.thumbnailWidth.unwrap_or(0)
    }

    pub fn clear_thumbnailWidth(&mut self) {
        self.thumbnailWidth = ::std::option::Option::None;
    }

    pub fn has_thumbnailWidth(&self) -> bool {
        self.thumbnailWidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailWidth(&mut self, v: u32) {
        self.thumbnailWidth = ::std::option::Option::Some(v);
    }

    // optional string caption = 20;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &DocumentMessage| { &m.url },
            |m: &mut DocumentMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &DocumentMessage| { &m.mimetype },
            |m: &mut DocumentMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &DocumentMessage| { &m.title },
            |m: &mut DocumentMessage| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &DocumentMessage| { &m.fileSha256 },
            |m: &mut DocumentMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &DocumentMessage| { &m.fileLength },
            |m: &mut DocumentMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pageCount",
            |m: &DocumentMessage| { &m.pageCount },
            |m: &mut DocumentMessage| { &mut m.pageCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &DocumentMessage| { &m.mediaKey },
            |m: &mut DocumentMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileName",
            |m: &DocumentMessage| { &m.fileName },
            |m: &mut DocumentMessage| { &mut m.fileName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &DocumentMessage| { &m.fileEncSha256 },
            |m: &mut DocumentMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &DocumentMessage| { &m.directPath },
            |m: &mut DocumentMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &DocumentMessage| { &m.mediaKeyTimestamp },
            |m: &mut DocumentMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contactVcard",
            |m: &DocumentMessage| { &m.contactVcard },
            |m: &mut DocumentMessage| { &mut m.contactVcard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailDirectPath",
            |m: &DocumentMessage| { &m.thumbnailDirectPath },
            |m: &mut DocumentMessage| { &mut m.thumbnailDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailSha256",
            |m: &DocumentMessage| { &m.thumbnailSha256 },
            |m: &mut DocumentMessage| { &mut m.thumbnailSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailEncSha256",
            |m: &DocumentMessage| { &m.thumbnailEncSha256 },
            |m: &mut DocumentMessage| { &mut m.thumbnailEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &DocumentMessage| { &m.jpegThumbnail },
            |m: &mut DocumentMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &DocumentMessage| { &m.contextInfo },
            |m: &mut DocumentMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailHeight",
            |m: &DocumentMessage| { &m.thumbnailHeight },
            |m: &mut DocumentMessage| { &mut m.thumbnailHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailWidth",
            |m: &DocumentMessage| { &m.thumbnailWidth },
            |m: &mut DocumentMessage| { &mut m.thumbnailWidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &DocumentMessage| { &m.caption },
            |m: &mut DocumentMessage| { &mut m.caption },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DocumentMessage>(
            "DocumentMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DocumentMessage {
    const NAME: &'static str = "DocumentMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.pageCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.fileName = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                82 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                96 => {
                    self.contactVcard = ::std::option::Option::Some(is.read_bool()?);
                },
                106 => {
                    self.thumbnailDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.thumbnailSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                122 => {
                    self.thumbnailEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                144 => {
                    self.thumbnailHeight = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.thumbnailWidth = ::std::option::Option::Some(is.read_uint32()?);
                },
                162 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.pageCount {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(11, v);
        }
        if let Some(v) = self.contactVcard {
            my_size += 1 + 1;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(15, &v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.thumbnailHeight {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.thumbnailWidth {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.pageCount {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.fileName.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.contactVcard {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            os.write_bytes(15, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.thumbnailHeight {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.thumbnailWidth {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DocumentMessage {
        DocumentMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.pageCount = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.fileName = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.contactVcard = ::std::option::Option::None;
        self.thumbnailDirectPath = ::std::option::Option::None;
        self.thumbnailSha256 = ::std::option::Option::None;
        self.thumbnailEncSha256 = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.thumbnailHeight = ::std::option::Option::None;
        self.thumbnailWidth = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DocumentMessage {
        static instance: DocumentMessage = DocumentMessage {
            url: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            title: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            pageCount: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            fileName: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            contactVcard: ::std::option::Option::None,
            thumbnailDirectPath: ::std::option::Option::None,
            thumbnailSha256: ::std::option::Option::None,
            thumbnailEncSha256: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            thumbnailHeight: ::std::option::Option::None,
            thumbnailWidth: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DocumentMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DocumentMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DocumentMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DeviceSentMessage)
pub struct DeviceSentMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.DeviceSentMessage.destinationJid)
    pub destinationJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.DeviceSentMessage.message)
    pub message: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:proto.DeviceSentMessage.phash)
    pub phash: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DeviceSentMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceSentMessage {
    fn default() -> &'a DeviceSentMessage {
        <DeviceSentMessage as ::protobuf::Message>::default_instance()
    }
}

impl DeviceSentMessage {
    pub fn new() -> DeviceSentMessage {
        ::std::default::Default::default()
    }

    // optional string destinationJid = 1;

    pub fn destinationJid(&self) -> &str {
        match self.destinationJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_destinationJid(&mut self) {
        self.destinationJid = ::std::option::Option::None;
    }

    pub fn has_destinationJid(&self) -> bool {
        self.destinationJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationJid(&mut self, v: ::std::string::String) {
        self.destinationJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationJid(&mut self) -> &mut ::std::string::String {
        if self.destinationJid.is_none() {
            self.destinationJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.destinationJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationJid(&mut self) -> ::std::string::String {
        self.destinationJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string phash = 3;

    pub fn phash(&self) -> &str {
        match self.phash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phash(&mut self) {
        self.phash = ::std::option::Option::None;
    }

    pub fn has_phash(&self) -> bool {
        self.phash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phash(&mut self, v: ::std::string::String) {
        self.phash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phash(&mut self) -> &mut ::std::string::String {
        if self.phash.is_none() {
            self.phash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phash.as_mut().unwrap()
    }

    // Take field
    pub fn take_phash(&mut self) -> ::std::string::String {
        self.phash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "destinationJid",
            |m: &DeviceSentMessage| { &m.destinationJid },
            |m: &mut DeviceSentMessage| { &mut m.destinationJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "message",
            |m: &DeviceSentMessage| { &m.message },
            |m: &mut DeviceSentMessage| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phash",
            |m: &DeviceSentMessage| { &m.phash },
            |m: &mut DeviceSentMessage| { &mut m.phash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceSentMessage>(
            "DeviceSentMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceSentMessage {
    const NAME: &'static str = "DeviceSentMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.destinationJid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                26 => {
                    self.phash = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.destinationJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.phash.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.destinationJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.phash.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceSentMessage {
        DeviceSentMessage::new()
    }

    fn clear(&mut self) {
        self.destinationJid = ::std::option::Option::None;
        self.message.clear();
        self.phash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceSentMessage {
        static instance: DeviceSentMessage = DeviceSentMessage {
            destinationJid: ::std::option::Option::None,
            message: ::protobuf::MessageField::none(),
            phash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceSentMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceSentMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceSentMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceSentMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DeclinePaymentRequestMessage)
pub struct DeclinePaymentRequestMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.DeclinePaymentRequestMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DeclinePaymentRequestMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeclinePaymentRequestMessage {
    fn default() -> &'a DeclinePaymentRequestMessage {
        <DeclinePaymentRequestMessage as ::protobuf::Message>::default_instance()
    }
}

impl DeclinePaymentRequestMessage {
    pub fn new() -> DeclinePaymentRequestMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &DeclinePaymentRequestMessage| { &m.key },
            |m: &mut DeclinePaymentRequestMessage| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeclinePaymentRequestMessage>(
            "DeclinePaymentRequestMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeclinePaymentRequestMessage {
    const NAME: &'static str = "DeclinePaymentRequestMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeclinePaymentRequestMessage {
        DeclinePaymentRequestMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeclinePaymentRequestMessage {
        static instance: DeclinePaymentRequestMessage = DeclinePaymentRequestMessage {
            key: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeclinePaymentRequestMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeclinePaymentRequestMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeclinePaymentRequestMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeclinePaymentRequestMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ContactsArrayMessage)
pub struct ContactsArrayMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ContactsArrayMessage.displayName)
    pub displayName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContactsArrayMessage.contacts)
    pub contacts: ::std::vec::Vec<ContactMessage>,
    // @@protoc_insertion_point(field:proto.ContactsArrayMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ContactsArrayMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContactsArrayMessage {
    fn default() -> &'a ContactsArrayMessage {
        <ContactsArrayMessage as ::protobuf::Message>::default_instance()
    }
}

impl ContactsArrayMessage {
    pub fn new() -> ContactsArrayMessage {
        ::std::default::Default::default()
    }

    // optional string displayName = 1;

    pub fn displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayName(&mut self) {
        self.displayName = ::std::option::Option::None;
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayName",
            |m: &ContactsArrayMessage| { &m.displayName },
            |m: &mut ContactsArrayMessage| { &mut m.displayName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contacts",
            |m: &ContactsArrayMessage| { &m.contacts },
            |m: &mut ContactsArrayMessage| { &mut m.contacts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ContactsArrayMessage| { &m.contextInfo },
            |m: &mut ContactsArrayMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContactsArrayMessage>(
            "ContactsArrayMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContactsArrayMessage {
    const NAME: &'static str = "ContactsArrayMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.contacts.push(is.read_message()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.contacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.contacts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContactsArrayMessage {
        ContactsArrayMessage::new()
    }

    fn clear(&mut self) {
        self.displayName = ::std::option::Option::None;
        self.contacts.clear();
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContactsArrayMessage {
        static instance: ContactsArrayMessage = ContactsArrayMessage {
            displayName: ::std::option::Option::None,
            contacts: ::std::vec::Vec::new(),
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContactsArrayMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContactsArrayMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContactsArrayMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactsArrayMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ContactMessage)
pub struct ContactMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ContactMessage.displayName)
    pub displayName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContactMessage.vcard)
    pub vcard: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContactMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ContactMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContactMessage {
    fn default() -> &'a ContactMessage {
        <ContactMessage as ::protobuf::Message>::default_instance()
    }
}

impl ContactMessage {
    pub fn new() -> ContactMessage {
        ::std::default::Default::default()
    }

    // optional string displayName = 1;

    pub fn displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayName(&mut self) {
        self.displayName = ::std::option::Option::None;
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string vcard = 16;

    pub fn vcard(&self) -> &str {
        match self.vcard.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_vcard(&mut self) {
        self.vcard = ::std::option::Option::None;
    }

    pub fn has_vcard(&self) -> bool {
        self.vcard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vcard(&mut self, v: ::std::string::String) {
        self.vcard = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vcard(&mut self) -> &mut ::std::string::String {
        if self.vcard.is_none() {
            self.vcard = ::std::option::Option::Some(::std::string::String::new());
        }
        self.vcard.as_mut().unwrap()
    }

    // Take field
    pub fn take_vcard(&mut self) -> ::std::string::String {
        self.vcard.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayName",
            |m: &ContactMessage| { &m.displayName },
            |m: &mut ContactMessage| { &mut m.displayName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vcard",
            |m: &ContactMessage| { &m.vcard },
            |m: &mut ContactMessage| { &mut m.vcard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ContactMessage| { &m.contextInfo },
            |m: &mut ContactMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContactMessage>(
            "ContactMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContactMessage {
    const NAME: &'static str = "ContactMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayName = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.vcard = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.vcard.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.vcard.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContactMessage {
        ContactMessage::new()
    }

    fn clear(&mut self) {
        self.displayName = ::std::option::Option::None;
        self.vcard = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContactMessage {
        static instance: ContactMessage = ContactMessage {
            displayName: ::std::option::Option::None,
            vcard: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContactMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContactMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContactMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Chat)
pub struct Chat {
    // message fields
    // @@protoc_insertion_point(field:proto.Chat.displayName)
    pub displayName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Chat.id)
    pub id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Chat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Chat {
    fn default() -> &'a Chat {
        <Chat as ::protobuf::Message>::default_instance()
    }
}

impl Chat {
    pub fn new() -> Chat {
        ::std::default::Default::default()
    }

    // optional string displayName = 1;

    pub fn displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayName(&mut self) {
        self.displayName = ::std::option::Option::None;
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string id = 2;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayName",
            |m: &Chat| { &m.displayName },
            |m: &mut Chat| { &mut m.displayName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Chat| { &m.id },
            |m: &mut Chat| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Chat>(
            "Chat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Chat {
    const NAME: &'static str = "Chat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.displayName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Chat {
        Chat::new()
    }

    fn clear(&mut self) {
        self.displayName = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Chat {
        static instance: Chat = Chat {
            displayName: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Chat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Chat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Chat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Chat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.CancelPaymentRequestMessage)
pub struct CancelPaymentRequestMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.CancelPaymentRequestMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.CancelPaymentRequestMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CancelPaymentRequestMessage {
    fn default() -> &'a CancelPaymentRequestMessage {
        <CancelPaymentRequestMessage as ::protobuf::Message>::default_instance()
    }
}

impl CancelPaymentRequestMessage {
    pub fn new() -> CancelPaymentRequestMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &CancelPaymentRequestMessage| { &m.key },
            |m: &mut CancelPaymentRequestMessage| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CancelPaymentRequestMessage>(
            "CancelPaymentRequestMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CancelPaymentRequestMessage {
    const NAME: &'static str = "CancelPaymentRequestMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CancelPaymentRequestMessage {
        CancelPaymentRequestMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CancelPaymentRequestMessage {
        static instance: CancelPaymentRequestMessage = CancelPaymentRequestMessage {
            key: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CancelPaymentRequestMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CancelPaymentRequestMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CancelPaymentRequestMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelPaymentRequestMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Call)
pub struct Call {
    // message fields
    // @@protoc_insertion_point(field:proto.Call.callKey)
    pub callKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.Call.conversionSource)
    pub conversionSource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Call.conversionData)
    pub conversionData: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.Call.conversionDelaySeconds)
    pub conversionDelaySeconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Call.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Call {
    fn default() -> &'a Call {
        <Call as ::protobuf::Message>::default_instance()
    }
}

impl Call {
    pub fn new() -> Call {
        ::std::default::Default::default()
    }

    // optional bytes callKey = 1;

    pub fn callKey(&self) -> &[u8] {
        match self.callKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_callKey(&mut self) {
        self.callKey = ::std::option::Option::None;
    }

    pub fn has_callKey(&self) -> bool {
        self.callKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.callKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_callKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.callKey.is_none() {
            self.callKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.callKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_callKey(&mut self) -> ::std::vec::Vec<u8> {
        self.callKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string conversionSource = 2;

    pub fn conversionSource(&self) -> &str {
        match self.conversionSource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_conversionSource(&mut self) {
        self.conversionSource = ::std::option::Option::None;
    }

    pub fn has_conversionSource(&self) -> bool {
        self.conversionSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionSource(&mut self, v: ::std::string::String) {
        self.conversionSource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversionSource(&mut self) -> &mut ::std::string::String {
        if self.conversionSource.is_none() {
            self.conversionSource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.conversionSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversionSource(&mut self) -> ::std::string::String {
        self.conversionSource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes conversionData = 3;

    pub fn conversionData(&self) -> &[u8] {
        match self.conversionData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_conversionData(&mut self) {
        self.conversionData = ::std::option::Option::None;
    }

    pub fn has_conversionData(&self) -> bool {
        self.conversionData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionData(&mut self, v: ::std::vec::Vec<u8>) {
        self.conversionData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversionData(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.conversionData.is_none() {
            self.conversionData = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.conversionData.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversionData(&mut self) -> ::std::vec::Vec<u8> {
        self.conversionData.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 conversionDelaySeconds = 4;

    pub fn conversionDelaySeconds(&self) -> u32 {
        self.conversionDelaySeconds.unwrap_or(0)
    }

    pub fn clear_conversionDelaySeconds(&mut self) {
        self.conversionDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_conversionDelaySeconds(&self) -> bool {
        self.conversionDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionDelaySeconds(&mut self, v: u32) {
        self.conversionDelaySeconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "callKey",
            |m: &Call| { &m.callKey },
            |m: &mut Call| { &mut m.callKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionSource",
            |m: &Call| { &m.conversionSource },
            |m: &mut Call| { &mut m.conversionSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionData",
            |m: &Call| { &m.conversionData },
            |m: &mut Call| { &mut m.conversionData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionDelaySeconds",
            |m: &Call| { &m.conversionDelaySeconds },
            |m: &mut Call| { &mut m.conversionDelaySeconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Call>(
            "Call",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Call {
    const NAME: &'static str = "Call";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.callKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.conversionSource = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.conversionData = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.conversionDelaySeconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.callKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.conversionSource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.conversionData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.conversionDelaySeconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.callKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.conversionSource.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.conversionData.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.conversionDelaySeconds {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Call {
        Call::new()
    }

    fn clear(&mut self) {
        self.callKey = ::std::option::Option::None;
        self.conversionSource = ::std::option::Option::None;
        self.conversionData = ::std::option::Option::None;
        self.conversionDelaySeconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Call {
        static instance: Call = Call {
            callKey: ::std::option::Option::None,
            conversionSource: ::std::option::Option::None,
            conversionData: ::std::option::Option::None,
            conversionDelaySeconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Call {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Call").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Call {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ButtonsResponseMessage)
pub struct ButtonsResponseMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ButtonsResponseMessage.selectedButtonId)
    pub selectedButtonId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ButtonsResponseMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.ButtonsResponseMessage.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<buttons_response_message::Type>>,
    // message oneof groups
    pub response: ::std::option::Option<buttons_response_message::Response>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ButtonsResponseMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonsResponseMessage {
    fn default() -> &'a ButtonsResponseMessage {
        <ButtonsResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl ButtonsResponseMessage {
    pub fn new() -> ButtonsResponseMessage {
        ::std::default::Default::default()
    }

    // optional string selectedButtonId = 1;

    pub fn selectedButtonId(&self) -> &str {
        match self.selectedButtonId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selectedButtonId(&mut self) {
        self.selectedButtonId = ::std::option::Option::None;
    }

    pub fn has_selectedButtonId(&self) -> bool {
        self.selectedButtonId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedButtonId(&mut self, v: ::std::string::String) {
        self.selectedButtonId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedButtonId(&mut self) -> &mut ::std::string::String {
        if self.selectedButtonId.is_none() {
            self.selectedButtonId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selectedButtonId.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectedButtonId(&mut self) -> ::std::string::String {
        self.selectedButtonId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.ButtonsResponseMessage.Type type = 4;

    pub fn type_(&self) -> buttons_response_message::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(buttons_response_message::Type::UNKNOWN),
            None => buttons_response_message::Type::UNKNOWN,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: buttons_response_message::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string selectedDisplayText = 2;

    pub fn selectedDisplayText(&self) -> &str {
        match self.response {
            ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_selectedDisplayText(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_selectedDisplayText(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_selectedDisplayText(&mut self, v: ::std::string::String) {
        self.response = ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(v))
    }

    // Mutable pointer to the field.
    pub fn mut_selectedDisplayText(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(::std::string::String::new()));
        }
        match self.response {
            ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_selectedDisplayText(&mut self) -> ::std::string::String {
        if self.has_selectedDisplayText() {
            match self.response.take() {
                ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedButtonId",
            |m: &ButtonsResponseMessage| { &m.selectedButtonId },
            |m: &mut ButtonsResponseMessage| { &mut m.selectedButtonId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ButtonsResponseMessage| { &m.contextInfo },
            |m: &mut ButtonsResponseMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ButtonsResponseMessage| { &m.type_ },
            |m: &mut ButtonsResponseMessage| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "selectedDisplayText",
            ButtonsResponseMessage::has_selectedDisplayText,
            ButtonsResponseMessage::selectedDisplayText,
            ButtonsResponseMessage::set_selectedDisplayText,
        ));
        oneofs.push(buttons_response_message::Response::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonsResponseMessage>(
            "ButtonsResponseMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonsResponseMessage {
    const NAME: &'static str = "ButtonsResponseMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectedButtonId = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.response = ::std::option::Option::Some(buttons_response_message::Response::SelectedDisplayText(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selectedButtonId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &buttons_response_message::Response::SelectedDisplayText(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selectedButtonId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &buttons_response_message::Response::SelectedDisplayText(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonsResponseMessage {
        ButtonsResponseMessage::new()
    }

    fn clear(&mut self) {
        self.selectedButtonId = ::std::option::Option::None;
        self.contextInfo.clear();
        self.type_ = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonsResponseMessage {
        static instance: ButtonsResponseMessage = ButtonsResponseMessage {
            selectedButtonId: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonsResponseMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonsResponseMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonsResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonsResponseMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ButtonsResponseMessage`
pub mod buttons_response_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:proto.ButtonsResponseMessage.response)
    pub enum Response {
        // @@protoc_insertion_point(oneof_field:proto.ButtonsResponseMessage.selectedDisplayText)
        SelectedDisplayText(::std::string::String),
    }

    impl ::protobuf::Oneof for Response {
    }

    impl ::protobuf::OneofFull for Response {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ButtonsResponseMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("response").unwrap()).clone()
        }
    }

    impl Response {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response>("response")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ButtonsResponseMessage.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:proto.ButtonsResponseMessage.Type.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.ButtonsResponseMessage.Type.DISPLAY_TEXT)
        DISPLAY_TEXT = 1,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::UNKNOWN),
                1 => ::std::option::Option::Some(Type::DISPLAY_TEXT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::UNKNOWN,
            Type::DISPLAY_TEXT,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ButtonsResponseMessage.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::UNKNOWN
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("ButtonsResponseMessage.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ButtonsMessage)
pub struct ButtonsMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ButtonsMessage.contentText)
    pub contentText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ButtonsMessage.footerText)
    pub footerText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ButtonsMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.ButtonsMessage.buttons)
    pub buttons: ::std::vec::Vec<buttons_message::Button>,
    // @@protoc_insertion_point(field:proto.ButtonsMessage.headerType)
    pub headerType: ::std::option::Option<::protobuf::EnumOrUnknown<buttons_message::HeaderType>>,
    // message oneof groups
    pub header: ::std::option::Option<buttons_message::Header>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ButtonsMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonsMessage {
    fn default() -> &'a ButtonsMessage {
        <ButtonsMessage as ::protobuf::Message>::default_instance()
    }
}

impl ButtonsMessage {
    pub fn new() -> ButtonsMessage {
        ::std::default::Default::default()
    }

    // optional string contentText = 6;

    pub fn contentText(&self) -> &str {
        match self.contentText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_contentText(&mut self) {
        self.contentText = ::std::option::Option::None;
    }

    pub fn has_contentText(&self) -> bool {
        self.contentText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contentText(&mut self, v: ::std::string::String) {
        self.contentText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contentText(&mut self) -> &mut ::std::string::String {
        if self.contentText.is_none() {
            self.contentText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.contentText.as_mut().unwrap()
    }

    // Take field
    pub fn take_contentText(&mut self) -> ::std::string::String {
        self.contentText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string footerText = 7;

    pub fn footerText(&self) -> &str {
        match self.footerText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_footerText(&mut self) {
        self.footerText = ::std::option::Option::None;
    }

    pub fn has_footerText(&self) -> bool {
        self.footerText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footerText(&mut self, v: ::std::string::String) {
        self.footerText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_footerText(&mut self) -> &mut ::std::string::String {
        if self.footerText.is_none() {
            self.footerText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.footerText.as_mut().unwrap()
    }

    // Take field
    pub fn take_footerText(&mut self) -> ::std::string::String {
        self.footerText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.ButtonsMessage.HeaderType headerType = 10;

    pub fn headerType(&self) -> buttons_message::HeaderType {
        match self.headerType {
            Some(e) => e.enum_value_or(buttons_message::HeaderType::UNKNOWN),
            None => buttons_message::HeaderType::UNKNOWN,
        }
    }

    pub fn clear_headerType(&mut self) {
        self.headerType = ::std::option::Option::None;
    }

    pub fn has_headerType(&self) -> bool {
        self.headerType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headerType(&mut self, v: buttons_message::HeaderType) {
        self.headerType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::Text(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::Text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.header = ::std::option::Option::Some(buttons_message::Header::Text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(buttons_message::Header::Text(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::Text(::std::string::String::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::Text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        if self.has_text() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::Text(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // optional .proto.DocumentMessage documentMessage = 2;

    pub fn documentMessage(&self) -> &DocumentMessage {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::DocumentMessage(ref v)) => v,
            _ => <DocumentMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_documentMessage(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_documentMessage(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::DocumentMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_documentMessage(&mut self, v: DocumentMessage) {
        self.header = ::std::option::Option::Some(buttons_message::Header::DocumentMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_documentMessage(&mut self) -> &mut DocumentMessage {
        if let ::std::option::Option::Some(buttons_message::Header::DocumentMessage(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::DocumentMessage(DocumentMessage::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::DocumentMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_documentMessage(&mut self) -> DocumentMessage {
        if self.has_documentMessage() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::DocumentMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            DocumentMessage::new()
        }
    }

    // optional .proto.ImageMessage imageMessage = 3;

    pub fn imageMessage(&self) -> &ImageMessage {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::ImageMessage(ref v)) => v,
            _ => <ImageMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_imageMessage(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_imageMessage(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::ImageMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_imageMessage(&mut self, v: ImageMessage) {
        self.header = ::std::option::Option::Some(buttons_message::Header::ImageMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_imageMessage(&mut self) -> &mut ImageMessage {
        if let ::std::option::Option::Some(buttons_message::Header::ImageMessage(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::ImageMessage(ImageMessage::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::ImageMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_imageMessage(&mut self) -> ImageMessage {
        if self.has_imageMessage() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::ImageMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            ImageMessage::new()
        }
    }

    // optional .proto.VideoMessage videoMessage = 4;

    pub fn videoMessage(&self) -> &VideoMessage {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::VideoMessage(ref v)) => v,
            _ => <VideoMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_videoMessage(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_videoMessage(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::VideoMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_videoMessage(&mut self, v: VideoMessage) {
        self.header = ::std::option::Option::Some(buttons_message::Header::VideoMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_videoMessage(&mut self) -> &mut VideoMessage {
        if let ::std::option::Option::Some(buttons_message::Header::VideoMessage(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::VideoMessage(VideoMessage::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::VideoMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_videoMessage(&mut self) -> VideoMessage {
        if self.has_videoMessage() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::VideoMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            VideoMessage::new()
        }
    }

    // optional .proto.LocationMessage locationMessage = 5;

    pub fn locationMessage(&self) -> &LocationMessage {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::LocationMessage(ref v)) => v,
            _ => <LocationMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_locationMessage(&mut self) {
        self.header = ::std::option::Option::None;
    }

    pub fn has_locationMessage(&self) -> bool {
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::LocationMessage(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_locationMessage(&mut self, v: LocationMessage) {
        self.header = ::std::option::Option::Some(buttons_message::Header::LocationMessage(v))
    }

    // Mutable pointer to the field.
    pub fn mut_locationMessage(&mut self) -> &mut LocationMessage {
        if let ::std::option::Option::Some(buttons_message::Header::LocationMessage(_)) = self.header {
        } else {
            self.header = ::std::option::Option::Some(buttons_message::Header::LocationMessage(LocationMessage::new()));
        }
        match self.header {
            ::std::option::Option::Some(buttons_message::Header::LocationMessage(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_locationMessage(&mut self) -> LocationMessage {
        if self.has_locationMessage() {
            match self.header.take() {
                ::std::option::Option::Some(buttons_message::Header::LocationMessage(v)) => v,
                _ => panic!(),
            }
        } else {
            LocationMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contentText",
            |m: &ButtonsMessage| { &m.contentText },
            |m: &mut ButtonsMessage| { &mut m.contentText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "footerText",
            |m: &ButtonsMessage| { &m.footerText },
            |m: &mut ButtonsMessage| { &mut m.footerText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ButtonsMessage| { &m.contextInfo },
            |m: &mut ButtonsMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buttons",
            |m: &ButtonsMessage| { &m.buttons },
            |m: &mut ButtonsMessage| { &mut m.buttons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "headerType",
            |m: &ButtonsMessage| { &m.headerType },
            |m: &mut ButtonsMessage| { &mut m.headerType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "text",
            ButtonsMessage::has_text,
            ButtonsMessage::text,
            ButtonsMessage::set_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DocumentMessage>(
            "documentMessage",
            ButtonsMessage::has_documentMessage,
            ButtonsMessage::documentMessage,
            ButtonsMessage::mut_documentMessage,
            ButtonsMessage::set_documentMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ImageMessage>(
            "imageMessage",
            ButtonsMessage::has_imageMessage,
            ButtonsMessage::imageMessage,
            ButtonsMessage::mut_imageMessage,
            ButtonsMessage::set_imageMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VideoMessage>(
            "videoMessage",
            ButtonsMessage::has_videoMessage,
            ButtonsMessage::videoMessage,
            ButtonsMessage::mut_videoMessage,
            ButtonsMessage::set_videoMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LocationMessage>(
            "locationMessage",
            ButtonsMessage::has_locationMessage,
            ButtonsMessage::locationMessage,
            ButtonsMessage::mut_locationMessage,
            ButtonsMessage::set_locationMessage,
        ));
        oneofs.push(buttons_message::Header::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonsMessage>(
            "ButtonsMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonsMessage {
    const NAME: &'static str = "ButtonsMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.contentText = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.footerText = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                74 => {
                    self.buttons.push(is.read_message()?);
                },
                80 => {
                    self.headerType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                10 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::Text(is.read_string()?));
                },
                18 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::DocumentMessage(is.read_message()?));
                },
                26 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::ImageMessage(is.read_message()?));
                },
                34 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::VideoMessage(is.read_message()?));
                },
                42 => {
                    self.header = ::std::option::Option::Some(buttons_message::Header::LocationMessage(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contentText.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.footerText.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.buttons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.headerType {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let ::std::option::Option::Some(ref v) = self.header {
            match v {
                &buttons_message::Header::Text(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &buttons_message::Header::DocumentMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &buttons_message::Header::ImageMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &buttons_message::Header::VideoMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &buttons_message::Header::LocationMessage(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.contentText.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.footerText.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.buttons {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.headerType {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let ::std::option::Option::Some(ref v) = self.header {
            match v {
                &buttons_message::Header::Text(ref v) => {
                    os.write_string(1, v)?;
                },
                &buttons_message::Header::DocumentMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &buttons_message::Header::ImageMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &buttons_message::Header::VideoMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &buttons_message::Header::LocationMessage(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonsMessage {
        ButtonsMessage::new()
    }

    fn clear(&mut self) {
        self.contentText = ::std::option::Option::None;
        self.footerText = ::std::option::Option::None;
        self.contextInfo.clear();
        self.buttons.clear();
        self.headerType = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.header = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonsMessage {
        static instance: ButtonsMessage = ButtonsMessage {
            contentText: ::std::option::Option::None,
            footerText: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            buttons: ::std::vec::Vec::new(),
            headerType: ::std::option::Option::None,
            header: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonsMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonsMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonsMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonsMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ButtonsMessage`
pub mod buttons_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:proto.ButtonsMessage.header)
    pub enum Header {
        // @@protoc_insertion_point(oneof_field:proto.ButtonsMessage.text)
        Text(::std::string::String),
        // @@protoc_insertion_point(oneof_field:proto.ButtonsMessage.documentMessage)
        DocumentMessage(super::DocumentMessage),
        // @@protoc_insertion_point(oneof_field:proto.ButtonsMessage.imageMessage)
        ImageMessage(super::ImageMessage),
        // @@protoc_insertion_point(oneof_field:proto.ButtonsMessage.videoMessage)
        VideoMessage(super::VideoMessage),
        // @@protoc_insertion_point(oneof_field:proto.ButtonsMessage.locationMessage)
        LocationMessage(super::LocationMessage),
    }

    impl ::protobuf::Oneof for Header {
    }

    impl ::protobuf::OneofFull for Header {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ButtonsMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("header").unwrap()).clone()
        }
    }

    impl Header {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Header>("header")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ButtonsMessage.Button)
    pub struct Button {
        // message fields
        // @@protoc_insertion_point(field:proto.ButtonsMessage.Button.buttonId)
        pub buttonId: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ButtonsMessage.Button.buttonText)
        pub buttonText: ::protobuf::MessageField<button::ButtonText>,
        // @@protoc_insertion_point(field:proto.ButtonsMessage.Button.type)
        pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<button::Type>>,
        // @@protoc_insertion_point(field:proto.ButtonsMessage.Button.nativeFlowInfo)
        pub nativeFlowInfo: ::protobuf::MessageField<button::NativeFlowInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ButtonsMessage.Button.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Button {
        fn default() -> &'a Button {
            <Button as ::protobuf::Message>::default_instance()
        }
    }

    impl Button {
        pub fn new() -> Button {
            ::std::default::Default::default()
        }

        // optional string buttonId = 1;

        pub fn buttonId(&self) -> &str {
            match self.buttonId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_buttonId(&mut self) {
            self.buttonId = ::std::option::Option::None;
        }

        pub fn has_buttonId(&self) -> bool {
            self.buttonId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buttonId(&mut self, v: ::std::string::String) {
            self.buttonId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_buttonId(&mut self) -> &mut ::std::string::String {
            if self.buttonId.is_none() {
                self.buttonId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.buttonId.as_mut().unwrap()
        }

        // Take field
        pub fn take_buttonId(&mut self) -> ::std::string::String {
            self.buttonId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .proto.ButtonsMessage.Button.Type type = 3;

        pub fn type_(&self) -> button::Type {
            match self.type_ {
                Some(e) => e.enum_value_or(button::Type::UNKNOWN),
                None => button::Type::UNKNOWN,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: button::Type) {
            self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "buttonId",
                |m: &Button| { &m.buttonId },
                |m: &mut Button| { &mut m.buttonId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, button::ButtonText>(
                "buttonText",
                |m: &Button| { &m.buttonText },
                |m: &mut Button| { &mut m.buttonText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Button| { &m.type_ },
                |m: &mut Button| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, button::NativeFlowInfo>(
                "nativeFlowInfo",
                |m: &Button| { &m.nativeFlowInfo },
                |m: &mut Button| { &mut m.nativeFlowInfo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Button>(
                "ButtonsMessage.Button",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Button {
        const NAME: &'static str = "Button";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.buttonId = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.buttonText)?;
                    },
                    24 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.nativeFlowInfo)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.buttonId.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.buttonText.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.nativeFlowInfo.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.buttonId.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.buttonText.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.type_ {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.nativeFlowInfo.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Button {
            Button::new()
        }

        fn clear(&mut self) {
            self.buttonId = ::std::option::Option::None;
            self.buttonText.clear();
            self.type_ = ::std::option::Option::None;
            self.nativeFlowInfo.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Button {
            static instance: Button = Button {
                buttonId: ::std::option::Option::None,
                buttonText: ::protobuf::MessageField::none(),
                type_: ::std::option::Option::None,
                nativeFlowInfo: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Button {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ButtonsMessage.Button").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Button {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Button {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Button`
    pub mod button {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.ButtonsMessage.Button.NativeFlowInfo)
        pub struct NativeFlowInfo {
            // message fields
            // @@protoc_insertion_point(field:proto.ButtonsMessage.Button.NativeFlowInfo.name)
            pub name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.ButtonsMessage.Button.NativeFlowInfo.paramsJson)
            pub paramsJson: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.ButtonsMessage.Button.NativeFlowInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a NativeFlowInfo {
            fn default() -> &'a NativeFlowInfo {
                <NativeFlowInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl NativeFlowInfo {
            pub fn new() -> NativeFlowInfo {
                ::std::default::Default::default()
            }

            // optional string name = 1;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string paramsJson = 2;

            pub fn paramsJson(&self) -> &str {
                match self.paramsJson.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_paramsJson(&mut self) {
                self.paramsJson = ::std::option::Option::None;
            }

            pub fn has_paramsJson(&self) -> bool {
                self.paramsJson.is_some()
            }

            // Param is passed by value, moved
            pub fn set_paramsJson(&mut self, v: ::std::string::String) {
                self.paramsJson = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_paramsJson(&mut self) -> &mut ::std::string::String {
                if self.paramsJson.is_none() {
                    self.paramsJson = ::std::option::Option::Some(::std::string::String::new());
                }
                self.paramsJson.as_mut().unwrap()
            }

            // Take field
            pub fn take_paramsJson(&mut self) -> ::std::string::String {
                self.paramsJson.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name",
                    |m: &NativeFlowInfo| { &m.name },
                    |m: &mut NativeFlowInfo| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "paramsJson",
                    |m: &NativeFlowInfo| { &m.paramsJson },
                    |m: &mut NativeFlowInfo| { &mut m.paramsJson },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NativeFlowInfo>(
                    "ButtonsMessage.Button.NativeFlowInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for NativeFlowInfo {
            const NAME: &'static str = "NativeFlowInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.paramsJson = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.paramsJson.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.paramsJson.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> NativeFlowInfo {
                NativeFlowInfo::new()
            }

            fn clear(&mut self) {
                self.name = ::std::option::Option::None;
                self.paramsJson = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static NativeFlowInfo {
                static instance: NativeFlowInfo = NativeFlowInfo {
                    name: ::std::option::Option::None,
                    paramsJson: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for NativeFlowInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ButtonsMessage.Button.NativeFlowInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for NativeFlowInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for NativeFlowInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.ButtonsMessage.Button.ButtonText)
        pub struct ButtonText {
            // message fields
            // @@protoc_insertion_point(field:proto.ButtonsMessage.Button.ButtonText.displayText)
            pub displayText: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.ButtonsMessage.Button.ButtonText.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ButtonText {
            fn default() -> &'a ButtonText {
                <ButtonText as ::protobuf::Message>::default_instance()
            }
        }

        impl ButtonText {
            pub fn new() -> ButtonText {
                ::std::default::Default::default()
            }

            // optional string displayText = 1;

            pub fn displayText(&self) -> &str {
                match self.displayText.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_displayText(&mut self) {
                self.displayText = ::std::option::Option::None;
            }

            pub fn has_displayText(&self) -> bool {
                self.displayText.is_some()
            }

            // Param is passed by value, moved
            pub fn set_displayText(&mut self, v: ::std::string::String) {
                self.displayText = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_displayText(&mut self) -> &mut ::std::string::String {
                if self.displayText.is_none() {
                    self.displayText = ::std::option::Option::Some(::std::string::String::new());
                }
                self.displayText.as_mut().unwrap()
            }

            // Take field
            pub fn take_displayText(&mut self) -> ::std::string::String {
                self.displayText.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "displayText",
                    |m: &ButtonText| { &m.displayText },
                    |m: &mut ButtonText| { &mut m.displayText },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonText>(
                    "ButtonsMessage.Button.ButtonText",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ButtonText {
            const NAME: &'static str = "ButtonText";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.displayText = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.displayText.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.displayText.as_ref() {
                    os.write_string(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ButtonText {
                ButtonText::new()
            }

            fn clear(&mut self) {
                self.displayText = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ButtonText {
                static instance: ButtonText = ButtonText {
                    displayText: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ButtonText {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ButtonsMessage.Button.ButtonText").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ButtonText {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ButtonText {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:proto.ButtonsMessage.Button.Type)
        pub enum Type {
            // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.Button.Type.UNKNOWN)
            UNKNOWN = 0,
            // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.Button.Type.RESPONSE)
            RESPONSE = 1,
            // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.Button.Type.NATIVE_FLOW)
            NATIVE_FLOW = 2,
        }

        impl ::protobuf::Enum for Type {
            const NAME: &'static str = "Type";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Type> {
                match value {
                    0 => ::std::option::Option::Some(Type::UNKNOWN),
                    1 => ::std::option::Option::Some(Type::RESPONSE),
                    2 => ::std::option::Option::Some(Type::NATIVE_FLOW),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Type] = &[
                Type::UNKNOWN,
                Type::RESPONSE,
                Type::NATIVE_FLOW,
            ];
        }

        impl ::protobuf::EnumFull for Type {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("ButtonsMessage.Button.Type").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Type {
            fn default() -> Self {
                Type::UNKNOWN
            }
        }

        impl Type {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("ButtonsMessage.Button.Type")
            }
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ButtonsMessage.HeaderType)
    pub enum HeaderType {
        // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.HeaderType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.HeaderType.EMPTY)
        EMPTY = 1,
        // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.HeaderType.TEXT)
        TEXT = 2,
        // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.HeaderType.DOCUMENT)
        DOCUMENT = 3,
        // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.HeaderType.IMAGE)
        IMAGE = 4,
        // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.HeaderType.VIDEO)
        VIDEO = 5,
        // @@protoc_insertion_point(enum_value:proto.ButtonsMessage.HeaderType.LOCATION)
        LOCATION = 6,
    }

    impl ::protobuf::Enum for HeaderType {
        const NAME: &'static str = "HeaderType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HeaderType> {
            match value {
                0 => ::std::option::Option::Some(HeaderType::UNKNOWN),
                1 => ::std::option::Option::Some(HeaderType::EMPTY),
                2 => ::std::option::Option::Some(HeaderType::TEXT),
                3 => ::std::option::Option::Some(HeaderType::DOCUMENT),
                4 => ::std::option::Option::Some(HeaderType::IMAGE),
                5 => ::std::option::Option::Some(HeaderType::VIDEO),
                6 => ::std::option::Option::Some(HeaderType::LOCATION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HeaderType] = &[
            HeaderType::UNKNOWN,
            HeaderType::EMPTY,
            HeaderType::TEXT,
            HeaderType::DOCUMENT,
            HeaderType::IMAGE,
            HeaderType::VIDEO,
            HeaderType::LOCATION,
        ];
    }

    impl ::protobuf::EnumFull for HeaderType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ButtonsMessage.HeaderType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for HeaderType {
        fn default() -> Self {
            HeaderType::UNKNOWN
        }
    }

    impl HeaderType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HeaderType>("ButtonsMessage.HeaderType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AudioMessage)
pub struct AudioMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.AudioMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.AudioMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.AudioMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.AudioMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.AudioMessage.seconds)
    pub seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.AudioMessage.ptt)
    pub ptt: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.AudioMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.AudioMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.AudioMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.AudioMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.AudioMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.AudioMessage.streamingSidecar)
    pub streamingSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.AudioMessage.waveform)
    pub waveform: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.AudioMessage.backgroundArgb)
    pub backgroundArgb: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AudioMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioMessage {
    fn default() -> &'a AudioMessage {
        <AudioMessage as ::protobuf::Message>::default_instance()
    }
}

impl AudioMessage {
    pub fn new() -> AudioMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mimetype = 2;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 3;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 4;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds = 5;

    pub fn seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional bool ptt = 6;

    pub fn ptt(&self) -> bool {
        self.ptt.unwrap_or(false)
    }

    pub fn clear_ptt(&mut self) {
        self.ptt = ::std::option::Option::None;
    }

    pub fn has_ptt(&self) -> bool {
        self.ptt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ptt(&mut self, v: bool) {
        self.ptt = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 7;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 8;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 9;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 10;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes streamingSidecar = 18;

    pub fn streamingSidecar(&self) -> &[u8] {
        match self.streamingSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_streamingSidecar(&mut self) {
        self.streamingSidecar = ::std::option::Option::None;
    }

    pub fn has_streamingSidecar(&self) -> bool {
        self.streamingSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streamingSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.streamingSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streamingSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.streamingSidecar.is_none() {
            self.streamingSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.streamingSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_streamingSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.streamingSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes waveform = 19;

    pub fn waveform(&self) -> &[u8] {
        match self.waveform.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_waveform(&mut self) {
        self.waveform = ::std::option::Option::None;
    }

    pub fn has_waveform(&self) -> bool {
        self.waveform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_waveform(&mut self, v: ::std::vec::Vec<u8>) {
        self.waveform = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_waveform(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.waveform.is_none() {
            self.waveform = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.waveform.as_mut().unwrap()
    }

    // Take field
    pub fn take_waveform(&mut self) -> ::std::vec::Vec<u8> {
        self.waveform.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 backgroundArgb = 20;

    pub fn backgroundArgb(&self) -> u32 {
        self.backgroundArgb.unwrap_or(0)
    }

    pub fn clear_backgroundArgb(&mut self) {
        self.backgroundArgb = ::std::option::Option::None;
    }

    pub fn has_backgroundArgb(&self) -> bool {
        self.backgroundArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backgroundArgb(&mut self, v: u32) {
        self.backgroundArgb = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &AudioMessage| { &m.url },
            |m: &mut AudioMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &AudioMessage| { &m.mimetype },
            |m: &mut AudioMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &AudioMessage| { &m.fileSha256 },
            |m: &mut AudioMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &AudioMessage| { &m.fileLength },
            |m: &mut AudioMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &AudioMessage| { &m.seconds },
            |m: &mut AudioMessage| { &mut m.seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ptt",
            |m: &AudioMessage| { &m.ptt },
            |m: &mut AudioMessage| { &mut m.ptt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &AudioMessage| { &m.mediaKey },
            |m: &mut AudioMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &AudioMessage| { &m.fileEncSha256 },
            |m: &mut AudioMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &AudioMessage| { &m.directPath },
            |m: &mut AudioMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &AudioMessage| { &m.mediaKeyTimestamp },
            |m: &mut AudioMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &AudioMessage| { &m.contextInfo },
            |m: &mut AudioMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "streamingSidecar",
            |m: &AudioMessage| { &m.streamingSidecar },
            |m: &mut AudioMessage| { &mut m.streamingSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "waveform",
            |m: &AudioMessage| { &m.waveform },
            |m: &mut AudioMessage| { &mut m.waveform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backgroundArgb",
            |m: &AudioMessage| { &m.backgroundArgb },
            |m: &mut AudioMessage| { &mut m.backgroundArgb },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioMessage>(
            "AudioMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioMessage {
    const NAME: &'static str = "AudioMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.ptt = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                74 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                146 => {
                    self.streamingSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                154 => {
                    self.waveform = ::std::option::Option::Some(is.read_bytes()?);
                },
                165 => {
                    self.backgroundArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.ptt {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.streamingSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.waveform.as_ref() {
            my_size += ::protobuf::rt::bytes_size(19, &v);
        }
        if let Some(v) = self.backgroundArgb {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ptt {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.streamingSidecar.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.waveform.as_ref() {
            os.write_bytes(19, v)?;
        }
        if let Some(v) = self.backgroundArgb {
            os.write_fixed32(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioMessage {
        AudioMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.ptt = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.contextInfo.clear();
        self.streamingSidecar = ::std::option::Option::None;
        self.waveform = ::std::option::Option::None;
        self.backgroundArgb = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioMessage {
        static instance: AudioMessage = AudioMessage {
            url: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            seconds: ::std::option::Option::None,
            ptt: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            streamingSidecar: ::std::option::Option::None,
            waveform: ::std::option::Option::None,
            backgroundArgb: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AppStateSyncKey)
pub struct AppStateSyncKey {
    // message fields
    // @@protoc_insertion_point(field:proto.AppStateSyncKey.keyId)
    pub keyId: ::protobuf::MessageField<AppStateSyncKeyId>,
    // @@protoc_insertion_point(field:proto.AppStateSyncKey.keyData)
    pub keyData: ::protobuf::MessageField<AppStateSyncKeyData>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AppStateSyncKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKey {
    fn default() -> &'a AppStateSyncKey {
        <AppStateSyncKey as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKey {
    pub fn new() -> AppStateSyncKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyId>(
            "keyId",
            |m: &AppStateSyncKey| { &m.keyId },
            |m: &mut AppStateSyncKey| { &mut m.keyId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyData>(
            "keyData",
            |m: &AppStateSyncKey| { &m.keyData },
            |m: &mut AppStateSyncKey| { &mut m.keyData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKey>(
            "AppStateSyncKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKey {
    const NAME: &'static str = "AppStateSyncKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyId)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keyData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.keyData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKey {
        AppStateSyncKey::new()
    }

    fn clear(&mut self) {
        self.keyId.clear();
        self.keyData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKey {
        static instance: AppStateSyncKey = AppStateSyncKey {
            keyId: ::protobuf::MessageField::none(),
            keyData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AppStateSyncKeyShare)
pub struct AppStateSyncKeyShare {
    // message fields
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyShare.keys)
    pub keys: ::std::vec::Vec<AppStateSyncKey>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AppStateSyncKeyShare.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyShare {
    fn default() -> &'a AppStateSyncKeyShare {
        <AppStateSyncKeyShare as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyShare {
    pub fn new() -> AppStateSyncKeyShare {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &AppStateSyncKeyShare| { &m.keys },
            |m: &mut AppStateSyncKeyShare| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyShare>(
            "AppStateSyncKeyShare",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyShare {
    const NAME: &'static str = "AppStateSyncKeyShare";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyShare {
        AppStateSyncKeyShare::new()
    }

    fn clear(&mut self) {
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyShare {
        static instance: AppStateSyncKeyShare = AppStateSyncKeyShare {
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyShare {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyShare").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyShare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyShare {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AppStateSyncKeyRequest)
pub struct AppStateSyncKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyRequest.keyIds)
    pub keyIds: ::std::vec::Vec<AppStateSyncKeyId>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AppStateSyncKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyRequest {
    fn default() -> &'a AppStateSyncKeyRequest {
        <AppStateSyncKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyRequest {
    pub fn new() -> AppStateSyncKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keyIds",
            |m: &AppStateSyncKeyRequest| { &m.keyIds },
            |m: &mut AppStateSyncKeyRequest| { &mut m.keyIds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyRequest>(
            "AppStateSyncKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyRequest {
    const NAME: &'static str = "AppStateSyncKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyIds.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.keyIds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.keyIds {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyRequest {
        AppStateSyncKeyRequest::new()
    }

    fn clear(&mut self) {
        self.keyIds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyRequest {
        static instance: AppStateSyncKeyRequest = AppStateSyncKeyRequest {
            keyIds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AppStateSyncKeyId)
pub struct AppStateSyncKeyId {
    // message fields
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyId.keyId)
    pub keyId: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AppStateSyncKeyId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyId {
    fn default() -> &'a AppStateSyncKeyId {
        <AppStateSyncKeyId as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyId {
    pub fn new() -> AppStateSyncKeyId {
        ::std::default::Default::default()
    }

    // optional bytes keyId = 1;

    pub fn keyId(&self) -> &[u8] {
        match self.keyId.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_keyId(&mut self) {
        self.keyId = ::std::option::Option::None;
    }

    pub fn has_keyId(&self) -> bool {
        self.keyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyId(&mut self, v: ::std::vec::Vec<u8>) {
        self.keyId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.keyId.is_none() {
            self.keyId = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.keyId.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyId(&mut self) -> ::std::vec::Vec<u8> {
        self.keyId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyId",
            |m: &AppStateSyncKeyId| { &m.keyId },
            |m: &mut AppStateSyncKeyId| { &mut m.keyId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyId>(
            "AppStateSyncKeyId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyId {
    const NAME: &'static str = "AppStateSyncKeyId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyId = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyId.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyId {
        AppStateSyncKeyId::new()
    }

    fn clear(&mut self) {
        self.keyId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyId {
        static instance: AppStateSyncKeyId = AppStateSyncKeyId {
            keyId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AppStateSyncKeyFingerprint)
pub struct AppStateSyncKeyFingerprint {
    // message fields
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyFingerprint.rawId)
    pub rawId: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyFingerprint.currentIndex)
    pub currentIndex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyFingerprint.deviceIndexes)
    pub deviceIndexes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AppStateSyncKeyFingerprint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyFingerprint {
    fn default() -> &'a AppStateSyncKeyFingerprint {
        <AppStateSyncKeyFingerprint as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyFingerprint {
    pub fn new() -> AppStateSyncKeyFingerprint {
        ::std::default::Default::default()
    }

    // optional uint32 rawId = 1;

    pub fn rawId(&self) -> u32 {
        self.rawId.unwrap_or(0)
    }

    pub fn clear_rawId(&mut self) {
        self.rawId = ::std::option::Option::None;
    }

    pub fn has_rawId(&self) -> bool {
        self.rawId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rawId(&mut self, v: u32) {
        self.rawId = ::std::option::Option::Some(v);
    }

    // optional uint32 currentIndex = 2;

    pub fn currentIndex(&self) -> u32 {
        self.currentIndex.unwrap_or(0)
    }

    pub fn clear_currentIndex(&mut self) {
        self.currentIndex = ::std::option::Option::None;
    }

    pub fn has_currentIndex(&self) -> bool {
        self.currentIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentIndex(&mut self, v: u32) {
        self.currentIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rawId",
            |m: &AppStateSyncKeyFingerprint| { &m.rawId },
            |m: &mut AppStateSyncKeyFingerprint| { &mut m.rawId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currentIndex",
            |m: &AppStateSyncKeyFingerprint| { &m.currentIndex },
            |m: &mut AppStateSyncKeyFingerprint| { &mut m.currentIndex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deviceIndexes",
            |m: &AppStateSyncKeyFingerprint| { &m.deviceIndexes },
            |m: &mut AppStateSyncKeyFingerprint| { &mut m.deviceIndexes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyFingerprint>(
            "AppStateSyncKeyFingerprint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyFingerprint {
    const NAME: &'static str = "AppStateSyncKeyFingerprint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rawId = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.currentIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.deviceIndexes)?;
                },
                24 => {
                    self.deviceIndexes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rawId {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.currentIndex {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.deviceIndexes);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rawId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.currentIndex {
            os.write_uint32(2, v)?;
        }
        os.write_repeated_packed_uint32(3, &self.deviceIndexes)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyFingerprint {
        AppStateSyncKeyFingerprint::new()
    }

    fn clear(&mut self) {
        self.rawId = ::std::option::Option::None;
        self.currentIndex = ::std::option::Option::None;
        self.deviceIndexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyFingerprint {
        static instance: AppStateSyncKeyFingerprint = AppStateSyncKeyFingerprint {
            rawId: ::std::option::Option::None,
            currentIndex: ::std::option::Option::None,
            deviceIndexes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyFingerprint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyFingerprint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyFingerprint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyFingerprint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AppStateSyncKeyData)
pub struct AppStateSyncKeyData {
    // message fields
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyData.keyData)
    pub keyData: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyData.fingerprint)
    pub fingerprint: ::protobuf::MessageField<AppStateSyncKeyFingerprint>,
    // @@protoc_insertion_point(field:proto.AppStateSyncKeyData.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AppStateSyncKeyData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateSyncKeyData {
    fn default() -> &'a AppStateSyncKeyData {
        <AppStateSyncKeyData as ::protobuf::Message>::default_instance()
    }
}

impl AppStateSyncKeyData {
    pub fn new() -> AppStateSyncKeyData {
        ::std::default::Default::default()
    }

    // optional bytes keyData = 1;

    pub fn keyData(&self) -> &[u8] {
        match self.keyData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_keyData(&mut self) {
        self.keyData = ::std::option::Option::None;
    }

    pub fn has_keyData(&self) -> bool {
        self.keyData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyData(&mut self, v: ::std::vec::Vec<u8>) {
        self.keyData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyData(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.keyData.is_none() {
            self.keyData = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.keyData.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyData(&mut self) -> ::std::vec::Vec<u8> {
        self.keyData.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 timestamp = 3;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyData",
            |m: &AppStateSyncKeyData| { &m.keyData },
            |m: &mut AppStateSyncKeyData| { &mut m.keyData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyFingerprint>(
            "fingerprint",
            |m: &AppStateSyncKeyData| { &m.fingerprint },
            |m: &mut AppStateSyncKeyData| { &mut m.fingerprint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &AppStateSyncKeyData| { &m.timestamp },
            |m: &mut AppStateSyncKeyData| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateSyncKeyData>(
            "AppStateSyncKeyData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateSyncKeyData {
    const NAME: &'static str = "AppStateSyncKeyData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyData = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fingerprint)?;
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.fingerprint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyData.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.fingerprint.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateSyncKeyData {
        AppStateSyncKeyData::new()
    }

    fn clear(&mut self) {
        self.keyData = ::std::option::Option::None;
        self.fingerprint.clear();
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateSyncKeyData {
        static instance: AppStateSyncKeyData = AppStateSyncKeyData {
            keyData: ::std::option::Option::None,
            fingerprint: ::protobuf::MessageField::none(),
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateSyncKeyData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateSyncKeyData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateSyncKeyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateSyncKeyData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AppStateFatalExceptionNotification)
pub struct AppStateFatalExceptionNotification {
    // message fields
    // @@protoc_insertion_point(field:proto.AppStateFatalExceptionNotification.collectionNames)
    pub collectionNames: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.AppStateFatalExceptionNotification.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AppStateFatalExceptionNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppStateFatalExceptionNotification {
    fn default() -> &'a AppStateFatalExceptionNotification {
        <AppStateFatalExceptionNotification as ::protobuf::Message>::default_instance()
    }
}

impl AppStateFatalExceptionNotification {
    pub fn new() -> AppStateFatalExceptionNotification {
        ::std::default::Default::default()
    }

    // optional int64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collectionNames",
            |m: &AppStateFatalExceptionNotification| { &m.collectionNames },
            |m: &mut AppStateFatalExceptionNotification| { &mut m.collectionNames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &AppStateFatalExceptionNotification| { &m.timestamp },
            |m: &mut AppStateFatalExceptionNotification| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppStateFatalExceptionNotification>(
            "AppStateFatalExceptionNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppStateFatalExceptionNotification {
    const NAME: &'static str = "AppStateFatalExceptionNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.collectionNames.push(is.read_string()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.collectionNames {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.collectionNames {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppStateFatalExceptionNotification {
        AppStateFatalExceptionNotification::new()
    }

    fn clear(&mut self) {
        self.collectionNames.clear();
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppStateFatalExceptionNotification {
        static instance: AppStateFatalExceptionNotification = AppStateFatalExceptionNotification {
            collectionNames: ::std::vec::Vec::new(),
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppStateFatalExceptionNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppStateFatalExceptionNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppStateFatalExceptionNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppStateFatalExceptionNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Location)
pub struct Location {
    // message fields
    // @@protoc_insertion_point(field:proto.Location.degreesLatitude)
    pub degreesLatitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.Location.degreesLongitude)
    pub degreesLongitude: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.Location.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Location.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    // optional double degreesLatitude = 1;

    pub fn degreesLatitude(&self) -> f64 {
        self.degreesLatitude.unwrap_or(0.)
    }

    pub fn clear_degreesLatitude(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
    }

    pub fn has_degreesLatitude(&self) -> bool {
        self.degreesLatitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLatitude(&mut self, v: f64) {
        self.degreesLatitude = ::std::option::Option::Some(v);
    }

    // optional double degreesLongitude = 2;

    pub fn degreesLongitude(&self) -> f64 {
        self.degreesLongitude.unwrap_or(0.)
    }

    pub fn clear_degreesLongitude(&mut self) {
        self.degreesLongitude = ::std::option::Option::None;
    }

    pub fn has_degreesLongitude(&self) -> bool {
        self.degreesLongitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_degreesLongitude(&mut self, v: f64) {
        self.degreesLongitude = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLatitude",
            |m: &Location| { &m.degreesLatitude },
            |m: &mut Location| { &mut m.degreesLatitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "degreesLongitude",
            |m: &Location| { &m.degreesLongitude },
            |m: &mut Location| { &mut m.degreesLongitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Location| { &m.name },
            |m: &mut Location| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
            "Location",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Location {
    const NAME: &'static str = "Location";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.degreesLatitude = ::std::option::Option::Some(is.read_double()?);
                },
                17 => {
                    self.degreesLongitude = ::std::option::Option::Some(is.read_double()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.degreesLatitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.degreesLongitude {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.degreesLatitude {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.degreesLongitude {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Location {
        Location::new()
    }

    fn clear(&mut self) {
        self.degreesLatitude = ::std::option::Option::None;
        self.degreesLongitude = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Location {
        static instance: Location = Location {
            degreesLatitude: ::std::option::Option::None,
            degreesLongitude: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Location {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Location").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.InteractiveAnnotation)
pub struct InteractiveAnnotation {
    // message fields
    // @@protoc_insertion_point(field:proto.InteractiveAnnotation.polygonVertices)
    pub polygonVertices: ::std::vec::Vec<Point>,
    // message oneof groups
    pub action: ::std::option::Option<interactive_annotation::Action>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.InteractiveAnnotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InteractiveAnnotation {
    fn default() -> &'a InteractiveAnnotation {
        <InteractiveAnnotation as ::protobuf::Message>::default_instance()
    }
}

impl InteractiveAnnotation {
    pub fn new() -> InteractiveAnnotation {
        ::std::default::Default::default()
    }

    // optional .proto.Location location = 2;

    pub fn location(&self) -> &Location {
        match self.action {
            ::std::option::Option::Some(interactive_annotation::Action::Location(ref v)) => v,
            _ => <Location as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_location(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(interactive_annotation::Action::Location(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: Location) {
        self.action = ::std::option::Option::Some(interactive_annotation::Action::Location(v))
    }

    // Mutable pointer to the field.
    pub fn mut_location(&mut self) -> &mut Location {
        if let ::std::option::Option::Some(interactive_annotation::Action::Location(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(interactive_annotation::Action::Location(Location::new()));
        }
        match self.action {
            ::std::option::Option::Some(interactive_annotation::Action::Location(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_location(&mut self) -> Location {
        if self.has_location() {
            match self.action.take() {
                ::std::option::Option::Some(interactive_annotation::Action::Location(v)) => v,
                _ => panic!(),
            }
        } else {
            Location::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "polygonVertices",
            |m: &InteractiveAnnotation| { &m.polygonVertices },
            |m: &mut InteractiveAnnotation| { &mut m.polygonVertices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Location>(
            "location",
            InteractiveAnnotation::has_location,
            InteractiveAnnotation::location,
            InteractiveAnnotation::mut_location,
            InteractiveAnnotation::set_location,
        ));
        oneofs.push(interactive_annotation::Action::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractiveAnnotation>(
            "InteractiveAnnotation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InteractiveAnnotation {
    const NAME: &'static str = "InteractiveAnnotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.polygonVertices.push(is.read_message()?);
                },
                18 => {
                    self.action = ::std::option::Option::Some(interactive_annotation::Action::Location(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.polygonVertices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &interactive_annotation::Action::Location(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.polygonVertices {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &interactive_annotation::Action::Location(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InteractiveAnnotation {
        InteractiveAnnotation::new()
    }

    fn clear(&mut self) {
        self.polygonVertices.clear();
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InteractiveAnnotation {
        static instance: InteractiveAnnotation = InteractiveAnnotation {
            polygonVertices: ::std::vec::Vec::new(),
            action: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InteractiveAnnotation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InteractiveAnnotation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InteractiveAnnotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InteractiveAnnotation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `InteractiveAnnotation`
pub mod interactive_annotation {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:proto.InteractiveAnnotation.action)
    pub enum Action {
        // @@protoc_insertion_point(oneof_field:proto.InteractiveAnnotation.location)
        Location(super::Location),
    }

    impl ::protobuf::Oneof for Action {
    }

    impl ::protobuf::OneofFull for Action {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::InteractiveAnnotation as ::protobuf::MessageFull>::descriptor().oneof_by_name("action").unwrap()).clone()
        }
    }

    impl Action {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action>("action")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HydratedTemplateButton)
pub struct HydratedTemplateButton {
    // message fields
    // @@protoc_insertion_point(field:proto.HydratedTemplateButton.index)
    pub index: ::std::option::Option<u32>,
    // message oneof groups
    pub hydratedButton: ::std::option::Option<hydrated_template_button::HydratedButton>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HydratedTemplateButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HydratedTemplateButton {
    fn default() -> &'a HydratedTemplateButton {
        <HydratedTemplateButton as ::protobuf::Message>::default_instance()
    }
}

impl HydratedTemplateButton {
    pub fn new() -> HydratedTemplateButton {
        ::std::default::Default::default()
    }

    // optional uint32 index = 4;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional .proto.HydratedTemplateButton.HydratedQuickReplyButton quickReplyButton = 1;

    pub fn quickReplyButton(&self) -> &hydrated_template_button::HydratedQuickReplyButton {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(ref v)) => v,
            _ => <hydrated_template_button::HydratedQuickReplyButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quickReplyButton(&mut self) {
        self.hydratedButton = ::std::option::Option::None;
    }

    pub fn has_quickReplyButton(&self) -> bool {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quickReplyButton(&mut self, v: hydrated_template_button::HydratedQuickReplyButton) {
        self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quickReplyButton(&mut self) -> &mut hydrated_template_button::HydratedQuickReplyButton {
        if let ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(_)) = self.hydratedButton {
        } else {
            self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(hydrated_template_button::HydratedQuickReplyButton::new()));
        }
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quickReplyButton(&mut self) -> hydrated_template_button::HydratedQuickReplyButton {
        if self.has_quickReplyButton() {
            match self.hydratedButton.take() {
                ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(v)) => v,
                _ => panic!(),
            }
        } else {
            hydrated_template_button::HydratedQuickReplyButton::new()
        }
    }

    // optional .proto.HydratedTemplateButton.HydratedURLButton urlButton = 2;

    pub fn urlButton(&self) -> &hydrated_template_button::HydratedURLButton {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(ref v)) => v,
            _ => <hydrated_template_button::HydratedURLButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_urlButton(&mut self) {
        self.hydratedButton = ::std::option::Option::None;
    }

    pub fn has_urlButton(&self) -> bool {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_urlButton(&mut self, v: hydrated_template_button::HydratedURLButton) {
        self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_urlButton(&mut self) -> &mut hydrated_template_button::HydratedURLButton {
        if let ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(_)) = self.hydratedButton {
        } else {
            self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(hydrated_template_button::HydratedURLButton::new()));
        }
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_urlButton(&mut self) -> hydrated_template_button::HydratedURLButton {
        if self.has_urlButton() {
            match self.hydratedButton.take() {
                ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(v)) => v,
                _ => panic!(),
            }
        } else {
            hydrated_template_button::HydratedURLButton::new()
        }
    }

    // optional .proto.HydratedTemplateButton.HydratedCallButton callButton = 3;

    pub fn callButton(&self) -> &hydrated_template_button::HydratedCallButton {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(ref v)) => v,
            _ => <hydrated_template_button::HydratedCallButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_callButton(&mut self) {
        self.hydratedButton = ::std::option::Option::None;
    }

    pub fn has_callButton(&self) -> bool {
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_callButton(&mut self, v: hydrated_template_button::HydratedCallButton) {
        self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_callButton(&mut self) -> &mut hydrated_template_button::HydratedCallButton {
        if let ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(_)) = self.hydratedButton {
        } else {
            self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(hydrated_template_button::HydratedCallButton::new()));
        }
        match self.hydratedButton {
            ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_callButton(&mut self) -> hydrated_template_button::HydratedCallButton {
        if self.has_callButton() {
            match self.hydratedButton.take() {
                ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(v)) => v,
                _ => panic!(),
            }
        } else {
            hydrated_template_button::HydratedCallButton::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &HydratedTemplateButton| { &m.index },
            |m: &mut HydratedTemplateButton| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, hydrated_template_button::HydratedQuickReplyButton>(
            "quickReplyButton",
            HydratedTemplateButton::has_quickReplyButton,
            HydratedTemplateButton::quickReplyButton,
            HydratedTemplateButton::mut_quickReplyButton,
            HydratedTemplateButton::set_quickReplyButton,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, hydrated_template_button::HydratedURLButton>(
            "urlButton",
            HydratedTemplateButton::has_urlButton,
            HydratedTemplateButton::urlButton,
            HydratedTemplateButton::mut_urlButton,
            HydratedTemplateButton::set_urlButton,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, hydrated_template_button::HydratedCallButton>(
            "callButton",
            HydratedTemplateButton::has_callButton,
            HydratedTemplateButton::callButton,
            HydratedTemplateButton::mut_callButton,
            HydratedTemplateButton::set_callButton,
        ));
        oneofs.push(hydrated_template_button::HydratedButton::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedTemplateButton>(
            "HydratedTemplateButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HydratedTemplateButton {
    const NAME: &'static str = "HydratedTemplateButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::QuickReplyButton(is.read_message()?));
                },
                18 => {
                    self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::UrlButton(is.read_message()?));
                },
                26 => {
                    self.hydratedButton = ::std::option::Option::Some(hydrated_template_button::HydratedButton::CallButton(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let ::std::option::Option::Some(ref v) = self.hydratedButton {
            match v {
                &hydrated_template_button::HydratedButton::QuickReplyButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hydrated_template_button::HydratedButton::UrlButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &hydrated_template_button::HydratedButton::CallButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_uint32(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.hydratedButton {
            match v {
                &hydrated_template_button::HydratedButton::QuickReplyButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &hydrated_template_button::HydratedButton::UrlButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &hydrated_template_button::HydratedButton::CallButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HydratedTemplateButton {
        HydratedTemplateButton::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.hydratedButton = ::std::option::Option::None;
        self.hydratedButton = ::std::option::Option::None;
        self.hydratedButton = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HydratedTemplateButton {
        static instance: HydratedTemplateButton = HydratedTemplateButton {
            index: ::std::option::Option::None,
            hydratedButton: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HydratedTemplateButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HydratedTemplateButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HydratedTemplateButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HydratedTemplateButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HydratedTemplateButton`
pub mod hydrated_template_button {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:proto.HydratedTemplateButton.hydratedButton)
    pub enum HydratedButton {
        // @@protoc_insertion_point(oneof_field:proto.HydratedTemplateButton.quickReplyButton)
        QuickReplyButton(HydratedQuickReplyButton),
        // @@protoc_insertion_point(oneof_field:proto.HydratedTemplateButton.urlButton)
        UrlButton(HydratedURLButton),
        // @@protoc_insertion_point(oneof_field:proto.HydratedTemplateButton.callButton)
        CallButton(HydratedCallButton),
    }

    impl ::protobuf::Oneof for HydratedButton {
    }

    impl ::protobuf::OneofFull for HydratedButton {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::HydratedTemplateButton as ::protobuf::MessageFull>::descriptor().oneof_by_name("hydratedButton").unwrap()).clone()
        }
    }

    impl HydratedButton {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<HydratedButton>("hydratedButton")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.HydratedTemplateButton.HydratedURLButton)
    pub struct HydratedURLButton {
        // message fields
        // @@protoc_insertion_point(field:proto.HydratedTemplateButton.HydratedURLButton.displayText)
        pub displayText: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.HydratedTemplateButton.HydratedURLButton.url)
        pub url: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.HydratedTemplateButton.HydratedURLButton.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HydratedURLButton {
        fn default() -> &'a HydratedURLButton {
            <HydratedURLButton as ::protobuf::Message>::default_instance()
        }
    }

    impl HydratedURLButton {
        pub fn new() -> HydratedURLButton {
            ::std::default::Default::default()
        }

        // optional string displayText = 1;

        pub fn displayText(&self) -> &str {
            match self.displayText.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_displayText(&mut self) {
            self.displayText = ::std::option::Option::None;
        }

        pub fn has_displayText(&self) -> bool {
            self.displayText.is_some()
        }

        // Param is passed by value, moved
        pub fn set_displayText(&mut self, v: ::std::string::String) {
            self.displayText = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_displayText(&mut self) -> &mut ::std::string::String {
            if self.displayText.is_none() {
                self.displayText = ::std::option::Option::Some(::std::string::String::new());
            }
            self.displayText.as_mut().unwrap()
        }

        // Take field
        pub fn take_displayText(&mut self) -> ::std::string::String {
            self.displayText.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string url = 2;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "displayText",
                |m: &HydratedURLButton| { &m.displayText },
                |m: &mut HydratedURLButton| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &HydratedURLButton| { &m.url },
                |m: &mut HydratedURLButton| { &mut m.url },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedURLButton>(
                "HydratedTemplateButton.HydratedURLButton",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HydratedURLButton {
        const NAME: &'static str = "HydratedURLButton";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.displayText = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.displayText.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.displayText.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HydratedURLButton {
            HydratedURLButton::new()
        }

        fn clear(&mut self) {
            self.displayText = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HydratedURLButton {
            static instance: HydratedURLButton = HydratedURLButton {
                displayText: ::std::option::Option::None,
                url: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HydratedURLButton {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HydratedTemplateButton.HydratedURLButton").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HydratedURLButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HydratedURLButton {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.HydratedTemplateButton.HydratedQuickReplyButton)
    pub struct HydratedQuickReplyButton {
        // message fields
        // @@protoc_insertion_point(field:proto.HydratedTemplateButton.HydratedQuickReplyButton.displayText)
        pub displayText: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.HydratedTemplateButton.HydratedQuickReplyButton.id)
        pub id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.HydratedTemplateButton.HydratedQuickReplyButton.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HydratedQuickReplyButton {
        fn default() -> &'a HydratedQuickReplyButton {
            <HydratedQuickReplyButton as ::protobuf::Message>::default_instance()
        }
    }

    impl HydratedQuickReplyButton {
        pub fn new() -> HydratedQuickReplyButton {
            ::std::default::Default::default()
        }

        // optional string displayText = 1;

        pub fn displayText(&self) -> &str {
            match self.displayText.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_displayText(&mut self) {
            self.displayText = ::std::option::Option::None;
        }

        pub fn has_displayText(&self) -> bool {
            self.displayText.is_some()
        }

        // Param is passed by value, moved
        pub fn set_displayText(&mut self, v: ::std::string::String) {
            self.displayText = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_displayText(&mut self) -> &mut ::std::string::String {
            if self.displayText.is_none() {
                self.displayText = ::std::option::Option::Some(::std::string::String::new());
            }
            self.displayText.as_mut().unwrap()
        }

        // Take field
        pub fn take_displayText(&mut self) -> ::std::string::String {
            self.displayText.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string id = 2;

        pub fn id(&self) -> &str {
            match self.id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: ::std::string::String) {
            self.id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_id(&mut self) -> &mut ::std::string::String {
            if self.id.is_none() {
                self.id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.id.as_mut().unwrap()
        }

        // Take field
        pub fn take_id(&mut self) -> ::std::string::String {
            self.id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "displayText",
                |m: &HydratedQuickReplyButton| { &m.displayText },
                |m: &mut HydratedQuickReplyButton| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &HydratedQuickReplyButton| { &m.id },
                |m: &mut HydratedQuickReplyButton| { &mut m.id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedQuickReplyButton>(
                "HydratedTemplateButton.HydratedQuickReplyButton",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HydratedQuickReplyButton {
        const NAME: &'static str = "HydratedQuickReplyButton";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.displayText = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.displayText.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.displayText.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.id.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HydratedQuickReplyButton {
            HydratedQuickReplyButton::new()
        }

        fn clear(&mut self) {
            self.displayText = ::std::option::Option::None;
            self.id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HydratedQuickReplyButton {
            static instance: HydratedQuickReplyButton = HydratedQuickReplyButton {
                displayText: ::std::option::Option::None,
                id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HydratedQuickReplyButton {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HydratedTemplateButton.HydratedQuickReplyButton").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HydratedQuickReplyButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HydratedQuickReplyButton {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.HydratedTemplateButton.HydratedCallButton)
    pub struct HydratedCallButton {
        // message fields
        // @@protoc_insertion_point(field:proto.HydratedTemplateButton.HydratedCallButton.displayText)
        pub displayText: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.HydratedTemplateButton.HydratedCallButton.phoneNumber)
        pub phoneNumber: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.HydratedTemplateButton.HydratedCallButton.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HydratedCallButton {
        fn default() -> &'a HydratedCallButton {
            <HydratedCallButton as ::protobuf::Message>::default_instance()
        }
    }

    impl HydratedCallButton {
        pub fn new() -> HydratedCallButton {
            ::std::default::Default::default()
        }

        // optional string displayText = 1;

        pub fn displayText(&self) -> &str {
            match self.displayText.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_displayText(&mut self) {
            self.displayText = ::std::option::Option::None;
        }

        pub fn has_displayText(&self) -> bool {
            self.displayText.is_some()
        }

        // Param is passed by value, moved
        pub fn set_displayText(&mut self, v: ::std::string::String) {
            self.displayText = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_displayText(&mut self) -> &mut ::std::string::String {
            if self.displayText.is_none() {
                self.displayText = ::std::option::Option::Some(::std::string::String::new());
            }
            self.displayText.as_mut().unwrap()
        }

        // Take field
        pub fn take_displayText(&mut self) -> ::std::string::String {
            self.displayText.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string phoneNumber = 2;

        pub fn phoneNumber(&self) -> &str {
            match self.phoneNumber.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_phoneNumber(&mut self) {
            self.phoneNumber = ::std::option::Option::None;
        }

        pub fn has_phoneNumber(&self) -> bool {
            self.phoneNumber.is_some()
        }

        // Param is passed by value, moved
        pub fn set_phoneNumber(&mut self, v: ::std::string::String) {
            self.phoneNumber = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_phoneNumber(&mut self) -> &mut ::std::string::String {
            if self.phoneNumber.is_none() {
                self.phoneNumber = ::std::option::Option::Some(::std::string::String::new());
            }
            self.phoneNumber.as_mut().unwrap()
        }

        // Take field
        pub fn take_phoneNumber(&mut self) -> ::std::string::String {
            self.phoneNumber.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "displayText",
                |m: &HydratedCallButton| { &m.displayText },
                |m: &mut HydratedCallButton| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "phoneNumber",
                |m: &HydratedCallButton| { &m.phoneNumber },
                |m: &mut HydratedCallButton| { &mut m.phoneNumber },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedCallButton>(
                "HydratedTemplateButton.HydratedCallButton",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HydratedCallButton {
        const NAME: &'static str = "HydratedCallButton";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.displayText = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.phoneNumber = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.displayText.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.phoneNumber.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.displayText.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.phoneNumber.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HydratedCallButton {
            HydratedCallButton::new()
        }

        fn clear(&mut self) {
            self.displayText = ::std::option::Option::None;
            self.phoneNumber = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HydratedCallButton {
            static instance: HydratedCallButton = HydratedCallButton {
                displayText: ::std::option::Option::None,
                phoneNumber: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HydratedCallButton {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HydratedTemplateButton.HydratedCallButton").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HydratedCallButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HydratedCallButton {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.GroupMention)
pub struct GroupMention {
    // message fields
    // @@protoc_insertion_point(field:proto.GroupMention.groupJid)
    pub groupJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.GroupMention.groupSubject)
    pub groupSubject: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.GroupMention.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupMention {
    fn default() -> &'a GroupMention {
        <GroupMention as ::protobuf::Message>::default_instance()
    }
}

impl GroupMention {
    pub fn new() -> GroupMention {
        ::std::default::Default::default()
    }

    // optional string groupJid = 1;

    pub fn groupJid(&self) -> &str {
        match self.groupJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupJid(&mut self) {
        self.groupJid = ::std::option::Option::None;
    }

    pub fn has_groupJid(&self) -> bool {
        self.groupJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupJid(&mut self, v: ::std::string::String) {
        self.groupJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupJid(&mut self) -> &mut ::std::string::String {
        if self.groupJid.is_none() {
            self.groupJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupJid(&mut self) -> ::std::string::String {
        self.groupJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupSubject = 2;

    pub fn groupSubject(&self) -> &str {
        match self.groupSubject.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupSubject(&mut self) {
        self.groupSubject = ::std::option::Option::None;
    }

    pub fn has_groupSubject(&self) -> bool {
        self.groupSubject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupSubject(&mut self, v: ::std::string::String) {
        self.groupSubject = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupSubject(&mut self) -> &mut ::std::string::String {
        if self.groupSubject.is_none() {
            self.groupSubject = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupSubject.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupSubject(&mut self) -> ::std::string::String {
        self.groupSubject.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupJid",
            |m: &GroupMention| { &m.groupJid },
            |m: &mut GroupMention| { &mut m.groupJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupSubject",
            |m: &GroupMention| { &m.groupSubject },
            |m: &mut GroupMention| { &mut m.groupSubject },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupMention>(
            "GroupMention",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupMention {
    const NAME: &'static str = "GroupMention";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupJid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.groupSubject = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.groupSubject.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.groupSubject.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupMention {
        GroupMention::new()
    }

    fn clear(&mut self) {
        self.groupJid = ::std::option::Option::None;
        self.groupSubject = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupMention {
        static instance: GroupMention = GroupMention {
            groupJid: ::std::option::Option::None,
            groupSubject: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupMention {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupMention").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupMention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupMention {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DisappearingMode)
pub struct DisappearingMode {
    // message fields
    // @@protoc_insertion_point(field:proto.DisappearingMode.initiator)
    pub initiator: ::std::option::Option<::protobuf::EnumOrUnknown<disappearing_mode::Initiator>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DisappearingMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisappearingMode {
    fn default() -> &'a DisappearingMode {
        <DisappearingMode as ::protobuf::Message>::default_instance()
    }
}

impl DisappearingMode {
    pub fn new() -> DisappearingMode {
        ::std::default::Default::default()
    }

    // optional .proto.DisappearingMode.Initiator initiator = 1;

    pub fn initiator(&self) -> disappearing_mode::Initiator {
        match self.initiator {
            Some(e) => e.enum_value_or(disappearing_mode::Initiator::CHANGED_IN_CHAT),
            None => disappearing_mode::Initiator::CHANGED_IN_CHAT,
        }
    }

    pub fn clear_initiator(&mut self) {
        self.initiator = ::std::option::Option::None;
    }

    pub fn has_initiator(&self) -> bool {
        self.initiator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: disappearing_mode::Initiator) {
        self.initiator = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator",
            |m: &DisappearingMode| { &m.initiator },
            |m: &mut DisappearingMode| { &mut m.initiator },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisappearingMode>(
            "DisappearingMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisappearingMode {
    const NAME: &'static str = "DisappearingMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.initiator = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initiator {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.initiator {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisappearingMode {
        DisappearingMode::new()
    }

    fn clear(&mut self) {
        self.initiator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisappearingMode {
        static instance: DisappearingMode = DisappearingMode {
            initiator: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisappearingMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisappearingMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisappearingMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisappearingMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DisappearingMode`
pub mod disappearing_mode {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.DisappearingMode.Initiator)
    pub enum Initiator {
        // @@protoc_insertion_point(enum_value:proto.DisappearingMode.Initiator.CHANGED_IN_CHAT)
        CHANGED_IN_CHAT = 0,
        // @@protoc_insertion_point(enum_value:proto.DisappearingMode.Initiator.INITIATED_BY_ME)
        INITIATED_BY_ME = 1,
        // @@protoc_insertion_point(enum_value:proto.DisappearingMode.Initiator.INITIATED_BY_OTHER)
        INITIATED_BY_OTHER = 2,
    }

    impl ::protobuf::Enum for Initiator {
        const NAME: &'static str = "Initiator";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Initiator> {
            match value {
                0 => ::std::option::Option::Some(Initiator::CHANGED_IN_CHAT),
                1 => ::std::option::Option::Some(Initiator::INITIATED_BY_ME),
                2 => ::std::option::Option::Some(Initiator::INITIATED_BY_OTHER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Initiator] = &[
            Initiator::CHANGED_IN_CHAT,
            Initiator::INITIATED_BY_ME,
            Initiator::INITIATED_BY_OTHER,
        ];
    }

    impl ::protobuf::EnumFull for Initiator {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("DisappearingMode.Initiator").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Initiator {
        fn default() -> Self {
            Initiator::CHANGED_IN_CHAT
        }
    }

    impl Initiator {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Initiator>("DisappearingMode.Initiator")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DeviceListMetadata)
pub struct DeviceListMetadata {
    // message fields
    // @@protoc_insertion_point(field:proto.DeviceListMetadata.senderKeyHash)
    pub senderKeyHash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DeviceListMetadata.senderTimestamp)
    pub senderTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.DeviceListMetadata.senderKeyIndexes)
    pub senderKeyIndexes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:proto.DeviceListMetadata.recipientKeyHash)
    pub recipientKeyHash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.DeviceListMetadata.recipientTimestamp)
    pub recipientTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.DeviceListMetadata.recipientKeyIndexes)
    pub recipientKeyIndexes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DeviceListMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceListMetadata {
    fn default() -> &'a DeviceListMetadata {
        <DeviceListMetadata as ::protobuf::Message>::default_instance()
    }
}

impl DeviceListMetadata {
    pub fn new() -> DeviceListMetadata {
        ::std::default::Default::default()
    }

    // optional bytes senderKeyHash = 1;

    pub fn senderKeyHash(&self) -> &[u8] {
        match self.senderKeyHash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_senderKeyHash(&mut self) {
        self.senderKeyHash = ::std::option::Option::None;
    }

    pub fn has_senderKeyHash(&self) -> bool {
        self.senderKeyHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderKeyHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.senderKeyHash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_senderKeyHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.senderKeyHash.is_none() {
            self.senderKeyHash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.senderKeyHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_senderKeyHash(&mut self) -> ::std::vec::Vec<u8> {
        self.senderKeyHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 senderTimestamp = 2;

    pub fn senderTimestamp(&self) -> u64 {
        self.senderTimestamp.unwrap_or(0)
    }

    pub fn clear_senderTimestamp(&mut self) {
        self.senderTimestamp = ::std::option::Option::None;
    }

    pub fn has_senderTimestamp(&self) -> bool {
        self.senderTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestamp(&mut self, v: u64) {
        self.senderTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes recipientKeyHash = 8;

    pub fn recipientKeyHash(&self) -> &[u8] {
        match self.recipientKeyHash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_recipientKeyHash(&mut self) {
        self.recipientKeyHash = ::std::option::Option::None;
    }

    pub fn has_recipientKeyHash(&self) -> bool {
        self.recipientKeyHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipientKeyHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.recipientKeyHash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipientKeyHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.recipientKeyHash.is_none() {
            self.recipientKeyHash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.recipientKeyHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipientKeyHash(&mut self) -> ::std::vec::Vec<u8> {
        self.recipientKeyHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 recipientTimestamp = 9;

    pub fn recipientTimestamp(&self) -> u64 {
        self.recipientTimestamp.unwrap_or(0)
    }

    pub fn clear_recipientTimestamp(&mut self) {
        self.recipientTimestamp = ::std::option::Option::None;
    }

    pub fn has_recipientTimestamp(&self) -> bool {
        self.recipientTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipientTimestamp(&mut self, v: u64) {
        self.recipientTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderKeyHash",
            |m: &DeviceListMetadata| { &m.senderKeyHash },
            |m: &mut DeviceListMetadata| { &mut m.senderKeyHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestamp",
            |m: &DeviceListMetadata| { &m.senderTimestamp },
            |m: &mut DeviceListMetadata| { &mut m.senderTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "senderKeyIndexes",
            |m: &DeviceListMetadata| { &m.senderKeyIndexes },
            |m: &mut DeviceListMetadata| { &mut m.senderKeyIndexes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipientKeyHash",
            |m: &DeviceListMetadata| { &m.recipientKeyHash },
            |m: &mut DeviceListMetadata| { &mut m.recipientKeyHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recipientTimestamp",
            |m: &DeviceListMetadata| { &m.recipientTimestamp },
            |m: &mut DeviceListMetadata| { &mut m.recipientTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "recipientKeyIndexes",
            |m: &DeviceListMetadata| { &m.recipientKeyIndexes },
            |m: &mut DeviceListMetadata| { &mut m.recipientKeyIndexes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceListMetadata>(
            "DeviceListMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceListMetadata {
    const NAME: &'static str = "DeviceListMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.senderKeyHash = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.senderTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.senderKeyIndexes)?;
                },
                24 => {
                    self.senderKeyIndexes.push(is.read_uint32()?);
                },
                66 => {
                    self.recipientKeyHash = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.recipientTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.recipientKeyIndexes)?;
                },
                80 => {
                    self.recipientKeyIndexes.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.senderKeyHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.senderTimestamp {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.senderKeyIndexes);
        if let Some(v) = self.recipientKeyHash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.recipientTimestamp {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(10, &self.recipientKeyIndexes);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.senderKeyHash.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.senderTimestamp {
            os.write_uint64(2, v)?;
        }
        os.write_repeated_packed_uint32(3, &self.senderKeyIndexes)?;
        if let Some(v) = self.recipientKeyHash.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.recipientTimestamp {
            os.write_uint64(9, v)?;
        }
        os.write_repeated_packed_uint32(10, &self.recipientKeyIndexes)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceListMetadata {
        DeviceListMetadata::new()
    }

    fn clear(&mut self) {
        self.senderKeyHash = ::std::option::Option::None;
        self.senderTimestamp = ::std::option::Option::None;
        self.senderKeyIndexes.clear();
        self.recipientKeyHash = ::std::option::Option::None;
        self.recipientTimestamp = ::std::option::Option::None;
        self.recipientKeyIndexes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceListMetadata {
        static instance: DeviceListMetadata = DeviceListMetadata {
            senderKeyHash: ::std::option::Option::None,
            senderTimestamp: ::std::option::Option::None,
            senderKeyIndexes: ::std::vec::Vec::new(),
            recipientKeyHash: ::std::option::Option::None,
            recipientTimestamp: ::std::option::Option::None,
            recipientKeyIndexes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceListMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceListMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceListMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceListMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ContextInfo)
pub struct ContextInfo {
    // message fields
    // @@protoc_insertion_point(field:proto.ContextInfo.stanzaId)
    pub stanzaId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.quotedMessage)
    pub quotedMessage: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:proto.ContextInfo.remoteJid)
    pub remoteJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.mentionedJid)
    pub mentionedJid: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.conversionSource)
    pub conversionSource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.conversionData)
    pub conversionData: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ContextInfo.conversionDelaySeconds)
    pub conversionDelaySeconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ContextInfo.forwardingScore)
    pub forwardingScore: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ContextInfo.isForwarded)
    pub isForwarded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ContextInfo.quotedAd)
    pub quotedAd: ::protobuf::MessageField<context_info::AdReplyInfo>,
    // @@protoc_insertion_point(field:proto.ContextInfo.placeholderKey)
    pub placeholderKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.ContextInfo.expiration)
    pub expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ContextInfo.ephemeralSettingTimestamp)
    pub ephemeralSettingTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.ContextInfo.ephemeralSharedSecret)
    pub ephemeralSharedSecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ContextInfo.externalAdReply)
    pub externalAdReply: ::protobuf::MessageField<context_info::ExternalAdReplyInfo>,
    // @@protoc_insertion_point(field:proto.ContextInfo.entryPointConversionSource)
    pub entryPointConversionSource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.entryPointConversionApp)
    pub entryPointConversionApp: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.entryPointConversionDelaySeconds)
    pub entryPointConversionDelaySeconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ContextInfo.disappearingMode)
    pub disappearingMode: ::protobuf::MessageField<DisappearingMode>,
    // @@protoc_insertion_point(field:proto.ContextInfo.actionLink)
    pub actionLink: ::protobuf::MessageField<ActionLink>,
    // @@protoc_insertion_point(field:proto.ContextInfo.groupSubject)
    pub groupSubject: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.parentGroupJid)
    pub parentGroupJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.trustBannerType)
    pub trustBannerType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContextInfo.trustBannerAction)
    pub trustBannerAction: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ContextInfo.isSampled)
    pub isSampled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ContextInfo.groupMentions)
    pub groupMentions: ::std::vec::Vec<GroupMention>,
    // @@protoc_insertion_point(field:proto.ContextInfo.utm)
    pub utm: ::protobuf::MessageField<context_info::UTMInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ContextInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContextInfo {
    fn default() -> &'a ContextInfo {
        <ContextInfo as ::protobuf::Message>::default_instance()
    }
}

impl ContextInfo {
    pub fn new() -> ContextInfo {
        ::std::default::Default::default()
    }

    // optional string stanzaId = 1;

    pub fn stanzaId(&self) -> &str {
        match self.stanzaId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stanzaId(&mut self) {
        self.stanzaId = ::std::option::Option::None;
    }

    pub fn has_stanzaId(&self) -> bool {
        self.stanzaId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stanzaId(&mut self, v: ::std::string::String) {
        self.stanzaId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stanzaId(&mut self) -> &mut ::std::string::String {
        if self.stanzaId.is_none() {
            self.stanzaId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stanzaId.as_mut().unwrap()
    }

    // Take field
    pub fn take_stanzaId(&mut self) -> ::std::string::String {
        self.stanzaId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string participant = 2;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string remoteJid = 4;

    pub fn remoteJid(&self) -> &str {
        match self.remoteJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remoteJid(&mut self) {
        self.remoteJid = ::std::option::Option::None;
    }

    pub fn has_remoteJid(&self) -> bool {
        self.remoteJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteJid(&mut self, v: ::std::string::String) {
        self.remoteJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteJid(&mut self) -> &mut ::std::string::String {
        if self.remoteJid.is_none() {
            self.remoteJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.remoteJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_remoteJid(&mut self) -> ::std::string::String {
        self.remoteJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string conversionSource = 18;

    pub fn conversionSource(&self) -> &str {
        match self.conversionSource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_conversionSource(&mut self) {
        self.conversionSource = ::std::option::Option::None;
    }

    pub fn has_conversionSource(&self) -> bool {
        self.conversionSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionSource(&mut self, v: ::std::string::String) {
        self.conversionSource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversionSource(&mut self) -> &mut ::std::string::String {
        if self.conversionSource.is_none() {
            self.conversionSource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.conversionSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversionSource(&mut self) -> ::std::string::String {
        self.conversionSource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes conversionData = 19;

    pub fn conversionData(&self) -> &[u8] {
        match self.conversionData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_conversionData(&mut self) {
        self.conversionData = ::std::option::Option::None;
    }

    pub fn has_conversionData(&self) -> bool {
        self.conversionData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionData(&mut self, v: ::std::vec::Vec<u8>) {
        self.conversionData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversionData(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.conversionData.is_none() {
            self.conversionData = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.conversionData.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversionData(&mut self) -> ::std::vec::Vec<u8> {
        self.conversionData.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 conversionDelaySeconds = 20;

    pub fn conversionDelaySeconds(&self) -> u32 {
        self.conversionDelaySeconds.unwrap_or(0)
    }

    pub fn clear_conversionDelaySeconds(&mut self) {
        self.conversionDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_conversionDelaySeconds(&self) -> bool {
        self.conversionDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversionDelaySeconds(&mut self, v: u32) {
        self.conversionDelaySeconds = ::std::option::Option::Some(v);
    }

    // optional uint32 forwardingScore = 21;

    pub fn forwardingScore(&self) -> u32 {
        self.forwardingScore.unwrap_or(0)
    }

    pub fn clear_forwardingScore(&mut self) {
        self.forwardingScore = ::std::option::Option::None;
    }

    pub fn has_forwardingScore(&self) -> bool {
        self.forwardingScore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forwardingScore(&mut self, v: u32) {
        self.forwardingScore = ::std::option::Option::Some(v);
    }

    // optional bool isForwarded = 22;

    pub fn isForwarded(&self) -> bool {
        self.isForwarded.unwrap_or(false)
    }

    pub fn clear_isForwarded(&mut self) {
        self.isForwarded = ::std::option::Option::None;
    }

    pub fn has_isForwarded(&self) -> bool {
        self.isForwarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isForwarded(&mut self, v: bool) {
        self.isForwarded = ::std::option::Option::Some(v);
    }

    // optional uint32 expiration = 25;

    pub fn expiration(&self) -> u32 {
        self.expiration.unwrap_or(0)
    }

    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: u32) {
        self.expiration = ::std::option::Option::Some(v);
    }

    // optional int64 ephemeralSettingTimestamp = 26;

    pub fn ephemeralSettingTimestamp(&self) -> i64 {
        self.ephemeralSettingTimestamp.unwrap_or(0)
    }

    pub fn clear_ephemeralSettingTimestamp(&mut self) {
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
    }

    pub fn has_ephemeralSettingTimestamp(&self) -> bool {
        self.ephemeralSettingTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralSettingTimestamp(&mut self, v: i64) {
        self.ephemeralSettingTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes ephemeralSharedSecret = 27;

    pub fn ephemeralSharedSecret(&self) -> &[u8] {
        match self.ephemeralSharedSecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ephemeralSharedSecret(&mut self) {
        self.ephemeralSharedSecret = ::std::option::Option::None;
    }

    pub fn has_ephemeralSharedSecret(&self) -> bool {
        self.ephemeralSharedSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralSharedSecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.ephemeralSharedSecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeralSharedSecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ephemeralSharedSecret.is_none() {
            self.ephemeralSharedSecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ephemeralSharedSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_ephemeralSharedSecret(&mut self) -> ::std::vec::Vec<u8> {
        self.ephemeralSharedSecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string entryPointConversionSource = 29;

    pub fn entryPointConversionSource(&self) -> &str {
        match self.entryPointConversionSource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entryPointConversionSource(&mut self) {
        self.entryPointConversionSource = ::std::option::Option::None;
    }

    pub fn has_entryPointConversionSource(&self) -> bool {
        self.entryPointConversionSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryPointConversionSource(&mut self, v: ::std::string::String) {
        self.entryPointConversionSource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entryPointConversionSource(&mut self) -> &mut ::std::string::String {
        if self.entryPointConversionSource.is_none() {
            self.entryPointConversionSource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entryPointConversionSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_entryPointConversionSource(&mut self) -> ::std::string::String {
        self.entryPointConversionSource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string entryPointConversionApp = 30;

    pub fn entryPointConversionApp(&self) -> &str {
        match self.entryPointConversionApp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entryPointConversionApp(&mut self) {
        self.entryPointConversionApp = ::std::option::Option::None;
    }

    pub fn has_entryPointConversionApp(&self) -> bool {
        self.entryPointConversionApp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryPointConversionApp(&mut self, v: ::std::string::String) {
        self.entryPointConversionApp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entryPointConversionApp(&mut self) -> &mut ::std::string::String {
        if self.entryPointConversionApp.is_none() {
            self.entryPointConversionApp = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entryPointConversionApp.as_mut().unwrap()
    }

    // Take field
    pub fn take_entryPointConversionApp(&mut self) -> ::std::string::String {
        self.entryPointConversionApp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 entryPointConversionDelaySeconds = 31;

    pub fn entryPointConversionDelaySeconds(&self) -> u32 {
        self.entryPointConversionDelaySeconds.unwrap_or(0)
    }

    pub fn clear_entryPointConversionDelaySeconds(&mut self) {
        self.entryPointConversionDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_entryPointConversionDelaySeconds(&self) -> bool {
        self.entryPointConversionDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryPointConversionDelaySeconds(&mut self, v: u32) {
        self.entryPointConversionDelaySeconds = ::std::option::Option::Some(v);
    }

    // optional string groupSubject = 34;

    pub fn groupSubject(&self) -> &str {
        match self.groupSubject.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupSubject(&mut self) {
        self.groupSubject = ::std::option::Option::None;
    }

    pub fn has_groupSubject(&self) -> bool {
        self.groupSubject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupSubject(&mut self, v: ::std::string::String) {
        self.groupSubject = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupSubject(&mut self) -> &mut ::std::string::String {
        if self.groupSubject.is_none() {
            self.groupSubject = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupSubject.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupSubject(&mut self) -> ::std::string::String {
        self.groupSubject.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string parentGroupJid = 35;

    pub fn parentGroupJid(&self) -> &str {
        match self.parentGroupJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parentGroupJid(&mut self) {
        self.parentGroupJid = ::std::option::Option::None;
    }

    pub fn has_parentGroupJid(&self) -> bool {
        self.parentGroupJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentGroupJid(&mut self, v: ::std::string::String) {
        self.parentGroupJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentGroupJid(&mut self) -> &mut ::std::string::String {
        if self.parentGroupJid.is_none() {
            self.parentGroupJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parentGroupJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_parentGroupJid(&mut self) -> ::std::string::String {
        self.parentGroupJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string trustBannerType = 37;

    pub fn trustBannerType(&self) -> &str {
        match self.trustBannerType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_trustBannerType(&mut self) {
        self.trustBannerType = ::std::option::Option::None;
    }

    pub fn has_trustBannerType(&self) -> bool {
        self.trustBannerType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trustBannerType(&mut self, v: ::std::string::String) {
        self.trustBannerType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trustBannerType(&mut self) -> &mut ::std::string::String {
        if self.trustBannerType.is_none() {
            self.trustBannerType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.trustBannerType.as_mut().unwrap()
    }

    // Take field
    pub fn take_trustBannerType(&mut self) -> ::std::string::String {
        self.trustBannerType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 trustBannerAction = 38;

    pub fn trustBannerAction(&self) -> u32 {
        self.trustBannerAction.unwrap_or(0)
    }

    pub fn clear_trustBannerAction(&mut self) {
        self.trustBannerAction = ::std::option::Option::None;
    }

    pub fn has_trustBannerAction(&self) -> bool {
        self.trustBannerAction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trustBannerAction(&mut self, v: u32) {
        self.trustBannerAction = ::std::option::Option::Some(v);
    }

    // optional bool isSampled = 39;

    pub fn isSampled(&self) -> bool {
        self.isSampled.unwrap_or(false)
    }

    pub fn clear_isSampled(&mut self) {
        self.isSampled = ::std::option::Option::None;
    }

    pub fn has_isSampled(&self) -> bool {
        self.isSampled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isSampled(&mut self, v: bool) {
        self.isSampled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stanzaId",
            |m: &ContextInfo| { &m.stanzaId },
            |m: &mut ContextInfo| { &mut m.stanzaId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &ContextInfo| { &m.participant },
            |m: &mut ContextInfo| { &mut m.participant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "quotedMessage",
            |m: &ContextInfo| { &m.quotedMessage },
            |m: &mut ContextInfo| { &mut m.quotedMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remoteJid",
            |m: &ContextInfo| { &m.remoteJid },
            |m: &mut ContextInfo| { &mut m.remoteJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mentionedJid",
            |m: &ContextInfo| { &m.mentionedJid },
            |m: &mut ContextInfo| { &mut m.mentionedJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionSource",
            |m: &ContextInfo| { &m.conversionSource },
            |m: &mut ContextInfo| { &mut m.conversionSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionData",
            |m: &ContextInfo| { &m.conversionData },
            |m: &mut ContextInfo| { &mut m.conversionData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversionDelaySeconds",
            |m: &ContextInfo| { &m.conversionDelaySeconds },
            |m: &mut ContextInfo| { &mut m.conversionDelaySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forwardingScore",
            |m: &ContextInfo| { &m.forwardingScore },
            |m: &mut ContextInfo| { &mut m.forwardingScore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isForwarded",
            |m: &ContextInfo| { &m.isForwarded },
            |m: &mut ContextInfo| { &mut m.isForwarded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, context_info::AdReplyInfo>(
            "quotedAd",
            |m: &ContextInfo| { &m.quotedAd },
            |m: &mut ContextInfo| { &mut m.quotedAd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "placeholderKey",
            |m: &ContextInfo| { &m.placeholderKey },
            |m: &mut ContextInfo| { &mut m.placeholderKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration",
            |m: &ContextInfo| { &m.expiration },
            |m: &mut ContextInfo| { &mut m.expiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralSettingTimestamp",
            |m: &ContextInfo| { &m.ephemeralSettingTimestamp },
            |m: &mut ContextInfo| { &mut m.ephemeralSettingTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralSharedSecret",
            |m: &ContextInfo| { &m.ephemeralSharedSecret },
            |m: &mut ContextInfo| { &mut m.ephemeralSharedSecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, context_info::ExternalAdReplyInfo>(
            "externalAdReply",
            |m: &ContextInfo| { &m.externalAdReply },
            |m: &mut ContextInfo| { &mut m.externalAdReply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryPointConversionSource",
            |m: &ContextInfo| { &m.entryPointConversionSource },
            |m: &mut ContextInfo| { &mut m.entryPointConversionSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryPointConversionApp",
            |m: &ContextInfo| { &m.entryPointConversionApp },
            |m: &mut ContextInfo| { &mut m.entryPointConversionApp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryPointConversionDelaySeconds",
            |m: &ContextInfo| { &m.entryPointConversionDelaySeconds },
            |m: &mut ContextInfo| { &mut m.entryPointConversionDelaySeconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DisappearingMode>(
            "disappearingMode",
            |m: &ContextInfo| { &m.disappearingMode },
            |m: &mut ContextInfo| { &mut m.disappearingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ActionLink>(
            "actionLink",
            |m: &ContextInfo| { &m.actionLink },
            |m: &mut ContextInfo| { &mut m.actionLink },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupSubject",
            |m: &ContextInfo| { &m.groupSubject },
            |m: &mut ContextInfo| { &mut m.groupSubject },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parentGroupJid",
            |m: &ContextInfo| { &m.parentGroupJid },
            |m: &mut ContextInfo| { &mut m.parentGroupJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trustBannerType",
            |m: &ContextInfo| { &m.trustBannerType },
            |m: &mut ContextInfo| { &mut m.trustBannerType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trustBannerAction",
            |m: &ContextInfo| { &m.trustBannerAction },
            |m: &mut ContextInfo| { &mut m.trustBannerAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isSampled",
            |m: &ContextInfo| { &m.isSampled },
            |m: &mut ContextInfo| { &mut m.isSampled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groupMentions",
            |m: &ContextInfo| { &m.groupMentions },
            |m: &mut ContextInfo| { &mut m.groupMentions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, context_info::UTMInfo>(
            "utm",
            |m: &ContextInfo| { &m.utm },
            |m: &mut ContextInfo| { &mut m.utm },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContextInfo>(
            "ContextInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContextInfo {
    const NAME: &'static str = "ContextInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stanzaId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedMessage)?;
                },
                34 => {
                    self.remoteJid = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.mentionedJid.push(is.read_string()?);
                },
                146 => {
                    self.conversionSource = ::std::option::Option::Some(is.read_string()?);
                },
                154 => {
                    self.conversionData = ::std::option::Option::Some(is.read_bytes()?);
                },
                160 => {
                    self.conversionDelaySeconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.forwardingScore = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.isForwarded = ::std::option::Option::Some(is.read_bool()?);
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedAd)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.placeholderKey)?;
                },
                200 => {
                    self.expiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.ephemeralSettingTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                218 => {
                    self.ephemeralSharedSecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.externalAdReply)?;
                },
                234 => {
                    self.entryPointConversionSource = ::std::option::Option::Some(is.read_string()?);
                },
                242 => {
                    self.entryPointConversionApp = ::std::option::Option::Some(is.read_string()?);
                },
                248 => {
                    self.entryPointConversionDelaySeconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.disappearingMode)?;
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.actionLink)?;
                },
                274 => {
                    self.groupSubject = ::std::option::Option::Some(is.read_string()?);
                },
                282 => {
                    self.parentGroupJid = ::std::option::Option::Some(is.read_string()?);
                },
                298 => {
                    self.trustBannerType = ::std::option::Option::Some(is.read_string()?);
                },
                304 => {
                    self.trustBannerAction = ::std::option::Option::Some(is.read_uint32()?);
                },
                312 => {
                    self.isSampled = ::std::option::Option::Some(is.read_bool()?);
                },
                322 => {
                    self.groupMentions.push(is.read_message()?);
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.utm)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stanzaId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.quotedMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.remoteJid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.mentionedJid {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        if let Some(v) = self.conversionSource.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.conversionData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(19, &v);
        }
        if let Some(v) = self.conversionDelaySeconds {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.forwardingScore {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.isForwarded {
            my_size += 2 + 1;
        }
        if let Some(v) = self.quotedAd.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.placeholderKey.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expiration {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            my_size += ::protobuf::rt::int64_size(26, v);
        }
        if let Some(v) = self.ephemeralSharedSecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(27, &v);
        }
        if let Some(v) = self.externalAdReply.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entryPointConversionSource.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.entryPointConversionApp.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        if let Some(v) = self.entryPointConversionDelaySeconds {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.actionLink.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.groupSubject.as_ref() {
            my_size += ::protobuf::rt::string_size(34, &v);
        }
        if let Some(v) = self.parentGroupJid.as_ref() {
            my_size += ::protobuf::rt::string_size(35, &v);
        }
        if let Some(v) = self.trustBannerType.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(v) = self.trustBannerAction {
            my_size += ::protobuf::rt::uint32_size(38, v);
        }
        if let Some(v) = self.isSampled {
            my_size += 2 + 1;
        }
        for value in &self.groupMentions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.utm.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stanzaId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.quotedMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.remoteJid.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.mentionedJid {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.conversionSource.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.conversionData.as_ref() {
            os.write_bytes(19, v)?;
        }
        if let Some(v) = self.conversionDelaySeconds {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.forwardingScore {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.isForwarded {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.quotedAd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.placeholderKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.expiration {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            os.write_int64(26, v)?;
        }
        if let Some(v) = self.ephemeralSharedSecret.as_ref() {
            os.write_bytes(27, v)?;
        }
        if let Some(v) = self.externalAdReply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.entryPointConversionSource.as_ref() {
            os.write_string(29, v)?;
        }
        if let Some(v) = self.entryPointConversionApp.as_ref() {
            os.write_string(30, v)?;
        }
        if let Some(v) = self.entryPointConversionDelaySeconds {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.actionLink.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.groupSubject.as_ref() {
            os.write_string(34, v)?;
        }
        if let Some(v) = self.parentGroupJid.as_ref() {
            os.write_string(35, v)?;
        }
        if let Some(v) = self.trustBannerType.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.trustBannerAction {
            os.write_uint32(38, v)?;
        }
        if let Some(v) = self.isSampled {
            os.write_bool(39, v)?;
        }
        for v in &self.groupMentions {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        };
        if let Some(v) = self.utm.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContextInfo {
        ContextInfo::new()
    }

    fn clear(&mut self) {
        self.stanzaId = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.quotedMessage.clear();
        self.remoteJid = ::std::option::Option::None;
        self.mentionedJid.clear();
        self.conversionSource = ::std::option::Option::None;
        self.conversionData = ::std::option::Option::None;
        self.conversionDelaySeconds = ::std::option::Option::None;
        self.forwardingScore = ::std::option::Option::None;
        self.isForwarded = ::std::option::Option::None;
        self.quotedAd.clear();
        self.placeholderKey.clear();
        self.expiration = ::std::option::Option::None;
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
        self.ephemeralSharedSecret = ::std::option::Option::None;
        self.externalAdReply.clear();
        self.entryPointConversionSource = ::std::option::Option::None;
        self.entryPointConversionApp = ::std::option::Option::None;
        self.entryPointConversionDelaySeconds = ::std::option::Option::None;
        self.disappearingMode.clear();
        self.actionLink.clear();
        self.groupSubject = ::std::option::Option::None;
        self.parentGroupJid = ::std::option::Option::None;
        self.trustBannerType = ::std::option::Option::None;
        self.trustBannerAction = ::std::option::Option::None;
        self.isSampled = ::std::option::Option::None;
        self.groupMentions.clear();
        self.utm.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContextInfo {
        static instance: ContextInfo = ContextInfo {
            stanzaId: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            quotedMessage: ::protobuf::MessageField::none(),
            remoteJid: ::std::option::Option::None,
            mentionedJid: ::std::vec::Vec::new(),
            conversionSource: ::std::option::Option::None,
            conversionData: ::std::option::Option::None,
            conversionDelaySeconds: ::std::option::Option::None,
            forwardingScore: ::std::option::Option::None,
            isForwarded: ::std::option::Option::None,
            quotedAd: ::protobuf::MessageField::none(),
            placeholderKey: ::protobuf::MessageField::none(),
            expiration: ::std::option::Option::None,
            ephemeralSettingTimestamp: ::std::option::Option::None,
            ephemeralSharedSecret: ::std::option::Option::None,
            externalAdReply: ::protobuf::MessageField::none(),
            entryPointConversionSource: ::std::option::Option::None,
            entryPointConversionApp: ::std::option::Option::None,
            entryPointConversionDelaySeconds: ::std::option::Option::None,
            disappearingMode: ::protobuf::MessageField::none(),
            actionLink: ::protobuf::MessageField::none(),
            groupSubject: ::std::option::Option::None,
            parentGroupJid: ::std::option::Option::None,
            trustBannerType: ::std::option::Option::None,
            trustBannerAction: ::std::option::Option::None,
            isSampled: ::std::option::Option::None,
            groupMentions: ::std::vec::Vec::new(),
            utm: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContextInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContextInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContextInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ContextInfo`
pub mod context_info {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ContextInfo.UTMInfo)
    pub struct UTMInfo {
        // message fields
        // @@protoc_insertion_point(field:proto.ContextInfo.UTMInfo.utmSource)
        pub utmSource: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.UTMInfo.utmCampaign)
        pub utmCampaign: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ContextInfo.UTMInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UTMInfo {
        fn default() -> &'a UTMInfo {
            <UTMInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl UTMInfo {
        pub fn new() -> UTMInfo {
            ::std::default::Default::default()
        }

        // optional string utmSource = 1;

        pub fn utmSource(&self) -> &str {
            match self.utmSource.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_utmSource(&mut self) {
            self.utmSource = ::std::option::Option::None;
        }

        pub fn has_utmSource(&self) -> bool {
            self.utmSource.is_some()
        }

        // Param is passed by value, moved
        pub fn set_utmSource(&mut self, v: ::std::string::String) {
            self.utmSource = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_utmSource(&mut self) -> &mut ::std::string::String {
            if self.utmSource.is_none() {
                self.utmSource = ::std::option::Option::Some(::std::string::String::new());
            }
            self.utmSource.as_mut().unwrap()
        }

        // Take field
        pub fn take_utmSource(&mut self) -> ::std::string::String {
            self.utmSource.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string utmCampaign = 2;

        pub fn utmCampaign(&self) -> &str {
            match self.utmCampaign.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_utmCampaign(&mut self) {
            self.utmCampaign = ::std::option::Option::None;
        }

        pub fn has_utmCampaign(&self) -> bool {
            self.utmCampaign.is_some()
        }

        // Param is passed by value, moved
        pub fn set_utmCampaign(&mut self, v: ::std::string::String) {
            self.utmCampaign = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_utmCampaign(&mut self) -> &mut ::std::string::String {
            if self.utmCampaign.is_none() {
                self.utmCampaign = ::std::option::Option::Some(::std::string::String::new());
            }
            self.utmCampaign.as_mut().unwrap()
        }

        // Take field
        pub fn take_utmCampaign(&mut self) -> ::std::string::String {
            self.utmCampaign.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "utmSource",
                |m: &UTMInfo| { &m.utmSource },
                |m: &mut UTMInfo| { &mut m.utmSource },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "utmCampaign",
                |m: &UTMInfo| { &m.utmCampaign },
                |m: &mut UTMInfo| { &mut m.utmCampaign },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UTMInfo>(
                "ContextInfo.UTMInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UTMInfo {
        const NAME: &'static str = "UTMInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.utmSource = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.utmCampaign = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.utmSource.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.utmCampaign.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.utmSource.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.utmCampaign.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UTMInfo {
            UTMInfo::new()
        }

        fn clear(&mut self) {
            self.utmSource = ::std::option::Option::None;
            self.utmCampaign = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UTMInfo {
            static instance: UTMInfo = UTMInfo {
                utmSource: ::std::option::Option::None,
                utmCampaign: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UTMInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ContextInfo.UTMInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UTMInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UTMInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ContextInfo.ExternalAdReplyInfo)
    pub struct ExternalAdReplyInfo {
        // message fields
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.title)
        pub title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.body)
        pub body: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.mediaType)
        pub mediaType: ::std::option::Option<::protobuf::EnumOrUnknown<external_ad_reply_info::MediaType>>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.thumbnailUrl)
        pub thumbnailUrl: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.mediaUrl)
        pub mediaUrl: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.thumbnail)
        pub thumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.sourceType)
        pub sourceType: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.sourceId)
        pub sourceId: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.sourceUrl)
        pub sourceUrl: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.containsAutoReply)
        pub containsAutoReply: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.renderLargerThumbnail)
        pub renderLargerThumbnail: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.showAdAttribution)
        pub showAdAttribution: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:proto.ContextInfo.ExternalAdReplyInfo.ctwaClid)
        pub ctwaClid: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ContextInfo.ExternalAdReplyInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ExternalAdReplyInfo {
        fn default() -> &'a ExternalAdReplyInfo {
            <ExternalAdReplyInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ExternalAdReplyInfo {
        pub fn new() -> ExternalAdReplyInfo {
            ::std::default::Default::default()
        }

        // optional string title = 1;

        pub fn title(&self) -> &str {
            match self.title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_title(&self) -> bool {
            self.title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            if self.title.is_none() {
                self.title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title.as_mut().unwrap()
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            self.title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string body = 2;

        pub fn body(&self) -> &str {
            match self.body.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_body(&mut self) {
            self.body = ::std::option::Option::None;
        }

        pub fn has_body(&self) -> bool {
            self.body.is_some()
        }

        // Param is passed by value, moved
        pub fn set_body(&mut self, v: ::std::string::String) {
            self.body = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_body(&mut self) -> &mut ::std::string::String {
            if self.body.is_none() {
                self.body = ::std::option::Option::Some(::std::string::String::new());
            }
            self.body.as_mut().unwrap()
        }

        // Take field
        pub fn take_body(&mut self) -> ::std::string::String {
            self.body.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .proto.ContextInfo.ExternalAdReplyInfo.MediaType mediaType = 3;

        pub fn mediaType(&self) -> external_ad_reply_info::MediaType {
            match self.mediaType {
                Some(e) => e.enum_value_or(external_ad_reply_info::MediaType::NONE),
                None => external_ad_reply_info::MediaType::NONE,
            }
        }

        pub fn clear_mediaType(&mut self) {
            self.mediaType = ::std::option::Option::None;
        }

        pub fn has_mediaType(&self) -> bool {
            self.mediaType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mediaType(&mut self, v: external_ad_reply_info::MediaType) {
            self.mediaType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string thumbnailUrl = 4;

        pub fn thumbnailUrl(&self) -> &str {
            match self.thumbnailUrl.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_thumbnailUrl(&mut self) {
            self.thumbnailUrl = ::std::option::Option::None;
        }

        pub fn has_thumbnailUrl(&self) -> bool {
            self.thumbnailUrl.is_some()
        }

        // Param is passed by value, moved
        pub fn set_thumbnailUrl(&mut self, v: ::std::string::String) {
            self.thumbnailUrl = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_thumbnailUrl(&mut self) -> &mut ::std::string::String {
            if self.thumbnailUrl.is_none() {
                self.thumbnailUrl = ::std::option::Option::Some(::std::string::String::new());
            }
            self.thumbnailUrl.as_mut().unwrap()
        }

        // Take field
        pub fn take_thumbnailUrl(&mut self) -> ::std::string::String {
            self.thumbnailUrl.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string mediaUrl = 5;

        pub fn mediaUrl(&self) -> &str {
            match self.mediaUrl.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mediaUrl(&mut self) {
            self.mediaUrl = ::std::option::Option::None;
        }

        pub fn has_mediaUrl(&self) -> bool {
            self.mediaUrl.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mediaUrl(&mut self, v: ::std::string::String) {
            self.mediaUrl = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mediaUrl(&mut self) -> &mut ::std::string::String {
            if self.mediaUrl.is_none() {
                self.mediaUrl = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mediaUrl.as_mut().unwrap()
        }

        // Take field
        pub fn take_mediaUrl(&mut self) -> ::std::string::String {
            self.mediaUrl.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes thumbnail = 6;

        pub fn thumbnail(&self) -> &[u8] {
            match self.thumbnail.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_thumbnail(&mut self) {
            self.thumbnail = ::std::option::Option::None;
        }

        pub fn has_thumbnail(&self) -> bool {
            self.thumbnail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_thumbnail(&mut self, v: ::std::vec::Vec<u8>) {
            self.thumbnail = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_thumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.thumbnail.is_none() {
                self.thumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.thumbnail.as_mut().unwrap()
        }

        // Take field
        pub fn take_thumbnail(&mut self) -> ::std::vec::Vec<u8> {
            self.thumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional string sourceType = 7;

        pub fn sourceType(&self) -> &str {
            match self.sourceType.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_sourceType(&mut self) {
            self.sourceType = ::std::option::Option::None;
        }

        pub fn has_sourceType(&self) -> bool {
            self.sourceType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sourceType(&mut self, v: ::std::string::String) {
            self.sourceType = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sourceType(&mut self) -> &mut ::std::string::String {
            if self.sourceType.is_none() {
                self.sourceType = ::std::option::Option::Some(::std::string::String::new());
            }
            self.sourceType.as_mut().unwrap()
        }

        // Take field
        pub fn take_sourceType(&mut self) -> ::std::string::String {
            self.sourceType.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string sourceId = 8;

        pub fn sourceId(&self) -> &str {
            match self.sourceId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_sourceId(&mut self) {
            self.sourceId = ::std::option::Option::None;
        }

        pub fn has_sourceId(&self) -> bool {
            self.sourceId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sourceId(&mut self, v: ::std::string::String) {
            self.sourceId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sourceId(&mut self) -> &mut ::std::string::String {
            if self.sourceId.is_none() {
                self.sourceId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.sourceId.as_mut().unwrap()
        }

        // Take field
        pub fn take_sourceId(&mut self) -> ::std::string::String {
            self.sourceId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string sourceUrl = 9;

        pub fn sourceUrl(&self) -> &str {
            match self.sourceUrl.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_sourceUrl(&mut self) {
            self.sourceUrl = ::std::option::Option::None;
        }

        pub fn has_sourceUrl(&self) -> bool {
            self.sourceUrl.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sourceUrl(&mut self, v: ::std::string::String) {
            self.sourceUrl = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sourceUrl(&mut self) -> &mut ::std::string::String {
            if self.sourceUrl.is_none() {
                self.sourceUrl = ::std::option::Option::Some(::std::string::String::new());
            }
            self.sourceUrl.as_mut().unwrap()
        }

        // Take field
        pub fn take_sourceUrl(&mut self) -> ::std::string::String {
            self.sourceUrl.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool containsAutoReply = 10;

        pub fn containsAutoReply(&self) -> bool {
            self.containsAutoReply.unwrap_or(false)
        }

        pub fn clear_containsAutoReply(&mut self) {
            self.containsAutoReply = ::std::option::Option::None;
        }

        pub fn has_containsAutoReply(&self) -> bool {
            self.containsAutoReply.is_some()
        }

        // Param is passed by value, moved
        pub fn set_containsAutoReply(&mut self, v: bool) {
            self.containsAutoReply = ::std::option::Option::Some(v);
        }

        // optional bool renderLargerThumbnail = 11;

        pub fn renderLargerThumbnail(&self) -> bool {
            self.renderLargerThumbnail.unwrap_or(false)
        }

        pub fn clear_renderLargerThumbnail(&mut self) {
            self.renderLargerThumbnail = ::std::option::Option::None;
        }

        pub fn has_renderLargerThumbnail(&self) -> bool {
            self.renderLargerThumbnail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_renderLargerThumbnail(&mut self, v: bool) {
            self.renderLargerThumbnail = ::std::option::Option::Some(v);
        }

        // optional bool showAdAttribution = 12;

        pub fn showAdAttribution(&self) -> bool {
            self.showAdAttribution.unwrap_or(false)
        }

        pub fn clear_showAdAttribution(&mut self) {
            self.showAdAttribution = ::std::option::Option::None;
        }

        pub fn has_showAdAttribution(&self) -> bool {
            self.showAdAttribution.is_some()
        }

        // Param is passed by value, moved
        pub fn set_showAdAttribution(&mut self, v: bool) {
            self.showAdAttribution = ::std::option::Option::Some(v);
        }

        // optional string ctwaClid = 13;

        pub fn ctwaClid(&self) -> &str {
            match self.ctwaClid.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ctwaClid(&mut self) {
            self.ctwaClid = ::std::option::Option::None;
        }

        pub fn has_ctwaClid(&self) -> bool {
            self.ctwaClid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ctwaClid(&mut self, v: ::std::string::String) {
            self.ctwaClid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ctwaClid(&mut self) -> &mut ::std::string::String {
            if self.ctwaClid.is_none() {
                self.ctwaClid = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ctwaClid.as_mut().unwrap()
        }

        // Take field
        pub fn take_ctwaClid(&mut self) -> ::std::string::String {
            self.ctwaClid.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "title",
                |m: &ExternalAdReplyInfo| { &m.title },
                |m: &mut ExternalAdReplyInfo| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "body",
                |m: &ExternalAdReplyInfo| { &m.body },
                |m: &mut ExternalAdReplyInfo| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mediaType",
                |m: &ExternalAdReplyInfo| { &m.mediaType },
                |m: &mut ExternalAdReplyInfo| { &mut m.mediaType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "thumbnailUrl",
                |m: &ExternalAdReplyInfo| { &m.thumbnailUrl },
                |m: &mut ExternalAdReplyInfo| { &mut m.thumbnailUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mediaUrl",
                |m: &ExternalAdReplyInfo| { &m.mediaUrl },
                |m: &mut ExternalAdReplyInfo| { &mut m.mediaUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "thumbnail",
                |m: &ExternalAdReplyInfo| { &m.thumbnail },
                |m: &mut ExternalAdReplyInfo| { &mut m.thumbnail },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sourceType",
                |m: &ExternalAdReplyInfo| { &m.sourceType },
                |m: &mut ExternalAdReplyInfo| { &mut m.sourceType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sourceId",
                |m: &ExternalAdReplyInfo| { &m.sourceId },
                |m: &mut ExternalAdReplyInfo| { &mut m.sourceId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sourceUrl",
                |m: &ExternalAdReplyInfo| { &m.sourceUrl },
                |m: &mut ExternalAdReplyInfo| { &mut m.sourceUrl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "containsAutoReply",
                |m: &ExternalAdReplyInfo| { &m.containsAutoReply },
                |m: &mut ExternalAdReplyInfo| { &mut m.containsAutoReply },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "renderLargerThumbnail",
                |m: &ExternalAdReplyInfo| { &m.renderLargerThumbnail },
                |m: &mut ExternalAdReplyInfo| { &mut m.renderLargerThumbnail },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "showAdAttribution",
                |m: &ExternalAdReplyInfo| { &m.showAdAttribution },
                |m: &mut ExternalAdReplyInfo| { &mut m.showAdAttribution },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ctwaClid",
                |m: &ExternalAdReplyInfo| { &m.ctwaClid },
                |m: &mut ExternalAdReplyInfo| { &mut m.ctwaClid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExternalAdReplyInfo>(
                "ContextInfo.ExternalAdReplyInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ExternalAdReplyInfo {
        const NAME: &'static str = "ExternalAdReplyInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.body = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.mediaType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        self.thumbnailUrl = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.mediaUrl = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.thumbnail = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    58 => {
                        self.sourceType = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.sourceId = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.sourceUrl = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.containsAutoReply = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.renderLargerThumbnail = ::std::option::Option::Some(is.read_bool()?);
                    },
                    96 => {
                        self.showAdAttribution = ::std::option::Option::Some(is.read_bool()?);
                    },
                    106 => {
                        self.ctwaClid = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.title.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.body.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.mediaType {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.thumbnailUrl.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.mediaUrl.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.thumbnail.as_ref() {
                my_size += ::protobuf::rt::bytes_size(6, &v);
            }
            if let Some(v) = self.sourceType.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.sourceId.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.sourceUrl.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.containsAutoReply {
                my_size += 1 + 1;
            }
            if let Some(v) = self.renderLargerThumbnail {
                my_size += 1 + 1;
            }
            if let Some(v) = self.showAdAttribution {
                my_size += 1 + 1;
            }
            if let Some(v) = self.ctwaClid.as_ref() {
                my_size += ::protobuf::rt::string_size(13, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.title.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.body.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.mediaType {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.thumbnailUrl.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.mediaUrl.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.thumbnail.as_ref() {
                os.write_bytes(6, v)?;
            }
            if let Some(v) = self.sourceType.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.sourceId.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.sourceUrl.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.containsAutoReply {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.renderLargerThumbnail {
                os.write_bool(11, v)?;
            }
            if let Some(v) = self.showAdAttribution {
                os.write_bool(12, v)?;
            }
            if let Some(v) = self.ctwaClid.as_ref() {
                os.write_string(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ExternalAdReplyInfo {
            ExternalAdReplyInfo::new()
        }

        fn clear(&mut self) {
            self.title = ::std::option::Option::None;
            self.body = ::std::option::Option::None;
            self.mediaType = ::std::option::Option::None;
            self.thumbnailUrl = ::std::option::Option::None;
            self.mediaUrl = ::std::option::Option::None;
            self.thumbnail = ::std::option::Option::None;
            self.sourceType = ::std::option::Option::None;
            self.sourceId = ::std::option::Option::None;
            self.sourceUrl = ::std::option::Option::None;
            self.containsAutoReply = ::std::option::Option::None;
            self.renderLargerThumbnail = ::std::option::Option::None;
            self.showAdAttribution = ::std::option::Option::None;
            self.ctwaClid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ExternalAdReplyInfo {
            static instance: ExternalAdReplyInfo = ExternalAdReplyInfo {
                title: ::std::option::Option::None,
                body: ::std::option::Option::None,
                mediaType: ::std::option::Option::None,
                thumbnailUrl: ::std::option::Option::None,
                mediaUrl: ::std::option::Option::None,
                thumbnail: ::std::option::Option::None,
                sourceType: ::std::option::Option::None,
                sourceId: ::std::option::Option::None,
                sourceUrl: ::std::option::Option::None,
                containsAutoReply: ::std::option::Option::None,
                renderLargerThumbnail: ::std::option::Option::None,
                showAdAttribution: ::std::option::Option::None,
                ctwaClid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ExternalAdReplyInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ContextInfo.ExternalAdReplyInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ExternalAdReplyInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ExternalAdReplyInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ExternalAdReplyInfo`
    pub mod external_ad_reply_info {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:proto.ContextInfo.ExternalAdReplyInfo.MediaType)
        pub enum MediaType {
            // @@protoc_insertion_point(enum_value:proto.ContextInfo.ExternalAdReplyInfo.MediaType.NONE)
            NONE = 0,
            // @@protoc_insertion_point(enum_value:proto.ContextInfo.ExternalAdReplyInfo.MediaType.IMAGE)
            IMAGE = 1,
            // @@protoc_insertion_point(enum_value:proto.ContextInfo.ExternalAdReplyInfo.MediaType.VIDEO)
            VIDEO = 2,
        }

        impl ::protobuf::Enum for MediaType {
            const NAME: &'static str = "MediaType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<MediaType> {
                match value {
                    0 => ::std::option::Option::Some(MediaType::NONE),
                    1 => ::std::option::Option::Some(MediaType::IMAGE),
                    2 => ::std::option::Option::Some(MediaType::VIDEO),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [MediaType] = &[
                MediaType::NONE,
                MediaType::IMAGE,
                MediaType::VIDEO,
            ];
        }

        impl ::protobuf::EnumFull for MediaType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("ContextInfo.ExternalAdReplyInfo.MediaType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for MediaType {
            fn default() -> Self {
                MediaType::NONE
            }
        }

        impl MediaType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaType>("ContextInfo.ExternalAdReplyInfo.MediaType")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ContextInfo.AdReplyInfo)
    pub struct AdReplyInfo {
        // message fields
        // @@protoc_insertion_point(field:proto.ContextInfo.AdReplyInfo.advertiserName)
        pub advertiserName: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ContextInfo.AdReplyInfo.mediaType)
        pub mediaType: ::std::option::Option<::protobuf::EnumOrUnknown<ad_reply_info::MediaType>>,
        // @@protoc_insertion_point(field:proto.ContextInfo.AdReplyInfo.jpegThumbnail)
        pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ContextInfo.AdReplyInfo.caption)
        pub caption: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ContextInfo.AdReplyInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdReplyInfo {
        fn default() -> &'a AdReplyInfo {
            <AdReplyInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl AdReplyInfo {
        pub fn new() -> AdReplyInfo {
            ::std::default::Default::default()
        }

        // optional string advertiserName = 1;

        pub fn advertiserName(&self) -> &str {
            match self.advertiserName.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_advertiserName(&mut self) {
            self.advertiserName = ::std::option::Option::None;
        }

        pub fn has_advertiserName(&self) -> bool {
            self.advertiserName.is_some()
        }

        // Param is passed by value, moved
        pub fn set_advertiserName(&mut self, v: ::std::string::String) {
            self.advertiserName = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_advertiserName(&mut self) -> &mut ::std::string::String {
            if self.advertiserName.is_none() {
                self.advertiserName = ::std::option::Option::Some(::std::string::String::new());
            }
            self.advertiserName.as_mut().unwrap()
        }

        // Take field
        pub fn take_advertiserName(&mut self) -> ::std::string::String {
            self.advertiserName.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .proto.ContextInfo.AdReplyInfo.MediaType mediaType = 2;

        pub fn mediaType(&self) -> ad_reply_info::MediaType {
            match self.mediaType {
                Some(e) => e.enum_value_or(ad_reply_info::MediaType::NONE),
                None => ad_reply_info::MediaType::NONE,
            }
        }

        pub fn clear_mediaType(&mut self) {
            self.mediaType = ::std::option::Option::None;
        }

        pub fn has_mediaType(&self) -> bool {
            self.mediaType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mediaType(&mut self, v: ad_reply_info::MediaType) {
            self.mediaType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bytes jpegThumbnail = 16;

        pub fn jpegThumbnail(&self) -> &[u8] {
            match self.jpegThumbnail.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_jpegThumbnail(&mut self) {
            self.jpegThumbnail = ::std::option::Option::None;
        }

        pub fn has_jpegThumbnail(&self) -> bool {
            self.jpegThumbnail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
            self.jpegThumbnail = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.jpegThumbnail.is_none() {
                self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.jpegThumbnail.as_mut().unwrap()
        }

        // Take field
        pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
            self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional string caption = 17;

        pub fn caption(&self) -> &str {
            match self.caption.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_caption(&mut self) {
            self.caption = ::std::option::Option::None;
        }

        pub fn has_caption(&self) -> bool {
            self.caption.is_some()
        }

        // Param is passed by value, moved
        pub fn set_caption(&mut self, v: ::std::string::String) {
            self.caption = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_caption(&mut self) -> &mut ::std::string::String {
            if self.caption.is_none() {
                self.caption = ::std::option::Option::Some(::std::string::String::new());
            }
            self.caption.as_mut().unwrap()
        }

        // Take field
        pub fn take_caption(&mut self) -> ::std::string::String {
            self.caption.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "advertiserName",
                |m: &AdReplyInfo| { &m.advertiserName },
                |m: &mut AdReplyInfo| { &mut m.advertiserName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mediaType",
                |m: &AdReplyInfo| { &m.mediaType },
                |m: &mut AdReplyInfo| { &mut m.mediaType },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "jpegThumbnail",
                |m: &AdReplyInfo| { &m.jpegThumbnail },
                |m: &mut AdReplyInfo| { &mut m.jpegThumbnail },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "caption",
                |m: &AdReplyInfo| { &m.caption },
                |m: &mut AdReplyInfo| { &mut m.caption },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdReplyInfo>(
                "ContextInfo.AdReplyInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AdReplyInfo {
        const NAME: &'static str = "AdReplyInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.advertiserName = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.mediaType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    130 => {
                        self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    138 => {
                        self.caption = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.advertiserName.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.mediaType {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.jpegThumbnail.as_ref() {
                my_size += ::protobuf::rt::bytes_size(16, &v);
            }
            if let Some(v) = self.caption.as_ref() {
                my_size += ::protobuf::rt::string_size(17, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.advertiserName.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.mediaType {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.jpegThumbnail.as_ref() {
                os.write_bytes(16, v)?;
            }
            if let Some(v) = self.caption.as_ref() {
                os.write_string(17, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdReplyInfo {
            AdReplyInfo::new()
        }

        fn clear(&mut self) {
            self.advertiserName = ::std::option::Option::None;
            self.mediaType = ::std::option::Option::None;
            self.jpegThumbnail = ::std::option::Option::None;
            self.caption = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdReplyInfo {
            static instance: AdReplyInfo = AdReplyInfo {
                advertiserName: ::std::option::Option::None,
                mediaType: ::std::option::Option::None,
                jpegThumbnail: ::std::option::Option::None,
                caption: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AdReplyInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ContextInfo.AdReplyInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AdReplyInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AdReplyInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AdReplyInfo`
    pub mod ad_reply_info {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:proto.ContextInfo.AdReplyInfo.MediaType)
        pub enum MediaType {
            // @@protoc_insertion_point(enum_value:proto.ContextInfo.AdReplyInfo.MediaType.NONE)
            NONE = 0,
            // @@protoc_insertion_point(enum_value:proto.ContextInfo.AdReplyInfo.MediaType.IMAGE)
            IMAGE = 1,
            // @@protoc_insertion_point(enum_value:proto.ContextInfo.AdReplyInfo.MediaType.VIDEO)
            VIDEO = 2,
        }

        impl ::protobuf::Enum for MediaType {
            const NAME: &'static str = "MediaType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<MediaType> {
                match value {
                    0 => ::std::option::Option::Some(MediaType::NONE),
                    1 => ::std::option::Option::Some(MediaType::IMAGE),
                    2 => ::std::option::Option::Some(MediaType::VIDEO),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [MediaType] = &[
                MediaType::NONE,
                MediaType::IMAGE,
                MediaType::VIDEO,
            ];
        }

        impl ::protobuf::EnumFull for MediaType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("ContextInfo.AdReplyInfo.MediaType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for MediaType {
            fn default() -> Self {
                MediaType::NONE
            }
        }

        impl MediaType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaType>("ContextInfo.AdReplyInfo.MediaType")
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ActionLink)
pub struct ActionLink {
    // message fields
    // @@protoc_insertion_point(field:proto.ActionLink.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ActionLink.buttonTitle)
    pub buttonTitle: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ActionLink.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActionLink {
    fn default() -> &'a ActionLink {
        <ActionLink as ::protobuf::Message>::default_instance()
    }
}

impl ActionLink {
    pub fn new() -> ActionLink {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string buttonTitle = 2;

    pub fn buttonTitle(&self) -> &str {
        match self.buttonTitle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_buttonTitle(&mut self) {
        self.buttonTitle = ::std::option::Option::None;
    }

    pub fn has_buttonTitle(&self) -> bool {
        self.buttonTitle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buttonTitle(&mut self, v: ::std::string::String) {
        self.buttonTitle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buttonTitle(&mut self) -> &mut ::std::string::String {
        if self.buttonTitle.is_none() {
            self.buttonTitle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.buttonTitle.as_mut().unwrap()
    }

    // Take field
    pub fn take_buttonTitle(&mut self) -> ::std::string::String {
        self.buttonTitle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &ActionLink| { &m.url },
            |m: &mut ActionLink| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buttonTitle",
            |m: &ActionLink| { &m.buttonTitle },
            |m: &mut ActionLink| { &mut m.buttonTitle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionLink>(
            "ActionLink",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActionLink {
    const NAME: &'static str = "ActionLink";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.buttonTitle = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.buttonTitle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.buttonTitle.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActionLink {
        ActionLink::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.buttonTitle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActionLink {
        static instance: ActionLink = ActionLink {
            url: ::std::option::Option::None,
            buttonTitle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActionLink {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActionLink").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActionLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionLink {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.TemplateButton)
pub struct TemplateButton {
    // message fields
    // @@protoc_insertion_point(field:proto.TemplateButton.index)
    pub index: ::std::option::Option<u32>,
    // message oneof groups
    pub button: ::std::option::Option<template_button::Button>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.TemplateButton.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TemplateButton {
    fn default() -> &'a TemplateButton {
        <TemplateButton as ::protobuf::Message>::default_instance()
    }
}

impl TemplateButton {
    pub fn new() -> TemplateButton {
        ::std::default::Default::default()
    }

    // optional uint32 index = 4;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional .proto.TemplateButton.QuickReplyButton quickReplyButton = 1;

    pub fn quickReplyButton(&self) -> &template_button::QuickReplyButton {
        match self.button {
            ::std::option::Option::Some(template_button::Button::QuickReplyButton(ref v)) => v,
            _ => <template_button::QuickReplyButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_quickReplyButton(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_quickReplyButton(&self) -> bool {
        match self.button {
            ::std::option::Option::Some(template_button::Button::QuickReplyButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quickReplyButton(&mut self, v: template_button::QuickReplyButton) {
        self.button = ::std::option::Option::Some(template_button::Button::QuickReplyButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quickReplyButton(&mut self) -> &mut template_button::QuickReplyButton {
        if let ::std::option::Option::Some(template_button::Button::QuickReplyButton(_)) = self.button {
        } else {
            self.button = ::std::option::Option::Some(template_button::Button::QuickReplyButton(template_button::QuickReplyButton::new()));
        }
        match self.button {
            ::std::option::Option::Some(template_button::Button::QuickReplyButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quickReplyButton(&mut self) -> template_button::QuickReplyButton {
        if self.has_quickReplyButton() {
            match self.button.take() {
                ::std::option::Option::Some(template_button::Button::QuickReplyButton(v)) => v,
                _ => panic!(),
            }
        } else {
            template_button::QuickReplyButton::new()
        }
    }

    // optional .proto.TemplateButton.URLButton urlButton = 2;

    pub fn urlButton(&self) -> &template_button::URLButton {
        match self.button {
            ::std::option::Option::Some(template_button::Button::UrlButton(ref v)) => v,
            _ => <template_button::URLButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_urlButton(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_urlButton(&self) -> bool {
        match self.button {
            ::std::option::Option::Some(template_button::Button::UrlButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_urlButton(&mut self, v: template_button::URLButton) {
        self.button = ::std::option::Option::Some(template_button::Button::UrlButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_urlButton(&mut self) -> &mut template_button::URLButton {
        if let ::std::option::Option::Some(template_button::Button::UrlButton(_)) = self.button {
        } else {
            self.button = ::std::option::Option::Some(template_button::Button::UrlButton(template_button::URLButton::new()));
        }
        match self.button {
            ::std::option::Option::Some(template_button::Button::UrlButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_urlButton(&mut self) -> template_button::URLButton {
        if self.has_urlButton() {
            match self.button.take() {
                ::std::option::Option::Some(template_button::Button::UrlButton(v)) => v,
                _ => panic!(),
            }
        } else {
            template_button::URLButton::new()
        }
    }

    // optional .proto.TemplateButton.CallButton callButton = 3;

    pub fn callButton(&self) -> &template_button::CallButton {
        match self.button {
            ::std::option::Option::Some(template_button::Button::CallButton(ref v)) => v,
            _ => <template_button::CallButton as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_callButton(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_callButton(&self) -> bool {
        match self.button {
            ::std::option::Option::Some(template_button::Button::CallButton(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_callButton(&mut self, v: template_button::CallButton) {
        self.button = ::std::option::Option::Some(template_button::Button::CallButton(v))
    }

    // Mutable pointer to the field.
    pub fn mut_callButton(&mut self) -> &mut template_button::CallButton {
        if let ::std::option::Option::Some(template_button::Button::CallButton(_)) = self.button {
        } else {
            self.button = ::std::option::Option::Some(template_button::Button::CallButton(template_button::CallButton::new()));
        }
        match self.button {
            ::std::option::Option::Some(template_button::Button::CallButton(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_callButton(&mut self) -> template_button::CallButton {
        if self.has_callButton() {
            match self.button.take() {
                ::std::option::Option::Some(template_button::Button::CallButton(v)) => v,
                _ => panic!(),
            }
        } else {
            template_button::CallButton::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &TemplateButton| { &m.index },
            |m: &mut TemplateButton| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, template_button::QuickReplyButton>(
            "quickReplyButton",
            TemplateButton::has_quickReplyButton,
            TemplateButton::quickReplyButton,
            TemplateButton::mut_quickReplyButton,
            TemplateButton::set_quickReplyButton,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, template_button::URLButton>(
            "urlButton",
            TemplateButton::has_urlButton,
            TemplateButton::urlButton,
            TemplateButton::mut_urlButton,
            TemplateButton::set_urlButton,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, template_button::CallButton>(
            "callButton",
            TemplateButton::has_callButton,
            TemplateButton::callButton,
            TemplateButton::mut_callButton,
            TemplateButton::set_callButton,
        ));
        oneofs.push(template_button::Button::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TemplateButton>(
            "TemplateButton",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TemplateButton {
    const NAME: &'static str = "TemplateButton";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                10 => {
                    self.button = ::std::option::Option::Some(template_button::Button::QuickReplyButton(is.read_message()?));
                },
                18 => {
                    self.button = ::std::option::Option::Some(template_button::Button::UrlButton(is.read_message()?));
                },
                26 => {
                    self.button = ::std::option::Option::Some(template_button::Button::CallButton(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let ::std::option::Option::Some(ref v) = self.button {
            match v {
                &template_button::Button::QuickReplyButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &template_button::Button::UrlButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &template_button::Button::CallButton(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_uint32(4, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.button {
            match v {
                &template_button::Button::QuickReplyButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &template_button::Button::UrlButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &template_button::Button::CallButton(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TemplateButton {
        TemplateButton::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TemplateButton {
        static instance: TemplateButton = TemplateButton {
            index: ::std::option::Option::None,
            button: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TemplateButton {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TemplateButton").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TemplateButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateButton {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TemplateButton`
pub mod template_button {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:proto.TemplateButton.button)
    pub enum Button {
        // @@protoc_insertion_point(oneof_field:proto.TemplateButton.quickReplyButton)
        QuickReplyButton(QuickReplyButton),
        // @@protoc_insertion_point(oneof_field:proto.TemplateButton.urlButton)
        UrlButton(URLButton),
        // @@protoc_insertion_point(oneof_field:proto.TemplateButton.callButton)
        CallButton(CallButton),
    }

    impl ::protobuf::Oneof for Button {
    }

    impl ::protobuf::OneofFull for Button {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TemplateButton as ::protobuf::MessageFull>::descriptor().oneof_by_name("button").unwrap()).clone()
        }
    }

    impl Button {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Button>("button")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.TemplateButton.URLButton)
    pub struct URLButton {
        // message fields
        // @@protoc_insertion_point(field:proto.TemplateButton.URLButton.displayText)
        pub displayText: ::protobuf::MessageField<super::HighlyStructuredMessage>,
        // @@protoc_insertion_point(field:proto.TemplateButton.URLButton.url)
        pub url: ::protobuf::MessageField<super::HighlyStructuredMessage>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.TemplateButton.URLButton.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a URLButton {
        fn default() -> &'a URLButton {
            <URLButton as ::protobuf::Message>::default_instance()
        }
    }

    impl URLButton {
        pub fn new() -> URLButton {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::HighlyStructuredMessage>(
                "displayText",
                |m: &URLButton| { &m.displayText },
                |m: &mut URLButton| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::HighlyStructuredMessage>(
                "url",
                |m: &URLButton| { &m.url },
                |m: &mut URLButton| { &mut m.url },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<URLButton>(
                "TemplateButton.URLButton",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for URLButton {
        const NAME: &'static str = "URLButton";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.url)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.displayText.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.url.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.displayText.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.url.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> URLButton {
            URLButton::new()
        }

        fn clear(&mut self) {
            self.displayText.clear();
            self.url.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static URLButton {
            static instance: URLButton = URLButton {
                displayText: ::protobuf::MessageField::none(),
                url: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for URLButton {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TemplateButton.URLButton").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for URLButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for URLButton {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.TemplateButton.QuickReplyButton)
    pub struct QuickReplyButton {
        // message fields
        // @@protoc_insertion_point(field:proto.TemplateButton.QuickReplyButton.displayText)
        pub displayText: ::protobuf::MessageField<super::HighlyStructuredMessage>,
        // @@protoc_insertion_point(field:proto.TemplateButton.QuickReplyButton.id)
        pub id: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.TemplateButton.QuickReplyButton.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QuickReplyButton {
        fn default() -> &'a QuickReplyButton {
            <QuickReplyButton as ::protobuf::Message>::default_instance()
        }
    }

    impl QuickReplyButton {
        pub fn new() -> QuickReplyButton {
            ::std::default::Default::default()
        }

        // optional string id = 2;

        pub fn id(&self) -> &str {
            match self.id.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: ::std::string::String) {
            self.id = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_id(&mut self) -> &mut ::std::string::String {
            if self.id.is_none() {
                self.id = ::std::option::Option::Some(::std::string::String::new());
            }
            self.id.as_mut().unwrap()
        }

        // Take field
        pub fn take_id(&mut self) -> ::std::string::String {
            self.id.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::HighlyStructuredMessage>(
                "displayText",
                |m: &QuickReplyButton| { &m.displayText },
                |m: &mut QuickReplyButton| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &QuickReplyButton| { &m.id },
                |m: &mut QuickReplyButton| { &mut m.id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuickReplyButton>(
                "TemplateButton.QuickReplyButton",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QuickReplyButton {
        const NAME: &'static str = "QuickReplyButton";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                    },
                    18 => {
                        self.id = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.displayText.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.id.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.displayText.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.id.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QuickReplyButton {
            QuickReplyButton::new()
        }

        fn clear(&mut self) {
            self.displayText.clear();
            self.id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QuickReplyButton {
            static instance: QuickReplyButton = QuickReplyButton {
                displayText: ::protobuf::MessageField::none(),
                id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for QuickReplyButton {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TemplateButton.QuickReplyButton").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QuickReplyButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QuickReplyButton {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.TemplateButton.CallButton)
    pub struct CallButton {
        // message fields
        // @@protoc_insertion_point(field:proto.TemplateButton.CallButton.displayText)
        pub displayText: ::protobuf::MessageField<super::HighlyStructuredMessage>,
        // @@protoc_insertion_point(field:proto.TemplateButton.CallButton.phoneNumber)
        pub phoneNumber: ::protobuf::MessageField<super::HighlyStructuredMessage>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.TemplateButton.CallButton.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CallButton {
        fn default() -> &'a CallButton {
            <CallButton as ::protobuf::Message>::default_instance()
        }
    }

    impl CallButton {
        pub fn new() -> CallButton {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::HighlyStructuredMessage>(
                "displayText",
                |m: &CallButton| { &m.displayText },
                |m: &mut CallButton| { &mut m.displayText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::HighlyStructuredMessage>(
                "phoneNumber",
                |m: &CallButton| { &m.phoneNumber },
                |m: &mut CallButton| { &mut m.phoneNumber },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CallButton>(
                "TemplateButton.CallButton",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CallButton {
        const NAME: &'static str = "CallButton";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.displayText)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.phoneNumber)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.displayText.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.phoneNumber.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.displayText.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.phoneNumber.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CallButton {
            CallButton::new()
        }

        fn clear(&mut self) {
            self.displayText.clear();
            self.phoneNumber.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CallButton {
            static instance: CallButton = CallButton {
                displayText: ::protobuf::MessageField::none(),
                phoneNumber: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CallButton {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TemplateButton.CallButton").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CallButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CallButton {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Point)
pub struct Point {
    // message fields
    // @@protoc_insertion_point(field:proto.Point.xDeprecated)
    pub xDeprecated: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.Point.yDeprecated)
    pub yDeprecated: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.Point.x)
    pub x: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.Point.y)
    pub y: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Point.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    // optional int32 xDeprecated = 1;

    pub fn xDeprecated(&self) -> i32 {
        self.xDeprecated.unwrap_or(0)
    }

    pub fn clear_xDeprecated(&mut self) {
        self.xDeprecated = ::std::option::Option::None;
    }

    pub fn has_xDeprecated(&self) -> bool {
        self.xDeprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xDeprecated(&mut self, v: i32) {
        self.xDeprecated = ::std::option::Option::Some(v);
    }

    // optional int32 yDeprecated = 2;

    pub fn yDeprecated(&self) -> i32 {
        self.yDeprecated.unwrap_or(0)
    }

    pub fn clear_yDeprecated(&mut self) {
        self.yDeprecated = ::std::option::Option::None;
    }

    pub fn has_yDeprecated(&self) -> bool {
        self.yDeprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yDeprecated(&mut self, v: i32) {
        self.yDeprecated = ::std::option::Option::Some(v);
    }

    // optional double x = 3;

    pub fn x(&self) -> f64 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f64) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional double y = 4;

    pub fn y(&self) -> f64 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f64) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xDeprecated",
            |m: &Point| { &m.xDeprecated },
            |m: &mut Point| { &mut m.xDeprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "yDeprecated",
            |m: &Point| { &m.yDeprecated },
            |m: &mut Point| { &mut m.yDeprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &Point| { &m.x },
            |m: &mut Point| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &Point| { &m.y },
            |m: &mut Point| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Point>(
            "Point",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Point {
    const NAME: &'static str = "Point";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.xDeprecated = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.yDeprecated = ::std::option::Option::Some(is.read_int32()?);
                },
                25 => {
                    self.x = ::std::option::Option::Some(is.read_double()?);
                },
                33 => {
                    self.y = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.xDeprecated {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.yDeprecated {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 8;
        }
        if let Some(v) = self.y {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.xDeprecated {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.yDeprecated {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.x {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.y {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point {
        Point::new()
    }

    fn clear(&mut self) {
        self.xDeprecated = ::std::option::Option::None;
        self.yDeprecated = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point {
        static instance: Point = Point {
            xDeprecated: ::std::option::Option::None,
            yDeprecated: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Point {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Point").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PaymentBackground)
pub struct PaymentBackground {
    // message fields
    // @@protoc_insertion_point(field:proto.PaymentBackground.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.placeholderArgb)
    pub placeholderArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.textArgb)
    pub textArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.subtextArgb)
    pub subtextArgb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.mediaData)
    pub mediaData: ::protobuf::MessageField<payment_background::MediaData>,
    // @@protoc_insertion_point(field:proto.PaymentBackground.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<payment_background::Type>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PaymentBackground.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentBackground {
    fn default() -> &'a PaymentBackground {
        <PaymentBackground as ::protobuf::Message>::default_instance()
    }
}

impl PaymentBackground {
    pub fn new() -> PaymentBackground {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileLength = 2;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 3;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 4;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional string mimetype = 5;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 placeholderArgb = 6;

    pub fn placeholderArgb(&self) -> u32 {
        self.placeholderArgb.unwrap_or(0)
    }

    pub fn clear_placeholderArgb(&mut self) {
        self.placeholderArgb = ::std::option::Option::None;
    }

    pub fn has_placeholderArgb(&self) -> bool {
        self.placeholderArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_placeholderArgb(&mut self, v: u32) {
        self.placeholderArgb = ::std::option::Option::Some(v);
    }

    // optional fixed32 textArgb = 7;

    pub fn textArgb(&self) -> u32 {
        self.textArgb.unwrap_or(0)
    }

    pub fn clear_textArgb(&mut self) {
        self.textArgb = ::std::option::Option::None;
    }

    pub fn has_textArgb(&self) -> bool {
        self.textArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textArgb(&mut self, v: u32) {
        self.textArgb = ::std::option::Option::Some(v);
    }

    // optional fixed32 subtextArgb = 8;

    pub fn subtextArgb(&self) -> u32 {
        self.subtextArgb.unwrap_or(0)
    }

    pub fn clear_subtextArgb(&mut self) {
        self.subtextArgb = ::std::option::Option::None;
    }

    pub fn has_subtextArgb(&self) -> bool {
        self.subtextArgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subtextArgb(&mut self, v: u32) {
        self.subtextArgb = ::std::option::Option::Some(v);
    }

    // optional .proto.PaymentBackground.Type type = 10;

    pub fn type_(&self) -> payment_background::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(payment_background::Type::UNKNOWN),
            None => payment_background::Type::UNKNOWN,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: payment_background::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &PaymentBackground| { &m.id },
            |m: &mut PaymentBackground| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &PaymentBackground| { &m.fileLength },
            |m: &mut PaymentBackground| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &PaymentBackground| { &m.width },
            |m: &mut PaymentBackground| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &PaymentBackground| { &m.height },
            |m: &mut PaymentBackground| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &PaymentBackground| { &m.mimetype },
            |m: &mut PaymentBackground| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "placeholderArgb",
            |m: &PaymentBackground| { &m.placeholderArgb },
            |m: &mut PaymentBackground| { &mut m.placeholderArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "textArgb",
            |m: &PaymentBackground| { &m.textArgb },
            |m: &mut PaymentBackground| { &mut m.textArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subtextArgb",
            |m: &PaymentBackground| { &m.subtextArgb },
            |m: &mut PaymentBackground| { &mut m.subtextArgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, payment_background::MediaData>(
            "mediaData",
            |m: &PaymentBackground| { &m.mediaData },
            |m: &mut PaymentBackground| { &mut m.mediaData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &PaymentBackground| { &m.type_ },
            |m: &mut PaymentBackground| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentBackground>(
            "PaymentBackground",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentBackground {
    const NAME: &'static str = "PaymentBackground";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                53 => {
                    self.placeholderArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.textArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.subtextArgb = ::std::option::Option::Some(is.read_fixed32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mediaData)?;
                },
                80 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.placeholderArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.textArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.subtextArgb {
            my_size += 1 + 4;
        }
        if let Some(v) = self.mediaData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.placeholderArgb {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.textArgb {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.subtextArgb {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.mediaData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentBackground {
        PaymentBackground::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.placeholderArgb = ::std::option::Option::None;
        self.textArgb = ::std::option::Option::None;
        self.subtextArgb = ::std::option::Option::None;
        self.mediaData.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentBackground {
        static instance: PaymentBackground = PaymentBackground {
            id: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            placeholderArgb: ::std::option::Option::None,
            textArgb: ::std::option::Option::None,
            subtextArgb: ::std::option::Option::None,
            mediaData: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentBackground {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentBackground").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentBackground {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentBackground {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PaymentBackground`
pub mod payment_background {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.PaymentBackground.MediaData)
    pub struct MediaData {
        // message fields
        // @@protoc_insertion_point(field:proto.PaymentBackground.MediaData.mediaKey)
        pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.PaymentBackground.MediaData.mediaKeyTimestamp)
        pub mediaKeyTimestamp: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:proto.PaymentBackground.MediaData.fileSha256)
        pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.PaymentBackground.MediaData.fileEncSha256)
        pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.PaymentBackground.MediaData.directPath)
        pub directPath: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.PaymentBackground.MediaData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MediaData {
        fn default() -> &'a MediaData {
            <MediaData as ::protobuf::Message>::default_instance()
        }
    }

    impl MediaData {
        pub fn new() -> MediaData {
            ::std::default::Default::default()
        }

        // optional bytes mediaKey = 1;

        pub fn mediaKey(&self) -> &[u8] {
            match self.mediaKey.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_mediaKey(&mut self) {
            self.mediaKey = ::std::option::Option::None;
        }

        pub fn has_mediaKey(&self) -> bool {
            self.mediaKey.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
            self.mediaKey = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.mediaKey.is_none() {
                self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.mediaKey.as_mut().unwrap()
        }

        // Take field
        pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
            self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int64 mediaKeyTimestamp = 2;

        pub fn mediaKeyTimestamp(&self) -> i64 {
            self.mediaKeyTimestamp.unwrap_or(0)
        }

        pub fn clear_mediaKeyTimestamp(&mut self) {
            self.mediaKeyTimestamp = ::std::option::Option::None;
        }

        pub fn has_mediaKeyTimestamp(&self) -> bool {
            self.mediaKeyTimestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
            self.mediaKeyTimestamp = ::std::option::Option::Some(v);
        }

        // optional bytes fileSha256 = 3;

        pub fn fileSha256(&self) -> &[u8] {
            match self.fileSha256.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_fileSha256(&mut self) {
            self.fileSha256 = ::std::option::Option::None;
        }

        pub fn has_fileSha256(&self) -> bool {
            self.fileSha256.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
            self.fileSha256 = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.fileSha256.is_none() {
                self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.fileSha256.as_mut().unwrap()
        }

        // Take field
        pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
            self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes fileEncSha256 = 4;

        pub fn fileEncSha256(&self) -> &[u8] {
            match self.fileEncSha256.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_fileEncSha256(&mut self) {
            self.fileEncSha256 = ::std::option::Option::None;
        }

        pub fn has_fileEncSha256(&self) -> bool {
            self.fileEncSha256.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
            self.fileEncSha256 = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.fileEncSha256.is_none() {
                self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.fileEncSha256.as_mut().unwrap()
        }

        // Take field
        pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
            self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional string directPath = 5;

        pub fn directPath(&self) -> &str {
            match self.directPath.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_directPath(&mut self) {
            self.directPath = ::std::option::Option::None;
        }

        pub fn has_directPath(&self) -> bool {
            self.directPath.is_some()
        }

        // Param is passed by value, moved
        pub fn set_directPath(&mut self, v: ::std::string::String) {
            self.directPath = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
            if self.directPath.is_none() {
                self.directPath = ::std::option::Option::Some(::std::string::String::new());
            }
            self.directPath.as_mut().unwrap()
        }

        // Take field
        pub fn take_directPath(&mut self) -> ::std::string::String {
            self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mediaKey",
                |m: &MediaData| { &m.mediaKey },
                |m: &mut MediaData| { &mut m.mediaKey },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mediaKeyTimestamp",
                |m: &MediaData| { &m.mediaKeyTimestamp },
                |m: &mut MediaData| { &mut m.mediaKeyTimestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fileSha256",
                |m: &MediaData| { &m.fileSha256 },
                |m: &mut MediaData| { &mut m.fileSha256 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fileEncSha256",
                |m: &MediaData| { &m.fileEncSha256 },
                |m: &mut MediaData| { &mut m.fileEncSha256 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "directPath",
                |m: &MediaData| { &m.directPath },
                |m: &mut MediaData| { &mut m.directPath },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaData>(
                "PaymentBackground.MediaData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MediaData {
        const NAME: &'static str = "MediaData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    16 => {
                        self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                    },
                    26 => {
                        self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    34 => {
                        self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    42 => {
                        self.directPath = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.mediaKey.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.mediaKeyTimestamp {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.fileSha256.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.fileEncSha256.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.directPath.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.mediaKey.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.mediaKeyTimestamp {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.fileSha256.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.fileEncSha256.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.directPath.as_ref() {
                os.write_string(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MediaData {
            MediaData::new()
        }

        fn clear(&mut self) {
            self.mediaKey = ::std::option::Option::None;
            self.mediaKeyTimestamp = ::std::option::Option::None;
            self.fileSha256 = ::std::option::Option::None;
            self.fileEncSha256 = ::std::option::Option::None;
            self.directPath = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MediaData {
            static instance: MediaData = MediaData {
                mediaKey: ::std::option::Option::None,
                mediaKeyTimestamp: ::std::option::Option::None,
                fileSha256: ::std::option::Option::None,
                fileEncSha256: ::std::option::Option::None,
                directPath: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MediaData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PaymentBackground.MediaData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MediaData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MediaData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.PaymentBackground.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:proto.PaymentBackground.Type.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.PaymentBackground.Type.DEFAULT)
        DEFAULT = 1,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::UNKNOWN),
                1 => ::std::option::Option::Some(Type::DEFAULT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::UNKNOWN,
            Type::DEFAULT,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentBackground.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::UNKNOWN
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("PaymentBackground.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Money)
pub struct Money {
    // message fields
    // @@protoc_insertion_point(field:proto.Money.value)
    pub value: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.Money.offset)
    pub offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.Money.currencyCode)
    pub currencyCode: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Money.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Money {
    fn default() -> &'a Money {
        <Money as ::protobuf::Message>::default_instance()
    }
}

impl Money {
    pub fn new() -> Money {
        ::std::default::Default::default()
    }

    // optional int64 value = 1;

    pub fn value(&self) -> i64 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint32 offset = 2;

    pub fn offset(&self) -> u32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional string currencyCode = 3;

    pub fn currencyCode(&self) -> &str {
        match self.currencyCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currencyCode(&mut self) {
        self.currencyCode = ::std::option::Option::None;
    }

    pub fn has_currencyCode(&self) -> bool {
        self.currencyCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currencyCode(&mut self, v: ::std::string::String) {
        self.currencyCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currencyCode(&mut self) -> &mut ::std::string::String {
        if self.currencyCode.is_none() {
            self.currencyCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currencyCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_currencyCode(&mut self) -> ::std::string::String {
        self.currencyCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &Money| { &m.value },
            |m: &mut Money| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &Money| { &m.offset },
            |m: &mut Money| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currencyCode",
            |m: &Money| { &m.currencyCode },
            |m: &mut Money| { &mut m.currencyCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Money>(
            "Money",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Money {
    const NAME: &'static str = "Money";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.currencyCode = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.currencyCode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.currencyCode.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Money {
        Money::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.currencyCode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Money {
        static instance: Money = Money {
            value: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            currencyCode: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Money {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Money").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Money {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Money {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Message)
pub struct Message {
    // message fields
    // @@protoc_insertion_point(field:proto.Message.conversation)
    pub conversation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Message.senderKeyDistributionMessage)
    pub senderKeyDistributionMessage: ::protobuf::MessageField<SenderKeyDistributionMessage>,
    // @@protoc_insertion_point(field:proto.Message.imageMessage)
    pub imageMessage: ::protobuf::MessageField<ImageMessage>,
    // @@protoc_insertion_point(field:proto.Message.contactMessage)
    pub contactMessage: ::protobuf::MessageField<ContactMessage>,
    // @@protoc_insertion_point(field:proto.Message.locationMessage)
    pub locationMessage: ::protobuf::MessageField<LocationMessage>,
    // @@protoc_insertion_point(field:proto.Message.extendedTextMessage)
    pub extendedTextMessage: ::protobuf::MessageField<ExtendedTextMessage>,
    // @@protoc_insertion_point(field:proto.Message.documentMessage)
    pub documentMessage: ::protobuf::MessageField<DocumentMessage>,
    // @@protoc_insertion_point(field:proto.Message.audioMessage)
    pub audioMessage: ::protobuf::MessageField<AudioMessage>,
    // @@protoc_insertion_point(field:proto.Message.videoMessage)
    pub videoMessage: ::protobuf::MessageField<VideoMessage>,
    // @@protoc_insertion_point(field:proto.Message.call)
    pub call: ::protobuf::MessageField<Call>,
    // @@protoc_insertion_point(field:proto.Message.chat)
    pub chat: ::protobuf::MessageField<Chat>,
    // @@protoc_insertion_point(field:proto.Message.protocolMessage)
    pub protocolMessage: ::protobuf::MessageField<ProtocolMessage>,
    // @@protoc_insertion_point(field:proto.Message.contactsArrayMessage)
    pub contactsArrayMessage: ::protobuf::MessageField<ContactsArrayMessage>,
    // @@protoc_insertion_point(field:proto.Message.highlyStructuredMessage)
    pub highlyStructuredMessage: ::protobuf::MessageField<HighlyStructuredMessage>,
    // @@protoc_insertion_point(field:proto.Message.fastRatchetKeySenderKeyDistributionMessage)
    pub fastRatchetKeySenderKeyDistributionMessage: ::protobuf::MessageField<SenderKeyDistributionMessage>,
    // @@protoc_insertion_point(field:proto.Message.sendPaymentMessage)
    pub sendPaymentMessage: ::protobuf::MessageField<SendPaymentMessage>,
    // @@protoc_insertion_point(field:proto.Message.liveLocationMessage)
    pub liveLocationMessage: ::protobuf::MessageField<LiveLocationMessage>,
    // @@protoc_insertion_point(field:proto.Message.requestPaymentMessage)
    pub requestPaymentMessage: ::protobuf::MessageField<RequestPaymentMessage>,
    // @@protoc_insertion_point(field:proto.Message.declinePaymentRequestMessage)
    pub declinePaymentRequestMessage: ::protobuf::MessageField<DeclinePaymentRequestMessage>,
    // @@protoc_insertion_point(field:proto.Message.cancelPaymentRequestMessage)
    pub cancelPaymentRequestMessage: ::protobuf::MessageField<CancelPaymentRequestMessage>,
    // @@protoc_insertion_point(field:proto.Message.templateMessage)
    pub templateMessage: ::protobuf::MessageField<TemplateMessage>,
    // @@protoc_insertion_point(field:proto.Message.stickerMessage)
    pub stickerMessage: ::protobuf::MessageField<StickerMessage>,
    // @@protoc_insertion_point(field:proto.Message.groupInviteMessage)
    pub groupInviteMessage: ::protobuf::MessageField<GroupInviteMessage>,
    // @@protoc_insertion_point(field:proto.Message.templateButtonReplyMessage)
    pub templateButtonReplyMessage: ::protobuf::MessageField<TemplateButtonReplyMessage>,
    // @@protoc_insertion_point(field:proto.Message.productMessage)
    pub productMessage: ::protobuf::MessageField<ProductMessage>,
    // @@protoc_insertion_point(field:proto.Message.deviceSentMessage)
    pub deviceSentMessage: ::protobuf::MessageField<DeviceSentMessage>,
    // @@protoc_insertion_point(field:proto.Message.messageContextInfo)
    pub messageContextInfo: ::protobuf::MessageField<MessageContextInfo>,
    // @@protoc_insertion_point(field:proto.Message.listMessage)
    pub listMessage: ::protobuf::MessageField<ListMessage>,
    // @@protoc_insertion_point(field:proto.Message.viewOnceMessage)
    pub viewOnceMessage: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:proto.Message.orderMessage)
    pub orderMessage: ::protobuf::MessageField<OrderMessage>,
    // @@protoc_insertion_point(field:proto.Message.listResponseMessage)
    pub listResponseMessage: ::protobuf::MessageField<ListResponseMessage>,
    // @@protoc_insertion_point(field:proto.Message.ephemeralMessage)
    pub ephemeralMessage: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:proto.Message.invoiceMessage)
    pub invoiceMessage: ::protobuf::MessageField<InvoiceMessage>,
    // @@protoc_insertion_point(field:proto.Message.buttonsMessage)
    pub buttonsMessage: ::protobuf::MessageField<ButtonsMessage>,
    // @@protoc_insertion_point(field:proto.Message.buttonsResponseMessage)
    pub buttonsResponseMessage: ::protobuf::MessageField<ButtonsResponseMessage>,
    // @@protoc_insertion_point(field:proto.Message.paymentInviteMessage)
    pub paymentInviteMessage: ::protobuf::MessageField<PaymentInviteMessage>,
    // @@protoc_insertion_point(field:proto.Message.interactiveMessage)
    pub interactiveMessage: ::protobuf::MessageField<InteractiveMessage>,
    // @@protoc_insertion_point(field:proto.Message.reactionMessage)
    pub reactionMessage: ::protobuf::MessageField<ReactionMessage>,
    // @@protoc_insertion_point(field:proto.Message.stickerSyncRmrMessage)
    pub stickerSyncRmrMessage: ::protobuf::MessageField<StickerSyncRMRMessage>,
    // @@protoc_insertion_point(field:proto.Message.interactiveResponseMessage)
    pub interactiveResponseMessage: ::protobuf::MessageField<InteractiveResponseMessage>,
    // @@protoc_insertion_point(field:proto.Message.pollCreationMessage)
    pub pollCreationMessage: ::protobuf::MessageField<PollCreationMessage>,
    // @@protoc_insertion_point(field:proto.Message.pollUpdateMessage)
    pub pollUpdateMessage: ::protobuf::MessageField<PollUpdateMessage>,
    // @@protoc_insertion_point(field:proto.Message.keepInChatMessage)
    pub keepInChatMessage: ::protobuf::MessageField<KeepInChatMessage>,
    // @@protoc_insertion_point(field:proto.Message.documentWithCaptionMessage)
    pub documentWithCaptionMessage: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:proto.Message.requestPhoneNumberMessage)
    pub requestPhoneNumberMessage: ::protobuf::MessageField<RequestPhoneNumberMessage>,
    // @@protoc_insertion_point(field:proto.Message.viewOnceMessageV2)
    pub viewOnceMessageV2: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:proto.Message.encReactionMessage)
    pub encReactionMessage: ::protobuf::MessageField<EncReactionMessage>,
    // @@protoc_insertion_point(field:proto.Message.editedMessage)
    pub editedMessage: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:proto.Message.viewOnceMessageV2Extension)
    pub viewOnceMessageV2Extension: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:proto.Message.pollCreationMessageV2)
    pub pollCreationMessageV2: ::protobuf::MessageField<PollCreationMessage>,
    // @@protoc_insertion_point(field:proto.Message.scheduledCallCreationMessage)
    pub scheduledCallCreationMessage: ::protobuf::MessageField<ScheduledCallCreationMessage>,
    // @@protoc_insertion_point(field:proto.Message.groupMentionedMessage)
    pub groupMentionedMessage: ::protobuf::MessageField<FutureProofMessage>,
    // @@protoc_insertion_point(field:proto.Message.pinMessage)
    pub pinMessage: ::protobuf::MessageField<PinMessage>,
    // @@protoc_insertion_point(field:proto.Message.pollCreationMessageV3)
    pub pollCreationMessageV3: ::protobuf::MessageField<PollCreationMessage>,
    // @@protoc_insertion_point(field:proto.Message.scheduledCallEditMessage)
    pub scheduledCallEditMessage: ::protobuf::MessageField<ScheduledCallEditMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // optional string conversation = 1;

    pub fn conversation(&self) -> &str {
        match self.conversation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_conversation(&mut self) {
        self.conversation = ::std::option::Option::None;
    }

    pub fn has_conversation(&self) -> bool {
        self.conversation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversation(&mut self, v: ::std::string::String) {
        self.conversation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conversation(&mut self) -> &mut ::std::string::String {
        if self.conversation.is_none() {
            self.conversation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.conversation.as_mut().unwrap()
    }

    // Take field
    pub fn take_conversation(&mut self) -> ::std::string::String {
        self.conversation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(55);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversation",
            |m: &Message| { &m.conversation },
            |m: &mut Message| { &mut m.conversation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SenderKeyDistributionMessage>(
            "senderKeyDistributionMessage",
            |m: &Message| { &m.senderKeyDistributionMessage },
            |m: &mut Message| { &mut m.senderKeyDistributionMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ImageMessage>(
            "imageMessage",
            |m: &Message| { &m.imageMessage },
            |m: &mut Message| { &mut m.imageMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContactMessage>(
            "contactMessage",
            |m: &Message| { &m.contactMessage },
            |m: &mut Message| { &mut m.contactMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocationMessage>(
            "locationMessage",
            |m: &Message| { &m.locationMessage },
            |m: &mut Message| { &mut m.locationMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExtendedTextMessage>(
            "extendedTextMessage",
            |m: &Message| { &m.extendedTextMessage },
            |m: &mut Message| { &mut m.extendedTextMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DocumentMessage>(
            "documentMessage",
            |m: &Message| { &m.documentMessage },
            |m: &mut Message| { &mut m.documentMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AudioMessage>(
            "audioMessage",
            |m: &Message| { &m.audioMessage },
            |m: &mut Message| { &mut m.audioMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VideoMessage>(
            "videoMessage",
            |m: &Message| { &m.videoMessage },
            |m: &mut Message| { &mut m.videoMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Call>(
            "call",
            |m: &Message| { &m.call },
            |m: &mut Message| { &mut m.call },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Chat>(
            "chat",
            |m: &Message| { &m.chat },
            |m: &mut Message| { &mut m.chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtocolMessage>(
            "protocolMessage",
            |m: &Message| { &m.protocolMessage },
            |m: &mut Message| { &mut m.protocolMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContactsArrayMessage>(
            "contactsArrayMessage",
            |m: &Message| { &m.contactsArrayMessage },
            |m: &mut Message| { &mut m.contactsArrayMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HighlyStructuredMessage>(
            "highlyStructuredMessage",
            |m: &Message| { &m.highlyStructuredMessage },
            |m: &mut Message| { &mut m.highlyStructuredMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SenderKeyDistributionMessage>(
            "fastRatchetKeySenderKeyDistributionMessage",
            |m: &Message| { &m.fastRatchetKeySenderKeyDistributionMessage },
            |m: &mut Message| { &mut m.fastRatchetKeySenderKeyDistributionMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SendPaymentMessage>(
            "sendPaymentMessage",
            |m: &Message| { &m.sendPaymentMessage },
            |m: &mut Message| { &mut m.sendPaymentMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LiveLocationMessage>(
            "liveLocationMessage",
            |m: &Message| { &m.liveLocationMessage },
            |m: &mut Message| { &mut m.liveLocationMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RequestPaymentMessage>(
            "requestPaymentMessage",
            |m: &Message| { &m.requestPaymentMessage },
            |m: &mut Message| { &mut m.requestPaymentMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeclinePaymentRequestMessage>(
            "declinePaymentRequestMessage",
            |m: &Message| { &m.declinePaymentRequestMessage },
            |m: &mut Message| { &mut m.declinePaymentRequestMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CancelPaymentRequestMessage>(
            "cancelPaymentRequestMessage",
            |m: &Message| { &m.cancelPaymentRequestMessage },
            |m: &mut Message| { &mut m.cancelPaymentRequestMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TemplateMessage>(
            "templateMessage",
            |m: &Message| { &m.templateMessage },
            |m: &mut Message| { &mut m.templateMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StickerMessage>(
            "stickerMessage",
            |m: &Message| { &m.stickerMessage },
            |m: &mut Message| { &mut m.stickerMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GroupInviteMessage>(
            "groupInviteMessage",
            |m: &Message| { &m.groupInviteMessage },
            |m: &mut Message| { &mut m.groupInviteMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TemplateButtonReplyMessage>(
            "templateButtonReplyMessage",
            |m: &Message| { &m.templateButtonReplyMessage },
            |m: &mut Message| { &mut m.templateButtonReplyMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductMessage>(
            "productMessage",
            |m: &Message| { &m.productMessage },
            |m: &mut Message| { &mut m.productMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceSentMessage>(
            "deviceSentMessage",
            |m: &Message| { &m.deviceSentMessage },
            |m: &mut Message| { &mut m.deviceSentMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageContextInfo>(
            "messageContextInfo",
            |m: &Message| { &m.messageContextInfo },
            |m: &mut Message| { &mut m.messageContextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListMessage>(
            "listMessage",
            |m: &Message| { &m.listMessage },
            |m: &mut Message| { &mut m.listMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "viewOnceMessage",
            |m: &Message| { &m.viewOnceMessage },
            |m: &mut Message| { &mut m.viewOnceMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, OrderMessage>(
            "orderMessage",
            |m: &Message| { &m.orderMessage },
            |m: &mut Message| { &mut m.orderMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ListResponseMessage>(
            "listResponseMessage",
            |m: &Message| { &m.listResponseMessage },
            |m: &mut Message| { &mut m.listResponseMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "ephemeralMessage",
            |m: &Message| { &m.ephemeralMessage },
            |m: &mut Message| { &mut m.ephemeralMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InvoiceMessage>(
            "invoiceMessage",
            |m: &Message| { &m.invoiceMessage },
            |m: &mut Message| { &mut m.invoiceMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ButtonsMessage>(
            "buttonsMessage",
            |m: &Message| { &m.buttonsMessage },
            |m: &mut Message| { &mut m.buttonsMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ButtonsResponseMessage>(
            "buttonsResponseMessage",
            |m: &Message| { &m.buttonsResponseMessage },
            |m: &mut Message| { &mut m.buttonsResponseMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentInviteMessage>(
            "paymentInviteMessage",
            |m: &Message| { &m.paymentInviteMessage },
            |m: &mut Message| { &mut m.paymentInviteMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InteractiveMessage>(
            "interactiveMessage",
            |m: &Message| { &m.interactiveMessage },
            |m: &mut Message| { &mut m.interactiveMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ReactionMessage>(
            "reactionMessage",
            |m: &Message| { &m.reactionMessage },
            |m: &mut Message| { &mut m.reactionMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StickerSyncRMRMessage>(
            "stickerSyncRmrMessage",
            |m: &Message| { &m.stickerSyncRmrMessage },
            |m: &mut Message| { &mut m.stickerSyncRmrMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InteractiveResponseMessage>(
            "interactiveResponseMessage",
            |m: &Message| { &m.interactiveResponseMessage },
            |m: &mut Message| { &mut m.interactiveResponseMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollCreationMessage>(
            "pollCreationMessage",
            |m: &Message| { &m.pollCreationMessage },
            |m: &mut Message| { &mut m.pollCreationMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollUpdateMessage>(
            "pollUpdateMessage",
            |m: &Message| { &m.pollUpdateMessage },
            |m: &mut Message| { &mut m.pollUpdateMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeepInChatMessage>(
            "keepInChatMessage",
            |m: &Message| { &m.keepInChatMessage },
            |m: &mut Message| { &mut m.keepInChatMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "documentWithCaptionMessage",
            |m: &Message| { &m.documentWithCaptionMessage },
            |m: &mut Message| { &mut m.documentWithCaptionMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RequestPhoneNumberMessage>(
            "requestPhoneNumberMessage",
            |m: &Message| { &m.requestPhoneNumberMessage },
            |m: &mut Message| { &mut m.requestPhoneNumberMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "viewOnceMessageV2",
            |m: &Message| { &m.viewOnceMessageV2 },
            |m: &mut Message| { &mut m.viewOnceMessageV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EncReactionMessage>(
            "encReactionMessage",
            |m: &Message| { &m.encReactionMessage },
            |m: &mut Message| { &mut m.encReactionMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "editedMessage",
            |m: &Message| { &m.editedMessage },
            |m: &mut Message| { &mut m.editedMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "viewOnceMessageV2Extension",
            |m: &Message| { &m.viewOnceMessageV2Extension },
            |m: &mut Message| { &mut m.viewOnceMessageV2Extension },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollCreationMessage>(
            "pollCreationMessageV2",
            |m: &Message| { &m.pollCreationMessageV2 },
            |m: &mut Message| { &mut m.pollCreationMessageV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScheduledCallCreationMessage>(
            "scheduledCallCreationMessage",
            |m: &Message| { &m.scheduledCallCreationMessage },
            |m: &mut Message| { &mut m.scheduledCallCreationMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FutureProofMessage>(
            "groupMentionedMessage",
            |m: &Message| { &m.groupMentionedMessage },
            |m: &mut Message| { &mut m.groupMentionedMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PinMessage>(
            "pinMessage",
            |m: &Message| { &m.pinMessage },
            |m: &mut Message| { &mut m.pinMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollCreationMessage>(
            "pollCreationMessageV3",
            |m: &Message| { &m.pollCreationMessageV3 },
            |m: &mut Message| { &mut m.pollCreationMessageV3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScheduledCallEditMessage>(
            "scheduledCallEditMessage",
            |m: &Message| { &m.scheduledCallEditMessage },
            |m: &mut Message| { &mut m.scheduledCallEditMessage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.conversation = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.senderKeyDistributionMessage)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.imageMessage)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contactMessage)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.locationMessage)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.extendedTextMessage)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.documentMessage)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audioMessage)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.videoMessage)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.call)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chat)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.protocolMessage)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contactsArrayMessage)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.highlyStructuredMessage)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fastRatchetKeySenderKeyDistributionMessage)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sendPaymentMessage)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.liveLocationMessage)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requestPaymentMessage)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.declinePaymentRequestMessage)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cancelPaymentRequestMessage)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.templateMessage)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stickerMessage)?;
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.groupInviteMessage)?;
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.templateButtonReplyMessage)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.productMessage)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceSentMessage)?;
                },
                282 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageContextInfo)?;
                },
                290 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.listMessage)?;
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.viewOnceMessage)?;
                },
                306 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.orderMessage)?;
                },
                314 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.listResponseMessage)?;
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ephemeralMessage)?;
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.invoiceMessage)?;
                },
                338 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buttonsMessage)?;
                },
                346 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buttonsResponseMessage)?;
                },
                354 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paymentInviteMessage)?;
                },
                362 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.interactiveMessage)?;
                },
                370 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reactionMessage)?;
                },
                378 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stickerSyncRmrMessage)?;
                },
                386 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.interactiveResponseMessage)?;
                },
                394 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pollCreationMessage)?;
                },
                402 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pollUpdateMessage)?;
                },
                410 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keepInChatMessage)?;
                },
                426 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.documentWithCaptionMessage)?;
                },
                434 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requestPhoneNumberMessage)?;
                },
                442 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.viewOnceMessageV2)?;
                },
                450 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.encReactionMessage)?;
                },
                466 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.editedMessage)?;
                },
                474 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.viewOnceMessageV2Extension)?;
                },
                482 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pollCreationMessageV2)?;
                },
                490 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scheduledCallCreationMessage)?;
                },
                498 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.groupMentionedMessage)?;
                },
                506 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pinMessage)?;
                },
                514 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pollCreationMessageV3)?;
                },
                522 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scheduledCallEditMessage)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.conversation.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.senderKeyDistributionMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.imageMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contactMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.locationMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.extendedTextMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.documentMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.audioMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.videoMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.call.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.protocolMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contactsArrayMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.highlyStructuredMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fastRatchetKeySenderKeyDistributionMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sendPaymentMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.liveLocationMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.requestPaymentMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.declinePaymentRequestMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cancelPaymentRequestMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.templateMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stickerMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.groupInviteMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.templateButtonReplyMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.productMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deviceSentMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.messageContextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.listMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.viewOnceMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.orderMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.listResponseMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ephemeralMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.invoiceMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buttonsMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.buttonsResponseMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.paymentInviteMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.interactiveMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reactionMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stickerSyncRmrMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.interactiveResponseMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pollCreationMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pollUpdateMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keepInChatMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.documentWithCaptionMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.requestPhoneNumberMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.viewOnceMessageV2.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.encReactionMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.editedMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.viewOnceMessageV2Extension.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pollCreationMessageV2.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scheduledCallCreationMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.groupMentionedMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pinMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pollCreationMessageV3.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scheduledCallEditMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.conversation.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.senderKeyDistributionMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.imageMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.contactMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.locationMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.extendedTextMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.documentMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.audioMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.videoMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.call.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.chat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.protocolMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.contactsArrayMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.highlyStructuredMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.fastRatchetKeySenderKeyDistributionMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.sendPaymentMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.liveLocationMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.requestPaymentMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.declinePaymentRequestMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.cancelPaymentRequestMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.templateMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.stickerMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.groupInviteMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.templateButtonReplyMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.productMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.deviceSentMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.messageContextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.listMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.viewOnceMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.orderMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        if let Some(v) = self.listResponseMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        }
        if let Some(v) = self.ephemeralMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.invoiceMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.buttonsMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.buttonsResponseMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        }
        if let Some(v) = self.paymentInviteMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        if let Some(v) = self.interactiveMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        }
        if let Some(v) = self.reactionMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
        }
        if let Some(v) = self.stickerSyncRmrMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(47, v, os)?;
        }
        if let Some(v) = self.interactiveResponseMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
        }
        if let Some(v) = self.pollCreationMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        }
        if let Some(v) = self.pollUpdateMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        if let Some(v) = self.keepInChatMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        }
        if let Some(v) = self.documentWithCaptionMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(53, v, os)?;
        }
        if let Some(v) = self.requestPhoneNumberMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        }
        if let Some(v) = self.viewOnceMessageV2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(55, v, os)?;
        }
        if let Some(v) = self.encReactionMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(56, v, os)?;
        }
        if let Some(v) = self.editedMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(58, v, os)?;
        }
        if let Some(v) = self.viewOnceMessageV2Extension.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(59, v, os)?;
        }
        if let Some(v) = self.pollCreationMessageV2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(60, v, os)?;
        }
        if let Some(v) = self.scheduledCallCreationMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(61, v, os)?;
        }
        if let Some(v) = self.groupMentionedMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(62, v, os)?;
        }
        if let Some(v) = self.pinMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(63, v, os)?;
        }
        if let Some(v) = self.pollCreationMessageV3.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
        }
        if let Some(v) = self.scheduledCallEditMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(65, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.conversation = ::std::option::Option::None;
        self.senderKeyDistributionMessage.clear();
        self.imageMessage.clear();
        self.contactMessage.clear();
        self.locationMessage.clear();
        self.extendedTextMessage.clear();
        self.documentMessage.clear();
        self.audioMessage.clear();
        self.videoMessage.clear();
        self.call.clear();
        self.chat.clear();
        self.protocolMessage.clear();
        self.contactsArrayMessage.clear();
        self.highlyStructuredMessage.clear();
        self.fastRatchetKeySenderKeyDistributionMessage.clear();
        self.sendPaymentMessage.clear();
        self.liveLocationMessage.clear();
        self.requestPaymentMessage.clear();
        self.declinePaymentRequestMessage.clear();
        self.cancelPaymentRequestMessage.clear();
        self.templateMessage.clear();
        self.stickerMessage.clear();
        self.groupInviteMessage.clear();
        self.templateButtonReplyMessage.clear();
        self.productMessage.clear();
        self.deviceSentMessage.clear();
        self.messageContextInfo.clear();
        self.listMessage.clear();
        self.viewOnceMessage.clear();
        self.orderMessage.clear();
        self.listResponseMessage.clear();
        self.ephemeralMessage.clear();
        self.invoiceMessage.clear();
        self.buttonsMessage.clear();
        self.buttonsResponseMessage.clear();
        self.paymentInviteMessage.clear();
        self.interactiveMessage.clear();
        self.reactionMessage.clear();
        self.stickerSyncRmrMessage.clear();
        self.interactiveResponseMessage.clear();
        self.pollCreationMessage.clear();
        self.pollUpdateMessage.clear();
        self.keepInChatMessage.clear();
        self.documentWithCaptionMessage.clear();
        self.requestPhoneNumberMessage.clear();
        self.viewOnceMessageV2.clear();
        self.encReactionMessage.clear();
        self.editedMessage.clear();
        self.viewOnceMessageV2Extension.clear();
        self.pollCreationMessageV2.clear();
        self.scheduledCallCreationMessage.clear();
        self.groupMentionedMessage.clear();
        self.pinMessage.clear();
        self.pollCreationMessageV3.clear();
        self.scheduledCallEditMessage.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            conversation: ::std::option::Option::None,
            senderKeyDistributionMessage: ::protobuf::MessageField::none(),
            imageMessage: ::protobuf::MessageField::none(),
            contactMessage: ::protobuf::MessageField::none(),
            locationMessage: ::protobuf::MessageField::none(),
            extendedTextMessage: ::protobuf::MessageField::none(),
            documentMessage: ::protobuf::MessageField::none(),
            audioMessage: ::protobuf::MessageField::none(),
            videoMessage: ::protobuf::MessageField::none(),
            call: ::protobuf::MessageField::none(),
            chat: ::protobuf::MessageField::none(),
            protocolMessage: ::protobuf::MessageField::none(),
            contactsArrayMessage: ::protobuf::MessageField::none(),
            highlyStructuredMessage: ::protobuf::MessageField::none(),
            fastRatchetKeySenderKeyDistributionMessage: ::protobuf::MessageField::none(),
            sendPaymentMessage: ::protobuf::MessageField::none(),
            liveLocationMessage: ::protobuf::MessageField::none(),
            requestPaymentMessage: ::protobuf::MessageField::none(),
            declinePaymentRequestMessage: ::protobuf::MessageField::none(),
            cancelPaymentRequestMessage: ::protobuf::MessageField::none(),
            templateMessage: ::protobuf::MessageField::none(),
            stickerMessage: ::protobuf::MessageField::none(),
            groupInviteMessage: ::protobuf::MessageField::none(),
            templateButtonReplyMessage: ::protobuf::MessageField::none(),
            productMessage: ::protobuf::MessageField::none(),
            deviceSentMessage: ::protobuf::MessageField::none(),
            messageContextInfo: ::protobuf::MessageField::none(),
            listMessage: ::protobuf::MessageField::none(),
            viewOnceMessage: ::protobuf::MessageField::none(),
            orderMessage: ::protobuf::MessageField::none(),
            listResponseMessage: ::protobuf::MessageField::none(),
            ephemeralMessage: ::protobuf::MessageField::none(),
            invoiceMessage: ::protobuf::MessageField::none(),
            buttonsMessage: ::protobuf::MessageField::none(),
            buttonsResponseMessage: ::protobuf::MessageField::none(),
            paymentInviteMessage: ::protobuf::MessageField::none(),
            interactiveMessage: ::protobuf::MessageField::none(),
            reactionMessage: ::protobuf::MessageField::none(),
            stickerSyncRmrMessage: ::protobuf::MessageField::none(),
            interactiveResponseMessage: ::protobuf::MessageField::none(),
            pollCreationMessage: ::protobuf::MessageField::none(),
            pollUpdateMessage: ::protobuf::MessageField::none(),
            keepInChatMessage: ::protobuf::MessageField::none(),
            documentWithCaptionMessage: ::protobuf::MessageField::none(),
            requestPhoneNumberMessage: ::protobuf::MessageField::none(),
            viewOnceMessageV2: ::protobuf::MessageField::none(),
            encReactionMessage: ::protobuf::MessageField::none(),
            editedMessage: ::protobuf::MessageField::none(),
            viewOnceMessageV2Extension: ::protobuf::MessageField::none(),
            pollCreationMessageV2: ::protobuf::MessageField::none(),
            scheduledCallCreationMessage: ::protobuf::MessageField::none(),
            groupMentionedMessage: ::protobuf::MessageField::none(),
            pinMessage: ::protobuf::MessageField::none(),
            pollCreationMessageV3: ::protobuf::MessageField::none(),
            scheduledCallEditMessage: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.MessageContextInfo)
pub struct MessageContextInfo {
    // message fields
    // @@protoc_insertion_point(field:proto.MessageContextInfo.deviceListMetadata)
    pub deviceListMetadata: ::protobuf::MessageField<DeviceListMetadata>,
    // @@protoc_insertion_point(field:proto.MessageContextInfo.deviceListMetadataVersion)
    pub deviceListMetadataVersion: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.MessageContextInfo.messageSecret)
    pub messageSecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.MessageContextInfo.paddingBytes)
    pub paddingBytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.MessageContextInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageContextInfo {
    fn default() -> &'a MessageContextInfo {
        <MessageContextInfo as ::protobuf::Message>::default_instance()
    }
}

impl MessageContextInfo {
    pub fn new() -> MessageContextInfo {
        ::std::default::Default::default()
    }

    // optional int32 deviceListMetadataVersion = 2;

    pub fn deviceListMetadataVersion(&self) -> i32 {
        self.deviceListMetadataVersion.unwrap_or(0)
    }

    pub fn clear_deviceListMetadataVersion(&mut self) {
        self.deviceListMetadataVersion = ::std::option::Option::None;
    }

    pub fn has_deviceListMetadataVersion(&self) -> bool {
        self.deviceListMetadataVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceListMetadataVersion(&mut self, v: i32) {
        self.deviceListMetadataVersion = ::std::option::Option::Some(v);
    }

    // optional bytes messageSecret = 3;

    pub fn messageSecret(&self) -> &[u8] {
        match self.messageSecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_messageSecret(&mut self) {
        self.messageSecret = ::std::option::Option::None;
    }

    pub fn has_messageSecret(&self) -> bool {
        self.messageSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageSecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.messageSecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageSecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.messageSecret.is_none() {
            self.messageSecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.messageSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageSecret(&mut self) -> ::std::vec::Vec<u8> {
        self.messageSecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes paddingBytes = 4;

    pub fn paddingBytes(&self) -> &[u8] {
        match self.paddingBytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_paddingBytes(&mut self) {
        self.paddingBytes = ::std::option::Option::None;
    }

    pub fn has_paddingBytes(&self) -> bool {
        self.paddingBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paddingBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.paddingBytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paddingBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.paddingBytes.is_none() {
            self.paddingBytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.paddingBytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_paddingBytes(&mut self) -> ::std::vec::Vec<u8> {
        self.paddingBytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceListMetadata>(
            "deviceListMetadata",
            |m: &MessageContextInfo| { &m.deviceListMetadata },
            |m: &mut MessageContextInfo| { &mut m.deviceListMetadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceListMetadataVersion",
            |m: &MessageContextInfo| { &m.deviceListMetadataVersion },
            |m: &mut MessageContextInfo| { &mut m.deviceListMetadataVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageSecret",
            |m: &MessageContextInfo| { &m.messageSecret },
            |m: &mut MessageContextInfo| { &mut m.messageSecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paddingBytes",
            |m: &MessageContextInfo| { &m.paddingBytes },
            |m: &mut MessageContextInfo| { &mut m.paddingBytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageContextInfo>(
            "MessageContextInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageContextInfo {
    const NAME: &'static str = "MessageContextInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deviceListMetadata)?;
                },
                16 => {
                    self.deviceListMetadataVersion = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.messageSecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.paddingBytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deviceListMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deviceListMetadataVersion {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.messageSecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.paddingBytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deviceListMetadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.deviceListMetadataVersion {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.messageSecret.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.paddingBytes.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageContextInfo {
        MessageContextInfo::new()
    }

    fn clear(&mut self) {
        self.deviceListMetadata.clear();
        self.deviceListMetadataVersion = ::std::option::Option::None;
        self.messageSecret = ::std::option::Option::None;
        self.paddingBytes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageContextInfo {
        static instance: MessageContextInfo = MessageContextInfo {
            deviceListMetadata: ::protobuf::MessageField::none(),
            deviceListMetadataVersion: ::std::option::Option::None,
            messageSecret: ::std::option::Option::None,
            paddingBytes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageContextInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageContextInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageContextInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageContextInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.VideoMessage)
pub struct VideoMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.VideoMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.VideoMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.VideoMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VideoMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.VideoMessage.seconds)
    pub seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.VideoMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VideoMessage.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.VideoMessage.gifPlayback)
    pub gifPlayback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.VideoMessage.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.VideoMessage.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.VideoMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VideoMessage.interactiveAnnotations)
    pub interactiveAnnotations: ::std::vec::Vec<InteractiveAnnotation>,
    // @@protoc_insertion_point(field:proto.VideoMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.VideoMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.VideoMessage.jpegThumbnail)
    pub jpegThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VideoMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.VideoMessage.streamingSidecar)
    pub streamingSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VideoMessage.gifAttribution)
    pub gifAttribution: ::std::option::Option<::protobuf::EnumOrUnknown<video_message::Attribution>>,
    // @@protoc_insertion_point(field:proto.VideoMessage.viewOnce)
    pub viewOnce: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.VideoMessage.thumbnailDirectPath)
    pub thumbnailDirectPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.VideoMessage.thumbnailSha256)
    pub thumbnailSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VideoMessage.thumbnailEncSha256)
    pub thumbnailEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VideoMessage.staticUrl)
    pub staticUrl: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.VideoMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VideoMessage {
    fn default() -> &'a VideoMessage {
        <VideoMessage as ::protobuf::Message>::default_instance()
    }
}

impl VideoMessage {
    pub fn new() -> VideoMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mimetype = 2;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 3;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 fileLength = 4;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds = 5;

    pub fn seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional bytes mediaKey = 6;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string caption = 7;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool gifPlayback = 8;

    pub fn gifPlayback(&self) -> bool {
        self.gifPlayback.unwrap_or(false)
    }

    pub fn clear_gifPlayback(&mut self) {
        self.gifPlayback = ::std::option::Option::None;
    }

    pub fn has_gifPlayback(&self) -> bool {
        self.gifPlayback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifPlayback(&mut self, v: bool) {
        self.gifPlayback = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 9;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 10;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional bytes fileEncSha256 = 11;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 13;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 mediaKeyTimestamp = 14;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes jpegThumbnail = 16;

    pub fn jpegThumbnail(&self) -> &[u8] {
        match self.jpegThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_jpegThumbnail(&mut self) {
        self.jpegThumbnail = ::std::option::Option::None;
    }

    pub fn has_jpegThumbnail(&self) -> bool {
        self.jpegThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jpegThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.jpegThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jpegThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.jpegThumbnail.is_none() {
            self.jpegThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.jpegThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_jpegThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.jpegThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes streamingSidecar = 18;

    pub fn streamingSidecar(&self) -> &[u8] {
        match self.streamingSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_streamingSidecar(&mut self) {
        self.streamingSidecar = ::std::option::Option::None;
    }

    pub fn has_streamingSidecar(&self) -> bool {
        self.streamingSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streamingSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.streamingSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streamingSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.streamingSidecar.is_none() {
            self.streamingSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.streamingSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_streamingSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.streamingSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .proto.VideoMessage.Attribution gifAttribution = 19;

    pub fn gifAttribution(&self) -> video_message::Attribution {
        match self.gifAttribution {
            Some(e) => e.enum_value_or(video_message::Attribution::NONE),
            None => video_message::Attribution::NONE,
        }
    }

    pub fn clear_gifAttribution(&mut self) {
        self.gifAttribution = ::std::option::Option::None;
    }

    pub fn has_gifAttribution(&self) -> bool {
        self.gifAttribution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifAttribution(&mut self, v: video_message::Attribution) {
        self.gifAttribution = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool viewOnce = 20;

    pub fn viewOnce(&self) -> bool {
        self.viewOnce.unwrap_or(false)
    }

    pub fn clear_viewOnce(&mut self) {
        self.viewOnce = ::std::option::Option::None;
    }

    pub fn has_viewOnce(&self) -> bool {
        self.viewOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewOnce(&mut self, v: bool) {
        self.viewOnce = ::std::option::Option::Some(v);
    }

    // optional string thumbnailDirectPath = 21;

    pub fn thumbnailDirectPath(&self) -> &str {
        match self.thumbnailDirectPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnailDirectPath(&mut self) {
        self.thumbnailDirectPath = ::std::option::Option::None;
    }

    pub fn has_thumbnailDirectPath(&self) -> bool {
        self.thumbnailDirectPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailDirectPath(&mut self, v: ::std::string::String) {
        self.thumbnailDirectPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailDirectPath(&mut self) -> &mut ::std::string::String {
        if self.thumbnailDirectPath.is_none() {
            self.thumbnailDirectPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnailDirectPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailDirectPath(&mut self) -> ::std::string::String {
        self.thumbnailDirectPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes thumbnailSha256 = 22;

    pub fn thumbnailSha256(&self) -> &[u8] {
        match self.thumbnailSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailSha256(&mut self) {
        self.thumbnailSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailSha256(&self) -> bool {
        self.thumbnailSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailSha256.is_none() {
            self.thumbnailSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes thumbnailEncSha256 = 23;

    pub fn thumbnailEncSha256(&self) -> &[u8] {
        match self.thumbnailEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_thumbnailEncSha256(&mut self) {
        self.thumbnailEncSha256 = ::std::option::Option::None;
    }

    pub fn has_thumbnailEncSha256(&self) -> bool {
        self.thumbnailEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnailEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.thumbnailEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnailEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.thumbnailEncSha256.is_none() {
            self.thumbnailEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.thumbnailEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnailEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.thumbnailEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string staticUrl = 24;

    pub fn staticUrl(&self) -> &str {
        match self.staticUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_staticUrl(&mut self) {
        self.staticUrl = ::std::option::Option::None;
    }

    pub fn has_staticUrl(&self) -> bool {
        self.staticUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staticUrl(&mut self, v: ::std::string::String) {
        self.staticUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_staticUrl(&mut self) -> &mut ::std::string::String {
        if self.staticUrl.is_none() {
            self.staticUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.staticUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_staticUrl(&mut self) -> ::std::string::String {
        self.staticUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &VideoMessage| { &m.url },
            |m: &mut VideoMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &VideoMessage| { &m.mimetype },
            |m: &mut VideoMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &VideoMessage| { &m.fileSha256 },
            |m: &mut VideoMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &VideoMessage| { &m.fileLength },
            |m: &mut VideoMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &VideoMessage| { &m.seconds },
            |m: &mut VideoMessage| { &mut m.seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &VideoMessage| { &m.mediaKey },
            |m: &mut VideoMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &VideoMessage| { &m.caption },
            |m: &mut VideoMessage| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifPlayback",
            |m: &VideoMessage| { &m.gifPlayback },
            |m: &mut VideoMessage| { &mut m.gifPlayback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &VideoMessage| { &m.height },
            |m: &mut VideoMessage| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &VideoMessage| { &m.width },
            |m: &mut VideoMessage| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &VideoMessage| { &m.fileEncSha256 },
            |m: &mut VideoMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "interactiveAnnotations",
            |m: &VideoMessage| { &m.interactiveAnnotations },
            |m: &mut VideoMessage| { &mut m.interactiveAnnotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &VideoMessage| { &m.directPath },
            |m: &mut VideoMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &VideoMessage| { &m.mediaKeyTimestamp },
            |m: &mut VideoMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jpegThumbnail",
            |m: &VideoMessage| { &m.jpegThumbnail },
            |m: &mut VideoMessage| { &mut m.jpegThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &VideoMessage| { &m.contextInfo },
            |m: &mut VideoMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "streamingSidecar",
            |m: &VideoMessage| { &m.streamingSidecar },
            |m: &mut VideoMessage| { &mut m.streamingSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gifAttribution",
            |m: &VideoMessage| { &m.gifAttribution },
            |m: &mut VideoMessage| { &mut m.gifAttribution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewOnce",
            |m: &VideoMessage| { &m.viewOnce },
            |m: &mut VideoMessage| { &mut m.viewOnce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailDirectPath",
            |m: &VideoMessage| { &m.thumbnailDirectPath },
            |m: &mut VideoMessage| { &mut m.thumbnailDirectPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailSha256",
            |m: &VideoMessage| { &m.thumbnailSha256 },
            |m: &mut VideoMessage| { &mut m.thumbnailSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnailEncSha256",
            |m: &VideoMessage| { &m.thumbnailEncSha256 },
            |m: &mut VideoMessage| { &mut m.thumbnailEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "staticUrl",
            |m: &VideoMessage| { &m.staticUrl },
            |m: &mut VideoMessage| { &mut m.staticUrl },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VideoMessage>(
            "VideoMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VideoMessage {
    const NAME: &'static str = "VideoMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                58 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.gifPlayback = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                98 => {
                    self.interactiveAnnotations.push(is.read_message()?);
                },
                106 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                130 => {
                    self.jpegThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                146 => {
                    self.streamingSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                152 => {
                    self.gifAttribution = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.viewOnce = ::std::option::Option::Some(is.read_bool()?);
                },
                170 => {
                    self.thumbnailDirectPath = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.thumbnailSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                186 => {
                    self.thumbnailEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                194 => {
                    self.staticUrl = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.gifPlayback {
            my_size += 1 + 1;
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        for value in &self.interactiveAnnotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(14, v);
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.streamingSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(18, &v);
        }
        if let Some(v) = self.gifAttribution {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.viewOnce {
            my_size += 2 + 1;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(22, &v);
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(23, &v);
        }
        if let Some(v) = self.staticUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.gifPlayback {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(11, v)?;
        }
        for v in &self.interactiveAnnotations {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.jpegThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.streamingSidecar.as_ref() {
            os.write_bytes(18, v)?;
        }
        if let Some(v) = self.gifAttribution {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.viewOnce {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.thumbnailDirectPath.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.thumbnailSha256.as_ref() {
            os.write_bytes(22, v)?;
        }
        if let Some(v) = self.thumbnailEncSha256.as_ref() {
            os.write_bytes(23, v)?;
        }
        if let Some(v) = self.staticUrl.as_ref() {
            os.write_string(24, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VideoMessage {
        VideoMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.gifPlayback = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.interactiveAnnotations.clear();
        self.directPath = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.jpegThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.streamingSidecar = ::std::option::Option::None;
        self.gifAttribution = ::std::option::Option::None;
        self.viewOnce = ::std::option::Option::None;
        self.thumbnailDirectPath = ::std::option::Option::None;
        self.thumbnailSha256 = ::std::option::Option::None;
        self.thumbnailEncSha256 = ::std::option::Option::None;
        self.staticUrl = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VideoMessage {
        static instance: VideoMessage = VideoMessage {
            url: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            seconds: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            gifPlayback: ::std::option::Option::None,
            height: ::std::option::Option::None,
            width: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            interactiveAnnotations: ::std::vec::Vec::new(),
            directPath: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            jpegThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            streamingSidecar: ::std::option::Option::None,
            gifAttribution: ::std::option::Option::None,
            viewOnce: ::std::option::Option::None,
            thumbnailDirectPath: ::std::option::Option::None,
            thumbnailSha256: ::std::option::Option::None,
            thumbnailEncSha256: ::std::option::Option::None,
            staticUrl: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VideoMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VideoMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VideoMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VideoMessage`
pub mod video_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.VideoMessage.Attribution)
    pub enum Attribution {
        // @@protoc_insertion_point(enum_value:proto.VideoMessage.Attribution.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:proto.VideoMessage.Attribution.GIPHY)
        GIPHY = 1,
        // @@protoc_insertion_point(enum_value:proto.VideoMessage.Attribution.TENOR)
        TENOR = 2,
    }

    impl ::protobuf::Enum for Attribution {
        const NAME: &'static str = "Attribution";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Attribution> {
            match value {
                0 => ::std::option::Option::Some(Attribution::NONE),
                1 => ::std::option::Option::Some(Attribution::GIPHY),
                2 => ::std::option::Option::Some(Attribution::TENOR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Attribution] = &[
            Attribution::NONE,
            Attribution::GIPHY,
            Attribution::TENOR,
        ];
    }

    impl ::protobuf::EnumFull for Attribution {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("VideoMessage.Attribution").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Attribution {
        fn default() -> Self {
            Attribution::NONE
        }
    }

    impl Attribution {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Attribution>("VideoMessage.Attribution")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.TemplateMessage)
pub struct TemplateMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.TemplateMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.TemplateMessage.hydratedTemplate)
    pub hydratedTemplate: ::protobuf::MessageField<template_message::HydratedFourRowTemplate>,
    // @@protoc_insertion_point(field:proto.TemplateMessage.templateId)
    pub templateId: ::std::option::Option<::std::string::String>,
    // message oneof groups
    pub format: ::std::option::Option<template_message::Format>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.TemplateMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TemplateMessage {
    fn default() -> &'a TemplateMessage {
        <TemplateMessage as ::protobuf::Message>::default_instance()
    }
}

impl TemplateMessage {
    pub fn new() -> TemplateMessage {
        ::std::default::Default::default()
    }

    // optional string templateId = 9;

    pub fn templateId(&self) -> &str {
        match self.templateId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_templateId(&mut self) {
        self.templateId = ::std::option::Option::None;
    }

    pub fn has_templateId(&self) -> bool {
        self.templateId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_templateId(&mut self, v: ::std::string::String) {
        self.templateId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_templateId(&mut self) -> &mut ::std::string::String {
        if self.templateId.is_none() {
            self.templateId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.templateId.as_mut().unwrap()
    }

    // Take field
    pub fn take_templateId(&mut self) -> ::std::string::String {
        self.templateId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.TemplateMessage.FourRowTemplate fourRowTemplate = 1;

    pub fn fourRowTemplate(&self) -> &template_message::FourRowTemplate {
        match self.format {
            ::std::option::Option::Some(template_message::Format::FourRowTemplate(ref v)) => v,
            _ => <template_message::FourRowTemplate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fourRowTemplate(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_fourRowTemplate(&self) -> bool {
        match self.format {
            ::std::option::Option::Some(template_message::Format::FourRowTemplate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fourRowTemplate(&mut self, v: template_message::FourRowTemplate) {
        self.format = ::std::option::Option::Some(template_message::Format::FourRowTemplate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fourRowTemplate(&mut self) -> &mut template_message::FourRowTemplate {
        if let ::std::option::Option::Some(template_message::Format::FourRowTemplate(_)) = self.format {
        } else {
            self.format = ::std::option::Option::Some(template_message::Format::FourRowTemplate(template_message::FourRowTemplate::new()));
        }
        match self.format {
            ::std::option::Option::Some(template_message::Format::FourRowTemplate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fourRowTemplate(&mut self) -> template_message::FourRowTemplate {
        if self.has_fourRowTemplate() {
            match self.format.take() {
                ::std::option::Option::Some(template_message::Format::FourRowTemplate(v)) => v,
                _ => panic!(),
            }
        } else {
            template_message::FourRowTemplate::new()
        }
    }

    // optional .proto.TemplateMessage.HydratedFourRowTemplate hydratedFourRowTemplate = 2;

    pub fn hydratedFourRowTemplate(&self) -> &template_message::HydratedFourRowTemplate {
        match self.format {
            ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(ref v)) => v,
            _ => <template_message::HydratedFourRowTemplate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_hydratedFourRowTemplate(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_hydratedFourRowTemplate(&self) -> bool {
        match self.format {
            ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hydratedFourRowTemplate(&mut self, v: template_message::HydratedFourRowTemplate) {
        self.format = ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hydratedFourRowTemplate(&mut self) -> &mut template_message::HydratedFourRowTemplate {
        if let ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(_)) = self.format {
        } else {
            self.format = ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(template_message::HydratedFourRowTemplate::new()));
        }
        match self.format {
            ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hydratedFourRowTemplate(&mut self) -> template_message::HydratedFourRowTemplate {
        if self.has_hydratedFourRowTemplate() {
            match self.format.take() {
                ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(v)) => v,
                _ => panic!(),
            }
        } else {
            template_message::HydratedFourRowTemplate::new()
        }
    }

    // optional .proto.InteractiveMessage interactiveMessageTemplate = 5;

    pub fn interactiveMessageTemplate(&self) -> &InteractiveMessage {
        match self.format {
            ::std::option::Option::Some(template_message::Format::InteractiveMessageTemplate(ref v)) => v,
            _ => <InteractiveMessage as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_interactiveMessageTemplate(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_interactiveMessageTemplate(&self) -> bool {
        match self.format {
            ::std::option::Option::Some(template_message::Format::InteractiveMessageTemplate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_interactiveMessageTemplate(&mut self, v: InteractiveMessage) {
        self.format = ::std::option::Option::Some(template_message::Format::InteractiveMessageTemplate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_interactiveMessageTemplate(&mut self) -> &mut InteractiveMessage {
        if let ::std::option::Option::Some(template_message::Format::InteractiveMessageTemplate(_)) = self.format {
        } else {
            self.format = ::std::option::Option::Some(template_message::Format::InteractiveMessageTemplate(InteractiveMessage::new()));
        }
        match self.format {
            ::std::option::Option::Some(template_message::Format::InteractiveMessageTemplate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_interactiveMessageTemplate(&mut self) -> InteractiveMessage {
        if self.has_interactiveMessageTemplate() {
            match self.format.take() {
                ::std::option::Option::Some(template_message::Format::InteractiveMessageTemplate(v)) => v,
                _ => panic!(),
            }
        } else {
            InteractiveMessage::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &TemplateMessage| { &m.contextInfo },
            |m: &mut TemplateMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, template_message::HydratedFourRowTemplate>(
            "hydratedTemplate",
            |m: &TemplateMessage| { &m.hydratedTemplate },
            |m: &mut TemplateMessage| { &mut m.hydratedTemplate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "templateId",
            |m: &TemplateMessage| { &m.templateId },
            |m: &mut TemplateMessage| { &mut m.templateId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, template_message::FourRowTemplate>(
            "fourRowTemplate",
            TemplateMessage::has_fourRowTemplate,
            TemplateMessage::fourRowTemplate,
            TemplateMessage::mut_fourRowTemplate,
            TemplateMessage::set_fourRowTemplate,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, template_message::HydratedFourRowTemplate>(
            "hydratedFourRowTemplate",
            TemplateMessage::has_hydratedFourRowTemplate,
            TemplateMessage::hydratedFourRowTemplate,
            TemplateMessage::mut_hydratedFourRowTemplate,
            TemplateMessage::set_hydratedFourRowTemplate,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, InteractiveMessage>(
            "interactiveMessageTemplate",
            TemplateMessage::has_interactiveMessageTemplate,
            TemplateMessage::interactiveMessageTemplate,
            TemplateMessage::mut_interactiveMessageTemplate,
            TemplateMessage::set_interactiveMessageTemplate,
        ));
        oneofs.push(template_message::Format::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TemplateMessage>(
            "TemplateMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TemplateMessage {
    const NAME: &'static str = "TemplateMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.hydratedTemplate)?;
                },
                74 => {
                    self.templateId = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    self.format = ::std::option::Option::Some(template_message::Format::FourRowTemplate(is.read_message()?));
                },
                18 => {
                    self.format = ::std::option::Option::Some(template_message::Format::HydratedFourRowTemplate(is.read_message()?));
                },
                42 => {
                    self.format = ::std::option::Option::Some(template_message::Format::InteractiveMessageTemplate(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hydratedTemplate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.templateId.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let ::std::option::Option::Some(ref v) = self.format {
            match v {
                &template_message::Format::FourRowTemplate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &template_message::Format::HydratedFourRowTemplate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &template_message::Format::InteractiveMessageTemplate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.hydratedTemplate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.templateId.as_ref() {
            os.write_string(9, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.format {
            match v {
                &template_message::Format::FourRowTemplate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &template_message::Format::HydratedFourRowTemplate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &template_message::Format::InteractiveMessageTemplate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TemplateMessage {
        TemplateMessage::new()
    }

    fn clear(&mut self) {
        self.contextInfo.clear();
        self.hydratedTemplate.clear();
        self.templateId = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TemplateMessage {
        static instance: TemplateMessage = TemplateMessage {
            contextInfo: ::protobuf::MessageField::none(),
            hydratedTemplate: ::protobuf::MessageField::none(),
            templateId: ::std::option::Option::None,
            format: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TemplateMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TemplateMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TemplateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TemplateMessage`
pub mod template_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:proto.TemplateMessage.format)
    pub enum Format {
        // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.fourRowTemplate)
        FourRowTemplate(FourRowTemplate),
        // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.hydratedFourRowTemplate)
        HydratedFourRowTemplate(HydratedFourRowTemplate),
        // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.interactiveMessageTemplate)
        InteractiveMessageTemplate(super::InteractiveMessage),
    }

    impl ::protobuf::Oneof for Format {
    }

    impl ::protobuf::OneofFull for Format {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TemplateMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("format").unwrap()).clone()
        }
    }

    impl Format {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Format>("format")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.TemplateMessage.HydratedFourRowTemplate)
    pub struct HydratedFourRowTemplate {
        // message fields
        // @@protoc_insertion_point(field:proto.TemplateMessage.HydratedFourRowTemplate.hydratedContentText)
        pub hydratedContentText: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.TemplateMessage.HydratedFourRowTemplate.hydratedFooterText)
        pub hydratedFooterText: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.TemplateMessage.HydratedFourRowTemplate.hydratedButtons)
        pub hydratedButtons: ::std::vec::Vec<super::HydratedTemplateButton>,
        // @@protoc_insertion_point(field:proto.TemplateMessage.HydratedFourRowTemplate.templateId)
        pub templateId: ::std::option::Option<::std::string::String>,
        // message oneof groups
        pub title: ::std::option::Option<hydrated_four_row_template::Title>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.TemplateMessage.HydratedFourRowTemplate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HydratedFourRowTemplate {
        fn default() -> &'a HydratedFourRowTemplate {
            <HydratedFourRowTemplate as ::protobuf::Message>::default_instance()
        }
    }

    impl HydratedFourRowTemplate {
        pub fn new() -> HydratedFourRowTemplate {
            ::std::default::Default::default()
        }

        // optional string hydratedContentText = 6;

        pub fn hydratedContentText(&self) -> &str {
            match self.hydratedContentText.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hydratedContentText(&mut self) {
            self.hydratedContentText = ::std::option::Option::None;
        }

        pub fn has_hydratedContentText(&self) -> bool {
            self.hydratedContentText.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hydratedContentText(&mut self, v: ::std::string::String) {
            self.hydratedContentText = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hydratedContentText(&mut self) -> &mut ::std::string::String {
            if self.hydratedContentText.is_none() {
                self.hydratedContentText = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hydratedContentText.as_mut().unwrap()
        }

        // Take field
        pub fn take_hydratedContentText(&mut self) -> ::std::string::String {
            self.hydratedContentText.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string hydratedFooterText = 7;

        pub fn hydratedFooterText(&self) -> &str {
            match self.hydratedFooterText.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hydratedFooterText(&mut self) {
            self.hydratedFooterText = ::std::option::Option::None;
        }

        pub fn has_hydratedFooterText(&self) -> bool {
            self.hydratedFooterText.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hydratedFooterText(&mut self, v: ::std::string::String) {
            self.hydratedFooterText = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hydratedFooterText(&mut self) -> &mut ::std::string::String {
            if self.hydratedFooterText.is_none() {
                self.hydratedFooterText = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hydratedFooterText.as_mut().unwrap()
        }

        // Take field
        pub fn take_hydratedFooterText(&mut self) -> ::std::string::String {
            self.hydratedFooterText.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string templateId = 9;

        pub fn templateId(&self) -> &str {
            match self.templateId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_templateId(&mut self) {
            self.templateId = ::std::option::Option::None;
        }

        pub fn has_templateId(&self) -> bool {
            self.templateId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_templateId(&mut self, v: ::std::string::String) {
            self.templateId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_templateId(&mut self) -> &mut ::std::string::String {
            if self.templateId.is_none() {
                self.templateId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.templateId.as_mut().unwrap()
        }

        // Take field
        pub fn take_templateId(&mut self) -> ::std::string::String {
            self.templateId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .proto.DocumentMessage documentMessage = 1;

        pub fn documentMessage(&self) -> &super::DocumentMessage {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(ref v)) => v,
                _ => <super::DocumentMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_documentMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_documentMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_documentMessage(&mut self, v: super::DocumentMessage) {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_documentMessage(&mut self) -> &mut super::DocumentMessage {
            if let ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(super::DocumentMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_documentMessage(&mut self) -> super::DocumentMessage {
            if self.has_documentMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::DocumentMessage::new()
            }
        }

        // optional string hydratedTitleText = 2;

        pub fn hydratedTitleText(&self) -> &str {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_hydratedTitleText(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_hydratedTitleText(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_hydratedTitleText(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(v))
        }

        // Mutable pointer to the field.
        pub fn mut_hydratedTitleText(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(::std::string::String::new()));
            }
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_hydratedTitleText(&mut self) -> ::std::string::String {
            if self.has_hydratedTitleText() {
                match self.title.take() {
                    ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // optional .proto.ImageMessage imageMessage = 3;

        pub fn imageMessage(&self) -> &super::ImageMessage {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(ref v)) => v,
                _ => <super::ImageMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_imageMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_imageMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_imageMessage(&mut self, v: super::ImageMessage) {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_imageMessage(&mut self) -> &mut super::ImageMessage {
            if let ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(super::ImageMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_imageMessage(&mut self) -> super::ImageMessage {
            if self.has_imageMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::ImageMessage::new()
            }
        }

        // optional .proto.VideoMessage videoMessage = 4;

        pub fn videoMessage(&self) -> &super::VideoMessage {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(ref v)) => v,
                _ => <super::VideoMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_videoMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_videoMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_videoMessage(&mut self, v: super::VideoMessage) {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_videoMessage(&mut self) -> &mut super::VideoMessage {
            if let ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(super::VideoMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_videoMessage(&mut self) -> super::VideoMessage {
            if self.has_videoMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::VideoMessage::new()
            }
        }

        // optional .proto.LocationMessage locationMessage = 5;

        pub fn locationMessage(&self) -> &super::LocationMessage {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(ref v)) => v,
                _ => <super::LocationMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_locationMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_locationMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_locationMessage(&mut self, v: super::LocationMessage) {
            self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_locationMessage(&mut self) -> &mut super::LocationMessage {
            if let ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(super::LocationMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_locationMessage(&mut self) -> super::LocationMessage {
            if self.has_locationMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::LocationMessage::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hydratedContentText",
                |m: &HydratedFourRowTemplate| { &m.hydratedContentText },
                |m: &mut HydratedFourRowTemplate| { &mut m.hydratedContentText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hydratedFooterText",
                |m: &HydratedFourRowTemplate| { &m.hydratedFooterText },
                |m: &mut HydratedFourRowTemplate| { &mut m.hydratedFooterText },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hydratedButtons",
                |m: &HydratedFourRowTemplate| { &m.hydratedButtons },
                |m: &mut HydratedFourRowTemplate| { &mut m.hydratedButtons },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "templateId",
                |m: &HydratedFourRowTemplate| { &m.templateId },
                |m: &mut HydratedFourRowTemplate| { &mut m.templateId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::DocumentMessage>(
                "documentMessage",
                HydratedFourRowTemplate::has_documentMessage,
                HydratedFourRowTemplate::documentMessage,
                HydratedFourRowTemplate::mut_documentMessage,
                HydratedFourRowTemplate::set_documentMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                "hydratedTitleText",
                HydratedFourRowTemplate::has_hydratedTitleText,
                HydratedFourRowTemplate::hydratedTitleText,
                HydratedFourRowTemplate::set_hydratedTitleText,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::ImageMessage>(
                "imageMessage",
                HydratedFourRowTemplate::has_imageMessage,
                HydratedFourRowTemplate::imageMessage,
                HydratedFourRowTemplate::mut_imageMessage,
                HydratedFourRowTemplate::set_imageMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::VideoMessage>(
                "videoMessage",
                HydratedFourRowTemplate::has_videoMessage,
                HydratedFourRowTemplate::videoMessage,
                HydratedFourRowTemplate::mut_videoMessage,
                HydratedFourRowTemplate::set_videoMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LocationMessage>(
                "locationMessage",
                HydratedFourRowTemplate::has_locationMessage,
                HydratedFourRowTemplate::locationMessage,
                HydratedFourRowTemplate::mut_locationMessage,
                HydratedFourRowTemplate::set_locationMessage,
            ));
            oneofs.push(hydrated_four_row_template::Title::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HydratedFourRowTemplate>(
                "TemplateMessage.HydratedFourRowTemplate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HydratedFourRowTemplate {
        const NAME: &'static str = "HydratedFourRowTemplate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    50 => {
                        self.hydratedContentText = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.hydratedFooterText = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.hydratedButtons.push(is.read_message()?);
                    },
                    74 => {
                        self.templateId = ::std::option::Option::Some(is.read_string()?);
                    },
                    10 => {
                        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::DocumentMessage(is.read_message()?));
                    },
                    18 => {
                        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::HydratedTitleText(is.read_string()?));
                    },
                    26 => {
                        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::ImageMessage(is.read_message()?));
                    },
                    34 => {
                        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::VideoMessage(is.read_message()?));
                    },
                    42 => {
                        self.title = ::std::option::Option::Some(hydrated_four_row_template::Title::LocationMessage(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hydratedContentText.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.hydratedFooterText.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            for value in &self.hydratedButtons {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.templateId.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let ::std::option::Option::Some(ref v) = self.title {
                match v {
                    &hydrated_four_row_template::Title::DocumentMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &hydrated_four_row_template::Title::HydratedTitleText(ref v) => {
                        my_size += ::protobuf::rt::string_size(2, &v);
                    },
                    &hydrated_four_row_template::Title::ImageMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &hydrated_four_row_template::Title::VideoMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &hydrated_four_row_template::Title::LocationMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.hydratedContentText.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.hydratedFooterText.as_ref() {
                os.write_string(7, v)?;
            }
            for v in &self.hydratedButtons {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            if let Some(v) = self.templateId.as_ref() {
                os.write_string(9, v)?;
            }
            if let ::std::option::Option::Some(ref v) = self.title {
                match v {
                    &hydrated_four_row_template::Title::DocumentMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &hydrated_four_row_template::Title::HydratedTitleText(ref v) => {
                        os.write_string(2, v)?;
                    },
                    &hydrated_four_row_template::Title::ImageMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &hydrated_four_row_template::Title::VideoMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                    &hydrated_four_row_template::Title::LocationMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HydratedFourRowTemplate {
            HydratedFourRowTemplate::new()
        }

        fn clear(&mut self) {
            self.hydratedContentText = ::std::option::Option::None;
            self.hydratedFooterText = ::std::option::Option::None;
            self.hydratedButtons.clear();
            self.templateId = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HydratedFourRowTemplate {
            static instance: HydratedFourRowTemplate = HydratedFourRowTemplate {
                hydratedContentText: ::std::option::Option::None,
                hydratedFooterText: ::std::option::Option::None,
                hydratedButtons: ::std::vec::Vec::new(),
                templateId: ::std::option::Option::None,
                title: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HydratedFourRowTemplate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TemplateMessage.HydratedFourRowTemplate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HydratedFourRowTemplate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HydratedFourRowTemplate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `HydratedFourRowTemplate`
    pub mod hydrated_four_row_template {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:proto.TemplateMessage.HydratedFourRowTemplate.title)
        pub enum Title {
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.HydratedFourRowTemplate.documentMessage)
            DocumentMessage(super::super::DocumentMessage),
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.HydratedFourRowTemplate.hydratedTitleText)
            HydratedTitleText(::std::string::String),
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.HydratedFourRowTemplate.imageMessage)
            ImageMessage(super::super::ImageMessage),
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.HydratedFourRowTemplate.videoMessage)
            VideoMessage(super::super::VideoMessage),
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.HydratedFourRowTemplate.locationMessage)
            LocationMessage(super::super::LocationMessage),
        }

        impl ::protobuf::Oneof for Title {
        }

        impl ::protobuf::OneofFull for Title {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::HydratedFourRowTemplate as ::protobuf::MessageFull>::descriptor().oneof_by_name("title").unwrap()).clone()
            }
        }

        impl Title {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Title>("title")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.TemplateMessage.FourRowTemplate)
    pub struct FourRowTemplate {
        // message fields
        // @@protoc_insertion_point(field:proto.TemplateMessage.FourRowTemplate.content)
        pub content: ::protobuf::MessageField<super::HighlyStructuredMessage>,
        // @@protoc_insertion_point(field:proto.TemplateMessage.FourRowTemplate.footer)
        pub footer: ::protobuf::MessageField<super::HighlyStructuredMessage>,
        // @@protoc_insertion_point(field:proto.TemplateMessage.FourRowTemplate.buttons)
        pub buttons: ::std::vec::Vec<super::TemplateButton>,
        // message oneof groups
        pub title: ::std::option::Option<four_row_template::Title>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.TemplateMessage.FourRowTemplate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FourRowTemplate {
        fn default() -> &'a FourRowTemplate {
            <FourRowTemplate as ::protobuf::Message>::default_instance()
        }
    }

    impl FourRowTemplate {
        pub fn new() -> FourRowTemplate {
            ::std::default::Default::default()
        }

        // optional .proto.DocumentMessage documentMessage = 1;

        pub fn documentMessage(&self) -> &super::DocumentMessage {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::DocumentMessage(ref v)) => v,
                _ => <super::DocumentMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_documentMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_documentMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::DocumentMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_documentMessage(&mut self, v: super::DocumentMessage) {
            self.title = ::std::option::Option::Some(four_row_template::Title::DocumentMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_documentMessage(&mut self) -> &mut super::DocumentMessage {
            if let ::std::option::Option::Some(four_row_template::Title::DocumentMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(four_row_template::Title::DocumentMessage(super::DocumentMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::DocumentMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_documentMessage(&mut self) -> super::DocumentMessage {
            if self.has_documentMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(four_row_template::Title::DocumentMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::DocumentMessage::new()
            }
        }

        // optional .proto.HighlyStructuredMessage highlyStructuredMessage = 2;

        pub fn highlyStructuredMessage(&self) -> &super::HighlyStructuredMessage {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(ref v)) => v,
                _ => <super::HighlyStructuredMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_highlyStructuredMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_highlyStructuredMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_highlyStructuredMessage(&mut self, v: super::HighlyStructuredMessage) {
            self.title = ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_highlyStructuredMessage(&mut self) -> &mut super::HighlyStructuredMessage {
            if let ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(super::HighlyStructuredMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_highlyStructuredMessage(&mut self) -> super::HighlyStructuredMessage {
            if self.has_highlyStructuredMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::HighlyStructuredMessage::new()
            }
        }

        // optional .proto.ImageMessage imageMessage = 3;

        pub fn imageMessage(&self) -> &super::ImageMessage {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::ImageMessage(ref v)) => v,
                _ => <super::ImageMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_imageMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_imageMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::ImageMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_imageMessage(&mut self, v: super::ImageMessage) {
            self.title = ::std::option::Option::Some(four_row_template::Title::ImageMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_imageMessage(&mut self) -> &mut super::ImageMessage {
            if let ::std::option::Option::Some(four_row_template::Title::ImageMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(four_row_template::Title::ImageMessage(super::ImageMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::ImageMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_imageMessage(&mut self) -> super::ImageMessage {
            if self.has_imageMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(four_row_template::Title::ImageMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::ImageMessage::new()
            }
        }

        // optional .proto.VideoMessage videoMessage = 4;

        pub fn videoMessage(&self) -> &super::VideoMessage {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::VideoMessage(ref v)) => v,
                _ => <super::VideoMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_videoMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_videoMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::VideoMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_videoMessage(&mut self, v: super::VideoMessage) {
            self.title = ::std::option::Option::Some(four_row_template::Title::VideoMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_videoMessage(&mut self) -> &mut super::VideoMessage {
            if let ::std::option::Option::Some(four_row_template::Title::VideoMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(four_row_template::Title::VideoMessage(super::VideoMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::VideoMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_videoMessage(&mut self) -> super::VideoMessage {
            if self.has_videoMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(four_row_template::Title::VideoMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::VideoMessage::new()
            }
        }

        // optional .proto.LocationMessage locationMessage = 5;

        pub fn locationMessage(&self) -> &super::LocationMessage {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::LocationMessage(ref v)) => v,
                _ => <super::LocationMessage as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_locationMessage(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_locationMessage(&self) -> bool {
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::LocationMessage(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_locationMessage(&mut self, v: super::LocationMessage) {
            self.title = ::std::option::Option::Some(four_row_template::Title::LocationMessage(v))
        }

        // Mutable pointer to the field.
        pub fn mut_locationMessage(&mut self) -> &mut super::LocationMessage {
            if let ::std::option::Option::Some(four_row_template::Title::LocationMessage(_)) = self.title {
            } else {
                self.title = ::std::option::Option::Some(four_row_template::Title::LocationMessage(super::LocationMessage::new()));
            }
            match self.title {
                ::std::option::Option::Some(four_row_template::Title::LocationMessage(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_locationMessage(&mut self) -> super::LocationMessage {
            if self.has_locationMessage() {
                match self.title.take() {
                    ::std::option::Option::Some(four_row_template::Title::LocationMessage(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::LocationMessage::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::HighlyStructuredMessage>(
                "content",
                |m: &FourRowTemplate| { &m.content },
                |m: &mut FourRowTemplate| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::HighlyStructuredMessage>(
                "footer",
                |m: &FourRowTemplate| { &m.footer },
                |m: &mut FourRowTemplate| { &mut m.footer },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "buttons",
                |m: &FourRowTemplate| { &m.buttons },
                |m: &mut FourRowTemplate| { &mut m.buttons },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::DocumentMessage>(
                "documentMessage",
                FourRowTemplate::has_documentMessage,
                FourRowTemplate::documentMessage,
                FourRowTemplate::mut_documentMessage,
                FourRowTemplate::set_documentMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::HighlyStructuredMessage>(
                "highlyStructuredMessage",
                FourRowTemplate::has_highlyStructuredMessage,
                FourRowTemplate::highlyStructuredMessage,
                FourRowTemplate::mut_highlyStructuredMessage,
                FourRowTemplate::set_highlyStructuredMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::ImageMessage>(
                "imageMessage",
                FourRowTemplate::has_imageMessage,
                FourRowTemplate::imageMessage,
                FourRowTemplate::mut_imageMessage,
                FourRowTemplate::set_imageMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::VideoMessage>(
                "videoMessage",
                FourRowTemplate::has_videoMessage,
                FourRowTemplate::videoMessage,
                FourRowTemplate::mut_videoMessage,
                FourRowTemplate::set_videoMessage,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::LocationMessage>(
                "locationMessage",
                FourRowTemplate::has_locationMessage,
                FourRowTemplate::locationMessage,
                FourRowTemplate::mut_locationMessage,
                FourRowTemplate::set_locationMessage,
            ));
            oneofs.push(four_row_template::Title::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FourRowTemplate>(
                "TemplateMessage.FourRowTemplate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FourRowTemplate {
        const NAME: &'static str = "FourRowTemplate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.content)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.footer)?;
                    },
                    66 => {
                        self.buttons.push(is.read_message()?);
                    },
                    10 => {
                        self.title = ::std::option::Option::Some(four_row_template::Title::DocumentMessage(is.read_message()?));
                    },
                    18 => {
                        self.title = ::std::option::Option::Some(four_row_template::Title::HighlyStructuredMessage(is.read_message()?));
                    },
                    26 => {
                        self.title = ::std::option::Option::Some(four_row_template::Title::ImageMessage(is.read_message()?));
                    },
                    34 => {
                        self.title = ::std::option::Option::Some(four_row_template::Title::VideoMessage(is.read_message()?));
                    },
                    42 => {
                        self.title = ::std::option::Option::Some(four_row_template::Title::LocationMessage(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.content.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.footer.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.buttons {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let ::std::option::Option::Some(ref v) = self.title {
                match v {
                    &four_row_template::Title::DocumentMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &four_row_template::Title::HighlyStructuredMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &four_row_template::Title::ImageMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &four_row_template::Title::VideoMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &four_row_template::Title::LocationMessage(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.content.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.footer.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            for v in &self.buttons {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            if let ::std::option::Option::Some(ref v) = self.title {
                match v {
                    &four_row_template::Title::DocumentMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &four_row_template::Title::HighlyStructuredMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &four_row_template::Title::ImageMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &four_row_template::Title::VideoMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                    &four_row_template::Title::LocationMessage(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FourRowTemplate {
            FourRowTemplate::new()
        }

        fn clear(&mut self) {
            self.content.clear();
            self.footer.clear();
            self.buttons.clear();
            self.title = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FourRowTemplate {
            static instance: FourRowTemplate = FourRowTemplate {
                content: ::protobuf::MessageField::none(),
                footer: ::protobuf::MessageField::none(),
                buttons: ::std::vec::Vec::new(),
                title: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FourRowTemplate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TemplateMessage.FourRowTemplate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FourRowTemplate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FourRowTemplate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `FourRowTemplate`
    pub mod four_row_template {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:proto.TemplateMessage.FourRowTemplate.title)
        pub enum Title {
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.FourRowTemplate.documentMessage)
            DocumentMessage(super::super::DocumentMessage),
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.FourRowTemplate.highlyStructuredMessage)
            HighlyStructuredMessage(super::super::HighlyStructuredMessage),
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.FourRowTemplate.imageMessage)
            ImageMessage(super::super::ImageMessage),
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.FourRowTemplate.videoMessage)
            VideoMessage(super::super::VideoMessage),
            // @@protoc_insertion_point(oneof_field:proto.TemplateMessage.FourRowTemplate.locationMessage)
            LocationMessage(super::super::LocationMessage),
        }

        impl ::protobuf::Oneof for Title {
        }

        impl ::protobuf::OneofFull for Title {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::FourRowTemplate as ::protobuf::MessageFull>::descriptor().oneof_by_name("title").unwrap()).clone()
            }
        }

        impl Title {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Title>("title")
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.TemplateButtonReplyMessage)
pub struct TemplateButtonReplyMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.TemplateButtonReplyMessage.selectedId)
    pub selectedId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.TemplateButtonReplyMessage.selectedDisplayText)
    pub selectedDisplayText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.TemplateButtonReplyMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.TemplateButtonReplyMessage.selectedIndex)
    pub selectedIndex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.TemplateButtonReplyMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TemplateButtonReplyMessage {
    fn default() -> &'a TemplateButtonReplyMessage {
        <TemplateButtonReplyMessage as ::protobuf::Message>::default_instance()
    }
}

impl TemplateButtonReplyMessage {
    pub fn new() -> TemplateButtonReplyMessage {
        ::std::default::Default::default()
    }

    // optional string selectedId = 1;

    pub fn selectedId(&self) -> &str {
        match self.selectedId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selectedId(&mut self) {
        self.selectedId = ::std::option::Option::None;
    }

    pub fn has_selectedId(&self) -> bool {
        self.selectedId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedId(&mut self, v: ::std::string::String) {
        self.selectedId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedId(&mut self) -> &mut ::std::string::String {
        if self.selectedId.is_none() {
            self.selectedId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selectedId.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectedId(&mut self) -> ::std::string::String {
        self.selectedId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string selectedDisplayText = 2;

    pub fn selectedDisplayText(&self) -> &str {
        match self.selectedDisplayText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_selectedDisplayText(&mut self) {
        self.selectedDisplayText = ::std::option::Option::None;
    }

    pub fn has_selectedDisplayText(&self) -> bool {
        self.selectedDisplayText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedDisplayText(&mut self, v: ::std::string::String) {
        self.selectedDisplayText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectedDisplayText(&mut self) -> &mut ::std::string::String {
        if self.selectedDisplayText.is_none() {
            self.selectedDisplayText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.selectedDisplayText.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectedDisplayText(&mut self) -> ::std::string::String {
        self.selectedDisplayText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 selectedIndex = 4;

    pub fn selectedIndex(&self) -> u32 {
        self.selectedIndex.unwrap_or(0)
    }

    pub fn clear_selectedIndex(&mut self) {
        self.selectedIndex = ::std::option::Option::None;
    }

    pub fn has_selectedIndex(&self) -> bool {
        self.selectedIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectedIndex(&mut self, v: u32) {
        self.selectedIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedId",
            |m: &TemplateButtonReplyMessage| { &m.selectedId },
            |m: &mut TemplateButtonReplyMessage| { &mut m.selectedId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedDisplayText",
            |m: &TemplateButtonReplyMessage| { &m.selectedDisplayText },
            |m: &mut TemplateButtonReplyMessage| { &mut m.selectedDisplayText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &TemplateButtonReplyMessage| { &m.contextInfo },
            |m: &mut TemplateButtonReplyMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectedIndex",
            |m: &TemplateButtonReplyMessage| { &m.selectedIndex },
            |m: &mut TemplateButtonReplyMessage| { &mut m.selectedIndex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TemplateButtonReplyMessage>(
            "TemplateButtonReplyMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TemplateButtonReplyMessage {
    const NAME: &'static str = "TemplateButtonReplyMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectedId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.selectedDisplayText = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                32 => {
                    self.selectedIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selectedId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.selectedDisplayText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.selectedIndex {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.selectedId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.selectedDisplayText.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.selectedIndex {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TemplateButtonReplyMessage {
        TemplateButtonReplyMessage::new()
    }

    fn clear(&mut self) {
        self.selectedId = ::std::option::Option::None;
        self.selectedDisplayText = ::std::option::Option::None;
        self.contextInfo.clear();
        self.selectedIndex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TemplateButtonReplyMessage {
        static instance: TemplateButtonReplyMessage = TemplateButtonReplyMessage {
            selectedId: ::std::option::Option::None,
            selectedDisplayText: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            selectedIndex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TemplateButtonReplyMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TemplateButtonReplyMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TemplateButtonReplyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateButtonReplyMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.StickerSyncRMRMessage)
pub struct StickerSyncRMRMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.StickerSyncRMRMessage.filehash)
    pub filehash: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerSyncRMRMessage.rmrSource)
    pub rmrSource: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerSyncRMRMessage.requestTimestamp)
    pub requestTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.StickerSyncRMRMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StickerSyncRMRMessage {
    fn default() -> &'a StickerSyncRMRMessage {
        <StickerSyncRMRMessage as ::protobuf::Message>::default_instance()
    }
}

impl StickerSyncRMRMessage {
    pub fn new() -> StickerSyncRMRMessage {
        ::std::default::Default::default()
    }

    // optional string rmrSource = 2;

    pub fn rmrSource(&self) -> &str {
        match self.rmrSource.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rmrSource(&mut self) {
        self.rmrSource = ::std::option::Option::None;
    }

    pub fn has_rmrSource(&self) -> bool {
        self.rmrSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rmrSource(&mut self, v: ::std::string::String) {
        self.rmrSource = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rmrSource(&mut self) -> &mut ::std::string::String {
        if self.rmrSource.is_none() {
            self.rmrSource = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rmrSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_rmrSource(&mut self) -> ::std::string::String {
        self.rmrSource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 requestTimestamp = 3;

    pub fn requestTimestamp(&self) -> i64 {
        self.requestTimestamp.unwrap_or(0)
    }

    pub fn clear_requestTimestamp(&mut self) {
        self.requestTimestamp = ::std::option::Option::None;
    }

    pub fn has_requestTimestamp(&self) -> bool {
        self.requestTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestTimestamp(&mut self, v: i64) {
        self.requestTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filehash",
            |m: &StickerSyncRMRMessage| { &m.filehash },
            |m: &mut StickerSyncRMRMessage| { &mut m.filehash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rmrSource",
            |m: &StickerSyncRMRMessage| { &m.rmrSource },
            |m: &mut StickerSyncRMRMessage| { &mut m.rmrSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requestTimestamp",
            |m: &StickerSyncRMRMessage| { &m.requestTimestamp },
            |m: &mut StickerSyncRMRMessage| { &mut m.requestTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StickerSyncRMRMessage>(
            "StickerSyncRMRMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StickerSyncRMRMessage {
    const NAME: &'static str = "StickerSyncRMRMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filehash.push(is.read_string()?);
                },
                18 => {
                    self.rmrSource = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.requestTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.filehash {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.rmrSource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.requestTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.filehash {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.rmrSource.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.requestTimestamp {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StickerSyncRMRMessage {
        StickerSyncRMRMessage::new()
    }

    fn clear(&mut self) {
        self.filehash.clear();
        self.rmrSource = ::std::option::Option::None;
        self.requestTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StickerSyncRMRMessage {
        static instance: StickerSyncRMRMessage = StickerSyncRMRMessage {
            filehash: ::std::vec::Vec::new(),
            rmrSource: ::std::option::Option::None,
            requestTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StickerSyncRMRMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StickerSyncRMRMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StickerSyncRMRMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StickerSyncRMRMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.StickerMessage)
pub struct StickerMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.StickerMessage.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerMessage.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerMessage.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerMessage.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerMessage.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerMessage.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StickerMessage.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StickerMessage.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerMessage.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.StickerMessage.mediaKeyTimestamp)
    pub mediaKeyTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.StickerMessage.firstFrameLength)
    pub firstFrameLength: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StickerMessage.firstFrameSidecar)
    pub firstFrameSidecar: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerMessage.isAnimated)
    pub isAnimated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.StickerMessage.pngThumbnail)
    pub pngThumbnail: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // @@protoc_insertion_point(field:proto.StickerMessage.stickerSentTs)
    pub stickerSentTs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.StickerMessage.isAvatar)
    pub isAvatar: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.StickerMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StickerMessage {
    fn default() -> &'a StickerMessage {
        <StickerMessage as ::protobuf::Message>::default_instance()
    }
}

impl StickerMessage {
    pub fn new() -> StickerMessage {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 2;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 3;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mediaKey = 4;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string mimetype = 5;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 height = 6;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 7;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional string directPath = 8;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileLength = 9;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional int64 mediaKeyTimestamp = 10;

    pub fn mediaKeyTimestamp(&self) -> i64 {
        self.mediaKeyTimestamp.unwrap_or(0)
    }

    pub fn clear_mediaKeyTimestamp(&mut self) {
        self.mediaKeyTimestamp = ::std::option::Option::None;
    }

    pub fn has_mediaKeyTimestamp(&self) -> bool {
        self.mediaKeyTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKeyTimestamp(&mut self, v: i64) {
        self.mediaKeyTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 firstFrameLength = 11;

    pub fn firstFrameLength(&self) -> u32 {
        self.firstFrameLength.unwrap_or(0)
    }

    pub fn clear_firstFrameLength(&mut self) {
        self.firstFrameLength = ::std::option::Option::None;
    }

    pub fn has_firstFrameLength(&self) -> bool {
        self.firstFrameLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstFrameLength(&mut self, v: u32) {
        self.firstFrameLength = ::std::option::Option::Some(v);
    }

    // optional bytes firstFrameSidecar = 12;

    pub fn firstFrameSidecar(&self) -> &[u8] {
        match self.firstFrameSidecar.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_firstFrameSidecar(&mut self) {
        self.firstFrameSidecar = ::std::option::Option::None;
    }

    pub fn has_firstFrameSidecar(&self) -> bool {
        self.firstFrameSidecar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstFrameSidecar(&mut self, v: ::std::vec::Vec<u8>) {
        self.firstFrameSidecar = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstFrameSidecar(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.firstFrameSidecar.is_none() {
            self.firstFrameSidecar = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.firstFrameSidecar.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstFrameSidecar(&mut self) -> ::std::vec::Vec<u8> {
        self.firstFrameSidecar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool isAnimated = 13;

    pub fn isAnimated(&self) -> bool {
        self.isAnimated.unwrap_or(false)
    }

    pub fn clear_isAnimated(&mut self) {
        self.isAnimated = ::std::option::Option::None;
    }

    pub fn has_isAnimated(&self) -> bool {
        self.isAnimated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isAnimated(&mut self, v: bool) {
        self.isAnimated = ::std::option::Option::Some(v);
    }

    // optional bytes pngThumbnail = 16;

    pub fn pngThumbnail(&self) -> &[u8] {
        match self.pngThumbnail.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pngThumbnail(&mut self) {
        self.pngThumbnail = ::std::option::Option::None;
    }

    pub fn has_pngThumbnail(&self) -> bool {
        self.pngThumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pngThumbnail(&mut self, v: ::std::vec::Vec<u8>) {
        self.pngThumbnail = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pngThumbnail(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pngThumbnail.is_none() {
            self.pngThumbnail = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.pngThumbnail.as_mut().unwrap()
    }

    // Take field
    pub fn take_pngThumbnail(&mut self) -> ::std::vec::Vec<u8> {
        self.pngThumbnail.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 stickerSentTs = 18;

    pub fn stickerSentTs(&self) -> i64 {
        self.stickerSentTs.unwrap_or(0)
    }

    pub fn clear_stickerSentTs(&mut self) {
        self.stickerSentTs = ::std::option::Option::None;
    }

    pub fn has_stickerSentTs(&self) -> bool {
        self.stickerSentTs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stickerSentTs(&mut self, v: i64) {
        self.stickerSentTs = ::std::option::Option::Some(v);
    }

    // optional bool isAvatar = 19;

    pub fn isAvatar(&self) -> bool {
        self.isAvatar.unwrap_or(false)
    }

    pub fn clear_isAvatar(&mut self) {
        self.isAvatar = ::std::option::Option::None;
    }

    pub fn has_isAvatar(&self) -> bool {
        self.isAvatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isAvatar(&mut self, v: bool) {
        self.isAvatar = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &StickerMessage| { &m.url },
            |m: &mut StickerMessage| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &StickerMessage| { &m.fileSha256 },
            |m: &mut StickerMessage| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &StickerMessage| { &m.fileEncSha256 },
            |m: &mut StickerMessage| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &StickerMessage| { &m.mediaKey },
            |m: &mut StickerMessage| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &StickerMessage| { &m.mimetype },
            |m: &mut StickerMessage| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &StickerMessage| { &m.height },
            |m: &mut StickerMessage| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &StickerMessage| { &m.width },
            |m: &mut StickerMessage| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &StickerMessage| { &m.directPath },
            |m: &mut StickerMessage| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &StickerMessage| { &m.fileLength },
            |m: &mut StickerMessage| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKeyTimestamp",
            |m: &StickerMessage| { &m.mediaKeyTimestamp },
            |m: &mut StickerMessage| { &mut m.mediaKeyTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstFrameLength",
            |m: &StickerMessage| { &m.firstFrameLength },
            |m: &mut StickerMessage| { &mut m.firstFrameLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstFrameSidecar",
            |m: &StickerMessage| { &m.firstFrameSidecar },
            |m: &mut StickerMessage| { &mut m.firstFrameSidecar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isAnimated",
            |m: &StickerMessage| { &m.isAnimated },
            |m: &mut StickerMessage| { &mut m.isAnimated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pngThumbnail",
            |m: &StickerMessage| { &m.pngThumbnail },
            |m: &mut StickerMessage| { &mut m.pngThumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &StickerMessage| { &m.contextInfo },
            |m: &mut StickerMessage| { &mut m.contextInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stickerSentTs",
            |m: &StickerMessage| { &m.stickerSentTs },
            |m: &mut StickerMessage| { &mut m.stickerSentTs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isAvatar",
            |m: &StickerMessage| { &m.isAvatar },
            |m: &mut StickerMessage| { &mut m.isAvatar },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StickerMessage>(
            "StickerMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StickerMessage {
    const NAME: &'static str = "StickerMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.mediaKeyTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                88 => {
                    self.firstFrameLength = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.firstFrameSidecar = ::std::option::Option::Some(is.read_bytes()?);
                },
                104 => {
                    self.isAnimated = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    self.pngThumbnail = ::std::option::Option::Some(is.read_bytes()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                144 => {
                    self.stickerSentTs = ::std::option::Option::Some(is.read_int64()?);
                },
                152 => {
                    self.isAvatar = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.mediaKeyTimestamp {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.firstFrameLength {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.firstFrameSidecar.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        if let Some(v) = self.isAnimated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pngThumbnail.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stickerSentTs {
            my_size += ::protobuf::rt::int64_size(18, v);
        }
        if let Some(v) = self.isAvatar {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.mediaKeyTimestamp {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.firstFrameLength {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.firstFrameSidecar.as_ref() {
            os.write_bytes(12, v)?;
        }
        if let Some(v) = self.isAnimated {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.pngThumbnail.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.stickerSentTs {
            os.write_int64(18, v)?;
        }
        if let Some(v) = self.isAvatar {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StickerMessage {
        StickerMessage::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.mediaKeyTimestamp = ::std::option::Option::None;
        self.firstFrameLength = ::std::option::Option::None;
        self.firstFrameSidecar = ::std::option::Option::None;
        self.isAnimated = ::std::option::Option::None;
        self.pngThumbnail = ::std::option::Option::None;
        self.contextInfo.clear();
        self.stickerSentTs = ::std::option::Option::None;
        self.isAvatar = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StickerMessage {
        static instance: StickerMessage = StickerMessage {
            url: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            height: ::std::option::Option::None,
            width: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            mediaKeyTimestamp: ::std::option::Option::None,
            firstFrameLength: ::std::option::Option::None,
            firstFrameSidecar: ::std::option::Option::None,
            isAnimated: ::std::option::Option::None,
            pngThumbnail: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            stickerSentTs: ::std::option::Option::None,
            isAvatar: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StickerMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StickerMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StickerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StickerMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SenderKeyDistributionMessage)
pub struct SenderKeyDistributionMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.SenderKeyDistributionMessage.groupId)
    pub groupId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.SenderKeyDistributionMessage.axolotlSenderKeyDistributionMessage)
    pub axolotlSenderKeyDistributionMessage: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SenderKeyDistributionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SenderKeyDistributionMessage {
    fn default() -> &'a SenderKeyDistributionMessage {
        <SenderKeyDistributionMessage as ::protobuf::Message>::default_instance()
    }
}

impl SenderKeyDistributionMessage {
    pub fn new() -> SenderKeyDistributionMessage {
        ::std::default::Default::default()
    }

    // optional string groupId = 1;

    pub fn groupId(&self) -> &str {
        match self.groupId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupId(&mut self) {
        self.groupId = ::std::option::Option::None;
    }

    pub fn has_groupId(&self) -> bool {
        self.groupId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupId(&mut self, v: ::std::string::String) {
        self.groupId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupId(&mut self) -> &mut ::std::string::String {
        if self.groupId.is_none() {
            self.groupId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupId.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupId(&mut self) -> ::std::string::String {
        self.groupId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes axolotlSenderKeyDistributionMessage = 2;

    pub fn axolotlSenderKeyDistributionMessage(&self) -> &[u8] {
        match self.axolotlSenderKeyDistributionMessage.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_axolotlSenderKeyDistributionMessage(&mut self) {
        self.axolotlSenderKeyDistributionMessage = ::std::option::Option::None;
    }

    pub fn has_axolotlSenderKeyDistributionMessage(&self) -> bool {
        self.axolotlSenderKeyDistributionMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_axolotlSenderKeyDistributionMessage(&mut self, v: ::std::vec::Vec<u8>) {
        self.axolotlSenderKeyDistributionMessage = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_axolotlSenderKeyDistributionMessage(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.axolotlSenderKeyDistributionMessage.is_none() {
            self.axolotlSenderKeyDistributionMessage = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.axolotlSenderKeyDistributionMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_axolotlSenderKeyDistributionMessage(&mut self) -> ::std::vec::Vec<u8> {
        self.axolotlSenderKeyDistributionMessage.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupId",
            |m: &SenderKeyDistributionMessage| { &m.groupId },
            |m: &mut SenderKeyDistributionMessage| { &mut m.groupId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "axolotlSenderKeyDistributionMessage",
            |m: &SenderKeyDistributionMessage| { &m.axolotlSenderKeyDistributionMessage },
            |m: &mut SenderKeyDistributionMessage| { &mut m.axolotlSenderKeyDistributionMessage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SenderKeyDistributionMessage>(
            "SenderKeyDistributionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SenderKeyDistributionMessage {
    const NAME: &'static str = "SenderKeyDistributionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.axolotlSenderKeyDistributionMessage = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.axolotlSenderKeyDistributionMessage.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.axolotlSenderKeyDistributionMessage.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SenderKeyDistributionMessage {
        SenderKeyDistributionMessage::new()
    }

    fn clear(&mut self) {
        self.groupId = ::std::option::Option::None;
        self.axolotlSenderKeyDistributionMessage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SenderKeyDistributionMessage {
        static instance: SenderKeyDistributionMessage = SenderKeyDistributionMessage {
            groupId: ::std::option::Option::None,
            axolotlSenderKeyDistributionMessage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SenderKeyDistributionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SenderKeyDistributionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SenderKeyDistributionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SenderKeyDistributionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SendPaymentMessage)
pub struct SendPaymentMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.SendPaymentMessage.noteMessage)
    pub noteMessage: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:proto.SendPaymentMessage.requestMessageKey)
    pub requestMessageKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.SendPaymentMessage.background)
    pub background: ::protobuf::MessageField<PaymentBackground>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SendPaymentMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SendPaymentMessage {
    fn default() -> &'a SendPaymentMessage {
        <SendPaymentMessage as ::protobuf::Message>::default_instance()
    }
}

impl SendPaymentMessage {
    pub fn new() -> SendPaymentMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "noteMessage",
            |m: &SendPaymentMessage| { &m.noteMessage },
            |m: &mut SendPaymentMessage| { &mut m.noteMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "requestMessageKey",
            |m: &SendPaymentMessage| { &m.requestMessageKey },
            |m: &mut SendPaymentMessage| { &mut m.requestMessageKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBackground>(
            "background",
            |m: &SendPaymentMessage| { &m.background },
            |m: &mut SendPaymentMessage| { &mut m.background },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendPaymentMessage>(
            "SendPaymentMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SendPaymentMessage {
    const NAME: &'static str = "SendPaymentMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.noteMessage)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requestMessageKey)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.noteMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.requestMessageKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.noteMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.requestMessageKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.background.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SendPaymentMessage {
        SendPaymentMessage::new()
    }

    fn clear(&mut self) {
        self.noteMessage.clear();
        self.requestMessageKey.clear();
        self.background.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SendPaymentMessage {
        static instance: SendPaymentMessage = SendPaymentMessage {
            noteMessage: ::protobuf::MessageField::none(),
            requestMessageKey: ::protobuf::MessageField::none(),
            background: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SendPaymentMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SendPaymentMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SendPaymentMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendPaymentMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ScheduledCallEditMessage)
pub struct ScheduledCallEditMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ScheduledCallEditMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.ScheduledCallEditMessage.editType)
    pub editType: ::std::option::Option<::protobuf::EnumOrUnknown<scheduled_call_edit_message::EditType>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ScheduledCallEditMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScheduledCallEditMessage {
    fn default() -> &'a ScheduledCallEditMessage {
        <ScheduledCallEditMessage as ::protobuf::Message>::default_instance()
    }
}

impl ScheduledCallEditMessage {
    pub fn new() -> ScheduledCallEditMessage {
        ::std::default::Default::default()
    }

    // optional .proto.ScheduledCallEditMessage.EditType editType = 2;

    pub fn editType(&self) -> scheduled_call_edit_message::EditType {
        match self.editType {
            Some(e) => e.enum_value_or(scheduled_call_edit_message::EditType::UNKNOWN),
            None => scheduled_call_edit_message::EditType::UNKNOWN,
        }
    }

    pub fn clear_editType(&mut self) {
        self.editType = ::std::option::Option::None;
    }

    pub fn has_editType(&self) -> bool {
        self.editType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_editType(&mut self, v: scheduled_call_edit_message::EditType) {
        self.editType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &ScheduledCallEditMessage| { &m.key },
            |m: &mut ScheduledCallEditMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "editType",
            |m: &ScheduledCallEditMessage| { &m.editType },
            |m: &mut ScheduledCallEditMessage| { &mut m.editType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScheduledCallEditMessage>(
            "ScheduledCallEditMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScheduledCallEditMessage {
    const NAME: &'static str = "ScheduledCallEditMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.editType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.editType {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.editType {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScheduledCallEditMessage {
        ScheduledCallEditMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.editType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScheduledCallEditMessage {
        static instance: ScheduledCallEditMessage = ScheduledCallEditMessage {
            key: ::protobuf::MessageField::none(),
            editType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScheduledCallEditMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScheduledCallEditMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScheduledCallEditMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScheduledCallEditMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ScheduledCallEditMessage`
pub mod scheduled_call_edit_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ScheduledCallEditMessage.EditType)
    pub enum EditType {
        // @@protoc_insertion_point(enum_value:proto.ScheduledCallEditMessage.EditType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.ScheduledCallEditMessage.EditType.CANCEL)
        CANCEL = 1,
    }

    impl ::protobuf::Enum for EditType {
        const NAME: &'static str = "EditType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EditType> {
            match value {
                0 => ::std::option::Option::Some(EditType::UNKNOWN),
                1 => ::std::option::Option::Some(EditType::CANCEL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EditType] = &[
            EditType::UNKNOWN,
            EditType::CANCEL,
        ];
    }

    impl ::protobuf::EnumFull for EditType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ScheduledCallEditMessage.EditType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EditType {
        fn default() -> Self {
            EditType::UNKNOWN
        }
    }

    impl EditType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EditType>("ScheduledCallEditMessage.EditType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ScheduledCallCreationMessage)
pub struct ScheduledCallCreationMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ScheduledCallCreationMessage.scheduledTimestampMs)
    pub scheduledTimestampMs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.ScheduledCallCreationMessage.callType)
    pub callType: ::std::option::Option<::protobuf::EnumOrUnknown<scheduled_call_creation_message::CallType>>,
    // @@protoc_insertion_point(field:proto.ScheduledCallCreationMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ScheduledCallCreationMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScheduledCallCreationMessage {
    fn default() -> &'a ScheduledCallCreationMessage {
        <ScheduledCallCreationMessage as ::protobuf::Message>::default_instance()
    }
}

impl ScheduledCallCreationMessage {
    pub fn new() -> ScheduledCallCreationMessage {
        ::std::default::Default::default()
    }

    // optional int64 scheduledTimestampMs = 1;

    pub fn scheduledTimestampMs(&self) -> i64 {
        self.scheduledTimestampMs.unwrap_or(0)
    }

    pub fn clear_scheduledTimestampMs(&mut self) {
        self.scheduledTimestampMs = ::std::option::Option::None;
    }

    pub fn has_scheduledTimestampMs(&self) -> bool {
        self.scheduledTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduledTimestampMs(&mut self, v: i64) {
        self.scheduledTimestampMs = ::std::option::Option::Some(v);
    }

    // optional .proto.ScheduledCallCreationMessage.CallType callType = 2;

    pub fn callType(&self) -> scheduled_call_creation_message::CallType {
        match self.callType {
            Some(e) => e.enum_value_or(scheduled_call_creation_message::CallType::UNKNOWN),
            None => scheduled_call_creation_message::CallType::UNKNOWN,
        }
    }

    pub fn clear_callType(&mut self) {
        self.callType = ::std::option::Option::None;
    }

    pub fn has_callType(&self) -> bool {
        self.callType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callType(&mut self, v: scheduled_call_creation_message::CallType) {
        self.callType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scheduledTimestampMs",
            |m: &ScheduledCallCreationMessage| { &m.scheduledTimestampMs },
            |m: &mut ScheduledCallCreationMessage| { &mut m.scheduledTimestampMs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "callType",
            |m: &ScheduledCallCreationMessage| { &m.callType },
            |m: &mut ScheduledCallCreationMessage| { &mut m.callType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &ScheduledCallCreationMessage| { &m.title },
            |m: &mut ScheduledCallCreationMessage| { &mut m.title },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScheduledCallCreationMessage>(
            "ScheduledCallCreationMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScheduledCallCreationMessage {
    const NAME: &'static str = "ScheduledCallCreationMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.scheduledTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.callType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scheduledTimestampMs {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.callType {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.scheduledTimestampMs {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.callType {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScheduledCallCreationMessage {
        ScheduledCallCreationMessage::new()
    }

    fn clear(&mut self) {
        self.scheduledTimestampMs = ::std::option::Option::None;
        self.callType = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScheduledCallCreationMessage {
        static instance: ScheduledCallCreationMessage = ScheduledCallCreationMessage {
            scheduledTimestampMs: ::std::option::Option::None,
            callType: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScheduledCallCreationMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScheduledCallCreationMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScheduledCallCreationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScheduledCallCreationMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ScheduledCallCreationMessage`
pub mod scheduled_call_creation_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ScheduledCallCreationMessage.CallType)
    pub enum CallType {
        // @@protoc_insertion_point(enum_value:proto.ScheduledCallCreationMessage.CallType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.ScheduledCallCreationMessage.CallType.VOICE)
        VOICE = 1,
        // @@protoc_insertion_point(enum_value:proto.ScheduledCallCreationMessage.CallType.VIDEO)
        VIDEO = 2,
    }

    impl ::protobuf::Enum for CallType {
        const NAME: &'static str = "CallType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CallType> {
            match value {
                0 => ::std::option::Option::Some(CallType::UNKNOWN),
                1 => ::std::option::Option::Some(CallType::VOICE),
                2 => ::std::option::Option::Some(CallType::VIDEO),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CallType] = &[
            CallType::UNKNOWN,
            CallType::VOICE,
            CallType::VIDEO,
        ];
    }

    impl ::protobuf::EnumFull for CallType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ScheduledCallCreationMessage.CallType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CallType {
        fn default() -> Self {
            CallType::UNKNOWN
        }
    }

    impl CallType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CallType>("ScheduledCallCreationMessage.CallType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.RequestPhoneNumberMessage)
pub struct RequestPhoneNumberMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.RequestPhoneNumberMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.RequestPhoneNumberMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestPhoneNumberMessage {
    fn default() -> &'a RequestPhoneNumberMessage {
        <RequestPhoneNumberMessage as ::protobuf::Message>::default_instance()
    }
}

impl RequestPhoneNumberMessage {
    pub fn new() -> RequestPhoneNumberMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &RequestPhoneNumberMessage| { &m.contextInfo },
            |m: &mut RequestPhoneNumberMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestPhoneNumberMessage>(
            "RequestPhoneNumberMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestPhoneNumberMessage {
    const NAME: &'static str = "RequestPhoneNumberMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestPhoneNumberMessage {
        RequestPhoneNumberMessage::new()
    }

    fn clear(&mut self) {
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestPhoneNumberMessage {
        static instance: RequestPhoneNumberMessage = RequestPhoneNumberMessage {
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestPhoneNumberMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestPhoneNumberMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestPhoneNumberMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPhoneNumberMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.RequestPaymentMessage)
pub struct RequestPaymentMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.RequestPaymentMessage.noteMessage)
    pub noteMessage: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:proto.RequestPaymentMessage.currencyCodeIso4217)
    pub currencyCodeIso4217: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.RequestPaymentMessage.amount1000)
    pub amount1000: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.RequestPaymentMessage.requestFrom)
    pub requestFrom: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.RequestPaymentMessage.expiryTimestamp)
    pub expiryTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.RequestPaymentMessage.amount)
    pub amount: ::protobuf::MessageField<Money>,
    // @@protoc_insertion_point(field:proto.RequestPaymentMessage.background)
    pub background: ::protobuf::MessageField<PaymentBackground>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.RequestPaymentMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestPaymentMessage {
    fn default() -> &'a RequestPaymentMessage {
        <RequestPaymentMessage as ::protobuf::Message>::default_instance()
    }
}

impl RequestPaymentMessage {
    pub fn new() -> RequestPaymentMessage {
        ::std::default::Default::default()
    }

    // optional string currencyCodeIso4217 = 1;

    pub fn currencyCodeIso4217(&self) -> &str {
        match self.currencyCodeIso4217.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currencyCodeIso4217(&mut self) {
        self.currencyCodeIso4217 = ::std::option::Option::None;
    }

    pub fn has_currencyCodeIso4217(&self) -> bool {
        self.currencyCodeIso4217.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currencyCodeIso4217(&mut self, v: ::std::string::String) {
        self.currencyCodeIso4217 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currencyCodeIso4217(&mut self) -> &mut ::std::string::String {
        if self.currencyCodeIso4217.is_none() {
            self.currencyCodeIso4217 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currencyCodeIso4217.as_mut().unwrap()
    }

    // Take field
    pub fn take_currencyCodeIso4217(&mut self) -> ::std::string::String {
        self.currencyCodeIso4217.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 amount1000 = 2;

    pub fn amount1000(&self) -> u64 {
        self.amount1000.unwrap_or(0)
    }

    pub fn clear_amount1000(&mut self) {
        self.amount1000 = ::std::option::Option::None;
    }

    pub fn has_amount1000(&self) -> bool {
        self.amount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount1000(&mut self, v: u64) {
        self.amount1000 = ::std::option::Option::Some(v);
    }

    // optional string requestFrom = 3;

    pub fn requestFrom(&self) -> &str {
        match self.requestFrom.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_requestFrom(&mut self) {
        self.requestFrom = ::std::option::Option::None;
    }

    pub fn has_requestFrom(&self) -> bool {
        self.requestFrom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestFrom(&mut self, v: ::std::string::String) {
        self.requestFrom = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requestFrom(&mut self) -> &mut ::std::string::String {
        if self.requestFrom.is_none() {
            self.requestFrom = ::std::option::Option::Some(::std::string::String::new());
        }
        self.requestFrom.as_mut().unwrap()
    }

    // Take field
    pub fn take_requestFrom(&mut self) -> ::std::string::String {
        self.requestFrom.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 expiryTimestamp = 5;

    pub fn expiryTimestamp(&self) -> i64 {
        self.expiryTimestamp.unwrap_or(0)
    }

    pub fn clear_expiryTimestamp(&mut self) {
        self.expiryTimestamp = ::std::option::Option::None;
    }

    pub fn has_expiryTimestamp(&self) -> bool {
        self.expiryTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryTimestamp(&mut self, v: i64) {
        self.expiryTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "noteMessage",
            |m: &RequestPaymentMessage| { &m.noteMessage },
            |m: &mut RequestPaymentMessage| { &mut m.noteMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currencyCodeIso4217",
            |m: &RequestPaymentMessage| { &m.currencyCodeIso4217 },
            |m: &mut RequestPaymentMessage| { &mut m.currencyCodeIso4217 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount1000",
            |m: &RequestPaymentMessage| { &m.amount1000 },
            |m: &mut RequestPaymentMessage| { &mut m.amount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requestFrom",
            |m: &RequestPaymentMessage| { &m.requestFrom },
            |m: &mut RequestPaymentMessage| { &mut m.requestFrom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiryTimestamp",
            |m: &RequestPaymentMessage| { &m.expiryTimestamp },
            |m: &mut RequestPaymentMessage| { &mut m.expiryTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Money>(
            "amount",
            |m: &RequestPaymentMessage| { &m.amount },
            |m: &mut RequestPaymentMessage| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentBackground>(
            "background",
            |m: &RequestPaymentMessage| { &m.background },
            |m: &mut RequestPaymentMessage| { &mut m.background },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestPaymentMessage>(
            "RequestPaymentMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestPaymentMessage {
    const NAME: &'static str = "RequestPaymentMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.noteMessage)?;
                },
                10 => {
                    self.currencyCodeIso4217 = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.amount1000 = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.requestFrom = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.expiryTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.amount)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.background)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.noteMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.currencyCodeIso4217.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.amount1000 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.requestFrom.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.expiryTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.background.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.noteMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.currencyCodeIso4217.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.amount1000 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.requestFrom.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.expiryTimestamp {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.amount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.background.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestPaymentMessage {
        RequestPaymentMessage::new()
    }

    fn clear(&mut self) {
        self.noteMessage.clear();
        self.currencyCodeIso4217 = ::std::option::Option::None;
        self.amount1000 = ::std::option::Option::None;
        self.requestFrom = ::std::option::Option::None;
        self.expiryTimestamp = ::std::option::Option::None;
        self.amount.clear();
        self.background.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestPaymentMessage {
        static instance: RequestPaymentMessage = RequestPaymentMessage {
            noteMessage: ::protobuf::MessageField::none(),
            currencyCodeIso4217: ::std::option::Option::None,
            amount1000: ::std::option::Option::None,
            requestFrom: ::std::option::Option::None,
            expiryTimestamp: ::std::option::Option::None,
            amount: ::protobuf::MessageField::none(),
            background: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestPaymentMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestPaymentMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestPaymentMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPaymentMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ReactionMessage)
pub struct ReactionMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ReactionMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.ReactionMessage.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ReactionMessage.groupingKey)
    pub groupingKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ReactionMessage.senderTimestampMs)
    pub senderTimestampMs: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ReactionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReactionMessage {
    fn default() -> &'a ReactionMessage {
        <ReactionMessage as ::protobuf::Message>::default_instance()
    }
}

impl ReactionMessage {
    pub fn new() -> ReactionMessage {
        ::std::default::Default::default()
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupingKey = 3;

    pub fn groupingKey(&self) -> &str {
        match self.groupingKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupingKey(&mut self) {
        self.groupingKey = ::std::option::Option::None;
    }

    pub fn has_groupingKey(&self) -> bool {
        self.groupingKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupingKey(&mut self, v: ::std::string::String) {
        self.groupingKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupingKey(&mut self) -> &mut ::std::string::String {
        if self.groupingKey.is_none() {
            self.groupingKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupingKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupingKey(&mut self) -> ::std::string::String {
        self.groupingKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 senderTimestampMs = 4;

    pub fn senderTimestampMs(&self) -> i64 {
        self.senderTimestampMs.unwrap_or(0)
    }

    pub fn clear_senderTimestampMs(&mut self) {
        self.senderTimestampMs = ::std::option::Option::None;
    }

    pub fn has_senderTimestampMs(&self) -> bool {
        self.senderTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestampMs(&mut self, v: i64) {
        self.senderTimestampMs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &ReactionMessage| { &m.key },
            |m: &mut ReactionMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &ReactionMessage| { &m.text },
            |m: &mut ReactionMessage| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupingKey",
            |m: &ReactionMessage| { &m.groupingKey },
            |m: &mut ReactionMessage| { &mut m.groupingKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestampMs",
            |m: &ReactionMessage| { &m.senderTimestampMs },
            |m: &mut ReactionMessage| { &mut m.senderTimestampMs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReactionMessage>(
            "ReactionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReactionMessage {
    const NAME: &'static str = "ReactionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.groupingKey = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.senderTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.groupingKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.senderTimestampMs {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.groupingKey.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.senderTimestampMs {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReactionMessage {
        ReactionMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.text = ::std::option::Option::None;
        self.groupingKey = ::std::option::Option::None;
        self.senderTimestampMs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReactionMessage {
        static instance: ReactionMessage = ReactionMessage {
            key: ::protobuf::MessageField::none(),
            text: ::std::option::Option::None,
            groupingKey: ::std::option::Option::None,
            senderTimestampMs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReactionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReactionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReactionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ProtocolMessage)
pub struct ProtocolMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ProtocolMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<protocol_message::Type>>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.ephemeralExpiration)
    pub ephemeralExpiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.ephemeralSettingTimestamp)
    pub ephemeralSettingTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.historySyncNotification)
    pub historySyncNotification: ::protobuf::MessageField<HistorySyncNotification>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.appStateSyncKeyShare)
    pub appStateSyncKeyShare: ::protobuf::MessageField<AppStateSyncKeyShare>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.appStateSyncKeyRequest)
    pub appStateSyncKeyRequest: ::protobuf::MessageField<AppStateSyncKeyRequest>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.initialSecurityNotificationSettingSync)
    pub initialSecurityNotificationSettingSync: ::protobuf::MessageField<InitialSecurityNotificationSettingSync>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.appStateFatalExceptionNotification)
    pub appStateFatalExceptionNotification: ::protobuf::MessageField<AppStateFatalExceptionNotification>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.disappearingMode)
    pub disappearingMode: ::protobuf::MessageField<DisappearingMode>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.editedMessage)
    pub editedMessage: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.timestampMs)
    pub timestampMs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.peerDataOperationRequestMessage)
    pub peerDataOperationRequestMessage: ::protobuf::MessageField<PeerDataOperationRequestMessage>,
    // @@protoc_insertion_point(field:proto.ProtocolMessage.peerDataOperationRequestResponseMessage)
    pub peerDataOperationRequestResponseMessage: ::protobuf::MessageField<PeerDataOperationRequestResponseMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ProtocolMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtocolMessage {
    fn default() -> &'a ProtocolMessage {
        <ProtocolMessage as ::protobuf::Message>::default_instance()
    }
}

impl ProtocolMessage {
    pub fn new() -> ProtocolMessage {
        ::std::default::Default::default()
    }

    // optional .proto.ProtocolMessage.Type type = 2;

    pub fn type_(&self) -> protocol_message::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(protocol_message::Type::REVOKE),
            None => protocol_message::Type::REVOKE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: protocol_message::Type) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 ephemeralExpiration = 4;

    pub fn ephemeralExpiration(&self) -> u32 {
        self.ephemeralExpiration.unwrap_or(0)
    }

    pub fn clear_ephemeralExpiration(&mut self) {
        self.ephemeralExpiration = ::std::option::Option::None;
    }

    pub fn has_ephemeralExpiration(&self) -> bool {
        self.ephemeralExpiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralExpiration(&mut self, v: u32) {
        self.ephemeralExpiration = ::std::option::Option::Some(v);
    }

    // optional int64 ephemeralSettingTimestamp = 5;

    pub fn ephemeralSettingTimestamp(&self) -> i64 {
        self.ephemeralSettingTimestamp.unwrap_or(0)
    }

    pub fn clear_ephemeralSettingTimestamp(&mut self) {
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
    }

    pub fn has_ephemeralSettingTimestamp(&self) -> bool {
        self.ephemeralSettingTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralSettingTimestamp(&mut self, v: i64) {
        self.ephemeralSettingTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 timestampMs = 15;

    pub fn timestampMs(&self) -> i64 {
        self.timestampMs.unwrap_or(0)
    }

    pub fn clear_timestampMs(&mut self) {
        self.timestampMs = ::std::option::Option::None;
    }

    pub fn has_timestampMs(&self) -> bool {
        self.timestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestampMs(&mut self, v: i64) {
        self.timestampMs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &ProtocolMessage| { &m.key },
            |m: &mut ProtocolMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ProtocolMessage| { &m.type_ },
            |m: &mut ProtocolMessage| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralExpiration",
            |m: &ProtocolMessage| { &m.ephemeralExpiration },
            |m: &mut ProtocolMessage| { &mut m.ephemeralExpiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralSettingTimestamp",
            |m: &ProtocolMessage| { &m.ephemeralSettingTimestamp },
            |m: &mut ProtocolMessage| { &mut m.ephemeralSettingTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HistorySyncNotification>(
            "historySyncNotification",
            |m: &ProtocolMessage| { &m.historySyncNotification },
            |m: &mut ProtocolMessage| { &mut m.historySyncNotification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyShare>(
            "appStateSyncKeyShare",
            |m: &ProtocolMessage| { &m.appStateSyncKeyShare },
            |m: &mut ProtocolMessage| { &mut m.appStateSyncKeyShare },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateSyncKeyRequest>(
            "appStateSyncKeyRequest",
            |m: &ProtocolMessage| { &m.appStateSyncKeyRequest },
            |m: &mut ProtocolMessage| { &mut m.appStateSyncKeyRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InitialSecurityNotificationSettingSync>(
            "initialSecurityNotificationSettingSync",
            |m: &ProtocolMessage| { &m.initialSecurityNotificationSettingSync },
            |m: &mut ProtocolMessage| { &mut m.initialSecurityNotificationSettingSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AppStateFatalExceptionNotification>(
            "appStateFatalExceptionNotification",
            |m: &ProtocolMessage| { &m.appStateFatalExceptionNotification },
            |m: &mut ProtocolMessage| { &mut m.appStateFatalExceptionNotification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DisappearingMode>(
            "disappearingMode",
            |m: &ProtocolMessage| { &m.disappearingMode },
            |m: &mut ProtocolMessage| { &mut m.disappearingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "editedMessage",
            |m: &ProtocolMessage| { &m.editedMessage },
            |m: &mut ProtocolMessage| { &mut m.editedMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestampMs",
            |m: &ProtocolMessage| { &m.timestampMs },
            |m: &mut ProtocolMessage| { &mut m.timestampMs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PeerDataOperationRequestMessage>(
            "peerDataOperationRequestMessage",
            |m: &ProtocolMessage| { &m.peerDataOperationRequestMessage },
            |m: &mut ProtocolMessage| { &mut m.peerDataOperationRequestMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PeerDataOperationRequestResponseMessage>(
            "peerDataOperationRequestResponseMessage",
            |m: &ProtocolMessage| { &m.peerDataOperationRequestResponseMessage },
            |m: &mut ProtocolMessage| { &mut m.peerDataOperationRequestResponseMessage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtocolMessage>(
            "ProtocolMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtocolMessage {
    const NAME: &'static str = "ProtocolMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.ephemeralExpiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ephemeralSettingTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.historySyncNotification)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appStateSyncKeyShare)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appStateSyncKeyRequest)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.initialSecurityNotificationSettingSync)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.appStateFatalExceptionNotification)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.disappearingMode)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.editedMessage)?;
                },
                120 => {
                    self.timestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peerDataOperationRequestMessage)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.peerDataOperationRequestResponseMessage)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.ephemeralExpiration {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.historySyncNotification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.appStateSyncKeyShare.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.appStateSyncKeyRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.initialSecurityNotificationSettingSync.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.appStateFatalExceptionNotification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.editedMessage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestampMs {
            my_size += ::protobuf::rt::int64_size(15, v);
        }
        if let Some(v) = self.peerDataOperationRequestMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.peerDataOperationRequestResponseMessage.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ephemeralExpiration {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.historySyncNotification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.appStateSyncKeyShare.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.appStateSyncKeyRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.initialSecurityNotificationSettingSync.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.appStateFatalExceptionNotification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.editedMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.timestampMs {
            os.write_int64(15, v)?;
        }
        if let Some(v) = self.peerDataOperationRequestMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.peerDataOperationRequestResponseMessage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtocolMessage {
        ProtocolMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.type_ = ::std::option::Option::None;
        self.ephemeralExpiration = ::std::option::Option::None;
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
        self.historySyncNotification.clear();
        self.appStateSyncKeyShare.clear();
        self.appStateSyncKeyRequest.clear();
        self.initialSecurityNotificationSettingSync.clear();
        self.appStateFatalExceptionNotification.clear();
        self.disappearingMode.clear();
        self.editedMessage.clear();
        self.timestampMs = ::std::option::Option::None;
        self.peerDataOperationRequestMessage.clear();
        self.peerDataOperationRequestResponseMessage.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtocolMessage {
        static instance: ProtocolMessage = ProtocolMessage {
            key: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            ephemeralExpiration: ::std::option::Option::None,
            ephemeralSettingTimestamp: ::std::option::Option::None,
            historySyncNotification: ::protobuf::MessageField::none(),
            appStateSyncKeyShare: ::protobuf::MessageField::none(),
            appStateSyncKeyRequest: ::protobuf::MessageField::none(),
            initialSecurityNotificationSettingSync: ::protobuf::MessageField::none(),
            appStateFatalExceptionNotification: ::protobuf::MessageField::none(),
            disappearingMode: ::protobuf::MessageField::none(),
            editedMessage: ::protobuf::MessageField::none(),
            timestampMs: ::std::option::Option::None,
            peerDataOperationRequestMessage: ::protobuf::MessageField::none(),
            peerDataOperationRequestResponseMessage: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtocolMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtocolMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtocolMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtocolMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProtocolMessage`
pub mod protocol_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ProtocolMessage.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.REVOKE)
        REVOKE = 0,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.EPHEMERAL_SETTING)
        EPHEMERAL_SETTING = 3,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.EPHEMERAL_SYNC_RESPONSE)
        EPHEMERAL_SYNC_RESPONSE = 4,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.HISTORY_SYNC_NOTIFICATION)
        HISTORY_SYNC_NOTIFICATION = 5,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.APP_STATE_SYNC_KEY_SHARE)
        APP_STATE_SYNC_KEY_SHARE = 6,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.APP_STATE_SYNC_KEY_REQUEST)
        APP_STATE_SYNC_KEY_REQUEST = 7,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.MSG_FANOUT_BACKFILL_REQUEST)
        MSG_FANOUT_BACKFILL_REQUEST = 8,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC)
        INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC = 9,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.APP_STATE_FATAL_EXCEPTION_NOTIFICATION)
        APP_STATE_FATAL_EXCEPTION_NOTIFICATION = 10,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.SHARE_PHONE_NUMBER)
        SHARE_PHONE_NUMBER = 11,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.MESSAGE_EDIT)
        MESSAGE_EDIT = 14,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.PEER_DATA_OPERATION_REQUEST_MESSAGE)
        PEER_DATA_OPERATION_REQUEST_MESSAGE = 16,
        // @@protoc_insertion_point(enum_value:proto.ProtocolMessage.Type.PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE)
        PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE = 17,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::REVOKE),
                3 => ::std::option::Option::Some(Type::EPHEMERAL_SETTING),
                4 => ::std::option::Option::Some(Type::EPHEMERAL_SYNC_RESPONSE),
                5 => ::std::option::Option::Some(Type::HISTORY_SYNC_NOTIFICATION),
                6 => ::std::option::Option::Some(Type::APP_STATE_SYNC_KEY_SHARE),
                7 => ::std::option::Option::Some(Type::APP_STATE_SYNC_KEY_REQUEST),
                8 => ::std::option::Option::Some(Type::MSG_FANOUT_BACKFILL_REQUEST),
                9 => ::std::option::Option::Some(Type::INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC),
                10 => ::std::option::Option::Some(Type::APP_STATE_FATAL_EXCEPTION_NOTIFICATION),
                11 => ::std::option::Option::Some(Type::SHARE_PHONE_NUMBER),
                14 => ::std::option::Option::Some(Type::MESSAGE_EDIT),
                16 => ::std::option::Option::Some(Type::PEER_DATA_OPERATION_REQUEST_MESSAGE),
                17 => ::std::option::Option::Some(Type::PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::REVOKE,
            Type::EPHEMERAL_SETTING,
            Type::EPHEMERAL_SYNC_RESPONSE,
            Type::HISTORY_SYNC_NOTIFICATION,
            Type::APP_STATE_SYNC_KEY_SHARE,
            Type::APP_STATE_SYNC_KEY_REQUEST,
            Type::MSG_FANOUT_BACKFILL_REQUEST,
            Type::INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC,
            Type::APP_STATE_FATAL_EXCEPTION_NOTIFICATION,
            Type::SHARE_PHONE_NUMBER,
            Type::MESSAGE_EDIT,
            Type::PEER_DATA_OPERATION_REQUEST_MESSAGE,
            Type::PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ProtocolMessage.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Type::REVOKE => 0,
                Type::EPHEMERAL_SETTING => 1,
                Type::EPHEMERAL_SYNC_RESPONSE => 2,
                Type::HISTORY_SYNC_NOTIFICATION => 3,
                Type::APP_STATE_SYNC_KEY_SHARE => 4,
                Type::APP_STATE_SYNC_KEY_REQUEST => 5,
                Type::MSG_FANOUT_BACKFILL_REQUEST => 6,
                Type::INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC => 7,
                Type::APP_STATE_FATAL_EXCEPTION_NOTIFICATION => 8,
                Type::SHARE_PHONE_NUMBER => 9,
                Type::MESSAGE_EDIT => 10,
                Type::PEER_DATA_OPERATION_REQUEST_MESSAGE => 11,
                Type::PEER_DATA_OPERATION_REQUEST_RESPONSE_MESSAGE => 12,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::REVOKE
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("ProtocolMessage.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ProductMessage)
pub struct ProductMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.ProductMessage.product)
    pub product: ::protobuf::MessageField<product_message::ProductSnapshot>,
    // @@protoc_insertion_point(field:proto.ProductMessage.businessOwnerJid)
    pub businessOwnerJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ProductMessage.catalog)
    pub catalog: ::protobuf::MessageField<product_message::CatalogSnapshot>,
    // @@protoc_insertion_point(field:proto.ProductMessage.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ProductMessage.footer)
    pub footer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ProductMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ProductMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductMessage {
    fn default() -> &'a ProductMessage {
        <ProductMessage as ::protobuf::Message>::default_instance()
    }
}

impl ProductMessage {
    pub fn new() -> ProductMessage {
        ::std::default::Default::default()
    }

    // optional string businessOwnerJid = 2;

    pub fn businessOwnerJid(&self) -> &str {
        match self.businessOwnerJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_businessOwnerJid(&mut self) {
        self.businessOwnerJid = ::std::option::Option::None;
    }

    pub fn has_businessOwnerJid(&self) -> bool {
        self.businessOwnerJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_businessOwnerJid(&mut self, v: ::std::string::String) {
        self.businessOwnerJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_businessOwnerJid(&mut self) -> &mut ::std::string::String {
        if self.businessOwnerJid.is_none() {
            self.businessOwnerJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.businessOwnerJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_businessOwnerJid(&mut self) -> ::std::string::String {
        self.businessOwnerJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string body = 5;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string footer = 6;

    pub fn footer(&self) -> &str {
        match self.footer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_footer(&mut self) {
        self.footer = ::std::option::Option::None;
    }

    pub fn has_footer(&self) -> bool {
        self.footer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_footer(&mut self, v: ::std::string::String) {
        self.footer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_footer(&mut self) -> &mut ::std::string::String {
        if self.footer.is_none() {
            self.footer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.footer.as_mut().unwrap()
    }

    // Take field
    pub fn take_footer(&mut self) -> ::std::string::String {
        self.footer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, product_message::ProductSnapshot>(
            "product",
            |m: &ProductMessage| { &m.product },
            |m: &mut ProductMessage| { &mut m.product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "businessOwnerJid",
            |m: &ProductMessage| { &m.businessOwnerJid },
            |m: &mut ProductMessage| { &mut m.businessOwnerJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, product_message::CatalogSnapshot>(
            "catalog",
            |m: &ProductMessage| { &m.catalog },
            |m: &mut ProductMessage| { &mut m.catalog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &ProductMessage| { &m.body },
            |m: &mut ProductMessage| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "footer",
            |m: &ProductMessage| { &m.footer },
            |m: &mut ProductMessage| { &mut m.footer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &ProductMessage| { &m.contextInfo },
            |m: &mut ProductMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductMessage>(
            "ProductMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductMessage {
    const NAME: &'static str = "ProductMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.product)?;
                },
                18 => {
                    self.businessOwnerJid = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.catalog)?;
                },
                42 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.footer = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.product.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.businessOwnerJid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.catalog.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.footer.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.product.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.businessOwnerJid.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.catalog.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.footer.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductMessage {
        ProductMessage::new()
    }

    fn clear(&mut self) {
        self.product.clear();
        self.businessOwnerJid = ::std::option::Option::None;
        self.catalog.clear();
        self.body = ::std::option::Option::None;
        self.footer = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductMessage {
        static instance: ProductMessage = ProductMessage {
            product: ::protobuf::MessageField::none(),
            businessOwnerJid: ::std::option::Option::None,
            catalog: ::protobuf::MessageField::none(),
            body: ::std::option::Option::None,
            footer: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProductMessage`
pub mod product_message {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ProductMessage.ProductSnapshot)
    pub struct ProductSnapshot {
        // message fields
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.productImage)
        pub productImage: ::protobuf::MessageField<super::ImageMessage>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.productId)
        pub productId: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.title)
        pub title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.description)
        pub description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.currencyCode)
        pub currencyCode: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.priceAmount1000)
        pub priceAmount1000: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.retailerId)
        pub retailerId: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.url)
        pub url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.productImageCount)
        pub productImageCount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.firstImageId)
        pub firstImageId: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ProductMessage.ProductSnapshot.salePriceAmount1000)
        pub salePriceAmount1000: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ProductMessage.ProductSnapshot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProductSnapshot {
        fn default() -> &'a ProductSnapshot {
            <ProductSnapshot as ::protobuf::Message>::default_instance()
        }
    }

    impl ProductSnapshot {
        pub fn new() -> ProductSnapshot {
            ::std::default::Default::default()
        }

        // optional string productId = 2;

        pub fn productId(&self) -> &str {
            match self.productId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_productId(&mut self) {
            self.productId = ::std::option::Option::None;
        }

        pub fn has_productId(&self) -> bool {
            self.productId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_productId(&mut self, v: ::std::string::String) {
            self.productId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_productId(&mut self) -> &mut ::std::string::String {
            if self.productId.is_none() {
                self.productId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.productId.as_mut().unwrap()
        }

        // Take field
        pub fn take_productId(&mut self) -> ::std::string::String {
            self.productId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string title = 3;

        pub fn title(&self) -> &str {
            match self.title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_title(&self) -> bool {
            self.title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            if self.title.is_none() {
                self.title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title.as_mut().unwrap()
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            self.title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description = 4;

        pub fn description(&self) -> &str {
            match self.description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description(&mut self) {
            self.description = ::std::option::Option::None;
        }

        pub fn has_description(&self) -> bool {
            self.description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            if self.description.is_none() {
                self.description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description.as_mut().unwrap()
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            self.description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string currencyCode = 5;

        pub fn currencyCode(&self) -> &str {
            match self.currencyCode.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_currencyCode(&mut self) {
            self.currencyCode = ::std::option::Option::None;
        }

        pub fn has_currencyCode(&self) -> bool {
            self.currencyCode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_currencyCode(&mut self, v: ::std::string::String) {
            self.currencyCode = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_currencyCode(&mut self) -> &mut ::std::string::String {
            if self.currencyCode.is_none() {
                self.currencyCode = ::std::option::Option::Some(::std::string::String::new());
            }
            self.currencyCode.as_mut().unwrap()
        }

        // Take field
        pub fn take_currencyCode(&mut self) -> ::std::string::String {
            self.currencyCode.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int64 priceAmount1000 = 6;

        pub fn priceAmount1000(&self) -> i64 {
            self.priceAmount1000.unwrap_or(0)
        }

        pub fn clear_priceAmount1000(&mut self) {
            self.priceAmount1000 = ::std::option::Option::None;
        }

        pub fn has_priceAmount1000(&self) -> bool {
            self.priceAmount1000.is_some()
        }

        // Param is passed by value, moved
        pub fn set_priceAmount1000(&mut self, v: i64) {
            self.priceAmount1000 = ::std::option::Option::Some(v);
        }

        // optional string retailerId = 7;

        pub fn retailerId(&self) -> &str {
            match self.retailerId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_retailerId(&mut self) {
            self.retailerId = ::std::option::Option::None;
        }

        pub fn has_retailerId(&self) -> bool {
            self.retailerId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_retailerId(&mut self, v: ::std::string::String) {
            self.retailerId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_retailerId(&mut self) -> &mut ::std::string::String {
            if self.retailerId.is_none() {
                self.retailerId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.retailerId.as_mut().unwrap()
        }

        // Take field
        pub fn take_retailerId(&mut self) -> ::std::string::String {
            self.retailerId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string url = 8;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 productImageCount = 9;

        pub fn productImageCount(&self) -> u32 {
            self.productImageCount.unwrap_or(0)
        }

        pub fn clear_productImageCount(&mut self) {
            self.productImageCount = ::std::option::Option::None;
        }

        pub fn has_productImageCount(&self) -> bool {
            self.productImageCount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_productImageCount(&mut self, v: u32) {
            self.productImageCount = ::std::option::Option::Some(v);
        }

        // optional string firstImageId = 11;

        pub fn firstImageId(&self) -> &str {
            match self.firstImageId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_firstImageId(&mut self) {
            self.firstImageId = ::std::option::Option::None;
        }

        pub fn has_firstImageId(&self) -> bool {
            self.firstImageId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_firstImageId(&mut self, v: ::std::string::String) {
            self.firstImageId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_firstImageId(&mut self) -> &mut ::std::string::String {
            if self.firstImageId.is_none() {
                self.firstImageId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.firstImageId.as_mut().unwrap()
        }

        // Take field
        pub fn take_firstImageId(&mut self) -> ::std::string::String {
            self.firstImageId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int64 salePriceAmount1000 = 12;

        pub fn salePriceAmount1000(&self) -> i64 {
            self.salePriceAmount1000.unwrap_or(0)
        }

        pub fn clear_salePriceAmount1000(&mut self) {
            self.salePriceAmount1000 = ::std::option::Option::None;
        }

        pub fn has_salePriceAmount1000(&self) -> bool {
            self.salePriceAmount1000.is_some()
        }

        // Param is passed by value, moved
        pub fn set_salePriceAmount1000(&mut self, v: i64) {
            self.salePriceAmount1000 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ImageMessage>(
                "productImage",
                |m: &ProductSnapshot| { &m.productImage },
                |m: &mut ProductSnapshot| { &mut m.productImage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "productId",
                |m: &ProductSnapshot| { &m.productId },
                |m: &mut ProductSnapshot| { &mut m.productId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "title",
                |m: &ProductSnapshot| { &m.title },
                |m: &mut ProductSnapshot| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "description",
                |m: &ProductSnapshot| { &m.description },
                |m: &mut ProductSnapshot| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "currencyCode",
                |m: &ProductSnapshot| { &m.currencyCode },
                |m: &mut ProductSnapshot| { &mut m.currencyCode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "priceAmount1000",
                |m: &ProductSnapshot| { &m.priceAmount1000 },
                |m: &mut ProductSnapshot| { &mut m.priceAmount1000 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "retailerId",
                |m: &ProductSnapshot| { &m.retailerId },
                |m: &mut ProductSnapshot| { &mut m.retailerId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &ProductSnapshot| { &m.url },
                |m: &mut ProductSnapshot| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "productImageCount",
                |m: &ProductSnapshot| { &m.productImageCount },
                |m: &mut ProductSnapshot| { &mut m.productImageCount },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "firstImageId",
                |m: &ProductSnapshot| { &m.firstImageId },
                |m: &mut ProductSnapshot| { &mut m.firstImageId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "salePriceAmount1000",
                |m: &ProductSnapshot| { &m.salePriceAmount1000 },
                |m: &mut ProductSnapshot| { &mut m.salePriceAmount1000 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSnapshot>(
                "ProductMessage.ProductSnapshot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProductSnapshot {
        const NAME: &'static str = "ProductSnapshot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.productImage)?;
                    },
                    18 => {
                        self.productId = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.title = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.description = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.currencyCode = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.priceAmount1000 = ::std::option::Option::Some(is.read_int64()?);
                    },
                    58 => {
                        self.retailerId = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.productImageCount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    90 => {
                        self.firstImageId = ::std::option::Option::Some(is.read_string()?);
                    },
                    96 => {
                        self.salePriceAmount1000 = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.productImage.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.productId.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.title.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.description.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.currencyCode.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.priceAmount1000 {
                my_size += ::protobuf::rt::int64_size(6, v);
            }
            if let Some(v) = self.retailerId.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.productImageCount {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.firstImageId.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.salePriceAmount1000 {
                my_size += ::protobuf::rt::int64_size(12, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.productImage.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.productId.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.title.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.description.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.currencyCode.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.priceAmount1000 {
                os.write_int64(6, v)?;
            }
            if let Some(v) = self.retailerId.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.productImageCount {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.firstImageId.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.salePriceAmount1000 {
                os.write_int64(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProductSnapshot {
            ProductSnapshot::new()
        }

        fn clear(&mut self) {
            self.productImage.clear();
            self.productId = ::std::option::Option::None;
            self.title = ::std::option::Option::None;
            self.description = ::std::option::Option::None;
            self.currencyCode = ::std::option::Option::None;
            self.priceAmount1000 = ::std::option::Option::None;
            self.retailerId = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.productImageCount = ::std::option::Option::None;
            self.firstImageId = ::std::option::Option::None;
            self.salePriceAmount1000 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProductSnapshot {
            static instance: ProductSnapshot = ProductSnapshot {
                productImage: ::protobuf::MessageField::none(),
                productId: ::std::option::Option::None,
                title: ::std::option::Option::None,
                description: ::std::option::Option::None,
                currencyCode: ::std::option::Option::None,
                priceAmount1000: ::std::option::Option::None,
                retailerId: ::std::option::Option::None,
                url: ::std::option::Option::None,
                productImageCount: ::std::option::Option::None,
                firstImageId: ::std::option::Option::None,
                salePriceAmount1000: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProductSnapshot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProductMessage.ProductSnapshot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProductSnapshot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProductSnapshot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ProductMessage.CatalogSnapshot)
    pub struct CatalogSnapshot {
        // message fields
        // @@protoc_insertion_point(field:proto.ProductMessage.CatalogSnapshot.catalogImage)
        pub catalogImage: ::protobuf::MessageField<super::ImageMessage>,
        // @@protoc_insertion_point(field:proto.ProductMessage.CatalogSnapshot.title)
        pub title: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ProductMessage.CatalogSnapshot.description)
        pub description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ProductMessage.CatalogSnapshot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CatalogSnapshot {
        fn default() -> &'a CatalogSnapshot {
            <CatalogSnapshot as ::protobuf::Message>::default_instance()
        }
    }

    impl CatalogSnapshot {
        pub fn new() -> CatalogSnapshot {
            ::std::default::Default::default()
        }

        // optional string title = 2;

        pub fn title(&self) -> &str {
            match self.title.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_title(&mut self) {
            self.title = ::std::option::Option::None;
        }

        pub fn has_title(&self) -> bool {
            self.title.is_some()
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            if self.title.is_none() {
                self.title = ::std::option::Option::Some(::std::string::String::new());
            }
            self.title.as_mut().unwrap()
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            self.title.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description = 3;

        pub fn description(&self) -> &str {
            match self.description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description(&mut self) {
            self.description = ::std::option::Option::None;
        }

        pub fn has_description(&self) -> bool {
            self.description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            if self.description.is_none() {
                self.description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description.as_mut().unwrap()
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            self.description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ImageMessage>(
                "catalogImage",
                |m: &CatalogSnapshot| { &m.catalogImage },
                |m: &mut CatalogSnapshot| { &mut m.catalogImage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "title",
                |m: &CatalogSnapshot| { &m.title },
                |m: &mut CatalogSnapshot| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "description",
                |m: &CatalogSnapshot| { &m.description },
                |m: &mut CatalogSnapshot| { &mut m.description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CatalogSnapshot>(
                "ProductMessage.CatalogSnapshot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CatalogSnapshot {
        const NAME: &'static str = "CatalogSnapshot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.catalogImage)?;
                    },
                    18 => {
                        self.title = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.catalogImage.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.title.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.catalogImage.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.title.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CatalogSnapshot {
            CatalogSnapshot::new()
        }

        fn clear(&mut self) {
            self.catalogImage.clear();
            self.title = ::std::option::Option::None;
            self.description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CatalogSnapshot {
            static instance: CatalogSnapshot = CatalogSnapshot {
                catalogImage: ::protobuf::MessageField::none(),
                title: ::std::option::Option::None,
                description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CatalogSnapshot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProductMessage.CatalogSnapshot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CatalogSnapshot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CatalogSnapshot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PollVoteMessage)
pub struct PollVoteMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.PollVoteMessage.selectedOptions)
    pub selectedOptions: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PollVoteMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollVoteMessage {
    fn default() -> &'a PollVoteMessage {
        <PollVoteMessage as ::protobuf::Message>::default_instance()
    }
}

impl PollVoteMessage {
    pub fn new() -> PollVoteMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "selectedOptions",
            |m: &PollVoteMessage| { &m.selectedOptions },
            |m: &mut PollVoteMessage| { &mut m.selectedOptions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollVoteMessage>(
            "PollVoteMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollVoteMessage {
    const NAME: &'static str = "PollVoteMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selectedOptions.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.selectedOptions {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.selectedOptions {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollVoteMessage {
        PollVoteMessage::new()
    }

    fn clear(&mut self) {
        self.selectedOptions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollVoteMessage {
        static instance: PollVoteMessage = PollVoteMessage {
            selectedOptions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollVoteMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollVoteMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollVoteMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollVoteMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PollUpdateMessage)
pub struct PollUpdateMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.PollUpdateMessage.pollCreationMessageKey)
    pub pollCreationMessageKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.PollUpdateMessage.vote)
    pub vote: ::protobuf::MessageField<PollEncValue>,
    // @@protoc_insertion_point(field:proto.PollUpdateMessage.metadata)
    pub metadata: ::protobuf::MessageField<PollUpdateMessageMetadata>,
    // @@protoc_insertion_point(field:proto.PollUpdateMessage.senderTimestampMs)
    pub senderTimestampMs: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PollUpdateMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollUpdateMessage {
    fn default() -> &'a PollUpdateMessage {
        <PollUpdateMessage as ::protobuf::Message>::default_instance()
    }
}

impl PollUpdateMessage {
    pub fn new() -> PollUpdateMessage {
        ::std::default::Default::default()
    }

    // optional int64 senderTimestampMs = 4;

    pub fn senderTimestampMs(&self) -> i64 {
        self.senderTimestampMs.unwrap_or(0)
    }

    pub fn clear_senderTimestampMs(&mut self) {
        self.senderTimestampMs = ::std::option::Option::None;
    }

    pub fn has_senderTimestampMs(&self) -> bool {
        self.senderTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestampMs(&mut self, v: i64) {
        self.senderTimestampMs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "pollCreationMessageKey",
            |m: &PollUpdateMessage| { &m.pollCreationMessageKey },
            |m: &mut PollUpdateMessage| { &mut m.pollCreationMessageKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollEncValue>(
            "vote",
            |m: &PollUpdateMessage| { &m.vote },
            |m: &mut PollUpdateMessage| { &mut m.vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollUpdateMessageMetadata>(
            "metadata",
            |m: &PollUpdateMessage| { &m.metadata },
            |m: &mut PollUpdateMessage| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestampMs",
            |m: &PollUpdateMessage| { &m.senderTimestampMs },
            |m: &mut PollUpdateMessage| { &mut m.senderTimestampMs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollUpdateMessage>(
            "PollUpdateMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollUpdateMessage {
    const NAME: &'static str = "PollUpdateMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pollCreationMessageKey)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vote)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                32 => {
                    self.senderTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pollCreationMessageKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.senderTimestampMs {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pollCreationMessageKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.senderTimestampMs {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollUpdateMessage {
        PollUpdateMessage::new()
    }

    fn clear(&mut self) {
        self.pollCreationMessageKey.clear();
        self.vote.clear();
        self.metadata.clear();
        self.senderTimestampMs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollUpdateMessage {
        static instance: PollUpdateMessage = PollUpdateMessage {
            pollCreationMessageKey: ::protobuf::MessageField::none(),
            vote: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            senderTimestampMs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollUpdateMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollUpdateMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollUpdateMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollUpdateMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PollUpdateMessageMetadata)
pub struct PollUpdateMessageMetadata {
    // special fields
    // @@protoc_insertion_point(special_field:proto.PollUpdateMessageMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollUpdateMessageMetadata {
    fn default() -> &'a PollUpdateMessageMetadata {
        <PollUpdateMessageMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PollUpdateMessageMetadata {
    pub fn new() -> PollUpdateMessageMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollUpdateMessageMetadata>(
            "PollUpdateMessageMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollUpdateMessageMetadata {
    const NAME: &'static str = "PollUpdateMessageMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollUpdateMessageMetadata {
        PollUpdateMessageMetadata::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollUpdateMessageMetadata {
        static instance: PollUpdateMessageMetadata = PollUpdateMessageMetadata {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollUpdateMessageMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollUpdateMessageMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollUpdateMessageMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollUpdateMessageMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PollEncValue)
pub struct PollEncValue {
    // message fields
    // @@protoc_insertion_point(field:proto.PollEncValue.encPayload)
    pub encPayload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.PollEncValue.encIv)
    pub encIv: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PollEncValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollEncValue {
    fn default() -> &'a PollEncValue {
        <PollEncValue as ::protobuf::Message>::default_instance()
    }
}

impl PollEncValue {
    pub fn new() -> PollEncValue {
        ::std::default::Default::default()
    }

    // optional bytes encPayload = 1;

    pub fn encPayload(&self) -> &[u8] {
        match self.encPayload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encPayload(&mut self) {
        self.encPayload = ::std::option::Option::None;
    }

    pub fn has_encPayload(&self) -> bool {
        self.encPayload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encPayload(&mut self, v: ::std::vec::Vec<u8>) {
        self.encPayload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encPayload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encPayload.is_none() {
            self.encPayload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encPayload.as_mut().unwrap()
    }

    // Take field
    pub fn take_encPayload(&mut self) -> ::std::vec::Vec<u8> {
        self.encPayload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes encIv = 2;

    pub fn encIv(&self) -> &[u8] {
        match self.encIv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encIv(&mut self) {
        self.encIv = ::std::option::Option::None;
    }

    pub fn has_encIv(&self) -> bool {
        self.encIv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encIv(&mut self, v: ::std::vec::Vec<u8>) {
        self.encIv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encIv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encIv.is_none() {
            self.encIv = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encIv.as_mut().unwrap()
    }

    // Take field
    pub fn take_encIv(&mut self) -> ::std::vec::Vec<u8> {
        self.encIv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encPayload",
            |m: &PollEncValue| { &m.encPayload },
            |m: &mut PollEncValue| { &mut m.encPayload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encIv",
            |m: &PollEncValue| { &m.encIv },
            |m: &mut PollEncValue| { &mut m.encIv },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollEncValue>(
            "PollEncValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollEncValue {
    const NAME: &'static str = "PollEncValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.encPayload = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.encIv = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encPayload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.encIv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encPayload.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.encIv.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollEncValue {
        PollEncValue::new()
    }

    fn clear(&mut self) {
        self.encPayload = ::std::option::Option::None;
        self.encIv = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollEncValue {
        static instance: PollEncValue = PollEncValue {
            encPayload: ::std::option::Option::None,
            encIv: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollEncValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollEncValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollEncValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollEncValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PollCreationMessage)
pub struct PollCreationMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.PollCreationMessage.encKey)
    pub encKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.PollCreationMessage.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PollCreationMessage.options)
    pub options: ::std::vec::Vec<poll_creation_message::Option>,
    // @@protoc_insertion_point(field:proto.PollCreationMessage.selectableOptionsCount)
    pub selectableOptionsCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.PollCreationMessage.contextInfo)
    pub contextInfo: ::protobuf::MessageField<ContextInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PollCreationMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollCreationMessage {
    fn default() -> &'a PollCreationMessage {
        <PollCreationMessage as ::protobuf::Message>::default_instance()
    }
}

impl PollCreationMessage {
    pub fn new() -> PollCreationMessage {
        ::std::default::Default::default()
    }

    // optional bytes encKey = 1;

    pub fn encKey(&self) -> &[u8] {
        match self.encKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encKey(&mut self) {
        self.encKey = ::std::option::Option::None;
    }

    pub fn has_encKey(&self) -> bool {
        self.encKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.encKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encKey.is_none() {
            self.encKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_encKey(&mut self) -> ::std::vec::Vec<u8> {
        self.encKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 selectableOptionsCount = 4;

    pub fn selectableOptionsCount(&self) -> u32 {
        self.selectableOptionsCount.unwrap_or(0)
    }

    pub fn clear_selectableOptionsCount(&mut self) {
        self.selectableOptionsCount = ::std::option::Option::None;
    }

    pub fn has_selectableOptionsCount(&self) -> bool {
        self.selectableOptionsCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectableOptionsCount(&mut self, v: u32) {
        self.selectableOptionsCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encKey",
            |m: &PollCreationMessage| { &m.encKey },
            |m: &mut PollCreationMessage| { &mut m.encKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PollCreationMessage| { &m.name },
            |m: &mut PollCreationMessage| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &PollCreationMessage| { &m.options },
            |m: &mut PollCreationMessage| { &mut m.options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selectableOptionsCount",
            |m: &PollCreationMessage| { &m.selectableOptionsCount },
            |m: &mut PollCreationMessage| { &mut m.selectableOptionsCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContextInfo>(
            "contextInfo",
            |m: &PollCreationMessage| { &m.contextInfo },
            |m: &mut PollCreationMessage| { &mut m.contextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollCreationMessage>(
            "PollCreationMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollCreationMessage {
    const NAME: &'static str = "PollCreationMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.encKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.options.push(is.read_message()?);
                },
                32 => {
                    self.selectableOptionsCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contextInfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.selectableOptionsCount {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.contextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.options {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.selectableOptionsCount {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.contextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollCreationMessage {
        PollCreationMessage::new()
    }

    fn clear(&mut self) {
        self.encKey = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.options.clear();
        self.selectableOptionsCount = ::std::option::Option::None;
        self.contextInfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollCreationMessage {
        static instance: PollCreationMessage = PollCreationMessage {
            encKey: ::std::option::Option::None,
            name: ::std::option::Option::None,
            options: ::std::vec::Vec::new(),
            selectableOptionsCount: ::std::option::Option::None,
            contextInfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollCreationMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollCreationMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollCreationMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollCreationMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PollCreationMessage`
pub mod poll_creation_message {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.PollCreationMessage.Option)
    pub struct Option {
        // message fields
        // @@protoc_insertion_point(field:proto.PollCreationMessage.Option.optionName)
        pub optionName: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.PollCreationMessage.Option.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Option {
        fn default() -> &'a Option {
            <Option as ::protobuf::Message>::default_instance()
        }
    }

    impl Option {
        pub fn new() -> Option {
            ::std::default::Default::default()
        }

        // optional string optionName = 1;

        pub fn optionName(&self) -> &str {
            match self.optionName.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_optionName(&mut self) {
            self.optionName = ::std::option::Option::None;
        }

        pub fn has_optionName(&self) -> bool {
            self.optionName.is_some()
        }

        // Param is passed by value, moved
        pub fn set_optionName(&mut self, v: ::std::string::String) {
            self.optionName = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_optionName(&mut self) -> &mut ::std::string::String {
            if self.optionName.is_none() {
                self.optionName = ::std::option::Option::Some(::std::string::String::new());
            }
            self.optionName.as_mut().unwrap()
        }

        // Take field
        pub fn take_optionName(&mut self) -> ::std::string::String {
            self.optionName.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "optionName",
                |m: &Option| { &m.optionName },
                |m: &mut Option| { &mut m.optionName },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Option>(
                "PollCreationMessage.Option",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Option {
        const NAME: &'static str = "Option";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.optionName = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.optionName.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.optionName.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Option {
            Option::new()
        }

        fn clear(&mut self) {
            self.optionName = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Option {
            static instance: Option = Option {
                optionName: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Option {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PollCreationMessage.Option").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Option {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Option {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PinMessage)
pub struct PinMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.PinMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.PinMessage.pinMessageType)
    pub pinMessageType: ::std::option::Option<::protobuf::EnumOrUnknown<pin_message::PinMessageType>>,
    // @@protoc_insertion_point(field:proto.PinMessage.senderTimestampMs)
    pub senderTimestampMs: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PinMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PinMessage {
    fn default() -> &'a PinMessage {
        <PinMessage as ::protobuf::Message>::default_instance()
    }
}

impl PinMessage {
    pub fn new() -> PinMessage {
        ::std::default::Default::default()
    }

    // optional .proto.PinMessage.PinMessageType pinMessageType = 2;

    pub fn pinMessageType(&self) -> pin_message::PinMessageType {
        match self.pinMessageType {
            Some(e) => e.enum_value_or(pin_message::PinMessageType::UNKNOWN_PIN_MESSAGE_TYPE),
            None => pin_message::PinMessageType::UNKNOWN_PIN_MESSAGE_TYPE,
        }
    }

    pub fn clear_pinMessageType(&mut self) {
        self.pinMessageType = ::std::option::Option::None;
    }

    pub fn has_pinMessageType(&self) -> bool {
        self.pinMessageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinMessageType(&mut self, v: pin_message::PinMessageType) {
        self.pinMessageType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 senderTimestampMs = 3;

    pub fn senderTimestampMs(&self) -> i64 {
        self.senderTimestampMs.unwrap_or(0)
    }

    pub fn clear_senderTimestampMs(&mut self) {
        self.senderTimestampMs = ::std::option::Option::None;
    }

    pub fn has_senderTimestampMs(&self) -> bool {
        self.senderTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestampMs(&mut self, v: i64) {
        self.senderTimestampMs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &PinMessage| { &m.key },
            |m: &mut PinMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pinMessageType",
            |m: &PinMessage| { &m.pinMessageType },
            |m: &mut PinMessage| { &mut m.pinMessageType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestampMs",
            |m: &PinMessage| { &m.senderTimestampMs },
            |m: &mut PinMessage| { &mut m.senderTimestampMs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PinMessage>(
            "PinMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PinMessage {
    const NAME: &'static str = "PinMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.pinMessageType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.senderTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pinMessageType {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.senderTimestampMs {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.pinMessageType {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.senderTimestampMs {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PinMessage {
        PinMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.pinMessageType = ::std::option::Option::None;
        self.senderTimestampMs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PinMessage {
        static instance: PinMessage = PinMessage {
            key: ::protobuf::MessageField::none(),
            pinMessageType: ::std::option::Option::None,
            senderTimestampMs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PinMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PinMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PinMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PinMessage`
pub mod pin_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.PinMessage.PinMessageType)
    pub enum PinMessageType {
        // @@protoc_insertion_point(enum_value:proto.PinMessage.PinMessageType.UNKNOWN_PIN_MESSAGE_TYPE)
        UNKNOWN_PIN_MESSAGE_TYPE = 0,
        // @@protoc_insertion_point(enum_value:proto.PinMessage.PinMessageType.PIN_FOR_ALL)
        PIN_FOR_ALL = 1,
        // @@protoc_insertion_point(enum_value:proto.PinMessage.PinMessageType.UNPIN_FOR_ALL)
        UNPIN_FOR_ALL = 2,
    }

    impl ::protobuf::Enum for PinMessageType {
        const NAME: &'static str = "PinMessageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PinMessageType> {
            match value {
                0 => ::std::option::Option::Some(PinMessageType::UNKNOWN_PIN_MESSAGE_TYPE),
                1 => ::std::option::Option::Some(PinMessageType::PIN_FOR_ALL),
                2 => ::std::option::Option::Some(PinMessageType::UNPIN_FOR_ALL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PinMessageType] = &[
            PinMessageType::UNKNOWN_PIN_MESSAGE_TYPE,
            PinMessageType::PIN_FOR_ALL,
            PinMessageType::UNPIN_FOR_ALL,
        ];
    }

    impl ::protobuf::EnumFull for PinMessageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PinMessage.PinMessageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for PinMessageType {
        fn default() -> Self {
            PinMessageType::UNKNOWN_PIN_MESSAGE_TYPE
        }
    }

    impl PinMessageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PinMessageType>("PinMessage.PinMessageType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PeerDataOperationRequestResponseMessage)
pub struct PeerDataOperationRequestResponseMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.peerDataOperationRequestType)
    pub peerDataOperationRequestType: ::std::option::Option<::protobuf::EnumOrUnknown<PeerDataOperationRequestType>>,
    // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.stanzaId)
    pub stanzaId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.peerDataOperationResult)
    pub peerDataOperationResult: ::std::vec::Vec<peer_data_operation_request_response_message::PeerDataOperationResult>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PeerDataOperationRequestResponseMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PeerDataOperationRequestResponseMessage {
    fn default() -> &'a PeerDataOperationRequestResponseMessage {
        <PeerDataOperationRequestResponseMessage as ::protobuf::Message>::default_instance()
    }
}

impl PeerDataOperationRequestResponseMessage {
    pub fn new() -> PeerDataOperationRequestResponseMessage {
        ::std::default::Default::default()
    }

    // optional .proto.PeerDataOperationRequestType peerDataOperationRequestType = 1;

    pub fn peerDataOperationRequestType(&self) -> PeerDataOperationRequestType {
        match self.peerDataOperationRequestType {
            Some(e) => e.enum_value_or(PeerDataOperationRequestType::UPLOAD_STICKER),
            None => PeerDataOperationRequestType::UPLOAD_STICKER,
        }
    }

    pub fn clear_peerDataOperationRequestType(&mut self) {
        self.peerDataOperationRequestType = ::std::option::Option::None;
    }

    pub fn has_peerDataOperationRequestType(&self) -> bool {
        self.peerDataOperationRequestType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peerDataOperationRequestType(&mut self, v: PeerDataOperationRequestType) {
        self.peerDataOperationRequestType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string stanzaId = 2;

    pub fn stanzaId(&self) -> &str {
        match self.stanzaId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stanzaId(&mut self) {
        self.stanzaId = ::std::option::Option::None;
    }

    pub fn has_stanzaId(&self) -> bool {
        self.stanzaId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stanzaId(&mut self, v: ::std::string::String) {
        self.stanzaId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stanzaId(&mut self) -> &mut ::std::string::String {
        if self.stanzaId.is_none() {
            self.stanzaId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stanzaId.as_mut().unwrap()
    }

    // Take field
    pub fn take_stanzaId(&mut self) -> ::std::string::String {
        self.stanzaId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "peerDataOperationRequestType",
            |m: &PeerDataOperationRequestResponseMessage| { &m.peerDataOperationRequestType },
            |m: &mut PeerDataOperationRequestResponseMessage| { &mut m.peerDataOperationRequestType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stanzaId",
            |m: &PeerDataOperationRequestResponseMessage| { &m.stanzaId },
            |m: &mut PeerDataOperationRequestResponseMessage| { &mut m.stanzaId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "peerDataOperationResult",
            |m: &PeerDataOperationRequestResponseMessage| { &m.peerDataOperationResult },
            |m: &mut PeerDataOperationRequestResponseMessage| { &mut m.peerDataOperationResult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerDataOperationRequestResponseMessage>(
            "PeerDataOperationRequestResponseMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PeerDataOperationRequestResponseMessage {
    const NAME: &'static str = "PeerDataOperationRequestResponseMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.peerDataOperationRequestType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.stanzaId = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.peerDataOperationResult.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.peerDataOperationRequestType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.stanzaId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.peerDataOperationResult {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.peerDataOperationRequestType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.stanzaId.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.peerDataOperationResult {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PeerDataOperationRequestResponseMessage {
        PeerDataOperationRequestResponseMessage::new()
    }

    fn clear(&mut self) {
        self.peerDataOperationRequestType = ::std::option::Option::None;
        self.stanzaId = ::std::option::Option::None;
        self.peerDataOperationResult.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PeerDataOperationRequestResponseMessage {
        static instance: PeerDataOperationRequestResponseMessage = PeerDataOperationRequestResponseMessage {
            peerDataOperationRequestType: ::std::option::Option::None,
            stanzaId: ::std::option::Option::None,
            peerDataOperationResult: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PeerDataOperationRequestResponseMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PeerDataOperationRequestResponseMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PeerDataOperationRequestResponseMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PeerDataOperationRequestResponseMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PeerDataOperationRequestResponseMessage`
pub mod peer_data_operation_request_response_message {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult)
    pub struct PeerDataOperationResult {
        // message fields
        // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.mediaUploadResult)
        pub mediaUploadResult: ::std::option::Option<::protobuf::EnumOrUnknown<super::media_retry_notification::ResultType>>,
        // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.stickerMessage)
        pub stickerMessage: ::protobuf::MessageField<super::StickerMessage>,
        // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.linkPreviewResponse)
        pub linkPreviewResponse: ::protobuf::MessageField<peer_data_operation_result::LinkPreviewResponse>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PeerDataOperationResult {
        fn default() -> &'a PeerDataOperationResult {
            <PeerDataOperationResult as ::protobuf::Message>::default_instance()
        }
    }

    impl PeerDataOperationResult {
        pub fn new() -> PeerDataOperationResult {
            ::std::default::Default::default()
        }

        // optional .proto.MediaRetryNotification.ResultType mediaUploadResult = 1;

        pub fn mediaUploadResult(&self) -> super::media_retry_notification::ResultType {
            match self.mediaUploadResult {
                Some(e) => e.enum_value_or(super::media_retry_notification::ResultType::GENERAL_ERROR),
                None => super::media_retry_notification::ResultType::GENERAL_ERROR,
            }
        }

        pub fn clear_mediaUploadResult(&mut self) {
            self.mediaUploadResult = ::std::option::Option::None;
        }

        pub fn has_mediaUploadResult(&self) -> bool {
            self.mediaUploadResult.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mediaUploadResult(&mut self, v: super::media_retry_notification::ResultType) {
            self.mediaUploadResult = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mediaUploadResult",
                |m: &PeerDataOperationResult| { &m.mediaUploadResult },
                |m: &mut PeerDataOperationResult| { &mut m.mediaUploadResult },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::StickerMessage>(
                "stickerMessage",
                |m: &PeerDataOperationResult| { &m.stickerMessage },
                |m: &mut PeerDataOperationResult| { &mut m.stickerMessage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, peer_data_operation_result::LinkPreviewResponse>(
                "linkPreviewResponse",
                |m: &PeerDataOperationResult| { &m.linkPreviewResponse },
                |m: &mut PeerDataOperationResult| { &mut m.linkPreviewResponse },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PeerDataOperationResult>(
                "PeerDataOperationRequestResponseMessage.PeerDataOperationResult",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PeerDataOperationResult {
        const NAME: &'static str = "PeerDataOperationResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.mediaUploadResult = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.stickerMessage)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.linkPreviewResponse)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.mediaUploadResult {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.stickerMessage.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.linkPreviewResponse.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.mediaUploadResult {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.stickerMessage.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.linkPreviewResponse.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PeerDataOperationResult {
            PeerDataOperationResult::new()
        }

        fn clear(&mut self) {
            self.mediaUploadResult = ::std::option::Option::None;
            self.stickerMessage.clear();
            self.linkPreviewResponse.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PeerDataOperationResult {
            static instance: PeerDataOperationResult = PeerDataOperationResult {
                mediaUploadResult: ::std::option::Option::None,
                stickerMessage: ::protobuf::MessageField::none(),
                linkPreviewResponse: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PeerDataOperationResult {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PeerDataOperationRequestResponseMessage.PeerDataOperationResult").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PeerDataOperationResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PeerDataOperationResult {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `PeerDataOperationResult`
    pub mod peer_data_operation_result {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse)
        pub struct LinkPreviewResponse {
            // message fields
            // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.url)
            pub url: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.title)
            pub title: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.description)
            pub description: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.thumbData)
            pub thumbData: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.canonicalUrl)
            pub canonicalUrl: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.matchText)
            pub matchText: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.previewType)
            pub previewType: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a LinkPreviewResponse {
            fn default() -> &'a LinkPreviewResponse {
                <LinkPreviewResponse as ::protobuf::Message>::default_instance()
            }
        }

        impl LinkPreviewResponse {
            pub fn new() -> LinkPreviewResponse {
                ::std::default::Default::default()
            }

            // optional string url = 1;

            pub fn url(&self) -> &str {
                match self.url.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_url(&mut self) {
                self.url = ::std::option::Option::None;
            }

            pub fn has_url(&self) -> bool {
                self.url.is_some()
            }

            // Param is passed by value, moved
            pub fn set_url(&mut self, v: ::std::string::String) {
                self.url = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_url(&mut self) -> &mut ::std::string::String {
                if self.url.is_none() {
                    self.url = ::std::option::Option::Some(::std::string::String::new());
                }
                self.url.as_mut().unwrap()
            }

            // Take field
            pub fn take_url(&mut self) -> ::std::string::String {
                self.url.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string title = 2;

            pub fn title(&self) -> &str {
                match self.title.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_title(&mut self) {
                self.title = ::std::option::Option::None;
            }

            pub fn has_title(&self) -> bool {
                self.title.is_some()
            }

            // Param is passed by value, moved
            pub fn set_title(&mut self, v: ::std::string::String) {
                self.title = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_title(&mut self) -> &mut ::std::string::String {
                if self.title.is_none() {
                    self.title = ::std::option::Option::Some(::std::string::String::new());
                }
                self.title.as_mut().unwrap()
            }

            // Take field
            pub fn take_title(&mut self) -> ::std::string::String {
                self.title.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string description = 3;

            pub fn description(&self) -> &str {
                match self.description.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_description(&mut self) {
                self.description = ::std::option::Option::None;
            }

            pub fn has_description(&self) -> bool {
                self.description.is_some()
            }

            // Param is passed by value, moved
            pub fn set_description(&mut self, v: ::std::string::String) {
                self.description = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_description(&mut self) -> &mut ::std::string::String {
                if self.description.is_none() {
                    self.description = ::std::option::Option::Some(::std::string::String::new());
                }
                self.description.as_mut().unwrap()
            }

            // Take field
            pub fn take_description(&mut self) -> ::std::string::String {
                self.description.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional bytes thumbData = 4;

            pub fn thumbData(&self) -> &[u8] {
                match self.thumbData.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_thumbData(&mut self) {
                self.thumbData = ::std::option::Option::None;
            }

            pub fn has_thumbData(&self) -> bool {
                self.thumbData.is_some()
            }

            // Param is passed by value, moved
            pub fn set_thumbData(&mut self, v: ::std::vec::Vec<u8>) {
                self.thumbData = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_thumbData(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.thumbData.is_none() {
                    self.thumbData = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.thumbData.as_mut().unwrap()
            }

            // Take field
            pub fn take_thumbData(&mut self) -> ::std::vec::Vec<u8> {
                self.thumbData.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // optional string canonicalUrl = 5;

            pub fn canonicalUrl(&self) -> &str {
                match self.canonicalUrl.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_canonicalUrl(&mut self) {
                self.canonicalUrl = ::std::option::Option::None;
            }

            pub fn has_canonicalUrl(&self) -> bool {
                self.canonicalUrl.is_some()
            }

            // Param is passed by value, moved
            pub fn set_canonicalUrl(&mut self, v: ::std::string::String) {
                self.canonicalUrl = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_canonicalUrl(&mut self) -> &mut ::std::string::String {
                if self.canonicalUrl.is_none() {
                    self.canonicalUrl = ::std::option::Option::Some(::std::string::String::new());
                }
                self.canonicalUrl.as_mut().unwrap()
            }

            // Take field
            pub fn take_canonicalUrl(&mut self) -> ::std::string::String {
                self.canonicalUrl.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string matchText = 6;

            pub fn matchText(&self) -> &str {
                match self.matchText.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_matchText(&mut self) {
                self.matchText = ::std::option::Option::None;
            }

            pub fn has_matchText(&self) -> bool {
                self.matchText.is_some()
            }

            // Param is passed by value, moved
            pub fn set_matchText(&mut self, v: ::std::string::String) {
                self.matchText = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_matchText(&mut self) -> &mut ::std::string::String {
                if self.matchText.is_none() {
                    self.matchText = ::std::option::Option::Some(::std::string::String::new());
                }
                self.matchText.as_mut().unwrap()
            }

            // Take field
            pub fn take_matchText(&mut self) -> ::std::string::String {
                self.matchText.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string previewType = 7;

            pub fn previewType(&self) -> &str {
                match self.previewType.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_previewType(&mut self) {
                self.previewType = ::std::option::Option::None;
            }

            pub fn has_previewType(&self) -> bool {
                self.previewType.is_some()
            }

            // Param is passed by value, moved
            pub fn set_previewType(&mut self, v: ::std::string::String) {
                self.previewType = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_previewType(&mut self) -> &mut ::std::string::String {
                if self.previewType.is_none() {
                    self.previewType = ::std::option::Option::Some(::std::string::String::new());
                }
                self.previewType.as_mut().unwrap()
            }

            // Take field
            pub fn take_previewType(&mut self) -> ::std::string::String {
                self.previewType.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(7);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "url",
                    |m: &LinkPreviewResponse| { &m.url },
                    |m: &mut LinkPreviewResponse| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "title",
                    |m: &LinkPreviewResponse| { &m.title },
                    |m: &mut LinkPreviewResponse| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "description",
                    |m: &LinkPreviewResponse| { &m.description },
                    |m: &mut LinkPreviewResponse| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "thumbData",
                    |m: &LinkPreviewResponse| { &m.thumbData },
                    |m: &mut LinkPreviewResponse| { &mut m.thumbData },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "canonicalUrl",
                    |m: &LinkPreviewResponse| { &m.canonicalUrl },
                    |m: &mut LinkPreviewResponse| { &mut m.canonicalUrl },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "matchText",
                    |m: &LinkPreviewResponse| { &m.matchText },
                    |m: &mut LinkPreviewResponse| { &mut m.matchText },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "previewType",
                    |m: &LinkPreviewResponse| { &m.previewType },
                    |m: &mut LinkPreviewResponse| { &mut m.previewType },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkPreviewResponse>(
                    "PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for LinkPreviewResponse {
            const NAME: &'static str = "LinkPreviewResponse";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.url = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.title = ::std::option::Option::Some(is.read_string()?);
                        },
                        26 => {
                            self.description = ::std::option::Option::Some(is.read_string()?);
                        },
                        34 => {
                            self.thumbData = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        42 => {
                            self.canonicalUrl = ::std::option::Option::Some(is.read_string()?);
                        },
                        50 => {
                            self.matchText = ::std::option::Option::Some(is.read_string()?);
                        },
                        58 => {
                            self.previewType = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.url.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.title.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                if let Some(v) = self.description.as_ref() {
                    my_size += ::protobuf::rt::string_size(3, &v);
                }
                if let Some(v) = self.thumbData.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                }
                if let Some(v) = self.canonicalUrl.as_ref() {
                    my_size += ::protobuf::rt::string_size(5, &v);
                }
                if let Some(v) = self.matchText.as_ref() {
                    my_size += ::protobuf::rt::string_size(6, &v);
                }
                if let Some(v) = self.previewType.as_ref() {
                    my_size += ::protobuf::rt::string_size(7, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.url.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.title.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.description.as_ref() {
                    os.write_string(3, v)?;
                }
                if let Some(v) = self.thumbData.as_ref() {
                    os.write_bytes(4, v)?;
                }
                if let Some(v) = self.canonicalUrl.as_ref() {
                    os.write_string(5, v)?;
                }
                if let Some(v) = self.matchText.as_ref() {
                    os.write_string(6, v)?;
                }
                if let Some(v) = self.previewType.as_ref() {
                    os.write_string(7, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> LinkPreviewResponse {
                LinkPreviewResponse::new()
            }

            fn clear(&mut self) {
                self.url = ::std::option::Option::None;
                self.title = ::std::option::Option::None;
                self.description = ::std::option::Option::None;
                self.thumbData = ::std::option::Option::None;
                self.canonicalUrl = ::std::option::Option::None;
                self.matchText = ::std::option::Option::None;
                self.previewType = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static LinkPreviewResponse {
                static instance: LinkPreviewResponse = LinkPreviewResponse {
                    url: ::std::option::Option::None,
                    title: ::std::option::Option::None,
                    description: ::std::option::Option::None,
                    thumbData: ::std::option::Option::None,
                    canonicalUrl: ::std::option::Option::None,
                    matchText: ::std::option::Option::None,
                    previewType: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for LinkPreviewResponse {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("PeerDataOperationRequestResponseMessage.PeerDataOperationResult.LinkPreviewResponse").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for LinkPreviewResponse {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for LinkPreviewResponse {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.EphemeralSetting)
pub struct EphemeralSetting {
    // message fields
    // @@protoc_insertion_point(field:proto.EphemeralSetting.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.EphemeralSetting.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.EphemeralSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EphemeralSetting {
    fn default() -> &'a EphemeralSetting {
        <EphemeralSetting as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralSetting {
    pub fn new() -> EphemeralSetting {
        ::std::default::Default::default()
    }

    // optional sfixed32 duration = 1;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional sfixed64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &EphemeralSetting| { &m.duration },
            |m: &mut EphemeralSetting| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &EphemeralSetting| { &m.timestamp },
            |m: &mut EphemeralSetting| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EphemeralSetting>(
            "EphemeralSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EphemeralSetting {
    const NAME: &'static str = "EphemeralSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.duration = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                17 => {
                    self.timestamp = ::std::option::Option::Some(is.read_sfixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_sfixed32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_sfixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EphemeralSetting {
        EphemeralSetting::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EphemeralSetting {
        static instance: EphemeralSetting = EphemeralSetting {
            duration: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EphemeralSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EphemeralSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EphemeralSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.WallpaperSettings)
pub struct WallpaperSettings {
    // message fields
    // @@protoc_insertion_point(field:proto.WallpaperSettings.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WallpaperSettings.opacity)
    pub opacity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.WallpaperSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WallpaperSettings {
    fn default() -> &'a WallpaperSettings {
        <WallpaperSettings as ::protobuf::Message>::default_instance()
    }
}

impl WallpaperSettings {
    pub fn new() -> WallpaperSettings {
        ::std::default::Default::default()
    }

    // optional string filename = 1;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 opacity = 2;

    pub fn opacity(&self) -> u32 {
        self.opacity.unwrap_or(0)
    }

    pub fn clear_opacity(&mut self) {
        self.opacity = ::std::option::Option::None;
    }

    pub fn has_opacity(&self) -> bool {
        self.opacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_opacity(&mut self, v: u32) {
        self.opacity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &WallpaperSettings| { &m.filename },
            |m: &mut WallpaperSettings| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "opacity",
            |m: &WallpaperSettings| { &m.opacity },
            |m: &mut WallpaperSettings| { &mut m.opacity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WallpaperSettings>(
            "WallpaperSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WallpaperSettings {
    const NAME: &'static str = "WallpaperSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.opacity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.opacity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filename.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.opacity {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WallpaperSettings {
        WallpaperSettings::new()
    }

    fn clear(&mut self) {
        self.filename = ::std::option::Option::None;
        self.opacity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WallpaperSettings {
        static instance: WallpaperSettings = WallpaperSettings {
            filename: ::std::option::Option::None,
            opacity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WallpaperSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WallpaperSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WallpaperSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WallpaperSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.StickerMetadata)
pub struct StickerMetadata {
    // message fields
    // @@protoc_insertion_point(field:proto.StickerMetadata.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.weight)
    pub weight: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:proto.StickerMetadata.lastStickerSentTs)
    pub lastStickerSentTs: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.StickerMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StickerMetadata {
    fn default() -> &'a StickerMetadata {
        <StickerMetadata as ::protobuf::Message>::default_instance()
    }
}

impl StickerMetadata {
    pub fn new() -> StickerMetadata {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileSha256 = 2;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 3;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mediaKey = 4;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string mimetype = 5;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 height = 6;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 7;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional string directPath = 8;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileLength = 9;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional float weight = 10;

    pub fn weight(&self) -> f32 {
        self.weight.unwrap_or(0.)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: f32) {
        self.weight = ::std::option::Option::Some(v);
    }

    // optional int64 lastStickerSentTs = 11;

    pub fn lastStickerSentTs(&self) -> i64 {
        self.lastStickerSentTs.unwrap_or(0)
    }

    pub fn clear_lastStickerSentTs(&mut self) {
        self.lastStickerSentTs = ::std::option::Option::None;
    }

    pub fn has_lastStickerSentTs(&self) -> bool {
        self.lastStickerSentTs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastStickerSentTs(&mut self, v: i64) {
        self.lastStickerSentTs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &StickerMetadata| { &m.url },
            |m: &mut StickerMetadata| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &StickerMetadata| { &m.fileSha256 },
            |m: &mut StickerMetadata| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &StickerMetadata| { &m.fileEncSha256 },
            |m: &mut StickerMetadata| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &StickerMetadata| { &m.mediaKey },
            |m: &mut StickerMetadata| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &StickerMetadata| { &m.mimetype },
            |m: &mut StickerMetadata| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &StickerMetadata| { &m.height },
            |m: &mut StickerMetadata| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &StickerMetadata| { &m.width },
            |m: &mut StickerMetadata| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &StickerMetadata| { &m.directPath },
            |m: &mut StickerMetadata| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &StickerMetadata| { &m.fileLength },
            |m: &mut StickerMetadata| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &StickerMetadata| { &m.weight },
            |m: &mut StickerMetadata| { &mut m.weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastStickerSentTs",
            |m: &StickerMetadata| { &m.lastStickerSentTs },
            |m: &mut StickerMetadata| { &mut m.lastStickerSentTs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StickerMetadata>(
            "StickerMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StickerMetadata {
    const NAME: &'static str = "StickerMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                85 => {
                    self.weight = ::std::option::Option::Some(is.read_float()?);
                },
                88 => {
                    self.lastStickerSentTs = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.weight {
            my_size += 1 + 4;
        }
        if let Some(v) = self.lastStickerSentTs {
            my_size += ::protobuf::rt::int64_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.weight {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.lastStickerSentTs {
            os.write_int64(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StickerMetadata {
        StickerMetadata::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.weight = ::std::option::Option::None;
        self.lastStickerSentTs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StickerMetadata {
        static instance: StickerMetadata = StickerMetadata {
            url: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            height: ::std::option::Option::None,
            width: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            weight: ::std::option::Option::None,
            lastStickerSentTs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StickerMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StickerMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StickerMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StickerMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Pushname)
pub struct Pushname {
    // message fields
    // @@protoc_insertion_point(field:proto.Pushname.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Pushname.pushname)
    pub pushname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Pushname.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pushname {
    fn default() -> &'a Pushname {
        <Pushname as ::protobuf::Message>::default_instance()
    }
}

impl Pushname {
    pub fn new() -> Pushname {
        ::std::default::Default::default()
    }

    // optional string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pushname = 2;

    pub fn pushname(&self) -> &str {
        match self.pushname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pushname(&mut self) {
        self.pushname = ::std::option::Option::None;
    }

    pub fn has_pushname(&self) -> bool {
        self.pushname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pushname(&mut self, v: ::std::string::String) {
        self.pushname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pushname(&mut self) -> &mut ::std::string::String {
        if self.pushname.is_none() {
            self.pushname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pushname.as_mut().unwrap()
    }

    // Take field
    pub fn take_pushname(&mut self) -> ::std::string::String {
        self.pushname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Pushname| { &m.id },
            |m: &mut Pushname| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pushname",
            |m: &Pushname| { &m.pushname },
            |m: &mut Pushname| { &mut m.pushname },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pushname>(
            "Pushname",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pushname {
    const NAME: &'static str = "Pushname";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.pushname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pushname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pushname.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pushname {
        Pushname::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.pushname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pushname {
        static instance: Pushname = Pushname {
            id: ::std::option::Option::None,
            pushname: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pushname {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pushname").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pushname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pushname {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PastParticipants)
pub struct PastParticipants {
    // message fields
    // @@protoc_insertion_point(field:proto.PastParticipants.groupJid)
    pub groupJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PastParticipants.pastParticipants)
    pub pastParticipants: ::std::vec::Vec<PastParticipant>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PastParticipants.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PastParticipants {
    fn default() -> &'a PastParticipants {
        <PastParticipants as ::protobuf::Message>::default_instance()
    }
}

impl PastParticipants {
    pub fn new() -> PastParticipants {
        ::std::default::Default::default()
    }

    // optional string groupJid = 1;

    pub fn groupJid(&self) -> &str {
        match self.groupJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupJid(&mut self) {
        self.groupJid = ::std::option::Option::None;
    }

    pub fn has_groupJid(&self) -> bool {
        self.groupJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupJid(&mut self, v: ::std::string::String) {
        self.groupJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupJid(&mut self) -> &mut ::std::string::String {
        if self.groupJid.is_none() {
            self.groupJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupJid(&mut self) -> ::std::string::String {
        self.groupJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupJid",
            |m: &PastParticipants| { &m.groupJid },
            |m: &mut PastParticipants| { &mut m.groupJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pastParticipants",
            |m: &PastParticipants| { &m.pastParticipants },
            |m: &mut PastParticipants| { &mut m.pastParticipants },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PastParticipants>(
            "PastParticipants",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PastParticipants {
    const NAME: &'static str = "PastParticipants";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groupJid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.pastParticipants.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.pastParticipants {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupJid.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.pastParticipants {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PastParticipants {
        PastParticipants::new()
    }

    fn clear(&mut self) {
        self.groupJid = ::std::option::Option::None;
        self.pastParticipants.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PastParticipants {
        static instance: PastParticipants = PastParticipants {
            groupJid: ::std::option::Option::None,
            pastParticipants: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PastParticipants {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PastParticipants").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PastParticipants {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PastParticipants {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PastParticipant)
pub struct PastParticipant {
    // message fields
    // @@protoc_insertion_point(field:proto.PastParticipant.userJid)
    pub userJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PastParticipant.leaveReason)
    pub leaveReason: ::std::option::Option<::protobuf::EnumOrUnknown<past_participant::LeaveReason>>,
    // @@protoc_insertion_point(field:proto.PastParticipant.leaveTs)
    pub leaveTs: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PastParticipant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PastParticipant {
    fn default() -> &'a PastParticipant {
        <PastParticipant as ::protobuf::Message>::default_instance()
    }
}

impl PastParticipant {
    pub fn new() -> PastParticipant {
        ::std::default::Default::default()
    }

    // optional string userJid = 1;

    pub fn userJid(&self) -> &str {
        match self.userJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_userJid(&mut self) {
        self.userJid = ::std::option::Option::None;
    }

    pub fn has_userJid(&self) -> bool {
        self.userJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userJid(&mut self, v: ::std::string::String) {
        self.userJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userJid(&mut self) -> &mut ::std::string::String {
        if self.userJid.is_none() {
            self.userJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.userJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_userJid(&mut self) -> ::std::string::String {
        self.userJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.PastParticipant.LeaveReason leaveReason = 2;

    pub fn leaveReason(&self) -> past_participant::LeaveReason {
        match self.leaveReason {
            Some(e) => e.enum_value_or(past_participant::LeaveReason::LEFT),
            None => past_participant::LeaveReason::LEFT,
        }
    }

    pub fn clear_leaveReason(&mut self) {
        self.leaveReason = ::std::option::Option::None;
    }

    pub fn has_leaveReason(&self) -> bool {
        self.leaveReason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaveReason(&mut self, v: past_participant::LeaveReason) {
        self.leaveReason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 leaveTs = 3;

    pub fn leaveTs(&self) -> u64 {
        self.leaveTs.unwrap_or(0)
    }

    pub fn clear_leaveTs(&mut self) {
        self.leaveTs = ::std::option::Option::None;
    }

    pub fn has_leaveTs(&self) -> bool {
        self.leaveTs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaveTs(&mut self, v: u64) {
        self.leaveTs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userJid",
            |m: &PastParticipant| { &m.userJid },
            |m: &mut PastParticipant| { &mut m.userJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaveReason",
            |m: &PastParticipant| { &m.leaveReason },
            |m: &mut PastParticipant| { &mut m.leaveReason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaveTs",
            |m: &PastParticipant| { &m.leaveTs },
            |m: &mut PastParticipant| { &mut m.leaveTs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PastParticipant>(
            "PastParticipant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PastParticipant {
    const NAME: &'static str = "PastParticipant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.userJid = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.leaveReason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.leaveTs = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.userJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.leaveReason {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.leaveTs {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.userJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.leaveReason {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.leaveTs {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PastParticipant {
        PastParticipant::new()
    }

    fn clear(&mut self) {
        self.userJid = ::std::option::Option::None;
        self.leaveReason = ::std::option::Option::None;
        self.leaveTs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PastParticipant {
        static instance: PastParticipant = PastParticipant {
            userJid: ::std::option::Option::None,
            leaveReason: ::std::option::Option::None,
            leaveTs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PastParticipant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PastParticipant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PastParticipant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PastParticipant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PastParticipant`
pub mod past_participant {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.PastParticipant.LeaveReason)
    pub enum LeaveReason {
        // @@protoc_insertion_point(enum_value:proto.PastParticipant.LeaveReason.LEFT)
        LEFT = 0,
        // @@protoc_insertion_point(enum_value:proto.PastParticipant.LeaveReason.REMOVED)
        REMOVED = 1,
    }

    impl ::protobuf::Enum for LeaveReason {
        const NAME: &'static str = "LeaveReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LeaveReason> {
            match value {
                0 => ::std::option::Option::Some(LeaveReason::LEFT),
                1 => ::std::option::Option::Some(LeaveReason::REMOVED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [LeaveReason] = &[
            LeaveReason::LEFT,
            LeaveReason::REMOVED,
        ];
    }

    impl ::protobuf::EnumFull for LeaveReason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PastParticipant.LeaveReason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for LeaveReason {
        fn default() -> Self {
            LeaveReason::LEFT
        }
    }

    impl LeaveReason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LeaveReason>("PastParticipant.LeaveReason")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HistorySync)
pub struct HistorySync {
    // message fields
    // @@protoc_insertion_point(field:proto.HistorySync.syncType)
    pub syncType: ::std::option::Option<::protobuf::EnumOrUnknown<history_sync::HistorySyncType>>,
    // @@protoc_insertion_point(field:proto.HistorySync.conversations)
    pub conversations: ::std::vec::Vec<Conversation>,
    // @@protoc_insertion_point(field:proto.HistorySync.statusV3Messages)
    pub statusV3Messages: ::std::vec::Vec<WebMessageInfo>,
    // @@protoc_insertion_point(field:proto.HistorySync.chunkOrder)
    pub chunkOrder: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.HistorySync.progress)
    pub progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.HistorySync.pushnames)
    pub pushnames: ::std::vec::Vec<Pushname>,
    // @@protoc_insertion_point(field:proto.HistorySync.globalSettings)
    pub globalSettings: ::protobuf::MessageField<GlobalSettings>,
    // @@protoc_insertion_point(field:proto.HistorySync.threadIdUserSecret)
    pub threadIdUserSecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HistorySync.threadDsTimeframeOffset)
    pub threadDsTimeframeOffset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.HistorySync.recentStickers)
    pub recentStickers: ::std::vec::Vec<StickerMetadata>,
    // @@protoc_insertion_point(field:proto.HistorySync.pastParticipants)
    pub pastParticipants: ::std::vec::Vec<PastParticipants>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HistorySync.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HistorySync {
    fn default() -> &'a HistorySync {
        <HistorySync as ::protobuf::Message>::default_instance()
    }
}

impl HistorySync {
    pub fn new() -> HistorySync {
        ::std::default::Default::default()
    }

    // required .proto.HistorySync.HistorySyncType syncType = 1;

    pub fn syncType(&self) -> history_sync::HistorySyncType {
        match self.syncType {
            Some(e) => e.enum_value_or(history_sync::HistorySyncType::INITIAL_BOOTSTRAP),
            None => history_sync::HistorySyncType::INITIAL_BOOTSTRAP,
        }
    }

    pub fn clear_syncType(&mut self) {
        self.syncType = ::std::option::Option::None;
    }

    pub fn has_syncType(&self) -> bool {
        self.syncType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncType(&mut self, v: history_sync::HistorySyncType) {
        self.syncType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 chunkOrder = 5;

    pub fn chunkOrder(&self) -> u32 {
        self.chunkOrder.unwrap_or(0)
    }

    pub fn clear_chunkOrder(&mut self) {
        self.chunkOrder = ::std::option::Option::None;
    }

    pub fn has_chunkOrder(&self) -> bool {
        self.chunkOrder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunkOrder(&mut self, v: u32) {
        self.chunkOrder = ::std::option::Option::Some(v);
    }

    // optional uint32 progress = 6;

    pub fn progress(&self) -> u32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: u32) {
        self.progress = ::std::option::Option::Some(v);
    }

    // optional bytes threadIdUserSecret = 9;

    pub fn threadIdUserSecret(&self) -> &[u8] {
        match self.threadIdUserSecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_threadIdUserSecret(&mut self) {
        self.threadIdUserSecret = ::std::option::Option::None;
    }

    pub fn has_threadIdUserSecret(&self) -> bool {
        self.threadIdUserSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threadIdUserSecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.threadIdUserSecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_threadIdUserSecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.threadIdUserSecret.is_none() {
            self.threadIdUserSecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.threadIdUserSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_threadIdUserSecret(&mut self) -> ::std::vec::Vec<u8> {
        self.threadIdUserSecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 threadDsTimeframeOffset = 10;

    pub fn threadDsTimeframeOffset(&self) -> u32 {
        self.threadDsTimeframeOffset.unwrap_or(0)
    }

    pub fn clear_threadDsTimeframeOffset(&mut self) {
        self.threadDsTimeframeOffset = ::std::option::Option::None;
    }

    pub fn has_threadDsTimeframeOffset(&self) -> bool {
        self.threadDsTimeframeOffset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threadDsTimeframeOffset(&mut self, v: u32) {
        self.threadDsTimeframeOffset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "syncType",
            |m: &HistorySync| { &m.syncType },
            |m: &mut HistorySync| { &mut m.syncType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conversations",
            |m: &HistorySync| { &m.conversations },
            |m: &mut HistorySync| { &mut m.conversations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "statusV3Messages",
            |m: &HistorySync| { &m.statusV3Messages },
            |m: &mut HistorySync| { &mut m.statusV3Messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chunkOrder",
            |m: &HistorySync| { &m.chunkOrder },
            |m: &mut HistorySync| { &mut m.chunkOrder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &HistorySync| { &m.progress },
            |m: &mut HistorySync| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pushnames",
            |m: &HistorySync| { &m.pushnames },
            |m: &mut HistorySync| { &mut m.pushnames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GlobalSettings>(
            "globalSettings",
            |m: &HistorySync| { &m.globalSettings },
            |m: &mut HistorySync| { &mut m.globalSettings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "threadIdUserSecret",
            |m: &HistorySync| { &m.threadIdUserSecret },
            |m: &mut HistorySync| { &mut m.threadIdUserSecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "threadDsTimeframeOffset",
            |m: &HistorySync| { &m.threadDsTimeframeOffset },
            |m: &mut HistorySync| { &mut m.threadDsTimeframeOffset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "recentStickers",
            |m: &HistorySync| { &m.recentStickers },
            |m: &mut HistorySync| { &mut m.recentStickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pastParticipants",
            |m: &HistorySync| { &m.pastParticipants },
            |m: &mut HistorySync| { &mut m.pastParticipants },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistorySync>(
            "HistorySync",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HistorySync {
    const NAME: &'static str = "HistorySync";

    fn is_initialized(&self) -> bool {
        if self.syncType.is_none() {
            return false;
        }
        for v in &self.conversations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statusV3Messages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pushnames {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.globalSettings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recentStickers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pastParticipants {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.syncType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.conversations.push(is.read_message()?);
                },
                26 => {
                    self.statusV3Messages.push(is.read_message()?);
                },
                40 => {
                    self.chunkOrder = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.pushnames.push(is.read_message()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.globalSettings)?;
                },
                74 => {
                    self.threadIdUserSecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                80 => {
                    self.threadDsTimeframeOffset = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.recentStickers.push(is.read_message()?);
                },
                98 => {
                    self.pastParticipants.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.syncType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.conversations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.statusV3Messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.chunkOrder {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.pushnames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.globalSettings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.threadIdUserSecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.threadDsTimeframeOffset {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        for value in &self.recentStickers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pastParticipants {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.syncType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.conversations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.statusV3Messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.chunkOrder {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.progress {
            os.write_uint32(6, v)?;
        }
        for v in &self.pushnames {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.globalSettings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.threadIdUserSecret.as_ref() {
            os.write_bytes(9, v)?;
        }
        if let Some(v) = self.threadDsTimeframeOffset {
            os.write_uint32(10, v)?;
        }
        for v in &self.recentStickers {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        for v in &self.pastParticipants {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HistorySync {
        HistorySync::new()
    }

    fn clear(&mut self) {
        self.syncType = ::std::option::Option::None;
        self.conversations.clear();
        self.statusV3Messages.clear();
        self.chunkOrder = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.pushnames.clear();
        self.globalSettings.clear();
        self.threadIdUserSecret = ::std::option::Option::None;
        self.threadDsTimeframeOffset = ::std::option::Option::None;
        self.recentStickers.clear();
        self.pastParticipants.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HistorySync {
        static instance: HistorySync = HistorySync {
            syncType: ::std::option::Option::None,
            conversations: ::std::vec::Vec::new(),
            statusV3Messages: ::std::vec::Vec::new(),
            chunkOrder: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            pushnames: ::std::vec::Vec::new(),
            globalSettings: ::protobuf::MessageField::none(),
            threadIdUserSecret: ::std::option::Option::None,
            threadDsTimeframeOffset: ::std::option::Option::None,
            recentStickers: ::std::vec::Vec::new(),
            pastParticipants: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HistorySync {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HistorySync").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HistorySync {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistorySync {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HistorySync`
pub mod history_sync {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.HistorySync.HistorySyncType)
    pub enum HistorySyncType {
        // @@protoc_insertion_point(enum_value:proto.HistorySync.HistorySyncType.INITIAL_BOOTSTRAP)
        INITIAL_BOOTSTRAP = 0,
        // @@protoc_insertion_point(enum_value:proto.HistorySync.HistorySyncType.INITIAL_STATUS_V3)
        INITIAL_STATUS_V3 = 1,
        // @@protoc_insertion_point(enum_value:proto.HistorySync.HistorySyncType.FULL)
        FULL = 2,
        // @@protoc_insertion_point(enum_value:proto.HistorySync.HistorySyncType.RECENT)
        RECENT = 3,
        // @@protoc_insertion_point(enum_value:proto.HistorySync.HistorySyncType.PUSH_NAME)
        PUSH_NAME = 4,
        // @@protoc_insertion_point(enum_value:proto.HistorySync.HistorySyncType.NON_BLOCKING_DATA)
        NON_BLOCKING_DATA = 5,
    }

    impl ::protobuf::Enum for HistorySyncType {
        const NAME: &'static str = "HistorySyncType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HistorySyncType> {
            match value {
                0 => ::std::option::Option::Some(HistorySyncType::INITIAL_BOOTSTRAP),
                1 => ::std::option::Option::Some(HistorySyncType::INITIAL_STATUS_V3),
                2 => ::std::option::Option::Some(HistorySyncType::FULL),
                3 => ::std::option::Option::Some(HistorySyncType::RECENT),
                4 => ::std::option::Option::Some(HistorySyncType::PUSH_NAME),
                5 => ::std::option::Option::Some(HistorySyncType::NON_BLOCKING_DATA),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HistorySyncType] = &[
            HistorySyncType::INITIAL_BOOTSTRAP,
            HistorySyncType::INITIAL_STATUS_V3,
            HistorySyncType::FULL,
            HistorySyncType::RECENT,
            HistorySyncType::PUSH_NAME,
            HistorySyncType::NON_BLOCKING_DATA,
        ];
    }

    impl ::protobuf::EnumFull for HistorySyncType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("HistorySync.HistorySyncType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for HistorySyncType {
        fn default() -> Self {
            HistorySyncType::INITIAL_BOOTSTRAP
        }
    }

    impl HistorySyncType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HistorySyncType>("HistorySync.HistorySyncType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HistorySyncMsg)
pub struct HistorySyncMsg {
    // message fields
    // @@protoc_insertion_point(field:proto.HistorySyncMsg.message)
    pub message: ::protobuf::MessageField<WebMessageInfo>,
    // @@protoc_insertion_point(field:proto.HistorySyncMsg.msgOrderId)
    pub msgOrderId: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HistorySyncMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HistorySyncMsg {
    fn default() -> &'a HistorySyncMsg {
        <HistorySyncMsg as ::protobuf::Message>::default_instance()
    }
}

impl HistorySyncMsg {
    pub fn new() -> HistorySyncMsg {
        ::std::default::Default::default()
    }

    // optional uint64 msgOrderId = 2;

    pub fn msgOrderId(&self) -> u64 {
        self.msgOrderId.unwrap_or(0)
    }

    pub fn clear_msgOrderId(&mut self) {
        self.msgOrderId = ::std::option::Option::None;
    }

    pub fn has_msgOrderId(&self) -> bool {
        self.msgOrderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgOrderId(&mut self, v: u64) {
        self.msgOrderId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WebMessageInfo>(
            "message",
            |m: &HistorySyncMsg| { &m.message },
            |m: &mut HistorySyncMsg| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgOrderId",
            |m: &HistorySyncMsg| { &m.msgOrderId },
            |m: &mut HistorySyncMsg| { &mut m.msgOrderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistorySyncMsg>(
            "HistorySyncMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HistorySyncMsg {
    const NAME: &'static str = "HistorySyncMsg";

    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                16 => {
                    self.msgOrderId = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.msgOrderId {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.msgOrderId {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HistorySyncMsg {
        HistorySyncMsg::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.msgOrderId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HistorySyncMsg {
        static instance: HistorySyncMsg = HistorySyncMsg {
            message: ::protobuf::MessageField::none(),
            msgOrderId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HistorySyncMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HistorySyncMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HistorySyncMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistorySyncMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.GroupParticipant)
pub struct GroupParticipant {
    // message fields
    // @@protoc_insertion_point(field:proto.GroupParticipant.userJid)
    pub userJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.GroupParticipant.rank)
    pub rank: ::std::option::Option<::protobuf::EnumOrUnknown<group_participant::Rank>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.GroupParticipant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GroupParticipant {
    fn default() -> &'a GroupParticipant {
        <GroupParticipant as ::protobuf::Message>::default_instance()
    }
}

impl GroupParticipant {
    pub fn new() -> GroupParticipant {
        ::std::default::Default::default()
    }

    // required string userJid = 1;

    pub fn userJid(&self) -> &str {
        match self.userJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_userJid(&mut self) {
        self.userJid = ::std::option::Option::None;
    }

    pub fn has_userJid(&self) -> bool {
        self.userJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userJid(&mut self, v: ::std::string::String) {
        self.userJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userJid(&mut self) -> &mut ::std::string::String {
        if self.userJid.is_none() {
            self.userJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.userJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_userJid(&mut self) -> ::std::string::String {
        self.userJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.GroupParticipant.Rank rank = 2;

    pub fn rank(&self) -> group_participant::Rank {
        match self.rank {
            Some(e) => e.enum_value_or(group_participant::Rank::REGULAR),
            None => group_participant::Rank::REGULAR,
        }
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: group_participant::Rank) {
        self.rank = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userJid",
            |m: &GroupParticipant| { &m.userJid },
            |m: &mut GroupParticipant| { &mut m.userJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &GroupParticipant| { &m.rank },
            |m: &mut GroupParticipant| { &mut m.rank },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupParticipant>(
            "GroupParticipant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GroupParticipant {
    const NAME: &'static str = "GroupParticipant";

    fn is_initialized(&self) -> bool {
        if self.userJid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.userJid = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.rank = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.userJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.rank {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.userJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rank {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GroupParticipant {
        GroupParticipant::new()
    }

    fn clear(&mut self) {
        self.userJid = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GroupParticipant {
        static instance: GroupParticipant = GroupParticipant {
            userJid: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GroupParticipant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GroupParticipant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GroupParticipant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupParticipant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GroupParticipant`
pub mod group_participant {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.GroupParticipant.Rank)
    pub enum Rank {
        // @@protoc_insertion_point(enum_value:proto.GroupParticipant.Rank.REGULAR)
        REGULAR = 0,
        // @@protoc_insertion_point(enum_value:proto.GroupParticipant.Rank.ADMIN)
        ADMIN = 1,
        // @@protoc_insertion_point(enum_value:proto.GroupParticipant.Rank.SUPERADMIN)
        SUPERADMIN = 2,
    }

    impl ::protobuf::Enum for Rank {
        const NAME: &'static str = "Rank";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Rank> {
            match value {
                0 => ::std::option::Option::Some(Rank::REGULAR),
                1 => ::std::option::Option::Some(Rank::ADMIN),
                2 => ::std::option::Option::Some(Rank::SUPERADMIN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Rank] = &[
            Rank::REGULAR,
            Rank::ADMIN,
            Rank::SUPERADMIN,
        ];
    }

    impl ::protobuf::EnumFull for Rank {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GroupParticipant.Rank").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Rank {
        fn default() -> Self {
            Rank::REGULAR
        }
    }

    impl Rank {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Rank>("GroupParticipant.Rank")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.GlobalSettings)
pub struct GlobalSettings {
    // message fields
    // @@protoc_insertion_point(field:proto.GlobalSettings.lightThemeWallpaper)
    pub lightThemeWallpaper: ::protobuf::MessageField<WallpaperSettings>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.mediaVisibility)
    pub mediaVisibility: ::std::option::Option<::protobuf::EnumOrUnknown<MediaVisibility>>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.darkThemeWallpaper)
    pub darkThemeWallpaper: ::protobuf::MessageField<WallpaperSettings>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.autoDownloadWiFi)
    pub autoDownloadWiFi: ::protobuf::MessageField<AutoDownloadSettings>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.autoDownloadCellular)
    pub autoDownloadCellular: ::protobuf::MessageField<AutoDownloadSettings>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.autoDownloadRoaming)
    pub autoDownloadRoaming: ::protobuf::MessageField<AutoDownloadSettings>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.showIndividualNotificationsPreview)
    pub showIndividualNotificationsPreview: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.showGroupNotificationsPreview)
    pub showGroupNotificationsPreview: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.disappearingModeDuration)
    pub disappearingModeDuration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.disappearingModeTimestamp)
    pub disappearingModeTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.GlobalSettings.avatarUserSettings)
    pub avatarUserSettings: ::protobuf::MessageField<AvatarUserSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.GlobalSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlobalSettings {
    fn default() -> &'a GlobalSettings {
        <GlobalSettings as ::protobuf::Message>::default_instance()
    }
}

impl GlobalSettings {
    pub fn new() -> GlobalSettings {
        ::std::default::Default::default()
    }

    // optional .proto.MediaVisibility mediaVisibility = 2;

    pub fn mediaVisibility(&self) -> MediaVisibility {
        match self.mediaVisibility {
            Some(e) => e.enum_value_or(MediaVisibility::DEFAULT),
            None => MediaVisibility::DEFAULT,
        }
    }

    pub fn clear_mediaVisibility(&mut self) {
        self.mediaVisibility = ::std::option::Option::None;
    }

    pub fn has_mediaVisibility(&self) -> bool {
        self.mediaVisibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaVisibility(&mut self, v: MediaVisibility) {
        self.mediaVisibility = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool showIndividualNotificationsPreview = 7;

    pub fn showIndividualNotificationsPreview(&self) -> bool {
        self.showIndividualNotificationsPreview.unwrap_or(false)
    }

    pub fn clear_showIndividualNotificationsPreview(&mut self) {
        self.showIndividualNotificationsPreview = ::std::option::Option::None;
    }

    pub fn has_showIndividualNotificationsPreview(&self) -> bool {
        self.showIndividualNotificationsPreview.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showIndividualNotificationsPreview(&mut self, v: bool) {
        self.showIndividualNotificationsPreview = ::std::option::Option::Some(v);
    }

    // optional bool showGroupNotificationsPreview = 8;

    pub fn showGroupNotificationsPreview(&self) -> bool {
        self.showGroupNotificationsPreview.unwrap_or(false)
    }

    pub fn clear_showGroupNotificationsPreview(&mut self) {
        self.showGroupNotificationsPreview = ::std::option::Option::None;
    }

    pub fn has_showGroupNotificationsPreview(&self) -> bool {
        self.showGroupNotificationsPreview.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showGroupNotificationsPreview(&mut self, v: bool) {
        self.showGroupNotificationsPreview = ::std::option::Option::Some(v);
    }

    // optional int32 disappearingModeDuration = 9;

    pub fn disappearingModeDuration(&self) -> i32 {
        self.disappearingModeDuration.unwrap_or(0)
    }

    pub fn clear_disappearingModeDuration(&mut self) {
        self.disappearingModeDuration = ::std::option::Option::None;
    }

    pub fn has_disappearingModeDuration(&self) -> bool {
        self.disappearingModeDuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disappearingModeDuration(&mut self, v: i32) {
        self.disappearingModeDuration = ::std::option::Option::Some(v);
    }

    // optional int64 disappearingModeTimestamp = 10;

    pub fn disappearingModeTimestamp(&self) -> i64 {
        self.disappearingModeTimestamp.unwrap_or(0)
    }

    pub fn clear_disappearingModeTimestamp(&mut self) {
        self.disappearingModeTimestamp = ::std::option::Option::None;
    }

    pub fn has_disappearingModeTimestamp(&self) -> bool {
        self.disappearingModeTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disappearingModeTimestamp(&mut self, v: i64) {
        self.disappearingModeTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WallpaperSettings>(
            "lightThemeWallpaper",
            |m: &GlobalSettings| { &m.lightThemeWallpaper },
            |m: &mut GlobalSettings| { &mut m.lightThemeWallpaper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaVisibility",
            |m: &GlobalSettings| { &m.mediaVisibility },
            |m: &mut GlobalSettings| { &mut m.mediaVisibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WallpaperSettings>(
            "darkThemeWallpaper",
            |m: &GlobalSettings| { &m.darkThemeWallpaper },
            |m: &mut GlobalSettings| { &mut m.darkThemeWallpaper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AutoDownloadSettings>(
            "autoDownloadWiFi",
            |m: &GlobalSettings| { &m.autoDownloadWiFi },
            |m: &mut GlobalSettings| { &mut m.autoDownloadWiFi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AutoDownloadSettings>(
            "autoDownloadCellular",
            |m: &GlobalSettings| { &m.autoDownloadCellular },
            |m: &mut GlobalSettings| { &mut m.autoDownloadCellular },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AutoDownloadSettings>(
            "autoDownloadRoaming",
            |m: &GlobalSettings| { &m.autoDownloadRoaming },
            |m: &mut GlobalSettings| { &mut m.autoDownloadRoaming },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "showIndividualNotificationsPreview",
            |m: &GlobalSettings| { &m.showIndividualNotificationsPreview },
            |m: &mut GlobalSettings| { &mut m.showIndividualNotificationsPreview },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "showGroupNotificationsPreview",
            |m: &GlobalSettings| { &m.showGroupNotificationsPreview },
            |m: &mut GlobalSettings| { &mut m.showGroupNotificationsPreview },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disappearingModeDuration",
            |m: &GlobalSettings| { &m.disappearingModeDuration },
            |m: &mut GlobalSettings| { &mut m.disappearingModeDuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disappearingModeTimestamp",
            |m: &GlobalSettings| { &m.disappearingModeTimestamp },
            |m: &mut GlobalSettings| { &mut m.disappearingModeTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AvatarUserSettings>(
            "avatarUserSettings",
            |m: &GlobalSettings| { &m.avatarUserSettings },
            |m: &mut GlobalSettings| { &mut m.avatarUserSettings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlobalSettings>(
            "GlobalSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlobalSettings {
    const NAME: &'static str = "GlobalSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lightThemeWallpaper)?;
                },
                16 => {
                    self.mediaVisibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.darkThemeWallpaper)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.autoDownloadWiFi)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.autoDownloadCellular)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.autoDownloadRoaming)?;
                },
                56 => {
                    self.showIndividualNotificationsPreview = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.showGroupNotificationsPreview = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.disappearingModeDuration = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.disappearingModeTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.avatarUserSettings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lightThemeWallpaper.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mediaVisibility {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.darkThemeWallpaper.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.autoDownloadWiFi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.autoDownloadCellular.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.autoDownloadRoaming.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.showIndividualNotificationsPreview {
            my_size += 1 + 1;
        }
        if let Some(v) = self.showGroupNotificationsPreview {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disappearingModeDuration {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.disappearingModeTimestamp {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.avatarUserSettings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lightThemeWallpaper.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.mediaVisibility {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.darkThemeWallpaper.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.autoDownloadWiFi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.autoDownloadCellular.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.autoDownloadRoaming.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.showIndividualNotificationsPreview {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.showGroupNotificationsPreview {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.disappearingModeDuration {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.disappearingModeTimestamp {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.avatarUserSettings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlobalSettings {
        GlobalSettings::new()
    }

    fn clear(&mut self) {
        self.lightThemeWallpaper.clear();
        self.mediaVisibility = ::std::option::Option::None;
        self.darkThemeWallpaper.clear();
        self.autoDownloadWiFi.clear();
        self.autoDownloadCellular.clear();
        self.autoDownloadRoaming.clear();
        self.showIndividualNotificationsPreview = ::std::option::Option::None;
        self.showGroupNotificationsPreview = ::std::option::Option::None;
        self.disappearingModeDuration = ::std::option::Option::None;
        self.disappearingModeTimestamp = ::std::option::Option::None;
        self.avatarUserSettings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlobalSettings {
        static instance: GlobalSettings = GlobalSettings {
            lightThemeWallpaper: ::protobuf::MessageField::none(),
            mediaVisibility: ::std::option::Option::None,
            darkThemeWallpaper: ::protobuf::MessageField::none(),
            autoDownloadWiFi: ::protobuf::MessageField::none(),
            autoDownloadCellular: ::protobuf::MessageField::none(),
            autoDownloadRoaming: ::protobuf::MessageField::none(),
            showIndividualNotificationsPreview: ::std::option::Option::None,
            showGroupNotificationsPreview: ::std::option::Option::None,
            disappearingModeDuration: ::std::option::Option::None,
            disappearingModeTimestamp: ::std::option::Option::None,
            avatarUserSettings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlobalSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlobalSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlobalSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Conversation)
pub struct Conversation {
    // message fields
    // @@protoc_insertion_point(field:proto.Conversation.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.messages)
    pub messages: ::std::vec::Vec<HistorySyncMsg>,
    // @@protoc_insertion_point(field:proto.Conversation.newJid)
    pub newJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.oldJid)
    pub oldJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.lastMsgTimestamp)
    pub lastMsgTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.Conversation.unreadCount)
    pub unreadCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.Conversation.readOnly)
    pub readOnly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.endOfHistoryTransfer)
    pub endOfHistoryTransfer: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.ephemeralExpiration)
    pub ephemeralExpiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.Conversation.ephemeralSettingTimestamp)
    pub ephemeralSettingTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.Conversation.endOfHistoryTransferType)
    pub endOfHistoryTransferType: ::std::option::Option<::protobuf::EnumOrUnknown<conversation::EndOfHistoryTransferType>>,
    // @@protoc_insertion_point(field:proto.Conversation.conversationTimestamp)
    pub conversationTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.Conversation.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.pHash)
    pub pHash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.notSpam)
    pub notSpam: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.archived)
    pub archived: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.disappearingMode)
    pub disappearingMode: ::protobuf::MessageField<DisappearingMode>,
    // @@protoc_insertion_point(field:proto.Conversation.unreadMentionCount)
    pub unreadMentionCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.Conversation.markedAsUnread)
    pub markedAsUnread: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.participant)
    pub participant: ::std::vec::Vec<GroupParticipant>,
    // @@protoc_insertion_point(field:proto.Conversation.tcToken)
    pub tcToken: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.Conversation.tcTokenTimestamp)
    pub tcTokenTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.Conversation.contactPrimaryIdentityKey)
    pub contactPrimaryIdentityKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.Conversation.pinned)
    pub pinned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.Conversation.muteEndTime)
    pub muteEndTime: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.Conversation.wallpaper)
    pub wallpaper: ::protobuf::MessageField<WallpaperSettings>,
    // @@protoc_insertion_point(field:proto.Conversation.mediaVisibility)
    pub mediaVisibility: ::std::option::Option<::protobuf::EnumOrUnknown<MediaVisibility>>,
    // @@protoc_insertion_point(field:proto.Conversation.tcTokenSenderTimestamp)
    pub tcTokenSenderTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.Conversation.suspended)
    pub suspended: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.terminated)
    pub terminated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.createdAt)
    pub createdAt: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.Conversation.createdBy)
    pub createdBy: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.support)
    pub support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.isParentGroup)
    pub isParentGroup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.isDefaultSubgroup)
    pub isDefaultSubgroup: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.parentGroupId)
    pub parentGroupId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.displayName)
    pub displayName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.pnJid)
    pub pnJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Conversation.shareOwnPn)
    pub shareOwnPn: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.pnhDuplicateLidThread)
    pub pnhDuplicateLidThread: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.Conversation.lidJid)
    pub lidJid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Conversation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Conversation {
    fn default() -> &'a Conversation {
        <Conversation as ::protobuf::Message>::default_instance()
    }
}

impl Conversation {
    pub fn new() -> Conversation {
        ::std::default::Default::default()
    }

    // required string id = 1;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string newJid = 3;

    pub fn newJid(&self) -> &str {
        match self.newJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_newJid(&mut self) {
        self.newJid = ::std::option::Option::None;
    }

    pub fn has_newJid(&self) -> bool {
        self.newJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newJid(&mut self, v: ::std::string::String) {
        self.newJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newJid(&mut self) -> &mut ::std::string::String {
        if self.newJid.is_none() {
            self.newJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.newJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_newJid(&mut self) -> ::std::string::String {
        self.newJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string oldJid = 4;

    pub fn oldJid(&self) -> &str {
        match self.oldJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_oldJid(&mut self) {
        self.oldJid = ::std::option::Option::None;
    }

    pub fn has_oldJid(&self) -> bool {
        self.oldJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldJid(&mut self, v: ::std::string::String) {
        self.oldJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldJid(&mut self) -> &mut ::std::string::String {
        if self.oldJid.is_none() {
            self.oldJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.oldJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldJid(&mut self) -> ::std::string::String {
        self.oldJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 lastMsgTimestamp = 5;

    pub fn lastMsgTimestamp(&self) -> u64 {
        self.lastMsgTimestamp.unwrap_or(0)
    }

    pub fn clear_lastMsgTimestamp(&mut self) {
        self.lastMsgTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastMsgTimestamp(&self) -> bool {
        self.lastMsgTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastMsgTimestamp(&mut self, v: u64) {
        self.lastMsgTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 unreadCount = 6;

    pub fn unreadCount(&self) -> u32 {
        self.unreadCount.unwrap_or(0)
    }

    pub fn clear_unreadCount(&mut self) {
        self.unreadCount = ::std::option::Option::None;
    }

    pub fn has_unreadCount(&self) -> bool {
        self.unreadCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreadCount(&mut self, v: u32) {
        self.unreadCount = ::std::option::Option::Some(v);
    }

    // optional bool readOnly = 7;

    pub fn readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional bool endOfHistoryTransfer = 8;

    pub fn endOfHistoryTransfer(&self) -> bool {
        self.endOfHistoryTransfer.unwrap_or(false)
    }

    pub fn clear_endOfHistoryTransfer(&mut self) {
        self.endOfHistoryTransfer = ::std::option::Option::None;
    }

    pub fn has_endOfHistoryTransfer(&self) -> bool {
        self.endOfHistoryTransfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endOfHistoryTransfer(&mut self, v: bool) {
        self.endOfHistoryTransfer = ::std::option::Option::Some(v);
    }

    // optional uint32 ephemeralExpiration = 9;

    pub fn ephemeralExpiration(&self) -> u32 {
        self.ephemeralExpiration.unwrap_or(0)
    }

    pub fn clear_ephemeralExpiration(&mut self) {
        self.ephemeralExpiration = ::std::option::Option::None;
    }

    pub fn has_ephemeralExpiration(&self) -> bool {
        self.ephemeralExpiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralExpiration(&mut self, v: u32) {
        self.ephemeralExpiration = ::std::option::Option::Some(v);
    }

    // optional int64 ephemeralSettingTimestamp = 10;

    pub fn ephemeralSettingTimestamp(&self) -> i64 {
        self.ephemeralSettingTimestamp.unwrap_or(0)
    }

    pub fn clear_ephemeralSettingTimestamp(&mut self) {
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
    }

    pub fn has_ephemeralSettingTimestamp(&self) -> bool {
        self.ephemeralSettingTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralSettingTimestamp(&mut self, v: i64) {
        self.ephemeralSettingTimestamp = ::std::option::Option::Some(v);
    }

    // optional .proto.Conversation.EndOfHistoryTransferType endOfHistoryTransferType = 11;

    pub fn endOfHistoryTransferType(&self) -> conversation::EndOfHistoryTransferType {
        match self.endOfHistoryTransferType {
            Some(e) => e.enum_value_or(conversation::EndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY),
            None => conversation::EndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY,
        }
    }

    pub fn clear_endOfHistoryTransferType(&mut self) {
        self.endOfHistoryTransferType = ::std::option::Option::None;
    }

    pub fn has_endOfHistoryTransferType(&self) -> bool {
        self.endOfHistoryTransferType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endOfHistoryTransferType(&mut self, v: conversation::EndOfHistoryTransferType) {
        self.endOfHistoryTransferType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 conversationTimestamp = 12;

    pub fn conversationTimestamp(&self) -> u64 {
        self.conversationTimestamp.unwrap_or(0)
    }

    pub fn clear_conversationTimestamp(&mut self) {
        self.conversationTimestamp = ::std::option::Option::None;
    }

    pub fn has_conversationTimestamp(&self) -> bool {
        self.conversationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conversationTimestamp(&mut self, v: u64) {
        self.conversationTimestamp = ::std::option::Option::Some(v);
    }

    // optional string name = 13;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pHash = 14;

    pub fn pHash(&self) -> &str {
        match self.pHash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pHash(&mut self) {
        self.pHash = ::std::option::Option::None;
    }

    pub fn has_pHash(&self) -> bool {
        self.pHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pHash(&mut self, v: ::std::string::String) {
        self.pHash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pHash(&mut self) -> &mut ::std::string::String {
        if self.pHash.is_none() {
            self.pHash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_pHash(&mut self) -> ::std::string::String {
        self.pHash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool notSpam = 15;

    pub fn notSpam(&self) -> bool {
        self.notSpam.unwrap_or(false)
    }

    pub fn clear_notSpam(&mut self) {
        self.notSpam = ::std::option::Option::None;
    }

    pub fn has_notSpam(&self) -> bool {
        self.notSpam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notSpam(&mut self, v: bool) {
        self.notSpam = ::std::option::Option::Some(v);
    }

    // optional bool archived = 16;

    pub fn archived(&self) -> bool {
        self.archived.unwrap_or(false)
    }

    pub fn clear_archived(&mut self) {
        self.archived = ::std::option::Option::None;
    }

    pub fn has_archived(&self) -> bool {
        self.archived.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archived(&mut self, v: bool) {
        self.archived = ::std::option::Option::Some(v);
    }

    // optional uint32 unreadMentionCount = 18;

    pub fn unreadMentionCount(&self) -> u32 {
        self.unreadMentionCount.unwrap_or(0)
    }

    pub fn clear_unreadMentionCount(&mut self) {
        self.unreadMentionCount = ::std::option::Option::None;
    }

    pub fn has_unreadMentionCount(&self) -> bool {
        self.unreadMentionCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreadMentionCount(&mut self, v: u32) {
        self.unreadMentionCount = ::std::option::Option::Some(v);
    }

    // optional bool markedAsUnread = 19;

    pub fn markedAsUnread(&self) -> bool {
        self.markedAsUnread.unwrap_or(false)
    }

    pub fn clear_markedAsUnread(&mut self) {
        self.markedAsUnread = ::std::option::Option::None;
    }

    pub fn has_markedAsUnread(&self) -> bool {
        self.markedAsUnread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_markedAsUnread(&mut self, v: bool) {
        self.markedAsUnread = ::std::option::Option::Some(v);
    }

    // optional bytes tcToken = 21;

    pub fn tcToken(&self) -> &[u8] {
        match self.tcToken.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tcToken(&mut self) {
        self.tcToken = ::std::option::Option::None;
    }

    pub fn has_tcToken(&self) -> bool {
        self.tcToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcToken(&mut self, v: ::std::vec::Vec<u8>) {
        self.tcToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcToken(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tcToken.is_none() {
            self.tcToken = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tcToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcToken(&mut self) -> ::std::vec::Vec<u8> {
        self.tcToken.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 tcTokenTimestamp = 22;

    pub fn tcTokenTimestamp(&self) -> u64 {
        self.tcTokenTimestamp.unwrap_or(0)
    }

    pub fn clear_tcTokenTimestamp(&mut self) {
        self.tcTokenTimestamp = ::std::option::Option::None;
    }

    pub fn has_tcTokenTimestamp(&self) -> bool {
        self.tcTokenTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcTokenTimestamp(&mut self, v: u64) {
        self.tcTokenTimestamp = ::std::option::Option::Some(v);
    }

    // optional bytes contactPrimaryIdentityKey = 23;

    pub fn contactPrimaryIdentityKey(&self) -> &[u8] {
        match self.contactPrimaryIdentityKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_contactPrimaryIdentityKey(&mut self) {
        self.contactPrimaryIdentityKey = ::std::option::Option::None;
    }

    pub fn has_contactPrimaryIdentityKey(&self) -> bool {
        self.contactPrimaryIdentityKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contactPrimaryIdentityKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.contactPrimaryIdentityKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contactPrimaryIdentityKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.contactPrimaryIdentityKey.is_none() {
            self.contactPrimaryIdentityKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.contactPrimaryIdentityKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_contactPrimaryIdentityKey(&mut self) -> ::std::vec::Vec<u8> {
        self.contactPrimaryIdentityKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 pinned = 24;

    pub fn pinned(&self) -> u32 {
        self.pinned.unwrap_or(0)
    }

    pub fn clear_pinned(&mut self) {
        self.pinned = ::std::option::Option::None;
    }

    pub fn has_pinned(&self) -> bool {
        self.pinned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinned(&mut self, v: u32) {
        self.pinned = ::std::option::Option::Some(v);
    }

    // optional uint64 muteEndTime = 25;

    pub fn muteEndTime(&self) -> u64 {
        self.muteEndTime.unwrap_or(0)
    }

    pub fn clear_muteEndTime(&mut self) {
        self.muteEndTime = ::std::option::Option::None;
    }

    pub fn has_muteEndTime(&self) -> bool {
        self.muteEndTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muteEndTime(&mut self, v: u64) {
        self.muteEndTime = ::std::option::Option::Some(v);
    }

    // optional .proto.MediaVisibility mediaVisibility = 27;

    pub fn mediaVisibility(&self) -> MediaVisibility {
        match self.mediaVisibility {
            Some(e) => e.enum_value_or(MediaVisibility::DEFAULT),
            None => MediaVisibility::DEFAULT,
        }
    }

    pub fn clear_mediaVisibility(&mut self) {
        self.mediaVisibility = ::std::option::Option::None;
    }

    pub fn has_mediaVisibility(&self) -> bool {
        self.mediaVisibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaVisibility(&mut self, v: MediaVisibility) {
        self.mediaVisibility = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 tcTokenSenderTimestamp = 28;

    pub fn tcTokenSenderTimestamp(&self) -> u64 {
        self.tcTokenSenderTimestamp.unwrap_or(0)
    }

    pub fn clear_tcTokenSenderTimestamp(&mut self) {
        self.tcTokenSenderTimestamp = ::std::option::Option::None;
    }

    pub fn has_tcTokenSenderTimestamp(&self) -> bool {
        self.tcTokenSenderTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcTokenSenderTimestamp(&mut self, v: u64) {
        self.tcTokenSenderTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool suspended = 29;

    pub fn suspended(&self) -> bool {
        self.suspended.unwrap_or(false)
    }

    pub fn clear_suspended(&mut self) {
        self.suspended = ::std::option::Option::None;
    }

    pub fn has_suspended(&self) -> bool {
        self.suspended.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspended(&mut self, v: bool) {
        self.suspended = ::std::option::Option::Some(v);
    }

    // optional bool terminated = 30;

    pub fn terminated(&self) -> bool {
        self.terminated.unwrap_or(false)
    }

    pub fn clear_terminated(&mut self) {
        self.terminated = ::std::option::Option::None;
    }

    pub fn has_terminated(&self) -> bool {
        self.terminated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminated(&mut self, v: bool) {
        self.terminated = ::std::option::Option::Some(v);
    }

    // optional uint64 createdAt = 31;

    pub fn createdAt(&self) -> u64 {
        self.createdAt.unwrap_or(0)
    }

    pub fn clear_createdAt(&mut self) {
        self.createdAt = ::std::option::Option::None;
    }

    pub fn has_createdAt(&self) -> bool {
        self.createdAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: u64) {
        self.createdAt = ::std::option::Option::Some(v);
    }

    // optional string createdBy = 32;

    pub fn createdBy(&self) -> &str {
        match self.createdBy.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_createdBy(&mut self) {
        self.createdBy = ::std::option::Option::None;
    }

    pub fn has_createdBy(&self) -> bool {
        self.createdBy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createdBy(&mut self, v: ::std::string::String) {
        self.createdBy = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_createdBy(&mut self) -> &mut ::std::string::String {
        if self.createdBy.is_none() {
            self.createdBy = ::std::option::Option::Some(::std::string::String::new());
        }
        self.createdBy.as_mut().unwrap()
    }

    // Take field
    pub fn take_createdBy(&mut self) -> ::std::string::String {
        self.createdBy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 33;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool support = 34;

    pub fn support(&self) -> bool {
        self.support.unwrap_or(false)
    }

    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: bool) {
        self.support = ::std::option::Option::Some(v);
    }

    // optional bool isParentGroup = 35;

    pub fn isParentGroup(&self) -> bool {
        self.isParentGroup.unwrap_or(false)
    }

    pub fn clear_isParentGroup(&mut self) {
        self.isParentGroup = ::std::option::Option::None;
    }

    pub fn has_isParentGroup(&self) -> bool {
        self.isParentGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isParentGroup(&mut self, v: bool) {
        self.isParentGroup = ::std::option::Option::Some(v);
    }

    // optional bool isDefaultSubgroup = 36;

    pub fn isDefaultSubgroup(&self) -> bool {
        self.isDefaultSubgroup.unwrap_or(false)
    }

    pub fn clear_isDefaultSubgroup(&mut self) {
        self.isDefaultSubgroup = ::std::option::Option::None;
    }

    pub fn has_isDefaultSubgroup(&self) -> bool {
        self.isDefaultSubgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isDefaultSubgroup(&mut self, v: bool) {
        self.isDefaultSubgroup = ::std::option::Option::Some(v);
    }

    // optional string parentGroupId = 37;

    pub fn parentGroupId(&self) -> &str {
        match self.parentGroupId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parentGroupId(&mut self) {
        self.parentGroupId = ::std::option::Option::None;
    }

    pub fn has_parentGroupId(&self) -> bool {
        self.parentGroupId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentGroupId(&mut self, v: ::std::string::String) {
        self.parentGroupId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentGroupId(&mut self) -> &mut ::std::string::String {
        if self.parentGroupId.is_none() {
            self.parentGroupId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parentGroupId.as_mut().unwrap()
    }

    // Take field
    pub fn take_parentGroupId(&mut self) -> ::std::string::String {
        self.parentGroupId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string displayName = 38;

    pub fn displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayName(&mut self) {
        self.displayName = ::std::option::Option::None;
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pnJid = 39;

    pub fn pnJid(&self) -> &str {
        match self.pnJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pnJid(&mut self) {
        self.pnJid = ::std::option::Option::None;
    }

    pub fn has_pnJid(&self) -> bool {
        self.pnJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pnJid(&mut self, v: ::std::string::String) {
        self.pnJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pnJid(&mut self) -> &mut ::std::string::String {
        if self.pnJid.is_none() {
            self.pnJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pnJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pnJid(&mut self) -> ::std::string::String {
        self.pnJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool shareOwnPn = 40;

    pub fn shareOwnPn(&self) -> bool {
        self.shareOwnPn.unwrap_or(false)
    }

    pub fn clear_shareOwnPn(&mut self) {
        self.shareOwnPn = ::std::option::Option::None;
    }

    pub fn has_shareOwnPn(&self) -> bool {
        self.shareOwnPn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareOwnPn(&mut self, v: bool) {
        self.shareOwnPn = ::std::option::Option::Some(v);
    }

    // optional bool pnhDuplicateLidThread = 41;

    pub fn pnhDuplicateLidThread(&self) -> bool {
        self.pnhDuplicateLidThread.unwrap_or(false)
    }

    pub fn clear_pnhDuplicateLidThread(&mut self) {
        self.pnhDuplicateLidThread = ::std::option::Option::None;
    }

    pub fn has_pnhDuplicateLidThread(&self) -> bool {
        self.pnhDuplicateLidThread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pnhDuplicateLidThread(&mut self, v: bool) {
        self.pnhDuplicateLidThread = ::std::option::Option::Some(v);
    }

    // optional string lidJid = 42;

    pub fn lidJid(&self) -> &str {
        match self.lidJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lidJid(&mut self) {
        self.lidJid = ::std::option::Option::None;
    }

    pub fn has_lidJid(&self) -> bool {
        self.lidJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lidJid(&mut self, v: ::std::string::String) {
        self.lidJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lidJid(&mut self) -> &mut ::std::string::String {
        if self.lidJid.is_none() {
            self.lidJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lidJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_lidJid(&mut self) -> ::std::string::String {
        self.lidJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(42);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &Conversation| { &m.id },
            |m: &mut Conversation| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &Conversation| { &m.messages },
            |m: &mut Conversation| { &mut m.messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "newJid",
            |m: &Conversation| { &m.newJid },
            |m: &mut Conversation| { &mut m.newJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oldJid",
            |m: &Conversation| { &m.oldJid },
            |m: &mut Conversation| { &mut m.oldJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastMsgTimestamp",
            |m: &Conversation| { &m.lastMsgTimestamp },
            |m: &mut Conversation| { &mut m.lastMsgTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unreadCount",
            |m: &Conversation| { &m.unreadCount },
            |m: &mut Conversation| { &mut m.unreadCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readOnly",
            |m: &Conversation| { &m.readOnly },
            |m: &mut Conversation| { &mut m.readOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endOfHistoryTransfer",
            |m: &Conversation| { &m.endOfHistoryTransfer },
            |m: &mut Conversation| { &mut m.endOfHistoryTransfer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralExpiration",
            |m: &Conversation| { &m.ephemeralExpiration },
            |m: &mut Conversation| { &mut m.ephemeralExpiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralSettingTimestamp",
            |m: &Conversation| { &m.ephemeralSettingTimestamp },
            |m: &mut Conversation| { &mut m.ephemeralSettingTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endOfHistoryTransferType",
            |m: &Conversation| { &m.endOfHistoryTransferType },
            |m: &mut Conversation| { &mut m.endOfHistoryTransferType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "conversationTimestamp",
            |m: &Conversation| { &m.conversationTimestamp },
            |m: &mut Conversation| { &mut m.conversationTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Conversation| { &m.name },
            |m: &mut Conversation| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pHash",
            |m: &Conversation| { &m.pHash },
            |m: &mut Conversation| { &mut m.pHash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notSpam",
            |m: &Conversation| { &m.notSpam },
            |m: &mut Conversation| { &mut m.notSpam },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "archived",
            |m: &Conversation| { &m.archived },
            |m: &mut Conversation| { &mut m.archived },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DisappearingMode>(
            "disappearingMode",
            |m: &Conversation| { &m.disappearingMode },
            |m: &mut Conversation| { &mut m.disappearingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unreadMentionCount",
            |m: &Conversation| { &m.unreadMentionCount },
            |m: &mut Conversation| { &mut m.unreadMentionCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "markedAsUnread",
            |m: &Conversation| { &m.markedAsUnread },
            |m: &mut Conversation| { &mut m.markedAsUnread },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "participant",
            |m: &Conversation| { &m.participant },
            |m: &mut Conversation| { &mut m.participant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcToken",
            |m: &Conversation| { &m.tcToken },
            |m: &mut Conversation| { &mut m.tcToken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcTokenTimestamp",
            |m: &Conversation| { &m.tcTokenTimestamp },
            |m: &mut Conversation| { &mut m.tcTokenTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "contactPrimaryIdentityKey",
            |m: &Conversation| { &m.contactPrimaryIdentityKey },
            |m: &mut Conversation| { &mut m.contactPrimaryIdentityKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pinned",
            |m: &Conversation| { &m.pinned },
            |m: &mut Conversation| { &mut m.pinned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "muteEndTime",
            |m: &Conversation| { &m.muteEndTime },
            |m: &mut Conversation| { &mut m.muteEndTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WallpaperSettings>(
            "wallpaper",
            |m: &Conversation| { &m.wallpaper },
            |m: &mut Conversation| { &mut m.wallpaper },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaVisibility",
            |m: &Conversation| { &m.mediaVisibility },
            |m: &mut Conversation| { &mut m.mediaVisibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tcTokenSenderTimestamp",
            |m: &Conversation| { &m.tcTokenSenderTimestamp },
            |m: &mut Conversation| { &mut m.tcTokenSenderTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suspended",
            |m: &Conversation| { &m.suspended },
            |m: &mut Conversation| { &mut m.suspended },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "terminated",
            |m: &Conversation| { &m.terminated },
            |m: &mut Conversation| { &mut m.terminated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "createdAt",
            |m: &Conversation| { &m.createdAt },
            |m: &mut Conversation| { &mut m.createdAt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "createdBy",
            |m: &Conversation| { &m.createdBy },
            |m: &mut Conversation| { &mut m.createdBy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &Conversation| { &m.description },
            |m: &mut Conversation| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support",
            |m: &Conversation| { &m.support },
            |m: &mut Conversation| { &mut m.support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isParentGroup",
            |m: &Conversation| { &m.isParentGroup },
            |m: &mut Conversation| { &mut m.isParentGroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isDefaultSubgroup",
            |m: &Conversation| { &m.isDefaultSubgroup },
            |m: &mut Conversation| { &mut m.isDefaultSubgroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parentGroupId",
            |m: &Conversation| { &m.parentGroupId },
            |m: &mut Conversation| { &mut m.parentGroupId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayName",
            |m: &Conversation| { &m.displayName },
            |m: &mut Conversation| { &mut m.displayName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pnJid",
            |m: &Conversation| { &m.pnJid },
            |m: &mut Conversation| { &mut m.pnJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shareOwnPn",
            |m: &Conversation| { &m.shareOwnPn },
            |m: &mut Conversation| { &mut m.shareOwnPn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pnhDuplicateLidThread",
            |m: &Conversation| { &m.pnhDuplicateLidThread },
            |m: &mut Conversation| { &mut m.pnhDuplicateLidThread },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lidJid",
            |m: &Conversation| { &m.lidJid },
            |m: &mut Conversation| { &mut m.lidJid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Conversation>(
            "Conversation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Conversation {
    const NAME: &'static str = "Conversation";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.disappearingMode {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.participant {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.wallpaper {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.messages.push(is.read_message()?);
                },
                26 => {
                    self.newJid = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.oldJid = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.lastMsgTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.unreadCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.readOnly = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.endOfHistoryTransfer = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.ephemeralExpiration = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ephemeralSettingTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                88 => {
                    self.endOfHistoryTransferType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.conversationTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                106 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.pHash = ::std::option::Option::Some(is.read_string()?);
                },
                120 => {
                    self.notSpam = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.archived = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.disappearingMode)?;
                },
                144 => {
                    self.unreadMentionCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.markedAsUnread = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.participant.push(is.read_message()?);
                },
                170 => {
                    self.tcToken = ::std::option::Option::Some(is.read_bytes()?);
                },
                176 => {
                    self.tcTokenTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                186 => {
                    self.contactPrimaryIdentityKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                192 => {
                    self.pinned = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.muteEndTime = ::std::option::Option::Some(is.read_uint64()?);
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.wallpaper)?;
                },
                216 => {
                    self.mediaVisibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                224 => {
                    self.tcTokenSenderTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                232 => {
                    self.suspended = ::std::option::Option::Some(is.read_bool()?);
                },
                240 => {
                    self.terminated = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.createdAt = ::std::option::Option::Some(is.read_uint64()?);
                },
                258 => {
                    self.createdBy = ::std::option::Option::Some(is.read_string()?);
                },
                266 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                272 => {
                    self.support = ::std::option::Option::Some(is.read_bool()?);
                },
                280 => {
                    self.isParentGroup = ::std::option::Option::Some(is.read_bool()?);
                },
                288 => {
                    self.isDefaultSubgroup = ::std::option::Option::Some(is.read_bool()?);
                },
                298 => {
                    self.parentGroupId = ::std::option::Option::Some(is.read_string()?);
                },
                306 => {
                    self.displayName = ::std::option::Option::Some(is.read_string()?);
                },
                314 => {
                    self.pnJid = ::std::option::Option::Some(is.read_string()?);
                },
                320 => {
                    self.shareOwnPn = ::std::option::Option::Some(is.read_bool()?);
                },
                328 => {
                    self.pnhDuplicateLidThread = ::std::option::Option::Some(is.read_bool()?);
                },
                338 => {
                    self.lidJid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.newJid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.oldJid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.lastMsgTimestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.unreadCount {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.readOnly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.endOfHistoryTransfer {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ephemeralExpiration {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.endOfHistoryTransferType {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.conversationTimestamp {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.pHash.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.notSpam {
            my_size += 1 + 1;
        }
        if let Some(v) = self.archived {
            my_size += 2 + 1;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unreadMentionCount {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.markedAsUnread {
            my_size += 2 + 1;
        }
        for value in &self.participant {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tcToken.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        if let Some(v) = self.tcTokenTimestamp {
            my_size += ::protobuf::rt::uint64_size(22, v);
        }
        if let Some(v) = self.contactPrimaryIdentityKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(23, &v);
        }
        if let Some(v) = self.pinned {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.muteEndTime {
            my_size += ::protobuf::rt::uint64_size(25, v);
        }
        if let Some(v) = self.wallpaper.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mediaVisibility {
            my_size += ::protobuf::rt::int32_size(27, v.value());
        }
        if let Some(v) = self.tcTokenSenderTimestamp {
            my_size += ::protobuf::rt::uint64_size(28, v);
        }
        if let Some(v) = self.suspended {
            my_size += 2 + 1;
        }
        if let Some(v) = self.terminated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.createdAt {
            my_size += ::protobuf::rt::uint64_size(31, v);
        }
        if let Some(v) = self.createdBy.as_ref() {
            my_size += ::protobuf::rt::string_size(32, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(33, &v);
        }
        if let Some(v) = self.support {
            my_size += 2 + 1;
        }
        if let Some(v) = self.isParentGroup {
            my_size += 2 + 1;
        }
        if let Some(v) = self.isDefaultSubgroup {
            my_size += 2 + 1;
        }
        if let Some(v) = self.parentGroupId.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(38, &v);
        }
        if let Some(v) = self.pnJid.as_ref() {
            my_size += ::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.shareOwnPn {
            my_size += 2 + 1;
        }
        if let Some(v) = self.pnhDuplicateLidThread {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lidJid.as_ref() {
            my_size += ::protobuf::rt::string_size(42, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.newJid.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.oldJid.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.lastMsgTimestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.unreadCount {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.endOfHistoryTransfer {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.ephemeralExpiration {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ephemeralSettingTimestamp {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.endOfHistoryTransferType {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.conversationTimestamp {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.pHash.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.notSpam {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.archived {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.disappearingMode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.unreadMentionCount {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.markedAsUnread {
            os.write_bool(19, v)?;
        }
        for v in &self.participant {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        if let Some(v) = self.tcToken.as_ref() {
            os.write_bytes(21, v)?;
        }
        if let Some(v) = self.tcTokenTimestamp {
            os.write_uint64(22, v)?;
        }
        if let Some(v) = self.contactPrimaryIdentityKey.as_ref() {
            os.write_bytes(23, v)?;
        }
        if let Some(v) = self.pinned {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.muteEndTime {
            os.write_uint64(25, v)?;
        }
        if let Some(v) = self.wallpaper.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.mediaVisibility {
            os.write_enum(27, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tcTokenSenderTimestamp {
            os.write_uint64(28, v)?;
        }
        if let Some(v) = self.suspended {
            os.write_bool(29, v)?;
        }
        if let Some(v) = self.terminated {
            os.write_bool(30, v)?;
        }
        if let Some(v) = self.createdAt {
            os.write_uint64(31, v)?;
        }
        if let Some(v) = self.createdBy.as_ref() {
            os.write_string(32, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(33, v)?;
        }
        if let Some(v) = self.support {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.isParentGroup {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.isDefaultSubgroup {
            os.write_bool(36, v)?;
        }
        if let Some(v) = self.parentGroupId.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(38, v)?;
        }
        if let Some(v) = self.pnJid.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.shareOwnPn {
            os.write_bool(40, v)?;
        }
        if let Some(v) = self.pnhDuplicateLidThread {
            os.write_bool(41, v)?;
        }
        if let Some(v) = self.lidJid.as_ref() {
            os.write_string(42, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Conversation {
        Conversation::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.messages.clear();
        self.newJid = ::std::option::Option::None;
        self.oldJid = ::std::option::Option::None;
        self.lastMsgTimestamp = ::std::option::Option::None;
        self.unreadCount = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.endOfHistoryTransfer = ::std::option::Option::None;
        self.ephemeralExpiration = ::std::option::Option::None;
        self.ephemeralSettingTimestamp = ::std::option::Option::None;
        self.endOfHistoryTransferType = ::std::option::Option::None;
        self.conversationTimestamp = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.pHash = ::std::option::Option::None;
        self.notSpam = ::std::option::Option::None;
        self.archived = ::std::option::Option::None;
        self.disappearingMode.clear();
        self.unreadMentionCount = ::std::option::Option::None;
        self.markedAsUnread = ::std::option::Option::None;
        self.participant.clear();
        self.tcToken = ::std::option::Option::None;
        self.tcTokenTimestamp = ::std::option::Option::None;
        self.contactPrimaryIdentityKey = ::std::option::Option::None;
        self.pinned = ::std::option::Option::None;
        self.muteEndTime = ::std::option::Option::None;
        self.wallpaper.clear();
        self.mediaVisibility = ::std::option::Option::None;
        self.tcTokenSenderTimestamp = ::std::option::Option::None;
        self.suspended = ::std::option::Option::None;
        self.terminated = ::std::option::Option::None;
        self.createdAt = ::std::option::Option::None;
        self.createdBy = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.isParentGroup = ::std::option::Option::None;
        self.isDefaultSubgroup = ::std::option::Option::None;
        self.parentGroupId = ::std::option::Option::None;
        self.displayName = ::std::option::Option::None;
        self.pnJid = ::std::option::Option::None;
        self.shareOwnPn = ::std::option::Option::None;
        self.pnhDuplicateLidThread = ::std::option::Option::None;
        self.lidJid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Conversation {
        static instance: Conversation = Conversation {
            id: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            newJid: ::std::option::Option::None,
            oldJid: ::std::option::Option::None,
            lastMsgTimestamp: ::std::option::Option::None,
            unreadCount: ::std::option::Option::None,
            readOnly: ::std::option::Option::None,
            endOfHistoryTransfer: ::std::option::Option::None,
            ephemeralExpiration: ::std::option::Option::None,
            ephemeralSettingTimestamp: ::std::option::Option::None,
            endOfHistoryTransferType: ::std::option::Option::None,
            conversationTimestamp: ::std::option::Option::None,
            name: ::std::option::Option::None,
            pHash: ::std::option::Option::None,
            notSpam: ::std::option::Option::None,
            archived: ::std::option::Option::None,
            disappearingMode: ::protobuf::MessageField::none(),
            unreadMentionCount: ::std::option::Option::None,
            markedAsUnread: ::std::option::Option::None,
            participant: ::std::vec::Vec::new(),
            tcToken: ::std::option::Option::None,
            tcTokenTimestamp: ::std::option::Option::None,
            contactPrimaryIdentityKey: ::std::option::Option::None,
            pinned: ::std::option::Option::None,
            muteEndTime: ::std::option::Option::None,
            wallpaper: ::protobuf::MessageField::none(),
            mediaVisibility: ::std::option::Option::None,
            tcTokenSenderTimestamp: ::std::option::Option::None,
            suspended: ::std::option::Option::None,
            terminated: ::std::option::Option::None,
            createdAt: ::std::option::Option::None,
            createdBy: ::std::option::Option::None,
            description: ::std::option::Option::None,
            support: ::std::option::Option::None,
            isParentGroup: ::std::option::Option::None,
            isDefaultSubgroup: ::std::option::Option::None,
            parentGroupId: ::std::option::Option::None,
            displayName: ::std::option::Option::None,
            pnJid: ::std::option::Option::None,
            shareOwnPn: ::std::option::Option::None,
            pnhDuplicateLidThread: ::std::option::Option::None,
            lidJid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Conversation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Conversation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Conversation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Conversation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Conversation`
pub mod conversation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.Conversation.EndOfHistoryTransferType)
    pub enum EndOfHistoryTransferType {
        // @@protoc_insertion_point(enum_value:proto.Conversation.EndOfHistoryTransferType.COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY)
        COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY = 0,
        // @@protoc_insertion_point(enum_value:proto.Conversation.EndOfHistoryTransferType.COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY)
        COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY = 1,
    }

    impl ::protobuf::Enum for EndOfHistoryTransferType {
        const NAME: &'static str = "EndOfHistoryTransferType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EndOfHistoryTransferType> {
            match value {
                0 => ::std::option::Option::Some(EndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY),
                1 => ::std::option::Option::Some(EndOfHistoryTransferType::COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EndOfHistoryTransferType] = &[
            EndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY,
            EndOfHistoryTransferType::COMPLETE_AND_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY,
        ];
    }

    impl ::protobuf::EnumFull for EndOfHistoryTransferType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Conversation.EndOfHistoryTransferType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EndOfHistoryTransferType {
        fn default() -> Self {
            EndOfHistoryTransferType::COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY
        }
    }

    impl EndOfHistoryTransferType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EndOfHistoryTransferType>("Conversation.EndOfHistoryTransferType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AvatarUserSettings)
pub struct AvatarUserSettings {
    // message fields
    // @@protoc_insertion_point(field:proto.AvatarUserSettings.fbid)
    pub fbid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.AvatarUserSettings.password)
    pub password: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AvatarUserSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AvatarUserSettings {
    fn default() -> &'a AvatarUserSettings {
        <AvatarUserSettings as ::protobuf::Message>::default_instance()
    }
}

impl AvatarUserSettings {
    pub fn new() -> AvatarUserSettings {
        ::std::default::Default::default()
    }

    // optional string fbid = 1;

    pub fn fbid(&self) -> &str {
        match self.fbid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fbid(&mut self) {
        self.fbid = ::std::option::Option::None;
    }

    pub fn has_fbid(&self) -> bool {
        self.fbid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbid(&mut self, v: ::std::string::String) {
        self.fbid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fbid(&mut self) -> &mut ::std::string::String {
        if self.fbid.is_none() {
            self.fbid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fbid.as_mut().unwrap()
    }

    // Take field
    pub fn take_fbid(&mut self) -> ::std::string::String {
        self.fbid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string password = 2;

    pub fn password(&self) -> &str {
        match self.password.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        if self.password.is_none() {
            self.password = ::std::option::Option::Some(::std::string::String::new());
        }
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbid",
            |m: &AvatarUserSettings| { &m.fbid },
            |m: &mut AvatarUserSettings| { &mut m.fbid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "password",
            |m: &AvatarUserSettings| { &m.password },
            |m: &mut AvatarUserSettings| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AvatarUserSettings>(
            "AvatarUserSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AvatarUserSettings {
    const NAME: &'static str = "AvatarUserSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fbid = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.password = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fbid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.password.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fbid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.password.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AvatarUserSettings {
        AvatarUserSettings::new()
    }

    fn clear(&mut self) {
        self.fbid = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AvatarUserSettings {
        static instance: AvatarUserSettings = AvatarUserSettings {
            fbid: ::std::option::Option::None,
            password: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AvatarUserSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AvatarUserSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AvatarUserSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvatarUserSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AutoDownloadSettings)
pub struct AutoDownloadSettings {
    // message fields
    // @@protoc_insertion_point(field:proto.AutoDownloadSettings.downloadImages)
    pub downloadImages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.AutoDownloadSettings.downloadAudio)
    pub downloadAudio: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.AutoDownloadSettings.downloadVideo)
    pub downloadVideo: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.AutoDownloadSettings.downloadDocuments)
    pub downloadDocuments: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AutoDownloadSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AutoDownloadSettings {
    fn default() -> &'a AutoDownloadSettings {
        <AutoDownloadSettings as ::protobuf::Message>::default_instance()
    }
}

impl AutoDownloadSettings {
    pub fn new() -> AutoDownloadSettings {
        ::std::default::Default::default()
    }

    // optional bool downloadImages = 1;

    pub fn downloadImages(&self) -> bool {
        self.downloadImages.unwrap_or(false)
    }

    pub fn clear_downloadImages(&mut self) {
        self.downloadImages = ::std::option::Option::None;
    }

    pub fn has_downloadImages(&self) -> bool {
        self.downloadImages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downloadImages(&mut self, v: bool) {
        self.downloadImages = ::std::option::Option::Some(v);
    }

    // optional bool downloadAudio = 2;

    pub fn downloadAudio(&self) -> bool {
        self.downloadAudio.unwrap_or(false)
    }

    pub fn clear_downloadAudio(&mut self) {
        self.downloadAudio = ::std::option::Option::None;
    }

    pub fn has_downloadAudio(&self) -> bool {
        self.downloadAudio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downloadAudio(&mut self, v: bool) {
        self.downloadAudio = ::std::option::Option::Some(v);
    }

    // optional bool downloadVideo = 3;

    pub fn downloadVideo(&self) -> bool {
        self.downloadVideo.unwrap_or(false)
    }

    pub fn clear_downloadVideo(&mut self) {
        self.downloadVideo = ::std::option::Option::None;
    }

    pub fn has_downloadVideo(&self) -> bool {
        self.downloadVideo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downloadVideo(&mut self, v: bool) {
        self.downloadVideo = ::std::option::Option::Some(v);
    }

    // optional bool downloadDocuments = 4;

    pub fn downloadDocuments(&self) -> bool {
        self.downloadDocuments.unwrap_or(false)
    }

    pub fn clear_downloadDocuments(&mut self) {
        self.downloadDocuments = ::std::option::Option::None;
    }

    pub fn has_downloadDocuments(&self) -> bool {
        self.downloadDocuments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downloadDocuments(&mut self, v: bool) {
        self.downloadDocuments = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "downloadImages",
            |m: &AutoDownloadSettings| { &m.downloadImages },
            |m: &mut AutoDownloadSettings| { &mut m.downloadImages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "downloadAudio",
            |m: &AutoDownloadSettings| { &m.downloadAudio },
            |m: &mut AutoDownloadSettings| { &mut m.downloadAudio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "downloadVideo",
            |m: &AutoDownloadSettings| { &m.downloadVideo },
            |m: &mut AutoDownloadSettings| { &mut m.downloadVideo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "downloadDocuments",
            |m: &AutoDownloadSettings| { &m.downloadDocuments },
            |m: &mut AutoDownloadSettings| { &mut m.downloadDocuments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutoDownloadSettings>(
            "AutoDownloadSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AutoDownloadSettings {
    const NAME: &'static str = "AutoDownloadSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.downloadImages = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.downloadAudio = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.downloadVideo = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.downloadDocuments = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.downloadImages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.downloadAudio {
            my_size += 1 + 1;
        }
        if let Some(v) = self.downloadVideo {
            my_size += 1 + 1;
        }
        if let Some(v) = self.downloadDocuments {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.downloadImages {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.downloadAudio {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.downloadVideo {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.downloadDocuments {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AutoDownloadSettings {
        AutoDownloadSettings::new()
    }

    fn clear(&mut self) {
        self.downloadImages = ::std::option::Option::None;
        self.downloadAudio = ::std::option::Option::None;
        self.downloadVideo = ::std::option::Option::None;
        self.downloadDocuments = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AutoDownloadSettings {
        static instance: AutoDownloadSettings = AutoDownloadSettings {
            downloadImages: ::std::option::Option::None,
            downloadAudio: ::std::option::Option::None,
            downloadVideo: ::std::option::Option::None,
            downloadDocuments: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AutoDownloadSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AutoDownloadSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AutoDownloadSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AutoDownloadSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.MsgRowOpaqueData)
pub struct MsgRowOpaqueData {
    // message fields
    // @@protoc_insertion_point(field:proto.MsgRowOpaqueData.currentMsg)
    pub currentMsg: ::protobuf::MessageField<MsgOpaqueData>,
    // @@protoc_insertion_point(field:proto.MsgRowOpaqueData.quotedMsg)
    pub quotedMsg: ::protobuf::MessageField<MsgOpaqueData>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.MsgRowOpaqueData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgRowOpaqueData {
    fn default() -> &'a MsgRowOpaqueData {
        <MsgRowOpaqueData as ::protobuf::Message>::default_instance()
    }
}

impl MsgRowOpaqueData {
    pub fn new() -> MsgRowOpaqueData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MsgOpaqueData>(
            "currentMsg",
            |m: &MsgRowOpaqueData| { &m.currentMsg },
            |m: &mut MsgRowOpaqueData| { &mut m.currentMsg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MsgOpaqueData>(
            "quotedMsg",
            |m: &MsgRowOpaqueData| { &m.quotedMsg },
            |m: &mut MsgRowOpaqueData| { &mut m.quotedMsg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgRowOpaqueData>(
            "MsgRowOpaqueData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgRowOpaqueData {
    const NAME: &'static str = "MsgRowOpaqueData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.currentMsg)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedMsg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currentMsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quotedMsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.currentMsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quotedMsg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgRowOpaqueData {
        MsgRowOpaqueData::new()
    }

    fn clear(&mut self) {
        self.currentMsg.clear();
        self.quotedMsg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgRowOpaqueData {
        static instance: MsgRowOpaqueData = MsgRowOpaqueData {
            currentMsg: ::protobuf::MessageField::none(),
            quotedMsg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgRowOpaqueData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgRowOpaqueData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgRowOpaqueData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgRowOpaqueData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.MsgOpaqueData)
pub struct MsgOpaqueData {
    // message fields
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.caption)
    pub caption: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.lng)
    pub lng: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.isLive)
    pub isLive: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.lat)
    pub lat: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.paymentAmount1000)
    pub paymentAmount1000: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.paymentNoteMsgBody)
    pub paymentNoteMsgBody: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.canonicalUrl)
    pub canonicalUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.matchedText)
    pub matchedText: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.futureproofBuffer)
    pub futureproofBuffer: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.clientUrl)
    pub clientUrl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.loc)
    pub loc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.pollName)
    pub pollName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.pollOptions)
    pub pollOptions: ::std::vec::Vec<msg_opaque_data::PollOption>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.pollSelectableOptionsCount)
    pub pollSelectableOptionsCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.messageSecret)
    pub messageSecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.originalSelfAuthor)
    pub originalSelfAuthor: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.senderTimestampMs)
    pub senderTimestampMs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.pollUpdateParentKey)
    pub pollUpdateParentKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.encPollVote)
    pub encPollVote: ::protobuf::MessageField<PollEncValue>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.isSentCagPollCreation)
    pub isSentCagPollCreation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.encReactionTargetMessageKey)
    pub encReactionTargetMessageKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.encReactionEncPayload)
    pub encReactionEncPayload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.MsgOpaqueData.encReactionEncIv)
    pub encReactionEncIv: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.MsgOpaqueData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MsgOpaqueData {
    fn default() -> &'a MsgOpaqueData {
        <MsgOpaqueData as ::protobuf::Message>::default_instance()
    }
}

impl MsgOpaqueData {
    pub fn new() -> MsgOpaqueData {
        ::std::default::Default::default()
    }

    // optional string body = 1;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string caption = 3;

    pub fn caption(&self) -> &str {
        match self.caption.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caption(&mut self) {
        self.caption = ::std::option::Option::None;
    }

    pub fn has_caption(&self) -> bool {
        self.caption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caption(&mut self, v: ::std::string::String) {
        self.caption = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caption(&mut self) -> &mut ::std::string::String {
        if self.caption.is_none() {
            self.caption = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caption.as_mut().unwrap()
    }

    // Take field
    pub fn take_caption(&mut self) -> ::std::string::String {
        self.caption.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double lng = 5;

    pub fn lng(&self) -> f64 {
        self.lng.unwrap_or(0.)
    }

    pub fn clear_lng(&mut self) {
        self.lng = ::std::option::Option::None;
    }

    pub fn has_lng(&self) -> bool {
        self.lng.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lng(&mut self, v: f64) {
        self.lng = ::std::option::Option::Some(v);
    }

    // optional bool isLive = 6;

    pub fn isLive(&self) -> bool {
        self.isLive.unwrap_or(false)
    }

    pub fn clear_isLive(&mut self) {
        self.isLive = ::std::option::Option::None;
    }

    pub fn has_isLive(&self) -> bool {
        self.isLive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isLive(&mut self, v: bool) {
        self.isLive = ::std::option::Option::Some(v);
    }

    // optional double lat = 7;

    pub fn lat(&self) -> f64 {
        self.lat.unwrap_or(0.)
    }

    pub fn clear_lat(&mut self) {
        self.lat = ::std::option::Option::None;
    }

    pub fn has_lat(&self) -> bool {
        self.lat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lat(&mut self, v: f64) {
        self.lat = ::std::option::Option::Some(v);
    }

    // optional int32 paymentAmount1000 = 8;

    pub fn paymentAmount1000(&self) -> i32 {
        self.paymentAmount1000.unwrap_or(0)
    }

    pub fn clear_paymentAmount1000(&mut self) {
        self.paymentAmount1000 = ::std::option::Option::None;
    }

    pub fn has_paymentAmount1000(&self) -> bool {
        self.paymentAmount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paymentAmount1000(&mut self, v: i32) {
        self.paymentAmount1000 = ::std::option::Option::Some(v);
    }

    // optional string paymentNoteMsgBody = 9;

    pub fn paymentNoteMsgBody(&self) -> &str {
        match self.paymentNoteMsgBody.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_paymentNoteMsgBody(&mut self) {
        self.paymentNoteMsgBody = ::std::option::Option::None;
    }

    pub fn has_paymentNoteMsgBody(&self) -> bool {
        self.paymentNoteMsgBody.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paymentNoteMsgBody(&mut self, v: ::std::string::String) {
        self.paymentNoteMsgBody = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paymentNoteMsgBody(&mut self) -> &mut ::std::string::String {
        if self.paymentNoteMsgBody.is_none() {
            self.paymentNoteMsgBody = ::std::option::Option::Some(::std::string::String::new());
        }
        self.paymentNoteMsgBody.as_mut().unwrap()
    }

    // Take field
    pub fn take_paymentNoteMsgBody(&mut self) -> ::std::string::String {
        self.paymentNoteMsgBody.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string canonicalUrl = 10;

    pub fn canonicalUrl(&self) -> &str {
        match self.canonicalUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_canonicalUrl(&mut self) {
        self.canonicalUrl = ::std::option::Option::None;
    }

    pub fn has_canonicalUrl(&self) -> bool {
        self.canonicalUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_canonicalUrl(&mut self, v: ::std::string::String) {
        self.canonicalUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonicalUrl(&mut self) -> &mut ::std::string::String {
        if self.canonicalUrl.is_none() {
            self.canonicalUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.canonicalUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_canonicalUrl(&mut self) -> ::std::string::String {
        self.canonicalUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string matchedText = 11;

    pub fn matchedText(&self) -> &str {
        match self.matchedText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_matchedText(&mut self) {
        self.matchedText = ::std::option::Option::None;
    }

    pub fn has_matchedText(&self) -> bool {
        self.matchedText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchedText(&mut self, v: ::std::string::String) {
        self.matchedText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_matchedText(&mut self) -> &mut ::std::string::String {
        if self.matchedText.is_none() {
            self.matchedText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.matchedText.as_mut().unwrap()
    }

    // Take field
    pub fn take_matchedText(&mut self) -> ::std::string::String {
        self.matchedText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string title = 12;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 13;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes futureproofBuffer = 14;

    pub fn futureproofBuffer(&self) -> &[u8] {
        match self.futureproofBuffer.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_futureproofBuffer(&mut self) {
        self.futureproofBuffer = ::std::option::Option::None;
    }

    pub fn has_futureproofBuffer(&self) -> bool {
        self.futureproofBuffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_futureproofBuffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.futureproofBuffer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_futureproofBuffer(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.futureproofBuffer.is_none() {
            self.futureproofBuffer = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.futureproofBuffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_futureproofBuffer(&mut self) -> ::std::vec::Vec<u8> {
        self.futureproofBuffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string clientUrl = 15;

    pub fn clientUrl(&self) -> &str {
        match self.clientUrl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clientUrl(&mut self) {
        self.clientUrl = ::std::option::Option::None;
    }

    pub fn has_clientUrl(&self) -> bool {
        self.clientUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientUrl(&mut self, v: ::std::string::String) {
        self.clientUrl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientUrl(&mut self) -> &mut ::std::string::String {
        if self.clientUrl.is_none() {
            self.clientUrl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clientUrl.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientUrl(&mut self) -> ::std::string::String {
        self.clientUrl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string loc = 16;

    pub fn loc(&self) -> &str {
        match self.loc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loc(&mut self) {
        self.loc = ::std::option::Option::None;
    }

    pub fn has_loc(&self) -> bool {
        self.loc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc(&mut self, v: ::std::string::String) {
        self.loc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc(&mut self) -> &mut ::std::string::String {
        if self.loc.is_none() {
            self.loc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loc.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc(&mut self) -> ::std::string::String {
        self.loc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pollName = 17;

    pub fn pollName(&self) -> &str {
        match self.pollName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pollName(&mut self) {
        self.pollName = ::std::option::Option::None;
    }

    pub fn has_pollName(&self) -> bool {
        self.pollName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pollName(&mut self, v: ::std::string::String) {
        self.pollName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pollName(&mut self) -> &mut ::std::string::String {
        if self.pollName.is_none() {
            self.pollName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pollName.as_mut().unwrap()
    }

    // Take field
    pub fn take_pollName(&mut self) -> ::std::string::String {
        self.pollName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 pollSelectableOptionsCount = 20;

    pub fn pollSelectableOptionsCount(&self) -> u32 {
        self.pollSelectableOptionsCount.unwrap_or(0)
    }

    pub fn clear_pollSelectableOptionsCount(&mut self) {
        self.pollSelectableOptionsCount = ::std::option::Option::None;
    }

    pub fn has_pollSelectableOptionsCount(&self) -> bool {
        self.pollSelectableOptionsCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pollSelectableOptionsCount(&mut self, v: u32) {
        self.pollSelectableOptionsCount = ::std::option::Option::Some(v);
    }

    // optional bytes messageSecret = 21;

    pub fn messageSecret(&self) -> &[u8] {
        match self.messageSecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_messageSecret(&mut self) {
        self.messageSecret = ::std::option::Option::None;
    }

    pub fn has_messageSecret(&self) -> bool {
        self.messageSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageSecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.messageSecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageSecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.messageSecret.is_none() {
            self.messageSecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.messageSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageSecret(&mut self) -> ::std::vec::Vec<u8> {
        self.messageSecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string originalSelfAuthor = 51;

    pub fn originalSelfAuthor(&self) -> &str {
        match self.originalSelfAuthor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_originalSelfAuthor(&mut self) {
        self.originalSelfAuthor = ::std::option::Option::None;
    }

    pub fn has_originalSelfAuthor(&self) -> bool {
        self.originalSelfAuthor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_originalSelfAuthor(&mut self, v: ::std::string::String) {
        self.originalSelfAuthor = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originalSelfAuthor(&mut self) -> &mut ::std::string::String {
        if self.originalSelfAuthor.is_none() {
            self.originalSelfAuthor = ::std::option::Option::Some(::std::string::String::new());
        }
        self.originalSelfAuthor.as_mut().unwrap()
    }

    // Take field
    pub fn take_originalSelfAuthor(&mut self) -> ::std::string::String {
        self.originalSelfAuthor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 senderTimestampMs = 22;

    pub fn senderTimestampMs(&self) -> i64 {
        self.senderTimestampMs.unwrap_or(0)
    }

    pub fn clear_senderTimestampMs(&mut self) {
        self.senderTimestampMs = ::std::option::Option::None;
    }

    pub fn has_senderTimestampMs(&self) -> bool {
        self.senderTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestampMs(&mut self, v: i64) {
        self.senderTimestampMs = ::std::option::Option::Some(v);
    }

    // optional string pollUpdateParentKey = 23;

    pub fn pollUpdateParentKey(&self) -> &str {
        match self.pollUpdateParentKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pollUpdateParentKey(&mut self) {
        self.pollUpdateParentKey = ::std::option::Option::None;
    }

    pub fn has_pollUpdateParentKey(&self) -> bool {
        self.pollUpdateParentKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pollUpdateParentKey(&mut self, v: ::std::string::String) {
        self.pollUpdateParentKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pollUpdateParentKey(&mut self) -> &mut ::std::string::String {
        if self.pollUpdateParentKey.is_none() {
            self.pollUpdateParentKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pollUpdateParentKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_pollUpdateParentKey(&mut self) -> ::std::string::String {
        self.pollUpdateParentKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool isSentCagPollCreation = 28;

    pub fn isSentCagPollCreation(&self) -> bool {
        self.isSentCagPollCreation.unwrap_or(false)
    }

    pub fn clear_isSentCagPollCreation(&mut self) {
        self.isSentCagPollCreation = ::std::option::Option::None;
    }

    pub fn has_isSentCagPollCreation(&self) -> bool {
        self.isSentCagPollCreation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isSentCagPollCreation(&mut self, v: bool) {
        self.isSentCagPollCreation = ::std::option::Option::Some(v);
    }

    // optional string encReactionTargetMessageKey = 25;

    pub fn encReactionTargetMessageKey(&self) -> &str {
        match self.encReactionTargetMessageKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_encReactionTargetMessageKey(&mut self) {
        self.encReactionTargetMessageKey = ::std::option::Option::None;
    }

    pub fn has_encReactionTargetMessageKey(&self) -> bool {
        self.encReactionTargetMessageKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encReactionTargetMessageKey(&mut self, v: ::std::string::String) {
        self.encReactionTargetMessageKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encReactionTargetMessageKey(&mut self) -> &mut ::std::string::String {
        if self.encReactionTargetMessageKey.is_none() {
            self.encReactionTargetMessageKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.encReactionTargetMessageKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_encReactionTargetMessageKey(&mut self) -> ::std::string::String {
        self.encReactionTargetMessageKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes encReactionEncPayload = 26;

    pub fn encReactionEncPayload(&self) -> &[u8] {
        match self.encReactionEncPayload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encReactionEncPayload(&mut self) {
        self.encReactionEncPayload = ::std::option::Option::None;
    }

    pub fn has_encReactionEncPayload(&self) -> bool {
        self.encReactionEncPayload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encReactionEncPayload(&mut self, v: ::std::vec::Vec<u8>) {
        self.encReactionEncPayload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encReactionEncPayload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encReactionEncPayload.is_none() {
            self.encReactionEncPayload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encReactionEncPayload.as_mut().unwrap()
    }

    // Take field
    pub fn take_encReactionEncPayload(&mut self) -> ::std::vec::Vec<u8> {
        self.encReactionEncPayload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes encReactionEncIv = 27;

    pub fn encReactionEncIv(&self) -> &[u8] {
        match self.encReactionEncIv.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encReactionEncIv(&mut self) {
        self.encReactionEncIv = ::std::option::Option::None;
    }

    pub fn has_encReactionEncIv(&self) -> bool {
        self.encReactionEncIv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encReactionEncIv(&mut self, v: ::std::vec::Vec<u8>) {
        self.encReactionEncIv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encReactionEncIv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encReactionEncIv.is_none() {
            self.encReactionEncIv = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.encReactionEncIv.as_mut().unwrap()
    }

    // Take field
    pub fn take_encReactionEncIv(&mut self) -> ::std::vec::Vec<u8> {
        self.encReactionEncIv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &MsgOpaqueData| { &m.body },
            |m: &mut MsgOpaqueData| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caption",
            |m: &MsgOpaqueData| { &m.caption },
            |m: &mut MsgOpaqueData| { &mut m.caption },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lng",
            |m: &MsgOpaqueData| { &m.lng },
            |m: &mut MsgOpaqueData| { &mut m.lng },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isLive",
            |m: &MsgOpaqueData| { &m.isLive },
            |m: &mut MsgOpaqueData| { &mut m.isLive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lat",
            |m: &MsgOpaqueData| { &m.lat },
            |m: &mut MsgOpaqueData| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paymentAmount1000",
            |m: &MsgOpaqueData| { &m.paymentAmount1000 },
            |m: &mut MsgOpaqueData| { &mut m.paymentAmount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paymentNoteMsgBody",
            |m: &MsgOpaqueData| { &m.paymentNoteMsgBody },
            |m: &mut MsgOpaqueData| { &mut m.paymentNoteMsgBody },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "canonicalUrl",
            |m: &MsgOpaqueData| { &m.canonicalUrl },
            |m: &mut MsgOpaqueData| { &mut m.canonicalUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchedText",
            |m: &MsgOpaqueData| { &m.matchedText },
            |m: &mut MsgOpaqueData| { &mut m.matchedText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &MsgOpaqueData| { &m.title },
            |m: &mut MsgOpaqueData| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &MsgOpaqueData| { &m.description },
            |m: &mut MsgOpaqueData| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "futureproofBuffer",
            |m: &MsgOpaqueData| { &m.futureproofBuffer },
            |m: &mut MsgOpaqueData| { &mut m.futureproofBuffer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientUrl",
            |m: &MsgOpaqueData| { &m.clientUrl },
            |m: &mut MsgOpaqueData| { &mut m.clientUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "loc",
            |m: &MsgOpaqueData| { &m.loc },
            |m: &mut MsgOpaqueData| { &mut m.loc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pollName",
            |m: &MsgOpaqueData| { &m.pollName },
            |m: &mut MsgOpaqueData| { &mut m.pollName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pollOptions",
            |m: &MsgOpaqueData| { &m.pollOptions },
            |m: &mut MsgOpaqueData| { &mut m.pollOptions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pollSelectableOptionsCount",
            |m: &MsgOpaqueData| { &m.pollSelectableOptionsCount },
            |m: &mut MsgOpaqueData| { &mut m.pollSelectableOptionsCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageSecret",
            |m: &MsgOpaqueData| { &m.messageSecret },
            |m: &mut MsgOpaqueData| { &mut m.messageSecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "originalSelfAuthor",
            |m: &MsgOpaqueData| { &m.originalSelfAuthor },
            |m: &mut MsgOpaqueData| { &mut m.originalSelfAuthor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestampMs",
            |m: &MsgOpaqueData| { &m.senderTimestampMs },
            |m: &mut MsgOpaqueData| { &mut m.senderTimestampMs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pollUpdateParentKey",
            |m: &MsgOpaqueData| { &m.pollUpdateParentKey },
            |m: &mut MsgOpaqueData| { &mut m.pollUpdateParentKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollEncValue>(
            "encPollVote",
            |m: &MsgOpaqueData| { &m.encPollVote },
            |m: &mut MsgOpaqueData| { &mut m.encPollVote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isSentCagPollCreation",
            |m: &MsgOpaqueData| { &m.isSentCagPollCreation },
            |m: &mut MsgOpaqueData| { &mut m.isSentCagPollCreation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encReactionTargetMessageKey",
            |m: &MsgOpaqueData| { &m.encReactionTargetMessageKey },
            |m: &mut MsgOpaqueData| { &mut m.encReactionTargetMessageKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encReactionEncPayload",
            |m: &MsgOpaqueData| { &m.encReactionEncPayload },
            |m: &mut MsgOpaqueData| { &mut m.encReactionEncPayload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encReactionEncIv",
            |m: &MsgOpaqueData| { &m.encReactionEncIv },
            |m: &mut MsgOpaqueData| { &mut m.encReactionEncIv },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MsgOpaqueData>(
            "MsgOpaqueData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MsgOpaqueData {
    const NAME: &'static str = "MsgOpaqueData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.caption = ::std::option::Option::Some(is.read_string()?);
                },
                41 => {
                    self.lng = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.isLive = ::std::option::Option::Some(is.read_bool()?);
                },
                57 => {
                    self.lat = ::std::option::Option::Some(is.read_double()?);
                },
                64 => {
                    self.paymentAmount1000 = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.paymentNoteMsgBody = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.canonicalUrl = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.matchedText = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.futureproofBuffer = ::std::option::Option::Some(is.read_bytes()?);
                },
                122 => {
                    self.clientUrl = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.loc = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.pollName = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.pollOptions.push(is.read_message()?);
                },
                160 => {
                    self.pollSelectableOptionsCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                170 => {
                    self.messageSecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                410 => {
                    self.originalSelfAuthor = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.senderTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                186 => {
                    self.pollUpdateParentKey = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.encPollVote)?;
                },
                224 => {
                    self.isSentCagPollCreation = ::std::option::Option::Some(is.read_bool()?);
                },
                202 => {
                    self.encReactionTargetMessageKey = ::std::option::Option::Some(is.read_string()?);
                },
                210 => {
                    self.encReactionEncPayload = ::std::option::Option::Some(is.read_bytes()?);
                },
                218 => {
                    self.encReactionEncIv = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.caption.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.lng {
            my_size += 1 + 8;
        }
        if let Some(v) = self.isLive {
            my_size += 1 + 1;
        }
        if let Some(v) = self.lat {
            my_size += 1 + 8;
        }
        if let Some(v) = self.paymentAmount1000 {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.paymentNoteMsgBody.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.canonicalUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.matchedText.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.futureproofBuffer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.clientUrl.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.loc.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.pollName.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        for value in &self.pollOptions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pollSelectableOptionsCount {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.messageSecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        if let Some(v) = self.originalSelfAuthor.as_ref() {
            my_size += ::protobuf::rt::string_size(51, &v);
        }
        if let Some(v) = self.senderTimestampMs {
            my_size += ::protobuf::rt::int64_size(22, v);
        }
        if let Some(v) = self.pollUpdateParentKey.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.encPollVote.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.isSentCagPollCreation {
            my_size += 2 + 1;
        }
        if let Some(v) = self.encReactionTargetMessageKey.as_ref() {
            my_size += ::protobuf::rt::string_size(25, &v);
        }
        if let Some(v) = self.encReactionEncPayload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(26, &v);
        }
        if let Some(v) = self.encReactionEncIv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(27, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.body.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.caption.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.lng {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.isLive {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.lat {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.paymentAmount1000 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.paymentNoteMsgBody.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.canonicalUrl.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.matchedText.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.futureproofBuffer.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.clientUrl.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.loc.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.pollName.as_ref() {
            os.write_string(17, v)?;
        }
        for v in &self.pollOptions {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.pollSelectableOptionsCount {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.messageSecret.as_ref() {
            os.write_bytes(21, v)?;
        }
        if let Some(v) = self.originalSelfAuthor.as_ref() {
            os.write_string(51, v)?;
        }
        if let Some(v) = self.senderTimestampMs {
            os.write_int64(22, v)?;
        }
        if let Some(v) = self.pollUpdateParentKey.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.encPollVote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.isSentCagPollCreation {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.encReactionTargetMessageKey.as_ref() {
            os.write_string(25, v)?;
        }
        if let Some(v) = self.encReactionEncPayload.as_ref() {
            os.write_bytes(26, v)?;
        }
        if let Some(v) = self.encReactionEncIv.as_ref() {
            os.write_bytes(27, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MsgOpaqueData {
        MsgOpaqueData::new()
    }

    fn clear(&mut self) {
        self.body = ::std::option::Option::None;
        self.caption = ::std::option::Option::None;
        self.lng = ::std::option::Option::None;
        self.isLive = ::std::option::Option::None;
        self.lat = ::std::option::Option::None;
        self.paymentAmount1000 = ::std::option::Option::None;
        self.paymentNoteMsgBody = ::std::option::Option::None;
        self.canonicalUrl = ::std::option::Option::None;
        self.matchedText = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.futureproofBuffer = ::std::option::Option::None;
        self.clientUrl = ::std::option::Option::None;
        self.loc = ::std::option::Option::None;
        self.pollName = ::std::option::Option::None;
        self.pollOptions.clear();
        self.pollSelectableOptionsCount = ::std::option::Option::None;
        self.messageSecret = ::std::option::Option::None;
        self.originalSelfAuthor = ::std::option::Option::None;
        self.senderTimestampMs = ::std::option::Option::None;
        self.pollUpdateParentKey = ::std::option::Option::None;
        self.encPollVote.clear();
        self.isSentCagPollCreation = ::std::option::Option::None;
        self.encReactionTargetMessageKey = ::std::option::Option::None;
        self.encReactionEncPayload = ::std::option::Option::None;
        self.encReactionEncIv = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MsgOpaqueData {
        static instance: MsgOpaqueData = MsgOpaqueData {
            body: ::std::option::Option::None,
            caption: ::std::option::Option::None,
            lng: ::std::option::Option::None,
            isLive: ::std::option::Option::None,
            lat: ::std::option::Option::None,
            paymentAmount1000: ::std::option::Option::None,
            paymentNoteMsgBody: ::std::option::Option::None,
            canonicalUrl: ::std::option::Option::None,
            matchedText: ::std::option::Option::None,
            title: ::std::option::Option::None,
            description: ::std::option::Option::None,
            futureproofBuffer: ::std::option::Option::None,
            clientUrl: ::std::option::Option::None,
            loc: ::std::option::Option::None,
            pollName: ::std::option::Option::None,
            pollOptions: ::std::vec::Vec::new(),
            pollSelectableOptionsCount: ::std::option::Option::None,
            messageSecret: ::std::option::Option::None,
            originalSelfAuthor: ::std::option::Option::None,
            senderTimestampMs: ::std::option::Option::None,
            pollUpdateParentKey: ::std::option::Option::None,
            encPollVote: ::protobuf::MessageField::none(),
            isSentCagPollCreation: ::std::option::Option::None,
            encReactionTargetMessageKey: ::std::option::Option::None,
            encReactionEncPayload: ::std::option::Option::None,
            encReactionEncIv: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MsgOpaqueData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MsgOpaqueData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MsgOpaqueData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgOpaqueData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MsgOpaqueData`
pub mod msg_opaque_data {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.MsgOpaqueData.PollOption)
    pub struct PollOption {
        // message fields
        // @@protoc_insertion_point(field:proto.MsgOpaqueData.PollOption.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.MsgOpaqueData.PollOption.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PollOption {
        fn default() -> &'a PollOption {
            <PollOption as ::protobuf::Message>::default_instance()
        }
    }

    impl PollOption {
        pub fn new() -> PollOption {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &PollOption| { &m.name },
                |m: &mut PollOption| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollOption>(
                "MsgOpaqueData.PollOption",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PollOption {
        const NAME: &'static str = "PollOption";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PollOption {
            PollOption::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PollOption {
            static instance: PollOption = PollOption {
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PollOption {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MsgOpaqueData.PollOption").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PollOption {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PollOption {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ServerErrorReceipt)
pub struct ServerErrorReceipt {
    // message fields
    // @@protoc_insertion_point(field:proto.ServerErrorReceipt.stanzaId)
    pub stanzaId: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ServerErrorReceipt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerErrorReceipt {
    fn default() -> &'a ServerErrorReceipt {
        <ServerErrorReceipt as ::protobuf::Message>::default_instance()
    }
}

impl ServerErrorReceipt {
    pub fn new() -> ServerErrorReceipt {
        ::std::default::Default::default()
    }

    // optional string stanzaId = 1;

    pub fn stanzaId(&self) -> &str {
        match self.stanzaId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stanzaId(&mut self) {
        self.stanzaId = ::std::option::Option::None;
    }

    pub fn has_stanzaId(&self) -> bool {
        self.stanzaId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stanzaId(&mut self, v: ::std::string::String) {
        self.stanzaId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stanzaId(&mut self) -> &mut ::std::string::String {
        if self.stanzaId.is_none() {
            self.stanzaId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stanzaId.as_mut().unwrap()
    }

    // Take field
    pub fn take_stanzaId(&mut self) -> ::std::string::String {
        self.stanzaId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stanzaId",
            |m: &ServerErrorReceipt| { &m.stanzaId },
            |m: &mut ServerErrorReceipt| { &mut m.stanzaId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerErrorReceipt>(
            "ServerErrorReceipt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerErrorReceipt {
    const NAME: &'static str = "ServerErrorReceipt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stanzaId = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stanzaId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stanzaId.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerErrorReceipt {
        ServerErrorReceipt::new()
    }

    fn clear(&mut self) {
        self.stanzaId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerErrorReceipt {
        static instance: ServerErrorReceipt = ServerErrorReceipt {
            stanzaId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerErrorReceipt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerErrorReceipt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerErrorReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerErrorReceipt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.MediaRetryNotification)
pub struct MediaRetryNotification {
    // message fields
    // @@protoc_insertion_point(field:proto.MediaRetryNotification.stanzaId)
    pub stanzaId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MediaRetryNotification.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MediaRetryNotification.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<media_retry_notification::ResultType>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.MediaRetryNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaRetryNotification {
    fn default() -> &'a MediaRetryNotification {
        <MediaRetryNotification as ::protobuf::Message>::default_instance()
    }
}

impl MediaRetryNotification {
    pub fn new() -> MediaRetryNotification {
        ::std::default::Default::default()
    }

    // optional string stanzaId = 1;

    pub fn stanzaId(&self) -> &str {
        match self.stanzaId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stanzaId(&mut self) {
        self.stanzaId = ::std::option::Option::None;
    }

    pub fn has_stanzaId(&self) -> bool {
        self.stanzaId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stanzaId(&mut self, v: ::std::string::String) {
        self.stanzaId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stanzaId(&mut self) -> &mut ::std::string::String {
        if self.stanzaId.is_none() {
            self.stanzaId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stanzaId.as_mut().unwrap()
    }

    // Take field
    pub fn take_stanzaId(&mut self) -> ::std::string::String {
        self.stanzaId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string directPath = 2;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.MediaRetryNotification.ResultType result = 3;

    pub fn result(&self) -> media_retry_notification::ResultType {
        match self.result {
            Some(e) => e.enum_value_or(media_retry_notification::ResultType::GENERAL_ERROR),
            None => media_retry_notification::ResultType::GENERAL_ERROR,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: media_retry_notification::ResultType) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stanzaId",
            |m: &MediaRetryNotification| { &m.stanzaId },
            |m: &mut MediaRetryNotification| { &mut m.stanzaId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &MediaRetryNotification| { &m.directPath },
            |m: &mut MediaRetryNotification| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &MediaRetryNotification| { &m.result },
            |m: &mut MediaRetryNotification| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaRetryNotification>(
            "MediaRetryNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaRetryNotification {
    const NAME: &'static str = "MediaRetryNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stanzaId = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stanzaId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stanzaId.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaRetryNotification {
        MediaRetryNotification::new()
    }

    fn clear(&mut self) {
        self.stanzaId = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaRetryNotification {
        static instance: MediaRetryNotification = MediaRetryNotification {
            stanzaId: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaRetryNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaRetryNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaRetryNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaRetryNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MediaRetryNotification`
pub mod media_retry_notification {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.MediaRetryNotification.ResultType)
    pub enum ResultType {
        // @@protoc_insertion_point(enum_value:proto.MediaRetryNotification.ResultType.GENERAL_ERROR)
        GENERAL_ERROR = 0,
        // @@protoc_insertion_point(enum_value:proto.MediaRetryNotification.ResultType.SUCCESS)
        SUCCESS = 1,
        // @@protoc_insertion_point(enum_value:proto.MediaRetryNotification.ResultType.NOT_FOUND)
        NOT_FOUND = 2,
        // @@protoc_insertion_point(enum_value:proto.MediaRetryNotification.ResultType.DECRYPTION_ERROR)
        DECRYPTION_ERROR = 3,
    }

    impl ::protobuf::Enum for ResultType {
        const NAME: &'static str = "ResultType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ResultType> {
            match value {
                0 => ::std::option::Option::Some(ResultType::GENERAL_ERROR),
                1 => ::std::option::Option::Some(ResultType::SUCCESS),
                2 => ::std::option::Option::Some(ResultType::NOT_FOUND),
                3 => ::std::option::Option::Some(ResultType::DECRYPTION_ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ResultType] = &[
            ResultType::GENERAL_ERROR,
            ResultType::SUCCESS,
            ResultType::NOT_FOUND,
            ResultType::DECRYPTION_ERROR,
        ];
    }

    impl ::protobuf::EnumFull for ResultType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MediaRetryNotification.ResultType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ResultType {
        fn default() -> Self {
            ResultType::GENERAL_ERROR
        }
    }

    impl ResultType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ResultType>("MediaRetryNotification.ResultType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.MessageKey)
pub struct MessageKey {
    // message fields
    // @@protoc_insertion_point(field:proto.MessageKey.remoteJid)
    pub remoteJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MessageKey.fromMe)
    pub fromMe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.MessageKey.id)
    pub id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.MessageKey.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.MessageKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageKey {
    fn default() -> &'a MessageKey {
        <MessageKey as ::protobuf::Message>::default_instance()
    }
}

impl MessageKey {
    pub fn new() -> MessageKey {
        ::std::default::Default::default()
    }

    // optional string remoteJid = 1;

    pub fn remoteJid(&self) -> &str {
        match self.remoteJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_remoteJid(&mut self) {
        self.remoteJid = ::std::option::Option::None;
    }

    pub fn has_remoteJid(&self) -> bool {
        self.remoteJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteJid(&mut self, v: ::std::string::String) {
        self.remoteJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remoteJid(&mut self) -> &mut ::std::string::String {
        if self.remoteJid.is_none() {
            self.remoteJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.remoteJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_remoteJid(&mut self) -> ::std::string::String {
        self.remoteJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool fromMe = 2;

    pub fn fromMe(&self) -> bool {
        self.fromMe.unwrap_or(false)
    }

    pub fn clear_fromMe(&mut self) {
        self.fromMe = ::std::option::Option::None;
    }

    pub fn has_fromMe(&self) -> bool {
        self.fromMe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromMe(&mut self, v: bool) {
        self.fromMe = ::std::option::Option::Some(v);
    }

    // optional string id = 3;

    pub fn id(&self) -> &str {
        match self.id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string participant = 4;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remoteJid",
            |m: &MessageKey| { &m.remoteJid },
            |m: &mut MessageKey| { &mut m.remoteJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromMe",
            |m: &MessageKey| { &m.fromMe },
            |m: &mut MessageKey| { &mut m.fromMe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &MessageKey| { &m.id },
            |m: &mut MessageKey| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &MessageKey| { &m.participant },
            |m: &mut MessageKey| { &mut m.participant },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageKey>(
            "MessageKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageKey {
    const NAME: &'static str = "MessageKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.remoteJid = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.fromMe = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.id = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.remoteJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fromMe {
            my_size += 1 + 1;
        }
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.remoteJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fromMe {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.id.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageKey {
        MessageKey::new()
    }

    fn clear(&mut self) {
        self.remoteJid = ::std::option::Option::None;
        self.fromMe = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageKey {
        static instance: MessageKey = MessageKey {
            remoteJid: ::std::option::Option::None,
            fromMe: ::std::option::Option::None,
            id: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncdVersion)
pub struct SyncdVersion {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncdVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncdVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdVersion {
    fn default() -> &'a SyncdVersion {
        <SyncdVersion as ::protobuf::Message>::default_instance()
    }
}

impl SyncdVersion {
    pub fn new() -> SyncdVersion {
        ::std::default::Default::default()
    }

    // optional uint64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &SyncdVersion| { &m.version },
            |m: &mut SyncdVersion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdVersion>(
            "SyncdVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdVersion {
    const NAME: &'static str = "SyncdVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdVersion {
        SyncdVersion::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdVersion {
        static instance: SyncdVersion = SyncdVersion {
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncdValue)
pub struct SyncdValue {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncdValue.blob)
    pub blob: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncdValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdValue {
    fn default() -> &'a SyncdValue {
        <SyncdValue as ::protobuf::Message>::default_instance()
    }
}

impl SyncdValue {
    pub fn new() -> SyncdValue {
        ::std::default::Default::default()
    }

    // optional bytes blob = 1;

    pub fn blob(&self) -> &[u8] {
        match self.blob.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_blob(&mut self) {
        self.blob = ::std::option::Option::None;
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blob.is_none() {
            self.blob = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blob",
            |m: &SyncdValue| { &m.blob },
            |m: &mut SyncdValue| { &mut m.blob },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdValue>(
            "SyncdValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdValue {
    const NAME: &'static str = "SyncdValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.blob = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.blob.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdValue {
        SyncdValue::new()
    }

    fn clear(&mut self) {
        self.blob = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdValue {
        static instance: SyncdValue = SyncdValue {
            blob: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncdSnapshot)
pub struct SyncdSnapshot {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncdSnapshot.version)
    pub version: ::protobuf::MessageField<SyncdVersion>,
    // @@protoc_insertion_point(field:proto.SyncdSnapshot.records)
    pub records: ::std::vec::Vec<SyncdRecord>,
    // @@protoc_insertion_point(field:proto.SyncdSnapshot.mac)
    pub mac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.SyncdSnapshot.keyId)
    pub keyId: ::protobuf::MessageField<KeyId>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncdSnapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdSnapshot {
    fn default() -> &'a SyncdSnapshot {
        <SyncdSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl SyncdSnapshot {
    pub fn new() -> SyncdSnapshot {
        ::std::default::Default::default()
    }

    // optional bytes mac = 3;

    pub fn mac(&self) -> &[u8] {
        match self.mac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mac(&mut self) {
        self.mac = ::std::option::Option::None;
    }

    pub fn has_mac(&self) -> bool {
        self.mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mac(&mut self, v: ::std::vec::Vec<u8>) {
        self.mac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mac.is_none() {
            self.mac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mac.as_mut().unwrap()
    }

    // Take field
    pub fn take_mac(&mut self) -> ::std::vec::Vec<u8> {
        self.mac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdVersion>(
            "version",
            |m: &SyncdSnapshot| { &m.version },
            |m: &mut SyncdSnapshot| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "records",
            |m: &SyncdSnapshot| { &m.records },
            |m: &mut SyncdSnapshot| { &mut m.records },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mac",
            |m: &SyncdSnapshot| { &m.mac },
            |m: &mut SyncdSnapshot| { &mut m.mac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyId>(
            "keyId",
            |m: &SyncdSnapshot| { &m.keyId },
            |m: &mut SyncdSnapshot| { &mut m.keyId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdSnapshot>(
            "SyncdSnapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdSnapshot {
    const NAME: &'static str = "SyncdSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                18 => {
                    self.records.push(is.read_message()?);
                },
                26 => {
                    self.mac = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyId)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.mac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.keyId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.records {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.mac.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.keyId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdSnapshot {
        SyncdSnapshot::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.records.clear();
        self.mac = ::std::option::Option::None;
        self.keyId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdSnapshot {
        static instance: SyncdSnapshot = SyncdSnapshot {
            version: ::protobuf::MessageField::none(),
            records: ::std::vec::Vec::new(),
            mac: ::std::option::Option::None,
            keyId: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdSnapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdSnapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdSnapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncdRecord)
pub struct SyncdRecord {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncdRecord.index)
    pub index: ::protobuf::MessageField<SyncdIndex>,
    // @@protoc_insertion_point(field:proto.SyncdRecord.value)
    pub value: ::protobuf::MessageField<SyncdValue>,
    // @@protoc_insertion_point(field:proto.SyncdRecord.keyId)
    pub keyId: ::protobuf::MessageField<KeyId>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncdRecord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdRecord {
    fn default() -> &'a SyncdRecord {
        <SyncdRecord as ::protobuf::Message>::default_instance()
    }
}

impl SyncdRecord {
    pub fn new() -> SyncdRecord {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdIndex>(
            "index",
            |m: &SyncdRecord| { &m.index },
            |m: &mut SyncdRecord| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdValue>(
            "value",
            |m: &SyncdRecord| { &m.value },
            |m: &mut SyncdRecord| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyId>(
            "keyId",
            |m: &SyncdRecord| { &m.keyId },
            |m: &mut SyncdRecord| { &mut m.keyId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdRecord>(
            "SyncdRecord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdRecord {
    const NAME: &'static str = "SyncdRecord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.index)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyId)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keyId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.keyId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdRecord {
        SyncdRecord::new()
    }

    fn clear(&mut self) {
        self.index.clear();
        self.value.clear();
        self.keyId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdRecord {
        static instance: SyncdRecord = SyncdRecord {
            index: ::protobuf::MessageField::none(),
            value: ::protobuf::MessageField::none(),
            keyId: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdRecord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdRecord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdRecord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncdPatch)
pub struct SyncdPatch {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncdPatch.version)
    pub version: ::protobuf::MessageField<SyncdVersion>,
    // @@protoc_insertion_point(field:proto.SyncdPatch.mutations)
    pub mutations: ::std::vec::Vec<SyncdMutation>,
    // @@protoc_insertion_point(field:proto.SyncdPatch.externalMutations)
    pub externalMutations: ::protobuf::MessageField<ExternalBlobReference>,
    // @@protoc_insertion_point(field:proto.SyncdPatch.snapshotMac)
    pub snapshotMac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.SyncdPatch.patchMac)
    pub patchMac: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.SyncdPatch.keyId)
    pub keyId: ::protobuf::MessageField<KeyId>,
    // @@protoc_insertion_point(field:proto.SyncdPatch.exitCode)
    pub exitCode: ::protobuf::MessageField<ExitCode>,
    // @@protoc_insertion_point(field:proto.SyncdPatch.deviceIndex)
    pub deviceIndex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncdPatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdPatch {
    fn default() -> &'a SyncdPatch {
        <SyncdPatch as ::protobuf::Message>::default_instance()
    }
}

impl SyncdPatch {
    pub fn new() -> SyncdPatch {
        ::std::default::Default::default()
    }

    // optional bytes snapshotMac = 4;

    pub fn snapshotMac(&self) -> &[u8] {
        match self.snapshotMac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_snapshotMac(&mut self) {
        self.snapshotMac = ::std::option::Option::None;
    }

    pub fn has_snapshotMac(&self) -> bool {
        self.snapshotMac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotMac(&mut self, v: ::std::vec::Vec<u8>) {
        self.snapshotMac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotMac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.snapshotMac.is_none() {
            self.snapshotMac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.snapshotMac.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotMac(&mut self) -> ::std::vec::Vec<u8> {
        self.snapshotMac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes patchMac = 5;

    pub fn patchMac(&self) -> &[u8] {
        match self.patchMac.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_patchMac(&mut self) {
        self.patchMac = ::std::option::Option::None;
    }

    pub fn has_patchMac(&self) -> bool {
        self.patchMac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patchMac(&mut self, v: ::std::vec::Vec<u8>) {
        self.patchMac = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patchMac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.patchMac.is_none() {
            self.patchMac = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.patchMac.as_mut().unwrap()
    }

    // Take field
    pub fn take_patchMac(&mut self) -> ::std::vec::Vec<u8> {
        self.patchMac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 deviceIndex = 8;

    pub fn deviceIndex(&self) -> u32 {
        self.deviceIndex.unwrap_or(0)
    }

    pub fn clear_deviceIndex(&mut self) {
        self.deviceIndex = ::std::option::Option::None;
    }

    pub fn has_deviceIndex(&self) -> bool {
        self.deviceIndex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceIndex(&mut self, v: u32) {
        self.deviceIndex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdVersion>(
            "version",
            |m: &SyncdPatch| { &m.version },
            |m: &mut SyncdPatch| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mutations",
            |m: &SyncdPatch| { &m.mutations },
            |m: &mut SyncdPatch| { &mut m.mutations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExternalBlobReference>(
            "externalMutations",
            |m: &SyncdPatch| { &m.externalMutations },
            |m: &mut SyncdPatch| { &mut m.externalMutations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "snapshotMac",
            |m: &SyncdPatch| { &m.snapshotMac },
            |m: &mut SyncdPatch| { &mut m.snapshotMac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "patchMac",
            |m: &SyncdPatch| { &m.patchMac },
            |m: &mut SyncdPatch| { &mut m.patchMac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyId>(
            "keyId",
            |m: &SyncdPatch| { &m.keyId },
            |m: &mut SyncdPatch| { &mut m.keyId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExitCode>(
            "exitCode",
            |m: &SyncdPatch| { &m.exitCode },
            |m: &mut SyncdPatch| { &mut m.exitCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceIndex",
            |m: &SyncdPatch| { &m.deviceIndex },
            |m: &mut SyncdPatch| { &mut m.deviceIndex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdPatch>(
            "SyncdPatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdPatch {
    const NAME: &'static str = "SyncdPatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.version)?;
                },
                18 => {
                    self.mutations.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.externalMutations)?;
                },
                34 => {
                    self.snapshotMac = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.patchMac = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyId)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exitCode)?;
                },
                64 => {
                    self.deviceIndex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.externalMutations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.snapshotMac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.patchMac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.keyId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.exitCode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deviceIndex {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.mutations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.externalMutations.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.snapshotMac.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.patchMac.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.keyId.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.exitCode.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.deviceIndex {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdPatch {
        SyncdPatch::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.mutations.clear();
        self.externalMutations.clear();
        self.snapshotMac = ::std::option::Option::None;
        self.patchMac = ::std::option::Option::None;
        self.keyId.clear();
        self.exitCode.clear();
        self.deviceIndex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdPatch {
        static instance: SyncdPatch = SyncdPatch {
            version: ::protobuf::MessageField::none(),
            mutations: ::std::vec::Vec::new(),
            externalMutations: ::protobuf::MessageField::none(),
            snapshotMac: ::std::option::Option::None,
            patchMac: ::std::option::Option::None,
            keyId: ::protobuf::MessageField::none(),
            exitCode: ::protobuf::MessageField::none(),
            deviceIndex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdPatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdPatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdPatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdPatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncdMutations)
pub struct SyncdMutations {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncdMutations.mutations)
    pub mutations: ::std::vec::Vec<SyncdMutation>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncdMutations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdMutations {
    fn default() -> &'a SyncdMutations {
        <SyncdMutations as ::protobuf::Message>::default_instance()
    }
}

impl SyncdMutations {
    pub fn new() -> SyncdMutations {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mutations",
            |m: &SyncdMutations| { &m.mutations },
            |m: &mut SyncdMutations| { &mut m.mutations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdMutations>(
            "SyncdMutations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdMutations {
    const NAME: &'static str = "SyncdMutations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mutations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.mutations {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdMutations {
        SyncdMutations::new()
    }

    fn clear(&mut self) {
        self.mutations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdMutations {
        static instance: SyncdMutations = SyncdMutations {
            mutations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdMutations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdMutations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdMutations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdMutations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncdMutation)
pub struct SyncdMutation {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncdMutation.operation)
    pub operation: ::std::option::Option<::protobuf::EnumOrUnknown<syncd_mutation::SyncdOperation>>,
    // @@protoc_insertion_point(field:proto.SyncdMutation.record)
    pub record: ::protobuf::MessageField<SyncdRecord>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncdMutation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdMutation {
    fn default() -> &'a SyncdMutation {
        <SyncdMutation as ::protobuf::Message>::default_instance()
    }
}

impl SyncdMutation {
    pub fn new() -> SyncdMutation {
        ::std::default::Default::default()
    }

    // optional .proto.SyncdMutation.SyncdOperation operation = 1;

    pub fn operation(&self) -> syncd_mutation::SyncdOperation {
        match self.operation {
            Some(e) => e.enum_value_or(syncd_mutation::SyncdOperation::SET),
            None => syncd_mutation::SyncdOperation::SET,
        }
    }

    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: syncd_mutation::SyncdOperation) {
        self.operation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation",
            |m: &SyncdMutation| { &m.operation },
            |m: &mut SyncdMutation| { &mut m.operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncdRecord>(
            "record",
            |m: &SyncdMutation| { &m.record },
            |m: &mut SyncdMutation| { &mut m.record },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdMutation>(
            "SyncdMutation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdMutation {
    const NAME: &'static str = "SyncdMutation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.record)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.record.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operation {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.record.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdMutation {
        SyncdMutation::new()
    }

    fn clear(&mut self) {
        self.operation = ::std::option::Option::None;
        self.record.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdMutation {
        static instance: SyncdMutation = SyncdMutation {
            operation: ::std::option::Option::None,
            record: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdMutation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdMutation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdMutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdMutation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SyncdMutation`
pub mod syncd_mutation {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.SyncdMutation.SyncdOperation)
    pub enum SyncdOperation {
        // @@protoc_insertion_point(enum_value:proto.SyncdMutation.SyncdOperation.SET)
        SET = 0,
        // @@protoc_insertion_point(enum_value:proto.SyncdMutation.SyncdOperation.REMOVE)
        REMOVE = 1,
    }

    impl ::protobuf::Enum for SyncdOperation {
        const NAME: &'static str = "SyncdOperation";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SyncdOperation> {
            match value {
                0 => ::std::option::Option::Some(SyncdOperation::SET),
                1 => ::std::option::Option::Some(SyncdOperation::REMOVE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SyncdOperation] = &[
            SyncdOperation::SET,
            SyncdOperation::REMOVE,
        ];
    }

    impl ::protobuf::EnumFull for SyncdOperation {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SyncdMutation.SyncdOperation").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SyncdOperation {
        fn default() -> Self {
            SyncdOperation::SET
        }
    }

    impl SyncdOperation {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SyncdOperation>("SyncdMutation.SyncdOperation")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncdIndex)
pub struct SyncdIndex {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncdIndex.blob)
    pub blob: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncdIndex.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncdIndex {
    fn default() -> &'a SyncdIndex {
        <SyncdIndex as ::protobuf::Message>::default_instance()
    }
}

impl SyncdIndex {
    pub fn new() -> SyncdIndex {
        ::std::default::Default::default()
    }

    // optional bytes blob = 1;

    pub fn blob(&self) -> &[u8] {
        match self.blob.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_blob(&mut self) {
        self.blob = ::std::option::Option::None;
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blob.is_none() {
            self.blob = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blob",
            |m: &SyncdIndex| { &m.blob },
            |m: &mut SyncdIndex| { &mut m.blob },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncdIndex>(
            "SyncdIndex",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncdIndex {
    const NAME: &'static str = "SyncdIndex";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.blob = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.blob.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncdIndex {
        SyncdIndex::new()
    }

    fn clear(&mut self) {
        self.blob = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncdIndex {
        static instance: SyncdIndex = SyncdIndex {
            blob: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncdIndex {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncdIndex").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncdIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncdIndex {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.KeyId)
pub struct KeyId {
    // message fields
    // @@protoc_insertion_point(field:proto.KeyId.id)
    pub id: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.KeyId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyId {
    fn default() -> &'a KeyId {
        <KeyId as ::protobuf::Message>::default_instance()
    }
}

impl KeyId {
    pub fn new() -> KeyId {
        ::std::default::Default::default()
    }

    // optional bytes id = 1;

    pub fn id(&self) -> &[u8] {
        match self.id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.id.is_none() {
            self.id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        self.id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &KeyId| { &m.id },
            |m: &mut KeyId| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyId>(
            "KeyId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyId {
    const NAME: &'static str = "KeyId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyId {
        KeyId::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyId {
        static instance: KeyId = KeyId {
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ExternalBlobReference)
pub struct ExternalBlobReference {
    // message fields
    // @@protoc_insertion_point(field:proto.ExternalBlobReference.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ExternalBlobReference.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExternalBlobReference.handle)
    pub handle: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ExternalBlobReference.fileSizeBytes)
    pub fileSizeBytes: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.ExternalBlobReference.fileSha256)
    pub fileSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ExternalBlobReference.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ExternalBlobReference.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExternalBlobReference {
    fn default() -> &'a ExternalBlobReference {
        <ExternalBlobReference as ::protobuf::Message>::default_instance()
    }
}

impl ExternalBlobReference {
    pub fn new() -> ExternalBlobReference {
        ::std::default::Default::default()
    }

    // optional bytes mediaKey = 1;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string directPath = 2;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string handle = 3;

    pub fn handle(&self) -> &str {
        match self.handle.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        if self.handle.is_none() {
            self.handle = ::std::option::Option::Some(::std::string::String::new());
        }
        self.handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        self.handle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileSizeBytes = 4;

    pub fn fileSizeBytes(&self) -> u64 {
        self.fileSizeBytes.unwrap_or(0)
    }

    pub fn clear_fileSizeBytes(&mut self) {
        self.fileSizeBytes = ::std::option::Option::None;
    }

    pub fn has_fileSizeBytes(&self) -> bool {
        self.fileSizeBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSizeBytes(&mut self, v: u64) {
        self.fileSizeBytes = ::std::option::Option::Some(v);
    }

    // optional bytes fileSha256 = 5;

    pub fn fileSha256(&self) -> &[u8] {
        match self.fileSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileSha256(&mut self) {
        self.fileSha256 = ::std::option::Option::None;
    }

    pub fn has_fileSha256(&self) -> bool {
        self.fileSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileSha256.is_none() {
            self.fileSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fileEncSha256 = 6;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &ExternalBlobReference| { &m.mediaKey },
            |m: &mut ExternalBlobReference| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &ExternalBlobReference| { &m.directPath },
            |m: &mut ExternalBlobReference| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &ExternalBlobReference| { &m.handle },
            |m: &mut ExternalBlobReference| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSizeBytes",
            |m: &ExternalBlobReference| { &m.fileSizeBytes },
            |m: &mut ExternalBlobReference| { &mut m.fileSizeBytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileSha256",
            |m: &ExternalBlobReference| { &m.fileSha256 },
            |m: &mut ExternalBlobReference| { &mut m.fileSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &ExternalBlobReference| { &m.fileEncSha256 },
            |m: &mut ExternalBlobReference| { &mut m.fileEncSha256 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExternalBlobReference>(
            "ExternalBlobReference",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExternalBlobReference {
    const NAME: &'static str = "ExternalBlobReference";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.handle = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.fileSizeBytes = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.fileSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                50 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.handle.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileSizeBytes {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.fileSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.handle.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.fileSizeBytes {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.fileSha256.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExternalBlobReference {
        ExternalBlobReference::new()
    }

    fn clear(&mut self) {
        self.mediaKey = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.fileSizeBytes = ::std::option::Option::None;
        self.fileSha256 = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExternalBlobReference {
        static instance: ExternalBlobReference = ExternalBlobReference {
            mediaKey: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            fileSizeBytes: ::std::option::Option::None,
            fileSha256: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExternalBlobReference {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExternalBlobReference").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExternalBlobReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExternalBlobReference {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ExitCode)
pub struct ExitCode {
    // message fields
    // @@protoc_insertion_point(field:proto.ExitCode.code)
    pub code: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.ExitCode.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ExitCode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExitCode {
    fn default() -> &'a ExitCode {
        <ExitCode as ::protobuf::Message>::default_instance()
    }
}

impl ExitCode {
    pub fn new() -> ExitCode {
        ::std::default::Default::default()
    }

    // optional uint64 code = 1;

    pub fn code(&self) -> u64 {
        self.code.unwrap_or(0)
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: u64) {
        self.code = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &ExitCode| { &m.code },
            |m: &mut ExitCode| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &ExitCode| { &m.text },
            |m: &mut ExitCode| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExitCode>(
            "ExitCode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExitCode {
    const NAME: &'static str = "ExitCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExitCode {
        ExitCode::new()
    }

    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExitCode {
        static instance: ExitCode = ExitCode {
            code: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExitCode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExitCode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExitCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExitCode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncActionValue)
pub struct SyncActionValue {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncActionValue.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.starAction)
    pub starAction: ::protobuf::MessageField<StarAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.contactAction)
    pub contactAction: ::protobuf::MessageField<ContactAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.muteAction)
    pub muteAction: ::protobuf::MessageField<MuteAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.pinAction)
    pub pinAction: ::protobuf::MessageField<PinAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.securityNotificationSetting)
    pub securityNotificationSetting: ::protobuf::MessageField<SecurityNotificationSetting>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.pushNameSetting)
    pub pushNameSetting: ::protobuf::MessageField<PushNameSetting>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.quickReplyAction)
    pub quickReplyAction: ::protobuf::MessageField<QuickReplyAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.recentEmojiWeightsAction)
    pub recentEmojiWeightsAction: ::protobuf::MessageField<RecentEmojiWeightsAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.labelEditAction)
    pub labelEditAction: ::protobuf::MessageField<LabelEditAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.labelAssociationAction)
    pub labelAssociationAction: ::protobuf::MessageField<LabelAssociationAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.localeSetting)
    pub localeSetting: ::protobuf::MessageField<LocaleSetting>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.archiveChatAction)
    pub archiveChatAction: ::protobuf::MessageField<ArchiveChatAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.deleteMessageForMeAction)
    pub deleteMessageForMeAction: ::protobuf::MessageField<DeleteMessageForMeAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.keyExpiration)
    pub keyExpiration: ::protobuf::MessageField<KeyExpiration>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.markChatAsReadAction)
    pub markChatAsReadAction: ::protobuf::MessageField<MarkChatAsReadAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.clearChatAction)
    pub clearChatAction: ::protobuf::MessageField<ClearChatAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.deleteChatAction)
    pub deleteChatAction: ::protobuf::MessageField<DeleteChatAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.unarchiveChatsSetting)
    pub unarchiveChatsSetting: ::protobuf::MessageField<UnarchiveChatsSetting>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.primaryFeature)
    pub primaryFeature: ::protobuf::MessageField<PrimaryFeature>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.androidUnsupportedActions)
    pub androidUnsupportedActions: ::protobuf::MessageField<AndroidUnsupportedActions>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.agentAction)
    pub agentAction: ::protobuf::MessageField<AgentAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.subscriptionAction)
    pub subscriptionAction: ::protobuf::MessageField<SubscriptionAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.userStatusMuteAction)
    pub userStatusMuteAction: ::protobuf::MessageField<UserStatusMuteAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.timeFormatAction)
    pub timeFormatAction: ::protobuf::MessageField<TimeFormatAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.nuxAction)
    pub nuxAction: ::protobuf::MessageField<NuxAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.primaryVersionAction)
    pub primaryVersionAction: ::protobuf::MessageField<PrimaryVersionAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.stickerAction)
    pub stickerAction: ::protobuf::MessageField<StickerAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.removeRecentStickerAction)
    pub removeRecentStickerAction: ::protobuf::MessageField<RemoveRecentStickerAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.chatAssignment)
    pub chatAssignment: ::protobuf::MessageField<ChatAssignmentAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.chatAssignmentOpenedStatus)
    pub chatAssignmentOpenedStatus: ::protobuf::MessageField<ChatAssignmentOpenedStatusAction>,
    // @@protoc_insertion_point(field:proto.SyncActionValue.pnForLidChatAction)
    pub pnForLidChatAction: ::protobuf::MessageField<PnForLidChatAction>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncActionValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncActionValue {
    fn default() -> &'a SyncActionValue {
        <SyncActionValue as ::protobuf::Message>::default_instance()
    }
}

impl SyncActionValue {
    pub fn new() -> SyncActionValue {
        ::std::default::Default::default()
    }

    // optional int64 timestamp = 1;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(32);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &SyncActionValue| { &m.timestamp },
            |m: &mut SyncActionValue| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StarAction>(
            "starAction",
            |m: &SyncActionValue| { &m.starAction },
            |m: &mut SyncActionValue| { &mut m.starAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ContactAction>(
            "contactAction",
            |m: &SyncActionValue| { &m.contactAction },
            |m: &mut SyncActionValue| { &mut m.contactAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MuteAction>(
            "muteAction",
            |m: &SyncActionValue| { &m.muteAction },
            |m: &mut SyncActionValue| { &mut m.muteAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PinAction>(
            "pinAction",
            |m: &SyncActionValue| { &m.pinAction },
            |m: &mut SyncActionValue| { &mut m.pinAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SecurityNotificationSetting>(
            "securityNotificationSetting",
            |m: &SyncActionValue| { &m.securityNotificationSetting },
            |m: &mut SyncActionValue| { &mut m.securityNotificationSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PushNameSetting>(
            "pushNameSetting",
            |m: &SyncActionValue| { &m.pushNameSetting },
            |m: &mut SyncActionValue| { &mut m.pushNameSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, QuickReplyAction>(
            "quickReplyAction",
            |m: &SyncActionValue| { &m.quickReplyAction },
            |m: &mut SyncActionValue| { &mut m.quickReplyAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RecentEmojiWeightsAction>(
            "recentEmojiWeightsAction",
            |m: &SyncActionValue| { &m.recentEmojiWeightsAction },
            |m: &mut SyncActionValue| { &mut m.recentEmojiWeightsAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LabelEditAction>(
            "labelEditAction",
            |m: &SyncActionValue| { &m.labelEditAction },
            |m: &mut SyncActionValue| { &mut m.labelEditAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LabelAssociationAction>(
            "labelAssociationAction",
            |m: &SyncActionValue| { &m.labelAssociationAction },
            |m: &mut SyncActionValue| { &mut m.labelAssociationAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LocaleSetting>(
            "localeSetting",
            |m: &SyncActionValue| { &m.localeSetting },
            |m: &mut SyncActionValue| { &mut m.localeSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ArchiveChatAction>(
            "archiveChatAction",
            |m: &SyncActionValue| { &m.archiveChatAction },
            |m: &mut SyncActionValue| { &mut m.archiveChatAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeleteMessageForMeAction>(
            "deleteMessageForMeAction",
            |m: &SyncActionValue| { &m.deleteMessageForMeAction },
            |m: &mut SyncActionValue| { &mut m.deleteMessageForMeAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeyExpiration>(
            "keyExpiration",
            |m: &SyncActionValue| { &m.keyExpiration },
            |m: &mut SyncActionValue| { &mut m.keyExpiration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MarkChatAsReadAction>(
            "markChatAsReadAction",
            |m: &SyncActionValue| { &m.markChatAsReadAction },
            |m: &mut SyncActionValue| { &mut m.markChatAsReadAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ClearChatAction>(
            "clearChatAction",
            |m: &SyncActionValue| { &m.clearChatAction },
            |m: &mut SyncActionValue| { &mut m.clearChatAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeleteChatAction>(
            "deleteChatAction",
            |m: &SyncActionValue| { &m.deleteChatAction },
            |m: &mut SyncActionValue| { &mut m.deleteChatAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnarchiveChatsSetting>(
            "unarchiveChatsSetting",
            |m: &SyncActionValue| { &m.unarchiveChatsSetting },
            |m: &mut SyncActionValue| { &mut m.unarchiveChatsSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PrimaryFeature>(
            "primaryFeature",
            |m: &SyncActionValue| { &m.primaryFeature },
            |m: &mut SyncActionValue| { &mut m.primaryFeature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AndroidUnsupportedActions>(
            "androidUnsupportedActions",
            |m: &SyncActionValue| { &m.androidUnsupportedActions },
            |m: &mut SyncActionValue| { &mut m.androidUnsupportedActions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AgentAction>(
            "agentAction",
            |m: &SyncActionValue| { &m.agentAction },
            |m: &mut SyncActionValue| { &mut m.agentAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SubscriptionAction>(
            "subscriptionAction",
            |m: &SyncActionValue| { &m.subscriptionAction },
            |m: &mut SyncActionValue| { &mut m.subscriptionAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserStatusMuteAction>(
            "userStatusMuteAction",
            |m: &SyncActionValue| { &m.userStatusMuteAction },
            |m: &mut SyncActionValue| { &mut m.userStatusMuteAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TimeFormatAction>(
            "timeFormatAction",
            |m: &SyncActionValue| { &m.timeFormatAction },
            |m: &mut SyncActionValue| { &mut m.timeFormatAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, NuxAction>(
            "nuxAction",
            |m: &SyncActionValue| { &m.nuxAction },
            |m: &mut SyncActionValue| { &mut m.nuxAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PrimaryVersionAction>(
            "primaryVersionAction",
            |m: &SyncActionValue| { &m.primaryVersionAction },
            |m: &mut SyncActionValue| { &mut m.primaryVersionAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StickerAction>(
            "stickerAction",
            |m: &SyncActionValue| { &m.stickerAction },
            |m: &mut SyncActionValue| { &mut m.stickerAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RemoveRecentStickerAction>(
            "removeRecentStickerAction",
            |m: &SyncActionValue| { &m.removeRecentStickerAction },
            |m: &mut SyncActionValue| { &mut m.removeRecentStickerAction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ChatAssignmentAction>(
            "chatAssignment",
            |m: &SyncActionValue| { &m.chatAssignment },
            |m: &mut SyncActionValue| { &mut m.chatAssignment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ChatAssignmentOpenedStatusAction>(
            "chatAssignmentOpenedStatus",
            |m: &SyncActionValue| { &m.chatAssignmentOpenedStatus },
            |m: &mut SyncActionValue| { &mut m.chatAssignmentOpenedStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PnForLidChatAction>(
            "pnForLidChatAction",
            |m: &SyncActionValue| { &m.pnForLidChatAction },
            |m: &mut SyncActionValue| { &mut m.pnForLidChatAction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncActionValue>(
            "SyncActionValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncActionValue {
    const NAME: &'static str = "SyncActionValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.starAction)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.contactAction)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.muteAction)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pinAction)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.securityNotificationSetting)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pushNameSetting)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quickReplyAction)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.recentEmojiWeightsAction)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelEditAction)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.labelAssociationAction)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.localeSetting)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.archiveChatAction)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deleteMessageForMeAction)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keyExpiration)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.markChatAsReadAction)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clearChatAction)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deleteChatAction)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.unarchiveChatsSetting)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.primaryFeature)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.androidUnsupportedActions)?;
                },
                218 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.agentAction)?;
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.subscriptionAction)?;
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userStatusMuteAction)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeFormatAction)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nuxAction)?;
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.primaryVersionAction)?;
                },
                266 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stickerAction)?;
                },
                274 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.removeRecentStickerAction)?;
                },
                282 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chatAssignment)?;
                },
                290 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.chatAssignmentOpenedStatus)?;
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pnForLidChatAction)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.starAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contactAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.muteAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pinAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.securityNotificationSetting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pushNameSetting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quickReplyAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.recentEmojiWeightsAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.labelEditAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.labelAssociationAction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.localeSetting.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.archiveChatAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deleteMessageForMeAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.keyExpiration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.markChatAsReadAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clearChatAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deleteChatAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unarchiveChatsSetting.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.primaryFeature.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.androidUnsupportedActions.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.agentAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.subscriptionAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.userStatusMuteAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timeFormatAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.nuxAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.primaryVersionAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.stickerAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.removeRecentStickerAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chatAssignment.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.chatAssignmentOpenedStatus.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pnForLidChatAction.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.starAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.contactAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.muteAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.pinAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.securityNotificationSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.pushNameSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.quickReplyAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.recentEmojiWeightsAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.labelEditAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.labelAssociationAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.localeSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.archiveChatAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.deleteMessageForMeAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.keyExpiration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.markChatAsReadAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.clearChatAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.deleteChatAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.unarchiveChatsSetting.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.primaryFeature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.androidUnsupportedActions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.agentAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.subscriptionAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.userStatusMuteAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.timeFormatAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.nuxAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.primaryVersionAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.stickerAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.removeRecentStickerAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.chatAssignment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.chatAssignmentOpenedStatus.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.pnForLidChatAction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncActionValue {
        SyncActionValue::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.starAction.clear();
        self.contactAction.clear();
        self.muteAction.clear();
        self.pinAction.clear();
        self.securityNotificationSetting.clear();
        self.pushNameSetting.clear();
        self.quickReplyAction.clear();
        self.recentEmojiWeightsAction.clear();
        self.labelEditAction.clear();
        self.labelAssociationAction.clear();
        self.localeSetting.clear();
        self.archiveChatAction.clear();
        self.deleteMessageForMeAction.clear();
        self.keyExpiration.clear();
        self.markChatAsReadAction.clear();
        self.clearChatAction.clear();
        self.deleteChatAction.clear();
        self.unarchiveChatsSetting.clear();
        self.primaryFeature.clear();
        self.androidUnsupportedActions.clear();
        self.agentAction.clear();
        self.subscriptionAction.clear();
        self.userStatusMuteAction.clear();
        self.timeFormatAction.clear();
        self.nuxAction.clear();
        self.primaryVersionAction.clear();
        self.stickerAction.clear();
        self.removeRecentStickerAction.clear();
        self.chatAssignment.clear();
        self.chatAssignmentOpenedStatus.clear();
        self.pnForLidChatAction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncActionValue {
        static instance: SyncActionValue = SyncActionValue {
            timestamp: ::std::option::Option::None,
            starAction: ::protobuf::MessageField::none(),
            contactAction: ::protobuf::MessageField::none(),
            muteAction: ::protobuf::MessageField::none(),
            pinAction: ::protobuf::MessageField::none(),
            securityNotificationSetting: ::protobuf::MessageField::none(),
            pushNameSetting: ::protobuf::MessageField::none(),
            quickReplyAction: ::protobuf::MessageField::none(),
            recentEmojiWeightsAction: ::protobuf::MessageField::none(),
            labelEditAction: ::protobuf::MessageField::none(),
            labelAssociationAction: ::protobuf::MessageField::none(),
            localeSetting: ::protobuf::MessageField::none(),
            archiveChatAction: ::protobuf::MessageField::none(),
            deleteMessageForMeAction: ::protobuf::MessageField::none(),
            keyExpiration: ::protobuf::MessageField::none(),
            markChatAsReadAction: ::protobuf::MessageField::none(),
            clearChatAction: ::protobuf::MessageField::none(),
            deleteChatAction: ::protobuf::MessageField::none(),
            unarchiveChatsSetting: ::protobuf::MessageField::none(),
            primaryFeature: ::protobuf::MessageField::none(),
            androidUnsupportedActions: ::protobuf::MessageField::none(),
            agentAction: ::protobuf::MessageField::none(),
            subscriptionAction: ::protobuf::MessageField::none(),
            userStatusMuteAction: ::protobuf::MessageField::none(),
            timeFormatAction: ::protobuf::MessageField::none(),
            nuxAction: ::protobuf::MessageField::none(),
            primaryVersionAction: ::protobuf::MessageField::none(),
            stickerAction: ::protobuf::MessageField::none(),
            removeRecentStickerAction: ::protobuf::MessageField::none(),
            chatAssignment: ::protobuf::MessageField::none(),
            chatAssignmentOpenedStatus: ::protobuf::MessageField::none(),
            pnForLidChatAction: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncActionValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncActionValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncActionValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncActionValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.UserStatusMuteAction)
pub struct UserStatusMuteAction {
    // message fields
    // @@protoc_insertion_point(field:proto.UserStatusMuteAction.muted)
    pub muted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.UserStatusMuteAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserStatusMuteAction {
    fn default() -> &'a UserStatusMuteAction {
        <UserStatusMuteAction as ::protobuf::Message>::default_instance()
    }
}

impl UserStatusMuteAction {
    pub fn new() -> UserStatusMuteAction {
        ::std::default::Default::default()
    }

    // optional bool muted = 1;

    pub fn muted(&self) -> bool {
        self.muted.unwrap_or(false)
    }

    pub fn clear_muted(&mut self) {
        self.muted = ::std::option::Option::None;
    }

    pub fn has_muted(&self) -> bool {
        self.muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muted(&mut self, v: bool) {
        self.muted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "muted",
            |m: &UserStatusMuteAction| { &m.muted },
            |m: &mut UserStatusMuteAction| { &mut m.muted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserStatusMuteAction>(
            "UserStatusMuteAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserStatusMuteAction {
    const NAME: &'static str = "UserStatusMuteAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.muted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.muted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.muted {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserStatusMuteAction {
        UserStatusMuteAction::new()
    }

    fn clear(&mut self) {
        self.muted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserStatusMuteAction {
        static instance: UserStatusMuteAction = UserStatusMuteAction {
            muted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserStatusMuteAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserStatusMuteAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserStatusMuteAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserStatusMuteAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.UnarchiveChatsSetting)
pub struct UnarchiveChatsSetting {
    // message fields
    // @@protoc_insertion_point(field:proto.UnarchiveChatsSetting.unarchiveChats)
    pub unarchiveChats: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.UnarchiveChatsSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnarchiveChatsSetting {
    fn default() -> &'a UnarchiveChatsSetting {
        <UnarchiveChatsSetting as ::protobuf::Message>::default_instance()
    }
}

impl UnarchiveChatsSetting {
    pub fn new() -> UnarchiveChatsSetting {
        ::std::default::Default::default()
    }

    // optional bool unarchiveChats = 1;

    pub fn unarchiveChats(&self) -> bool {
        self.unarchiveChats.unwrap_or(false)
    }

    pub fn clear_unarchiveChats(&mut self) {
        self.unarchiveChats = ::std::option::Option::None;
    }

    pub fn has_unarchiveChats(&self) -> bool {
        self.unarchiveChats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unarchiveChats(&mut self, v: bool) {
        self.unarchiveChats = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unarchiveChats",
            |m: &UnarchiveChatsSetting| { &m.unarchiveChats },
            |m: &mut UnarchiveChatsSetting| { &mut m.unarchiveChats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnarchiveChatsSetting>(
            "UnarchiveChatsSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnarchiveChatsSetting {
    const NAME: &'static str = "UnarchiveChatsSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.unarchiveChats = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unarchiveChats {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.unarchiveChats {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnarchiveChatsSetting {
        UnarchiveChatsSetting::new()
    }

    fn clear(&mut self) {
        self.unarchiveChats = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnarchiveChatsSetting {
        static instance: UnarchiveChatsSetting = UnarchiveChatsSetting {
            unarchiveChats: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnarchiveChatsSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnarchiveChatsSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnarchiveChatsSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnarchiveChatsSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.TimeFormatAction)
pub struct TimeFormatAction {
    // message fields
    // @@protoc_insertion_point(field:proto.TimeFormatAction.isTwentyFourHourFormatEnabled)
    pub isTwentyFourHourFormatEnabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.TimeFormatAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeFormatAction {
    fn default() -> &'a TimeFormatAction {
        <TimeFormatAction as ::protobuf::Message>::default_instance()
    }
}

impl TimeFormatAction {
    pub fn new() -> TimeFormatAction {
        ::std::default::Default::default()
    }

    // optional bool isTwentyFourHourFormatEnabled = 1;

    pub fn isTwentyFourHourFormatEnabled(&self) -> bool {
        self.isTwentyFourHourFormatEnabled.unwrap_or(false)
    }

    pub fn clear_isTwentyFourHourFormatEnabled(&mut self) {
        self.isTwentyFourHourFormatEnabled = ::std::option::Option::None;
    }

    pub fn has_isTwentyFourHourFormatEnabled(&self) -> bool {
        self.isTwentyFourHourFormatEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isTwentyFourHourFormatEnabled(&mut self, v: bool) {
        self.isTwentyFourHourFormatEnabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isTwentyFourHourFormatEnabled",
            |m: &TimeFormatAction| { &m.isTwentyFourHourFormatEnabled },
            |m: &mut TimeFormatAction| { &mut m.isTwentyFourHourFormatEnabled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeFormatAction>(
            "TimeFormatAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeFormatAction {
    const NAME: &'static str = "TimeFormatAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.isTwentyFourHourFormatEnabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.isTwentyFourHourFormatEnabled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.isTwentyFourHourFormatEnabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeFormatAction {
        TimeFormatAction::new()
    }

    fn clear(&mut self) {
        self.isTwentyFourHourFormatEnabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeFormatAction {
        static instance: TimeFormatAction = TimeFormatAction {
            isTwentyFourHourFormatEnabled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeFormatAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeFormatAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeFormatAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeFormatAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncActionMessage)
pub struct SyncActionMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncActionMessage.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.SyncActionMessage.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncActionMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncActionMessage {
    fn default() -> &'a SyncActionMessage {
        <SyncActionMessage as ::protobuf::Message>::default_instance()
    }
}

impl SyncActionMessage {
    pub fn new() -> SyncActionMessage {
        ::std::default::Default::default()
    }

    // optional int64 timestamp = 2;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &SyncActionMessage| { &m.key },
            |m: &mut SyncActionMessage| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &SyncActionMessage| { &m.timestamp },
            |m: &mut SyncActionMessage| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncActionMessage>(
            "SyncActionMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncActionMessage {
    const NAME: &'static str = "SyncActionMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncActionMessage {
        SyncActionMessage::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncActionMessage {
        static instance: SyncActionMessage = SyncActionMessage {
            key: ::protobuf::MessageField::none(),
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncActionMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncActionMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncActionMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncActionMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncActionMessageRange)
pub struct SyncActionMessageRange {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncActionMessageRange.lastMessageTimestamp)
    pub lastMessageTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.SyncActionMessageRange.lastSystemMessageTimestamp)
    pub lastSystemMessageTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.SyncActionMessageRange.messages)
    pub messages: ::std::vec::Vec<SyncActionMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncActionMessageRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncActionMessageRange {
    fn default() -> &'a SyncActionMessageRange {
        <SyncActionMessageRange as ::protobuf::Message>::default_instance()
    }
}

impl SyncActionMessageRange {
    pub fn new() -> SyncActionMessageRange {
        ::std::default::Default::default()
    }

    // optional int64 lastMessageTimestamp = 1;

    pub fn lastMessageTimestamp(&self) -> i64 {
        self.lastMessageTimestamp.unwrap_or(0)
    }

    pub fn clear_lastMessageTimestamp(&mut self) {
        self.lastMessageTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastMessageTimestamp(&self) -> bool {
        self.lastMessageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastMessageTimestamp(&mut self, v: i64) {
        self.lastMessageTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 lastSystemMessageTimestamp = 2;

    pub fn lastSystemMessageTimestamp(&self) -> i64 {
        self.lastSystemMessageTimestamp.unwrap_or(0)
    }

    pub fn clear_lastSystemMessageTimestamp(&mut self) {
        self.lastSystemMessageTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastSystemMessageTimestamp(&self) -> bool {
        self.lastSystemMessageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastSystemMessageTimestamp(&mut self, v: i64) {
        self.lastSystemMessageTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastMessageTimestamp",
            |m: &SyncActionMessageRange| { &m.lastMessageTimestamp },
            |m: &mut SyncActionMessageRange| { &mut m.lastMessageTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastSystemMessageTimestamp",
            |m: &SyncActionMessageRange| { &m.lastSystemMessageTimestamp },
            |m: &mut SyncActionMessageRange| { &mut m.lastSystemMessageTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &SyncActionMessageRange| { &m.messages },
            |m: &mut SyncActionMessageRange| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncActionMessageRange>(
            "SyncActionMessageRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncActionMessageRange {
    const NAME: &'static str = "SyncActionMessageRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lastMessageTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.lastSystemMessageTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lastMessageTimestamp {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.lastSystemMessageTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lastMessageTimestamp {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.lastSystemMessageTimestamp {
            os.write_int64(2, v)?;
        }
        for v in &self.messages {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncActionMessageRange {
        SyncActionMessageRange::new()
    }

    fn clear(&mut self) {
        self.lastMessageTimestamp = ::std::option::Option::None;
        self.lastSystemMessageTimestamp = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncActionMessageRange {
        static instance: SyncActionMessageRange = SyncActionMessageRange {
            lastMessageTimestamp: ::std::option::Option::None,
            lastSystemMessageTimestamp: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncActionMessageRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncActionMessageRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncActionMessageRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncActionMessageRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SubscriptionAction)
pub struct SubscriptionAction {
    // message fields
    // @@protoc_insertion_point(field:proto.SubscriptionAction.isDeactivated)
    pub isDeactivated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.SubscriptionAction.isAutoRenewing)
    pub isAutoRenewing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.SubscriptionAction.expirationDate)
    pub expirationDate: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SubscriptionAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscriptionAction {
    fn default() -> &'a SubscriptionAction {
        <SubscriptionAction as ::protobuf::Message>::default_instance()
    }
}

impl SubscriptionAction {
    pub fn new() -> SubscriptionAction {
        ::std::default::Default::default()
    }

    // optional bool isDeactivated = 1;

    pub fn isDeactivated(&self) -> bool {
        self.isDeactivated.unwrap_or(false)
    }

    pub fn clear_isDeactivated(&mut self) {
        self.isDeactivated = ::std::option::Option::None;
    }

    pub fn has_isDeactivated(&self) -> bool {
        self.isDeactivated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isDeactivated(&mut self, v: bool) {
        self.isDeactivated = ::std::option::Option::Some(v);
    }

    // optional bool isAutoRenewing = 2;

    pub fn isAutoRenewing(&self) -> bool {
        self.isAutoRenewing.unwrap_or(false)
    }

    pub fn clear_isAutoRenewing(&mut self) {
        self.isAutoRenewing = ::std::option::Option::None;
    }

    pub fn has_isAutoRenewing(&self) -> bool {
        self.isAutoRenewing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isAutoRenewing(&mut self, v: bool) {
        self.isAutoRenewing = ::std::option::Option::Some(v);
    }

    // optional int64 expirationDate = 3;

    pub fn expirationDate(&self) -> i64 {
        self.expirationDate.unwrap_or(0)
    }

    pub fn clear_expirationDate(&mut self) {
        self.expirationDate = ::std::option::Option::None;
    }

    pub fn has_expirationDate(&self) -> bool {
        self.expirationDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expirationDate(&mut self, v: i64) {
        self.expirationDate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isDeactivated",
            |m: &SubscriptionAction| { &m.isDeactivated },
            |m: &mut SubscriptionAction| { &mut m.isDeactivated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isAutoRenewing",
            |m: &SubscriptionAction| { &m.isAutoRenewing },
            |m: &mut SubscriptionAction| { &mut m.isAutoRenewing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expirationDate",
            |m: &SubscriptionAction| { &m.expirationDate },
            |m: &mut SubscriptionAction| { &mut m.expirationDate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscriptionAction>(
            "SubscriptionAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscriptionAction {
    const NAME: &'static str = "SubscriptionAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.isDeactivated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.isAutoRenewing = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.expirationDate = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.isDeactivated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.isAutoRenewing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.expirationDate {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.isDeactivated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.isAutoRenewing {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.expirationDate {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscriptionAction {
        SubscriptionAction::new()
    }

    fn clear(&mut self) {
        self.isDeactivated = ::std::option::Option::None;
        self.isAutoRenewing = ::std::option::Option::None;
        self.expirationDate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscriptionAction {
        static instance: SubscriptionAction = SubscriptionAction {
            isDeactivated: ::std::option::Option::None,
            isAutoRenewing: ::std::option::Option::None,
            expirationDate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscriptionAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscriptionAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscriptionAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.StickerAction)
pub struct StickerAction {
    // message fields
    // @@protoc_insertion_point(field:proto.StickerAction.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerAction.fileEncSha256)
    pub fileEncSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerAction.mediaKey)
    pub mediaKey: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.StickerAction.mimetype)
    pub mimetype: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerAction.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StickerAction.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.StickerAction.directPath)
    pub directPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.StickerAction.fileLength)
    pub fileLength: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.StickerAction.isFavorite)
    pub isFavorite: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.StickerAction.deviceIdHint)
    pub deviceIdHint: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.StickerAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StickerAction {
    fn default() -> &'a StickerAction {
        <StickerAction as ::protobuf::Message>::default_instance()
    }
}

impl StickerAction {
    pub fn new() -> StickerAction {
        ::std::default::Default::default()
    }

    // optional string url = 1;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes fileEncSha256 = 2;

    pub fn fileEncSha256(&self) -> &[u8] {
        match self.fileEncSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fileEncSha256(&mut self) {
        self.fileEncSha256 = ::std::option::Option::None;
    }

    pub fn has_fileEncSha256(&self) -> bool {
        self.fileEncSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.fileEncSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fileEncSha256.is_none() {
            self.fileEncSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fileEncSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.fileEncSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mediaKey = 3;

    pub fn mediaKey(&self) -> &[u8] {
        match self.mediaKey.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaKey(&mut self) {
        self.mediaKey = ::std::option::Option::None;
    }

    pub fn has_mediaKey(&self) -> bool {
        self.mediaKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaKey.is_none() {
            self.mediaKey = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaKey(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string mimetype = 4;

    pub fn mimetype(&self) -> &str {
        match self.mimetype.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mimetype(&mut self) {
        self.mimetype = ::std::option::Option::None;
    }

    pub fn has_mimetype(&self) -> bool {
        self.mimetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mimetype(&mut self, v: ::std::string::String) {
        self.mimetype = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mimetype(&mut self) -> &mut ::std::string::String {
        if self.mimetype.is_none() {
            self.mimetype = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mimetype.as_mut().unwrap()
    }

    // Take field
    pub fn take_mimetype(&mut self) -> ::std::string::String {
        self.mimetype.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 height = 5;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 width = 6;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional string directPath = 7;

    pub fn directPath(&self) -> &str {
        match self.directPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_directPath(&mut self) {
        self.directPath = ::std::option::Option::None;
    }

    pub fn has_directPath(&self) -> bool {
        self.directPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directPath(&mut self, v: ::std::string::String) {
        self.directPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directPath(&mut self) -> &mut ::std::string::String {
        if self.directPath.is_none() {
            self.directPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.directPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_directPath(&mut self) -> ::std::string::String {
        self.directPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileLength = 8;

    pub fn fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }

    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // optional bool isFavorite = 9;

    pub fn isFavorite(&self) -> bool {
        self.isFavorite.unwrap_or(false)
    }

    pub fn clear_isFavorite(&mut self) {
        self.isFavorite = ::std::option::Option::None;
    }

    pub fn has_isFavorite(&self) -> bool {
        self.isFavorite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isFavorite(&mut self, v: bool) {
        self.isFavorite = ::std::option::Option::Some(v);
    }

    // optional uint32 deviceIdHint = 10;

    pub fn deviceIdHint(&self) -> u32 {
        self.deviceIdHint.unwrap_or(0)
    }

    pub fn clear_deviceIdHint(&mut self) {
        self.deviceIdHint = ::std::option::Option::None;
    }

    pub fn has_deviceIdHint(&self) -> bool {
        self.deviceIdHint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceIdHint(&mut self, v: u32) {
        self.deviceIdHint = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &StickerAction| { &m.url },
            |m: &mut StickerAction| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileEncSha256",
            |m: &StickerAction| { &m.fileEncSha256 },
            |m: &mut StickerAction| { &mut m.fileEncSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaKey",
            |m: &StickerAction| { &m.mediaKey },
            |m: &mut StickerAction| { &mut m.mediaKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mimetype",
            |m: &StickerAction| { &m.mimetype },
            |m: &mut StickerAction| { &mut m.mimetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &StickerAction| { &m.height },
            |m: &mut StickerAction| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &StickerAction| { &m.width },
            |m: &mut StickerAction| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "directPath",
            |m: &StickerAction| { &m.directPath },
            |m: &mut StickerAction| { &mut m.directPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fileLength",
            |m: &StickerAction| { &m.fileLength },
            |m: &mut StickerAction| { &mut m.fileLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isFavorite",
            |m: &StickerAction| { &m.isFavorite },
            |m: &mut StickerAction| { &mut m.isFavorite },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceIdHint",
            |m: &StickerAction| { &m.deviceIdHint },
            |m: &mut StickerAction| { &mut m.deviceIdHint },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StickerAction>(
            "StickerAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StickerAction {
    const NAME: &'static str = "StickerAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.fileEncSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.mediaKey = ::std::option::Option::Some(is.read_bytes()?);
                },
                34 => {
                    self.mimetype = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.directPath = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.fileLength = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.isFavorite = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.deviceIdHint = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.mediaKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.mimetype.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.directPath.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.isFavorite {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deviceIdHint {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fileEncSha256.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.mediaKey.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.mimetype.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.directPath.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.fileLength {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.isFavorite {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.deviceIdHint {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StickerAction {
        StickerAction::new()
    }

    fn clear(&mut self) {
        self.url = ::std::option::Option::None;
        self.fileEncSha256 = ::std::option::Option::None;
        self.mediaKey = ::std::option::Option::None;
        self.mimetype = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.directPath = ::std::option::Option::None;
        self.fileLength = ::std::option::Option::None;
        self.isFavorite = ::std::option::Option::None;
        self.deviceIdHint = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StickerAction {
        static instance: StickerAction = StickerAction {
            url: ::std::option::Option::None,
            fileEncSha256: ::std::option::Option::None,
            mediaKey: ::std::option::Option::None,
            mimetype: ::std::option::Option::None,
            height: ::std::option::Option::None,
            width: ::std::option::Option::None,
            directPath: ::std::option::Option::None,
            fileLength: ::std::option::Option::None,
            isFavorite: ::std::option::Option::None,
            deviceIdHint: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StickerAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StickerAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StickerAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StickerAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.StarAction)
pub struct StarAction {
    // message fields
    // @@protoc_insertion_point(field:proto.StarAction.starred)
    pub starred: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.StarAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StarAction {
    fn default() -> &'a StarAction {
        <StarAction as ::protobuf::Message>::default_instance()
    }
}

impl StarAction {
    pub fn new() -> StarAction {
        ::std::default::Default::default()
    }

    // optional bool starred = 1;

    pub fn starred(&self) -> bool {
        self.starred.unwrap_or(false)
    }

    pub fn clear_starred(&mut self) {
        self.starred = ::std::option::Option::None;
    }

    pub fn has_starred(&self) -> bool {
        self.starred.is_some()
    }

    // Param is passed by value, moved
    pub fn set_starred(&mut self, v: bool) {
        self.starred = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "starred",
            |m: &StarAction| { &m.starred },
            |m: &mut StarAction| { &mut m.starred },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StarAction>(
            "StarAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StarAction {
    const NAME: &'static str = "StarAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.starred = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.starred {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.starred {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StarAction {
        StarAction::new()
    }

    fn clear(&mut self) {
        self.starred = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StarAction {
        static instance: StarAction = StarAction {
            starred: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StarAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StarAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StarAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StarAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SecurityNotificationSetting)
pub struct SecurityNotificationSetting {
    // message fields
    // @@protoc_insertion_point(field:proto.SecurityNotificationSetting.showNotification)
    pub showNotification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SecurityNotificationSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecurityNotificationSetting {
    fn default() -> &'a SecurityNotificationSetting {
        <SecurityNotificationSetting as ::protobuf::Message>::default_instance()
    }
}

impl SecurityNotificationSetting {
    pub fn new() -> SecurityNotificationSetting {
        ::std::default::Default::default()
    }

    // optional bool showNotification = 1;

    pub fn showNotification(&self) -> bool {
        self.showNotification.unwrap_or(false)
    }

    pub fn clear_showNotification(&mut self) {
        self.showNotification = ::std::option::Option::None;
    }

    pub fn has_showNotification(&self) -> bool {
        self.showNotification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_showNotification(&mut self, v: bool) {
        self.showNotification = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "showNotification",
            |m: &SecurityNotificationSetting| { &m.showNotification },
            |m: &mut SecurityNotificationSetting| { &mut m.showNotification },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityNotificationSetting>(
            "SecurityNotificationSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecurityNotificationSetting {
    const NAME: &'static str = "SecurityNotificationSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.showNotification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.showNotification {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.showNotification {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecurityNotificationSetting {
        SecurityNotificationSetting::new()
    }

    fn clear(&mut self) {
        self.showNotification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecurityNotificationSetting {
        static instance: SecurityNotificationSetting = SecurityNotificationSetting {
            showNotification: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecurityNotificationSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecurityNotificationSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecurityNotificationSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityNotificationSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.RemoveRecentStickerAction)
pub struct RemoveRecentStickerAction {
    // message fields
    // @@protoc_insertion_point(field:proto.RemoveRecentStickerAction.lastStickerSentTs)
    pub lastStickerSentTs: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.RemoveRecentStickerAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveRecentStickerAction {
    fn default() -> &'a RemoveRecentStickerAction {
        <RemoveRecentStickerAction as ::protobuf::Message>::default_instance()
    }
}

impl RemoveRecentStickerAction {
    pub fn new() -> RemoveRecentStickerAction {
        ::std::default::Default::default()
    }

    // optional int64 lastStickerSentTs = 1;

    pub fn lastStickerSentTs(&self) -> i64 {
        self.lastStickerSentTs.unwrap_or(0)
    }

    pub fn clear_lastStickerSentTs(&mut self) {
        self.lastStickerSentTs = ::std::option::Option::None;
    }

    pub fn has_lastStickerSentTs(&self) -> bool {
        self.lastStickerSentTs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastStickerSentTs(&mut self, v: i64) {
        self.lastStickerSentTs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastStickerSentTs",
            |m: &RemoveRecentStickerAction| { &m.lastStickerSentTs },
            |m: &mut RemoveRecentStickerAction| { &mut m.lastStickerSentTs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveRecentStickerAction>(
            "RemoveRecentStickerAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveRecentStickerAction {
    const NAME: &'static str = "RemoveRecentStickerAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lastStickerSentTs = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lastStickerSentTs {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lastStickerSentTs {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveRecentStickerAction {
        RemoveRecentStickerAction::new()
    }

    fn clear(&mut self) {
        self.lastStickerSentTs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveRecentStickerAction {
        static instance: RemoveRecentStickerAction = RemoveRecentStickerAction {
            lastStickerSentTs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveRecentStickerAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveRecentStickerAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveRecentStickerAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveRecentStickerAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.RecentEmojiWeightsAction)
pub struct RecentEmojiWeightsAction {
    // message fields
    // @@protoc_insertion_point(field:proto.RecentEmojiWeightsAction.weights)
    pub weights: ::std::vec::Vec<RecentEmojiWeight>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.RecentEmojiWeightsAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecentEmojiWeightsAction {
    fn default() -> &'a RecentEmojiWeightsAction {
        <RecentEmojiWeightsAction as ::protobuf::Message>::default_instance()
    }
}

impl RecentEmojiWeightsAction {
    pub fn new() -> RecentEmojiWeightsAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weights",
            |m: &RecentEmojiWeightsAction| { &m.weights },
            |m: &mut RecentEmojiWeightsAction| { &mut m.weights },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecentEmojiWeightsAction>(
            "RecentEmojiWeightsAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecentEmojiWeightsAction {
    const NAME: &'static str = "RecentEmojiWeightsAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.weights.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.weights {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.weights {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecentEmojiWeightsAction {
        RecentEmojiWeightsAction::new()
    }

    fn clear(&mut self) {
        self.weights.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecentEmojiWeightsAction {
        static instance: RecentEmojiWeightsAction = RecentEmojiWeightsAction {
            weights: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecentEmojiWeightsAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecentEmojiWeightsAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecentEmojiWeightsAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecentEmojiWeightsAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.QuickReplyAction)
pub struct QuickReplyAction {
    // message fields
    // @@protoc_insertion_point(field:proto.QuickReplyAction.shortcut)
    pub shortcut: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.QuickReplyAction.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.QuickReplyAction.keywords)
    pub keywords: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.QuickReplyAction.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.QuickReplyAction.deleted)
    pub deleted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.QuickReplyAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuickReplyAction {
    fn default() -> &'a QuickReplyAction {
        <QuickReplyAction as ::protobuf::Message>::default_instance()
    }
}

impl QuickReplyAction {
    pub fn new() -> QuickReplyAction {
        ::std::default::Default::default()
    }

    // optional string shortcut = 1;

    pub fn shortcut(&self) -> &str {
        match self.shortcut.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_shortcut(&mut self) {
        self.shortcut = ::std::option::Option::None;
    }

    pub fn has_shortcut(&self) -> bool {
        self.shortcut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortcut(&mut self, v: ::std::string::String) {
        self.shortcut = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shortcut(&mut self) -> &mut ::std::string::String {
        if self.shortcut.is_none() {
            self.shortcut = ::std::option::Option::Some(::std::string::String::new());
        }
        self.shortcut.as_mut().unwrap()
    }

    // Take field
    pub fn take_shortcut(&mut self) -> ::std::string::String {
        self.shortcut.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 count = 4;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 5;

    pub fn deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shortcut",
            |m: &QuickReplyAction| { &m.shortcut },
            |m: &mut QuickReplyAction| { &mut m.shortcut },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &QuickReplyAction| { &m.message },
            |m: &mut QuickReplyAction| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keywords",
            |m: &QuickReplyAction| { &m.keywords },
            |m: &mut QuickReplyAction| { &mut m.keywords },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &QuickReplyAction| { &m.count },
            |m: &mut QuickReplyAction| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleted",
            |m: &QuickReplyAction| { &m.deleted },
            |m: &mut QuickReplyAction| { &mut m.deleted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuickReplyAction>(
            "QuickReplyAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuickReplyAction {
    const NAME: &'static str = "QuickReplyAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.shortcut = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.keywords.push(is.read_string()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shortcut.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.keywords {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.deleted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shortcut.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.keywords {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuickReplyAction {
        QuickReplyAction::new()
    }

    fn clear(&mut self) {
        self.shortcut = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.keywords.clear();
        self.count = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuickReplyAction {
        static instance: QuickReplyAction = QuickReplyAction {
            shortcut: ::std::option::Option::None,
            message: ::std::option::Option::None,
            keywords: ::std::vec::Vec::new(),
            count: ::std::option::Option::None,
            deleted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuickReplyAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuickReplyAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuickReplyAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuickReplyAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PushNameSetting)
pub struct PushNameSetting {
    // message fields
    // @@protoc_insertion_point(field:proto.PushNameSetting.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PushNameSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PushNameSetting {
    fn default() -> &'a PushNameSetting {
        <PushNameSetting as ::protobuf::Message>::default_instance()
    }
}

impl PushNameSetting {
    pub fn new() -> PushNameSetting {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &PushNameSetting| { &m.name },
            |m: &mut PushNameSetting| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PushNameSetting>(
            "PushNameSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PushNameSetting {
    const NAME: &'static str = "PushNameSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PushNameSetting {
        PushNameSetting::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PushNameSetting {
        static instance: PushNameSetting = PushNameSetting {
            name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PushNameSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PushNameSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PushNameSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushNameSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PrimaryVersionAction)
pub struct PrimaryVersionAction {
    // message fields
    // @@protoc_insertion_point(field:proto.PrimaryVersionAction.version)
    pub version: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PrimaryVersionAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrimaryVersionAction {
    fn default() -> &'a PrimaryVersionAction {
        <PrimaryVersionAction as ::protobuf::Message>::default_instance()
    }
}

impl PrimaryVersionAction {
    pub fn new() -> PrimaryVersionAction {
        ::std::default::Default::default()
    }

    // optional string version = 1;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &PrimaryVersionAction| { &m.version },
            |m: &mut PrimaryVersionAction| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrimaryVersionAction>(
            "PrimaryVersionAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrimaryVersionAction {
    const NAME: &'static str = "PrimaryVersionAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrimaryVersionAction {
        PrimaryVersionAction::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrimaryVersionAction {
        static instance: PrimaryVersionAction = PrimaryVersionAction {
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrimaryVersionAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrimaryVersionAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrimaryVersionAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimaryVersionAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PrimaryFeature)
pub struct PrimaryFeature {
    // message fields
    // @@protoc_insertion_point(field:proto.PrimaryFeature.flags)
    pub flags: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PrimaryFeature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrimaryFeature {
    fn default() -> &'a PrimaryFeature {
        <PrimaryFeature as ::protobuf::Message>::default_instance()
    }
}

impl PrimaryFeature {
    pub fn new() -> PrimaryFeature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "flags",
            |m: &PrimaryFeature| { &m.flags },
            |m: &mut PrimaryFeature| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrimaryFeature>(
            "PrimaryFeature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrimaryFeature {
    const NAME: &'static str = "PrimaryFeature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.flags.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.flags {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.flags {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrimaryFeature {
        PrimaryFeature::new()
    }

    fn clear(&mut self) {
        self.flags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrimaryFeature {
        static instance: PrimaryFeature = PrimaryFeature {
            flags: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrimaryFeature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrimaryFeature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrimaryFeature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimaryFeature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PnForLidChatAction)
pub struct PnForLidChatAction {
    // message fields
    // @@protoc_insertion_point(field:proto.PnForLidChatAction.pnJid)
    pub pnJid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PnForLidChatAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PnForLidChatAction {
    fn default() -> &'a PnForLidChatAction {
        <PnForLidChatAction as ::protobuf::Message>::default_instance()
    }
}

impl PnForLidChatAction {
    pub fn new() -> PnForLidChatAction {
        ::std::default::Default::default()
    }

    // optional string pnJid = 1;

    pub fn pnJid(&self) -> &str {
        match self.pnJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pnJid(&mut self) {
        self.pnJid = ::std::option::Option::None;
    }

    pub fn has_pnJid(&self) -> bool {
        self.pnJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pnJid(&mut self, v: ::std::string::String) {
        self.pnJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pnJid(&mut self) -> &mut ::std::string::String {
        if self.pnJid.is_none() {
            self.pnJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pnJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pnJid(&mut self) -> ::std::string::String {
        self.pnJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pnJid",
            |m: &PnForLidChatAction| { &m.pnJid },
            |m: &mut PnForLidChatAction| { &mut m.pnJid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PnForLidChatAction>(
            "PnForLidChatAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PnForLidChatAction {
    const NAME: &'static str = "PnForLidChatAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pnJid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pnJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pnJid.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PnForLidChatAction {
        PnForLidChatAction::new()
    }

    fn clear(&mut self) {
        self.pnJid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PnForLidChatAction {
        static instance: PnForLidChatAction = PnForLidChatAction {
            pnJid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PnForLidChatAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PnForLidChatAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PnForLidChatAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PnForLidChatAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PinAction)
pub struct PinAction {
    // message fields
    // @@protoc_insertion_point(field:proto.PinAction.pinned)
    pub pinned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PinAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PinAction {
    fn default() -> &'a PinAction {
        <PinAction as ::protobuf::Message>::default_instance()
    }
}

impl PinAction {
    pub fn new() -> PinAction {
        ::std::default::Default::default()
    }

    // optional bool pinned = 1;

    pub fn pinned(&self) -> bool {
        self.pinned.unwrap_or(false)
    }

    pub fn clear_pinned(&mut self) {
        self.pinned = ::std::option::Option::None;
    }

    pub fn has_pinned(&self) -> bool {
        self.pinned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinned(&mut self, v: bool) {
        self.pinned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pinned",
            |m: &PinAction| { &m.pinned },
            |m: &mut PinAction| { &mut m.pinned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PinAction>(
            "PinAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PinAction {
    const NAME: &'static str = "PinAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pinned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pinned {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pinned {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PinAction {
        PinAction::new()
    }

    fn clear(&mut self) {
        self.pinned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PinAction {
        static instance: PinAction = PinAction {
            pinned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PinAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PinAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PinAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.NuxAction)
pub struct NuxAction {
    // message fields
    // @@protoc_insertion_point(field:proto.NuxAction.acknowledged)
    pub acknowledged: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.NuxAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NuxAction {
    fn default() -> &'a NuxAction {
        <NuxAction as ::protobuf::Message>::default_instance()
    }
}

impl NuxAction {
    pub fn new() -> NuxAction {
        ::std::default::Default::default()
    }

    // optional bool acknowledged = 1;

    pub fn acknowledged(&self) -> bool {
        self.acknowledged.unwrap_or(false)
    }

    pub fn clear_acknowledged(&mut self) {
        self.acknowledged = ::std::option::Option::None;
    }

    pub fn has_acknowledged(&self) -> bool {
        self.acknowledged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledged(&mut self, v: bool) {
        self.acknowledged = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acknowledged",
            |m: &NuxAction| { &m.acknowledged },
            |m: &mut NuxAction| { &mut m.acknowledged },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NuxAction>(
            "NuxAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NuxAction {
    const NAME: &'static str = "NuxAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.acknowledged = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.acknowledged {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.acknowledged {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NuxAction {
        NuxAction::new()
    }

    fn clear(&mut self) {
        self.acknowledged = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NuxAction {
        static instance: NuxAction = NuxAction {
            acknowledged: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NuxAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NuxAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NuxAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NuxAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.MuteAction)
pub struct MuteAction {
    // message fields
    // @@protoc_insertion_point(field:proto.MuteAction.muted)
    pub muted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.MuteAction.muteEndTimestamp)
    pub muteEndTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.MuteAction.autoMuted)
    pub autoMuted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.MuteAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MuteAction {
    fn default() -> &'a MuteAction {
        <MuteAction as ::protobuf::Message>::default_instance()
    }
}

impl MuteAction {
    pub fn new() -> MuteAction {
        ::std::default::Default::default()
    }

    // optional bool muted = 1;

    pub fn muted(&self) -> bool {
        self.muted.unwrap_or(false)
    }

    pub fn clear_muted(&mut self) {
        self.muted = ::std::option::Option::None;
    }

    pub fn has_muted(&self) -> bool {
        self.muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muted(&mut self, v: bool) {
        self.muted = ::std::option::Option::Some(v);
    }

    // optional int64 muteEndTimestamp = 2;

    pub fn muteEndTimestamp(&self) -> i64 {
        self.muteEndTimestamp.unwrap_or(0)
    }

    pub fn clear_muteEndTimestamp(&mut self) {
        self.muteEndTimestamp = ::std::option::Option::None;
    }

    pub fn has_muteEndTimestamp(&self) -> bool {
        self.muteEndTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_muteEndTimestamp(&mut self, v: i64) {
        self.muteEndTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool autoMuted = 3;

    pub fn autoMuted(&self) -> bool {
        self.autoMuted.unwrap_or(false)
    }

    pub fn clear_autoMuted(&mut self) {
        self.autoMuted = ::std::option::Option::None;
    }

    pub fn has_autoMuted(&self) -> bool {
        self.autoMuted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autoMuted(&mut self, v: bool) {
        self.autoMuted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "muted",
            |m: &MuteAction| { &m.muted },
            |m: &mut MuteAction| { &mut m.muted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "muteEndTimestamp",
            |m: &MuteAction| { &m.muteEndTimestamp },
            |m: &mut MuteAction| { &mut m.muteEndTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "autoMuted",
            |m: &MuteAction| { &m.autoMuted },
            |m: &mut MuteAction| { &mut m.autoMuted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MuteAction>(
            "MuteAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MuteAction {
    const NAME: &'static str = "MuteAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.muted = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.muteEndTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.autoMuted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.muted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.muteEndTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.autoMuted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.muted {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.muteEndTimestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.autoMuted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MuteAction {
        MuteAction::new()
    }

    fn clear(&mut self) {
        self.muted = ::std::option::Option::None;
        self.muteEndTimestamp = ::std::option::Option::None;
        self.autoMuted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MuteAction {
        static instance: MuteAction = MuteAction {
            muted: ::std::option::Option::None,
            muteEndTimestamp: ::std::option::Option::None,
            autoMuted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MuteAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MuteAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MuteAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MuteAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.MarkChatAsReadAction)
pub struct MarkChatAsReadAction {
    // message fields
    // @@protoc_insertion_point(field:proto.MarkChatAsReadAction.read)
    pub read: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.MarkChatAsReadAction.messageRange)
    pub messageRange: ::protobuf::MessageField<SyncActionMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.MarkChatAsReadAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MarkChatAsReadAction {
    fn default() -> &'a MarkChatAsReadAction {
        <MarkChatAsReadAction as ::protobuf::Message>::default_instance()
    }
}

impl MarkChatAsReadAction {
    pub fn new() -> MarkChatAsReadAction {
        ::std::default::Default::default()
    }

    // optional bool read = 1;

    pub fn read(&self) -> bool {
        self.read.unwrap_or(false)
    }

    pub fn clear_read(&mut self) {
        self.read = ::std::option::Option::None;
    }

    pub fn has_read(&self) -> bool {
        self.read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: bool) {
        self.read = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "read",
            |m: &MarkChatAsReadAction| { &m.read },
            |m: &mut MarkChatAsReadAction| { &mut m.read },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionMessageRange>(
            "messageRange",
            |m: &MarkChatAsReadAction| { &m.messageRange },
            |m: &mut MarkChatAsReadAction| { &mut m.messageRange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MarkChatAsReadAction>(
            "MarkChatAsReadAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MarkChatAsReadAction {
    const NAME: &'static str = "MarkChatAsReadAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.read = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageRange)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.read {
            my_size += 1 + 1;
        }
        if let Some(v) = self.messageRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.read {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.messageRange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MarkChatAsReadAction {
        MarkChatAsReadAction::new()
    }

    fn clear(&mut self) {
        self.read = ::std::option::Option::None;
        self.messageRange.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MarkChatAsReadAction {
        static instance: MarkChatAsReadAction = MarkChatAsReadAction {
            read: ::std::option::Option::None,
            messageRange: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MarkChatAsReadAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MarkChatAsReadAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MarkChatAsReadAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarkChatAsReadAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.LocaleSetting)
pub struct LocaleSetting {
    // message fields
    // @@protoc_insertion_point(field:proto.LocaleSetting.locale)
    pub locale: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.LocaleSetting.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocaleSetting {
    fn default() -> &'a LocaleSetting {
        <LocaleSetting as ::protobuf::Message>::default_instance()
    }
}

impl LocaleSetting {
    pub fn new() -> LocaleSetting {
        ::std::default::Default::default()
    }

    // optional string locale = 1;

    pub fn locale(&self) -> &str {
        match self.locale.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_locale(&mut self) {
        self.locale = ::std::option::Option::None;
    }

    pub fn has_locale(&self) -> bool {
        self.locale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locale(&mut self, v: ::std::string::String) {
        self.locale = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locale(&mut self) -> &mut ::std::string::String {
        if self.locale.is_none() {
            self.locale = ::std::option::Option::Some(::std::string::String::new());
        }
        self.locale.as_mut().unwrap()
    }

    // Take field
    pub fn take_locale(&mut self) -> ::std::string::String {
        self.locale.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "locale",
            |m: &LocaleSetting| { &m.locale },
            |m: &mut LocaleSetting| { &mut m.locale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocaleSetting>(
            "LocaleSetting",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocaleSetting {
    const NAME: &'static str = "LocaleSetting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.locale = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.locale.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.locale.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocaleSetting {
        LocaleSetting::new()
    }

    fn clear(&mut self) {
        self.locale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocaleSetting {
        static instance: LocaleSetting = LocaleSetting {
            locale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocaleSetting {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocaleSetting").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocaleSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocaleSetting {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.LabelEditAction)
pub struct LabelEditAction {
    // message fields
    // @@protoc_insertion_point(field:proto.LabelEditAction.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.LabelEditAction.color)
    pub color: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.LabelEditAction.predefinedId)
    pub predefinedId: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.LabelEditAction.deleted)
    pub deleted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.LabelEditAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelEditAction {
    fn default() -> &'a LabelEditAction {
        <LabelEditAction as ::protobuf::Message>::default_instance()
    }
}

impl LabelEditAction {
    pub fn new() -> LabelEditAction {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 color = 2;

    pub fn color(&self) -> i32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: i32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional int32 predefinedId = 3;

    pub fn predefinedId(&self) -> i32 {
        self.predefinedId.unwrap_or(0)
    }

    pub fn clear_predefinedId(&mut self) {
        self.predefinedId = ::std::option::Option::None;
    }

    pub fn has_predefinedId(&self) -> bool {
        self.predefinedId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predefinedId(&mut self, v: i32) {
        self.predefinedId = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 4;

    pub fn deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &LabelEditAction| { &m.name },
            |m: &mut LabelEditAction| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &LabelEditAction| { &m.color },
            |m: &mut LabelEditAction| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "predefinedId",
            |m: &LabelEditAction| { &m.predefinedId },
            |m: &mut LabelEditAction| { &mut m.predefinedId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleted",
            |m: &LabelEditAction| { &m.deleted },
            |m: &mut LabelEditAction| { &mut m.deleted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelEditAction>(
            "LabelEditAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelEditAction {
    const NAME: &'static str = "LabelEditAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.color = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.predefinedId = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.predefinedId {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.deleted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.color {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.predefinedId {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelEditAction {
        LabelEditAction::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.predefinedId = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelEditAction {
        static instance: LabelEditAction = LabelEditAction {
            name: ::std::option::Option::None,
            color: ::std::option::Option::None,
            predefinedId: ::std::option::Option::None,
            deleted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelEditAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelEditAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelEditAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelEditAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.LabelAssociationAction)
pub struct LabelAssociationAction {
    // message fields
    // @@protoc_insertion_point(field:proto.LabelAssociationAction.labeled)
    pub labeled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.LabelAssociationAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelAssociationAction {
    fn default() -> &'a LabelAssociationAction {
        <LabelAssociationAction as ::protobuf::Message>::default_instance()
    }
}

impl LabelAssociationAction {
    pub fn new() -> LabelAssociationAction {
        ::std::default::Default::default()
    }

    // optional bool labeled = 1;

    pub fn labeled(&self) -> bool {
        self.labeled.unwrap_or(false)
    }

    pub fn clear_labeled(&mut self) {
        self.labeled = ::std::option::Option::None;
    }

    pub fn has_labeled(&self) -> bool {
        self.labeled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labeled(&mut self, v: bool) {
        self.labeled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labeled",
            |m: &LabelAssociationAction| { &m.labeled },
            |m: &mut LabelAssociationAction| { &mut m.labeled },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelAssociationAction>(
            "LabelAssociationAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelAssociationAction {
    const NAME: &'static str = "LabelAssociationAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.labeled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.labeled {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.labeled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelAssociationAction {
        LabelAssociationAction::new()
    }

    fn clear(&mut self) {
        self.labeled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelAssociationAction {
        static instance: LabelAssociationAction = LabelAssociationAction {
            labeled: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelAssociationAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelAssociationAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelAssociationAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelAssociationAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.KeyExpiration)
pub struct KeyExpiration {
    // message fields
    // @@protoc_insertion_point(field:proto.KeyExpiration.expiredKeyEpoch)
    pub expiredKeyEpoch: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.KeyExpiration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyExpiration {
    fn default() -> &'a KeyExpiration {
        <KeyExpiration as ::protobuf::Message>::default_instance()
    }
}

impl KeyExpiration {
    pub fn new() -> KeyExpiration {
        ::std::default::Default::default()
    }

    // optional int32 expiredKeyEpoch = 1;

    pub fn expiredKeyEpoch(&self) -> i32 {
        self.expiredKeyEpoch.unwrap_or(0)
    }

    pub fn clear_expiredKeyEpoch(&mut self) {
        self.expiredKeyEpoch = ::std::option::Option::None;
    }

    pub fn has_expiredKeyEpoch(&self) -> bool {
        self.expiredKeyEpoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiredKeyEpoch(&mut self, v: i32) {
        self.expiredKeyEpoch = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiredKeyEpoch",
            |m: &KeyExpiration| { &m.expiredKeyEpoch },
            |m: &mut KeyExpiration| { &mut m.expiredKeyEpoch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyExpiration>(
            "KeyExpiration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyExpiration {
    const NAME: &'static str = "KeyExpiration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.expiredKeyEpoch = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.expiredKeyEpoch {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.expiredKeyEpoch {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyExpiration {
        KeyExpiration::new()
    }

    fn clear(&mut self) {
        self.expiredKeyEpoch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyExpiration {
        static instance: KeyExpiration = KeyExpiration {
            expiredKeyEpoch: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyExpiration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyExpiration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyExpiration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyExpiration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DeleteMessageForMeAction)
pub struct DeleteMessageForMeAction {
    // message fields
    // @@protoc_insertion_point(field:proto.DeleteMessageForMeAction.deleteMedia)
    pub deleteMedia: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.DeleteMessageForMeAction.messageTimestamp)
    pub messageTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DeleteMessageForMeAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteMessageForMeAction {
    fn default() -> &'a DeleteMessageForMeAction {
        <DeleteMessageForMeAction as ::protobuf::Message>::default_instance()
    }
}

impl DeleteMessageForMeAction {
    pub fn new() -> DeleteMessageForMeAction {
        ::std::default::Default::default()
    }

    // optional bool deleteMedia = 1;

    pub fn deleteMedia(&self) -> bool {
        self.deleteMedia.unwrap_or(false)
    }

    pub fn clear_deleteMedia(&mut self) {
        self.deleteMedia = ::std::option::Option::None;
    }

    pub fn has_deleteMedia(&self) -> bool {
        self.deleteMedia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleteMedia(&mut self, v: bool) {
        self.deleteMedia = ::std::option::Option::Some(v);
    }

    // optional int64 messageTimestamp = 2;

    pub fn messageTimestamp(&self) -> i64 {
        self.messageTimestamp.unwrap_or(0)
    }

    pub fn clear_messageTimestamp(&mut self) {
        self.messageTimestamp = ::std::option::Option::None;
    }

    pub fn has_messageTimestamp(&self) -> bool {
        self.messageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageTimestamp(&mut self, v: i64) {
        self.messageTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deleteMedia",
            |m: &DeleteMessageForMeAction| { &m.deleteMedia },
            |m: &mut DeleteMessageForMeAction| { &mut m.deleteMedia },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageTimestamp",
            |m: &DeleteMessageForMeAction| { &m.messageTimestamp },
            |m: &mut DeleteMessageForMeAction| { &mut m.messageTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteMessageForMeAction>(
            "DeleteMessageForMeAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteMessageForMeAction {
    const NAME: &'static str = "DeleteMessageForMeAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deleteMedia = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.messageTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deleteMedia {
            my_size += 1 + 1;
        }
        if let Some(v) = self.messageTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deleteMedia {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.messageTimestamp {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteMessageForMeAction {
        DeleteMessageForMeAction::new()
    }

    fn clear(&mut self) {
        self.deleteMedia = ::std::option::Option::None;
        self.messageTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteMessageForMeAction {
        static instance: DeleteMessageForMeAction = DeleteMessageForMeAction {
            deleteMedia: ::std::option::Option::None,
            messageTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteMessageForMeAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteMessageForMeAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteMessageForMeAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteMessageForMeAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.DeleteChatAction)
pub struct DeleteChatAction {
    // message fields
    // @@protoc_insertion_point(field:proto.DeleteChatAction.messageRange)
    pub messageRange: ::protobuf::MessageField<SyncActionMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.DeleteChatAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteChatAction {
    fn default() -> &'a DeleteChatAction {
        <DeleteChatAction as ::protobuf::Message>::default_instance()
    }
}

impl DeleteChatAction {
    pub fn new() -> DeleteChatAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionMessageRange>(
            "messageRange",
            |m: &DeleteChatAction| { &m.messageRange },
            |m: &mut DeleteChatAction| { &mut m.messageRange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteChatAction>(
            "DeleteChatAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteChatAction {
    const NAME: &'static str = "DeleteChatAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageRange)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.messageRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.messageRange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteChatAction {
        DeleteChatAction::new()
    }

    fn clear(&mut self) {
        self.messageRange.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteChatAction {
        static instance: DeleteChatAction = DeleteChatAction {
            messageRange: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteChatAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteChatAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteChatAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteChatAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ContactAction)
pub struct ContactAction {
    // message fields
    // @@protoc_insertion_point(field:proto.ContactAction.fullName)
    pub fullName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContactAction.firstName)
    pub firstName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ContactAction.lidJid)
    pub lidJid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ContactAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ContactAction {
    fn default() -> &'a ContactAction {
        <ContactAction as ::protobuf::Message>::default_instance()
    }
}

impl ContactAction {
    pub fn new() -> ContactAction {
        ::std::default::Default::default()
    }

    // optional string fullName = 1;

    pub fn fullName(&self) -> &str {
        match self.fullName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fullName(&mut self) {
        self.fullName = ::std::option::Option::None;
    }

    pub fn has_fullName(&self) -> bool {
        self.fullName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullName(&mut self, v: ::std::string::String) {
        self.fullName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullName(&mut self) -> &mut ::std::string::String {
        if self.fullName.is_none() {
            self.fullName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fullName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fullName(&mut self) -> ::std::string::String {
        self.fullName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string firstName = 2;

    pub fn firstName(&self) -> &str {
        match self.firstName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_firstName(&mut self) {
        self.firstName = ::std::option::Option::None;
    }

    pub fn has_firstName(&self) -> bool {
        self.firstName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstName(&mut self, v: ::std::string::String) {
        self.firstName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstName(&mut self) -> &mut ::std::string::String {
        if self.firstName.is_none() {
            self.firstName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.firstName.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstName(&mut self) -> ::std::string::String {
        self.firstName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string lidJid = 3;

    pub fn lidJid(&self) -> &str {
        match self.lidJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lidJid(&mut self) {
        self.lidJid = ::std::option::Option::None;
    }

    pub fn has_lidJid(&self) -> bool {
        self.lidJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lidJid(&mut self, v: ::std::string::String) {
        self.lidJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lidJid(&mut self) -> &mut ::std::string::String {
        if self.lidJid.is_none() {
            self.lidJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lidJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_lidJid(&mut self) -> ::std::string::String {
        self.lidJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fullName",
            |m: &ContactAction| { &m.fullName },
            |m: &mut ContactAction| { &mut m.fullName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstName",
            |m: &ContactAction| { &m.firstName },
            |m: &mut ContactAction| { &mut m.firstName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lidJid",
            |m: &ContactAction| { &m.lidJid },
            |m: &mut ContactAction| { &mut m.lidJid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContactAction>(
            "ContactAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ContactAction {
    const NAME: &'static str = "ContactAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.fullName = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.firstName = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.lidJid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fullName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.firstName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lidJid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fullName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.firstName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lidJid.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ContactAction {
        ContactAction::new()
    }

    fn clear(&mut self) {
        self.fullName = ::std::option::Option::None;
        self.firstName = ::std::option::Option::None;
        self.lidJid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ContactAction {
        static instance: ContactAction = ContactAction {
            fullName: ::std::option::Option::None,
            firstName: ::std::option::Option::None,
            lidJid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ContactAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ContactAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ContactAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ClearChatAction)
pub struct ClearChatAction {
    // message fields
    // @@protoc_insertion_point(field:proto.ClearChatAction.messageRange)
    pub messageRange: ::protobuf::MessageField<SyncActionMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ClearChatAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClearChatAction {
    fn default() -> &'a ClearChatAction {
        <ClearChatAction as ::protobuf::Message>::default_instance()
    }
}

impl ClearChatAction {
    pub fn new() -> ClearChatAction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionMessageRange>(
            "messageRange",
            |m: &ClearChatAction| { &m.messageRange },
            |m: &mut ClearChatAction| { &mut m.messageRange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClearChatAction>(
            "ClearChatAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClearChatAction {
    const NAME: &'static str = "ClearChatAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageRange)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.messageRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.messageRange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClearChatAction {
        ClearChatAction::new()
    }

    fn clear(&mut self) {
        self.messageRange.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClearChatAction {
        static instance: ClearChatAction = ClearChatAction {
            messageRange: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClearChatAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClearChatAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClearChatAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearChatAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ChatAssignmentOpenedStatusAction)
pub struct ChatAssignmentOpenedStatusAction {
    // message fields
    // @@protoc_insertion_point(field:proto.ChatAssignmentOpenedStatusAction.chatOpened)
    pub chatOpened: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ChatAssignmentOpenedStatusAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatAssignmentOpenedStatusAction {
    fn default() -> &'a ChatAssignmentOpenedStatusAction {
        <ChatAssignmentOpenedStatusAction as ::protobuf::Message>::default_instance()
    }
}

impl ChatAssignmentOpenedStatusAction {
    pub fn new() -> ChatAssignmentOpenedStatusAction {
        ::std::default::Default::default()
    }

    // optional bool chatOpened = 1;

    pub fn chatOpened(&self) -> bool {
        self.chatOpened.unwrap_or(false)
    }

    pub fn clear_chatOpened(&mut self) {
        self.chatOpened = ::std::option::Option::None;
    }

    pub fn has_chatOpened(&self) -> bool {
        self.chatOpened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatOpened(&mut self, v: bool) {
        self.chatOpened = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chatOpened",
            |m: &ChatAssignmentOpenedStatusAction| { &m.chatOpened },
            |m: &mut ChatAssignmentOpenedStatusAction| { &mut m.chatOpened },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatAssignmentOpenedStatusAction>(
            "ChatAssignmentOpenedStatusAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatAssignmentOpenedStatusAction {
    const NAME: &'static str = "ChatAssignmentOpenedStatusAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chatOpened = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chatOpened {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.chatOpened {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatAssignmentOpenedStatusAction {
        ChatAssignmentOpenedStatusAction::new()
    }

    fn clear(&mut self) {
        self.chatOpened = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatAssignmentOpenedStatusAction {
        static instance: ChatAssignmentOpenedStatusAction = ChatAssignmentOpenedStatusAction {
            chatOpened: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatAssignmentOpenedStatusAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatAssignmentOpenedStatusAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatAssignmentOpenedStatusAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatAssignmentOpenedStatusAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ChatAssignmentAction)
pub struct ChatAssignmentAction {
    // message fields
    // @@protoc_insertion_point(field:proto.ChatAssignmentAction.deviceAgentID)
    pub deviceAgentID: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ChatAssignmentAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatAssignmentAction {
    fn default() -> &'a ChatAssignmentAction {
        <ChatAssignmentAction as ::protobuf::Message>::default_instance()
    }
}

impl ChatAssignmentAction {
    pub fn new() -> ChatAssignmentAction {
        ::std::default::Default::default()
    }

    // optional string deviceAgentID = 1;

    pub fn deviceAgentID(&self) -> &str {
        match self.deviceAgentID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deviceAgentID(&mut self) {
        self.deviceAgentID = ::std::option::Option::None;
    }

    pub fn has_deviceAgentID(&self) -> bool {
        self.deviceAgentID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceAgentID(&mut self, v: ::std::string::String) {
        self.deviceAgentID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceAgentID(&mut self) -> &mut ::std::string::String {
        if self.deviceAgentID.is_none() {
            self.deviceAgentID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deviceAgentID.as_mut().unwrap()
    }

    // Take field
    pub fn take_deviceAgentID(&mut self) -> ::std::string::String {
        self.deviceAgentID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceAgentID",
            |m: &ChatAssignmentAction| { &m.deviceAgentID },
            |m: &mut ChatAssignmentAction| { &mut m.deviceAgentID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatAssignmentAction>(
            "ChatAssignmentAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatAssignmentAction {
    const NAME: &'static str = "ChatAssignmentAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.deviceAgentID = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deviceAgentID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.deviceAgentID.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatAssignmentAction {
        ChatAssignmentAction::new()
    }

    fn clear(&mut self) {
        self.deviceAgentID = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatAssignmentAction {
        static instance: ChatAssignmentAction = ChatAssignmentAction {
            deviceAgentID: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatAssignmentAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatAssignmentAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatAssignmentAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatAssignmentAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ArchiveChatAction)
pub struct ArchiveChatAction {
    // message fields
    // @@protoc_insertion_point(field:proto.ArchiveChatAction.archived)
    pub archived: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ArchiveChatAction.messageRange)
    pub messageRange: ::protobuf::MessageField<SyncActionMessageRange>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ArchiveChatAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArchiveChatAction {
    fn default() -> &'a ArchiveChatAction {
        <ArchiveChatAction as ::protobuf::Message>::default_instance()
    }
}

impl ArchiveChatAction {
    pub fn new() -> ArchiveChatAction {
        ::std::default::Default::default()
    }

    // optional bool archived = 1;

    pub fn archived(&self) -> bool {
        self.archived.unwrap_or(false)
    }

    pub fn clear_archived(&mut self) {
        self.archived = ::std::option::Option::None;
    }

    pub fn has_archived(&self) -> bool {
        self.archived.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archived(&mut self, v: bool) {
        self.archived = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "archived",
            |m: &ArchiveChatAction| { &m.archived },
            |m: &mut ArchiveChatAction| { &mut m.archived },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionMessageRange>(
            "messageRange",
            |m: &ArchiveChatAction| { &m.messageRange },
            |m: &mut ArchiveChatAction| { &mut m.messageRange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArchiveChatAction>(
            "ArchiveChatAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArchiveChatAction {
    const NAME: &'static str = "ArchiveChatAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.archived = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.messageRange)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.archived {
            my_size += 1 + 1;
        }
        if let Some(v) = self.messageRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.archived {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.messageRange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArchiveChatAction {
        ArchiveChatAction::new()
    }

    fn clear(&mut self) {
        self.archived = ::std::option::Option::None;
        self.messageRange.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArchiveChatAction {
        static instance: ArchiveChatAction = ArchiveChatAction {
            archived: ::std::option::Option::None,
            messageRange: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArchiveChatAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArchiveChatAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArchiveChatAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArchiveChatAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AndroidUnsupportedActions)
pub struct AndroidUnsupportedActions {
    // message fields
    // @@protoc_insertion_point(field:proto.AndroidUnsupportedActions.allowed)
    pub allowed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AndroidUnsupportedActions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AndroidUnsupportedActions {
    fn default() -> &'a AndroidUnsupportedActions {
        <AndroidUnsupportedActions as ::protobuf::Message>::default_instance()
    }
}

impl AndroidUnsupportedActions {
    pub fn new() -> AndroidUnsupportedActions {
        ::std::default::Default::default()
    }

    // optional bool allowed = 1;

    pub fn allowed(&self) -> bool {
        self.allowed.unwrap_or(false)
    }

    pub fn clear_allowed(&mut self) {
        self.allowed = ::std::option::Option::None;
    }

    pub fn has_allowed(&self) -> bool {
        self.allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed(&mut self, v: bool) {
        self.allowed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allowed",
            |m: &AndroidUnsupportedActions| { &m.allowed },
            |m: &mut AndroidUnsupportedActions| { &mut m.allowed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AndroidUnsupportedActions>(
            "AndroidUnsupportedActions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AndroidUnsupportedActions {
    const NAME: &'static str = "AndroidUnsupportedActions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allowed {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.allowed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AndroidUnsupportedActions {
        AndroidUnsupportedActions::new()
    }

    fn clear(&mut self) {
        self.allowed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AndroidUnsupportedActions {
        static instance: AndroidUnsupportedActions = AndroidUnsupportedActions {
            allowed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AndroidUnsupportedActions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AndroidUnsupportedActions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AndroidUnsupportedActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AndroidUnsupportedActions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.AgentAction)
pub struct AgentAction {
    // message fields
    // @@protoc_insertion_point(field:proto.AgentAction.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.AgentAction.deviceID)
    pub deviceID: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.AgentAction.isDeleted)
    pub isDeleted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.AgentAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AgentAction {
    fn default() -> &'a AgentAction {
        <AgentAction as ::protobuf::Message>::default_instance()
    }
}

impl AgentAction {
    pub fn new() -> AgentAction {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 deviceID = 2;

    pub fn deviceID(&self) -> i32 {
        self.deviceID.unwrap_or(0)
    }

    pub fn clear_deviceID(&mut self) {
        self.deviceID = ::std::option::Option::None;
    }

    pub fn has_deviceID(&self) -> bool {
        self.deviceID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceID(&mut self, v: i32) {
        self.deviceID = ::std::option::Option::Some(v);
    }

    // optional bool isDeleted = 3;

    pub fn isDeleted(&self) -> bool {
        self.isDeleted.unwrap_or(false)
    }

    pub fn clear_isDeleted(&mut self) {
        self.isDeleted = ::std::option::Option::None;
    }

    pub fn has_isDeleted(&self) -> bool {
        self.isDeleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isDeleted(&mut self, v: bool) {
        self.isDeleted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &AgentAction| { &m.name },
            |m: &mut AgentAction| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceID",
            |m: &AgentAction| { &m.deviceID },
            |m: &mut AgentAction| { &mut m.deviceID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isDeleted",
            |m: &AgentAction| { &m.isDeleted },
            |m: &mut AgentAction| { &mut m.isDeleted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AgentAction>(
            "AgentAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AgentAction {
    const NAME: &'static str = "AgentAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.deviceID = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.isDeleted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.deviceID {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.isDeleted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.deviceID {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.isDeleted {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AgentAction {
        AgentAction::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.deviceID = ::std::option::Option::None;
        self.isDeleted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AgentAction {
        static instance: AgentAction = AgentAction {
            name: ::std::option::Option::None,
            deviceID: ::std::option::Option::None,
            isDeleted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AgentAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AgentAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AgentAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgentAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.SyncActionData)
pub struct SyncActionData {
    // message fields
    // @@protoc_insertion_point(field:proto.SyncActionData.index)
    pub index: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.SyncActionData.value)
    pub value: ::protobuf::MessageField<SyncActionValue>,
    // @@protoc_insertion_point(field:proto.SyncActionData.padding)
    pub padding: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.SyncActionData.version)
    pub version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.SyncActionData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SyncActionData {
    fn default() -> &'a SyncActionData {
        <SyncActionData as ::protobuf::Message>::default_instance()
    }
}

impl SyncActionData {
    pub fn new() -> SyncActionData {
        ::std::default::Default::default()
    }

    // optional bytes index = 1;

    pub fn index(&self) -> &[u8] {
        match self.index.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: ::std::vec::Vec<u8>) {
        self.index = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.index.is_none() {
            self.index = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.index.as_mut().unwrap()
    }

    // Take field
    pub fn take_index(&mut self) -> ::std::vec::Vec<u8> {
        self.index.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes padding = 3;

    pub fn padding(&self) -> &[u8] {
        match self.padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_padding(&mut self) {
        self.padding = ::std::option::Option::None;
    }

    pub fn has_padding(&self) -> bool {
        self.padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding(&mut self, v: ::std::vec::Vec<u8>) {
        self.padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.padding.is_none() {
            self.padding = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding(&mut self) -> ::std::vec::Vec<u8> {
        self.padding.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 version = 4;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &SyncActionData| { &m.index },
            |m: &mut SyncActionData| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SyncActionValue>(
            "value",
            |m: &SyncActionData| { &m.value },
            |m: &mut SyncActionData| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "padding",
            |m: &SyncActionData| { &m.padding },
            |m: &mut SyncActionData| { &mut m.padding },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &SyncActionData| { &m.version },
            |m: &mut SyncActionData| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SyncActionData>(
            "SyncActionData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SyncActionData {
    const NAME: &'static str = "SyncActionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.index = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                26 => {
                    self.padding = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.padding.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SyncActionData {
        SyncActionData::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.value.clear();
        self.padding = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SyncActionData {
        static instance: SyncActionData = SyncActionData {
            index: ::std::option::Option::None,
            value: ::protobuf::MessageField::none(),
            padding: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SyncActionData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SyncActionData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SyncActionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncActionData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.RecentEmojiWeight)
pub struct RecentEmojiWeight {
    // message fields
    // @@protoc_insertion_point(field:proto.RecentEmojiWeight.emoji)
    pub emoji: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.RecentEmojiWeight.weight)
    pub weight: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.RecentEmojiWeight.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecentEmojiWeight {
    fn default() -> &'a RecentEmojiWeight {
        <RecentEmojiWeight as ::protobuf::Message>::default_instance()
    }
}

impl RecentEmojiWeight {
    pub fn new() -> RecentEmojiWeight {
        ::std::default::Default::default()
    }

    // optional string emoji = 1;

    pub fn emoji(&self) -> &str {
        match self.emoji.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_emoji(&mut self) {
        self.emoji = ::std::option::Option::None;
    }

    pub fn has_emoji(&self) -> bool {
        self.emoji.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emoji(&mut self, v: ::std::string::String) {
        self.emoji = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emoji(&mut self) -> &mut ::std::string::String {
        if self.emoji.is_none() {
            self.emoji = ::std::option::Option::Some(::std::string::String::new());
        }
        self.emoji.as_mut().unwrap()
    }

    // Take field
    pub fn take_emoji(&mut self) -> ::std::string::String {
        self.emoji.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float weight = 2;

    pub fn weight(&self) -> f32 {
        self.weight.unwrap_or(0.)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: f32) {
        self.weight = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "emoji",
            |m: &RecentEmojiWeight| { &m.emoji },
            |m: &mut RecentEmojiWeight| { &mut m.emoji },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &RecentEmojiWeight| { &m.weight },
            |m: &mut RecentEmojiWeight| { &mut m.weight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecentEmojiWeight>(
            "RecentEmojiWeight",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecentEmojiWeight {
    const NAME: &'static str = "RecentEmojiWeight";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.emoji = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.weight = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.emoji.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.weight {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.emoji.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.weight {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecentEmojiWeight {
        RecentEmojiWeight::new()
    }

    fn clear(&mut self) {
        self.emoji = ::std::option::Option::None;
        self.weight = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecentEmojiWeight {
        static instance: RecentEmojiWeight = RecentEmojiWeight {
            emoji: ::std::option::Option::None,
            weight: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecentEmojiWeight {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecentEmojiWeight").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecentEmojiWeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecentEmojiWeight {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.VerifiedNameCertificate)
pub struct VerifiedNameCertificate {
    // message fields
    // @@protoc_insertion_point(field:proto.VerifiedNameCertificate.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VerifiedNameCertificate.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.VerifiedNameCertificate.serverSignature)
    pub serverSignature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.VerifiedNameCertificate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VerifiedNameCertificate {
    fn default() -> &'a VerifiedNameCertificate {
        <VerifiedNameCertificate as ::protobuf::Message>::default_instance()
    }
}

impl VerifiedNameCertificate {
    pub fn new() -> VerifiedNameCertificate {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes serverSignature = 3;

    pub fn serverSignature(&self) -> &[u8] {
        match self.serverSignature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serverSignature(&mut self) {
        self.serverSignature = ::std::option::Option::None;
    }

    pub fn has_serverSignature(&self) -> bool {
        self.serverSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverSignature(&mut self, v: ::std::vec::Vec<u8>) {
        self.serverSignature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverSignature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serverSignature.is_none() {
            self.serverSignature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serverSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverSignature(&mut self) -> ::std::vec::Vec<u8> {
        self.serverSignature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &VerifiedNameCertificate| { &m.details },
            |m: &mut VerifiedNameCertificate| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &VerifiedNameCertificate| { &m.signature },
            |m: &mut VerifiedNameCertificate| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverSignature",
            |m: &VerifiedNameCertificate| { &m.serverSignature },
            |m: &mut VerifiedNameCertificate| { &mut m.serverSignature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VerifiedNameCertificate>(
            "VerifiedNameCertificate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VerifiedNameCertificate {
    const NAME: &'static str = "VerifiedNameCertificate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.serverSignature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.serverSignature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.serverSignature.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VerifiedNameCertificate {
        VerifiedNameCertificate::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.serverSignature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VerifiedNameCertificate {
        static instance: VerifiedNameCertificate = VerifiedNameCertificate {
            details: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            serverSignature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VerifiedNameCertificate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VerifiedNameCertificate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VerifiedNameCertificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifiedNameCertificate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VerifiedNameCertificate`
pub mod verified_name_certificate {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.VerifiedNameCertificate.Details)
    pub struct Details {
        // message fields
        // @@protoc_insertion_point(field:proto.VerifiedNameCertificate.Details.serial)
        pub serial: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:proto.VerifiedNameCertificate.Details.issuer)
        pub issuer: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.VerifiedNameCertificate.Details.verifiedName)
        pub verifiedName: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.VerifiedNameCertificate.Details.localizedNames)
        pub localizedNames: ::std::vec::Vec<super::LocalizedName>,
        // @@protoc_insertion_point(field:proto.VerifiedNameCertificate.Details.issueTime)
        pub issueTime: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.VerifiedNameCertificate.Details.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Details {
        fn default() -> &'a Details {
            <Details as ::protobuf::Message>::default_instance()
        }
    }

    impl Details {
        pub fn new() -> Details {
            ::std::default::Default::default()
        }

        // optional uint64 serial = 1;

        pub fn serial(&self) -> u64 {
            self.serial.unwrap_or(0)
        }

        pub fn clear_serial(&mut self) {
            self.serial = ::std::option::Option::None;
        }

        pub fn has_serial(&self) -> bool {
            self.serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_serial(&mut self, v: u64) {
            self.serial = ::std::option::Option::Some(v);
        }

        // optional string issuer = 2;

        pub fn issuer(&self) -> &str {
            match self.issuer.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_issuer(&mut self) {
            self.issuer = ::std::option::Option::None;
        }

        pub fn has_issuer(&self) -> bool {
            self.issuer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_issuer(&mut self, v: ::std::string::String) {
            self.issuer = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
            if self.issuer.is_none() {
                self.issuer = ::std::option::Option::Some(::std::string::String::new());
            }
            self.issuer.as_mut().unwrap()
        }

        // Take field
        pub fn take_issuer(&mut self) -> ::std::string::String {
            self.issuer.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string verifiedName = 4;

        pub fn verifiedName(&self) -> &str {
            match self.verifiedName.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_verifiedName(&mut self) {
            self.verifiedName = ::std::option::Option::None;
        }

        pub fn has_verifiedName(&self) -> bool {
            self.verifiedName.is_some()
        }

        // Param is passed by value, moved
        pub fn set_verifiedName(&mut self, v: ::std::string::String) {
            self.verifiedName = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_verifiedName(&mut self) -> &mut ::std::string::String {
            if self.verifiedName.is_none() {
                self.verifiedName = ::std::option::Option::Some(::std::string::String::new());
            }
            self.verifiedName.as_mut().unwrap()
        }

        // Take field
        pub fn take_verifiedName(&mut self) -> ::std::string::String {
            self.verifiedName.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 issueTime = 10;

        pub fn issueTime(&self) -> u64 {
            self.issueTime.unwrap_or(0)
        }

        pub fn clear_issueTime(&mut self) {
            self.issueTime = ::std::option::Option::None;
        }

        pub fn has_issueTime(&self) -> bool {
            self.issueTime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_issueTime(&mut self, v: u64) {
            self.issueTime = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "serial",
                |m: &Details| { &m.serial },
                |m: &mut Details| { &mut m.serial },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "issuer",
                |m: &Details| { &m.issuer },
                |m: &mut Details| { &mut m.issuer },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "verifiedName",
                |m: &Details| { &m.verifiedName },
                |m: &mut Details| { &mut m.verifiedName },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "localizedNames",
                |m: &Details| { &m.localizedNames },
                |m: &mut Details| { &mut m.localizedNames },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "issueTime",
                |m: &Details| { &m.issueTime },
                |m: &mut Details| { &mut m.issueTime },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Details>(
                "VerifiedNameCertificate.Details",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Details {
        const NAME: &'static str = "Details";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.serial = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.issuer = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.verifiedName = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.localizedNames.push(is.read_message()?);
                    },
                    80 => {
                        self.issueTime = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.serial {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.issuer.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.verifiedName.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            for value in &self.localizedNames {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.issueTime {
                my_size += ::protobuf::rt::uint64_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.serial {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.issuer.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.verifiedName.as_ref() {
                os.write_string(4, v)?;
            }
            for v in &self.localizedNames {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            if let Some(v) = self.issueTime {
                os.write_uint64(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Details {
            Details::new()
        }

        fn clear(&mut self) {
            self.serial = ::std::option::Option::None;
            self.issuer = ::std::option::Option::None;
            self.verifiedName = ::std::option::Option::None;
            self.localizedNames.clear();
            self.issueTime = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Details {
            static instance: Details = Details {
                serial: ::std::option::Option::None,
                issuer: ::std::option::Option::None,
                verifiedName: ::std::option::Option::None,
                localizedNames: ::std::vec::Vec::new(),
                issueTime: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Details {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("VerifiedNameCertificate.Details").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Details {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Details {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.LocalizedName)
pub struct LocalizedName {
    // message fields
    // @@protoc_insertion_point(field:proto.LocalizedName.lg)
    pub lg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.LocalizedName.lc)
    pub lc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.LocalizedName.verifiedName)
    pub verifiedName: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.LocalizedName.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocalizedName {
    fn default() -> &'a LocalizedName {
        <LocalizedName as ::protobuf::Message>::default_instance()
    }
}

impl LocalizedName {
    pub fn new() -> LocalizedName {
        ::std::default::Default::default()
    }

    // optional string lg = 1;

    pub fn lg(&self) -> &str {
        match self.lg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lg(&mut self) {
        self.lg = ::std::option::Option::None;
    }

    pub fn has_lg(&self) -> bool {
        self.lg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lg(&mut self, v: ::std::string::String) {
        self.lg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lg(&mut self) -> &mut ::std::string::String {
        if self.lg.is_none() {
            self.lg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lg.as_mut().unwrap()
    }

    // Take field
    pub fn take_lg(&mut self) -> ::std::string::String {
        self.lg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string lc = 2;

    pub fn lc(&self) -> &str {
        match self.lc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lc(&mut self) {
        self.lc = ::std::option::Option::None;
    }

    pub fn has_lc(&self) -> bool {
        self.lc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lc(&mut self, v: ::std::string::String) {
        self.lc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lc(&mut self) -> &mut ::std::string::String {
        if self.lc.is_none() {
            self.lc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lc.as_mut().unwrap()
    }

    // Take field
    pub fn take_lc(&mut self) -> ::std::string::String {
        self.lc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string verifiedName = 3;

    pub fn verifiedName(&self) -> &str {
        match self.verifiedName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_verifiedName(&mut self) {
        self.verifiedName = ::std::option::Option::None;
    }

    pub fn has_verifiedName(&self) -> bool {
        self.verifiedName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verifiedName(&mut self, v: ::std::string::String) {
        self.verifiedName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verifiedName(&mut self) -> &mut ::std::string::String {
        if self.verifiedName.is_none() {
            self.verifiedName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.verifiedName.as_mut().unwrap()
    }

    // Take field
    pub fn take_verifiedName(&mut self) -> ::std::string::String {
        self.verifiedName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lg",
            |m: &LocalizedName| { &m.lg },
            |m: &mut LocalizedName| { &mut m.lg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lc",
            |m: &LocalizedName| { &m.lc },
            |m: &mut LocalizedName| { &mut m.lc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verifiedName",
            |m: &LocalizedName| { &m.verifiedName },
            |m: &mut LocalizedName| { &mut m.verifiedName },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocalizedName>(
            "LocalizedName",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocalizedName {
    const NAME: &'static str = "LocalizedName";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lg = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.lc = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.verifiedName = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.lc.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.verifiedName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lg.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.lc.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.verifiedName.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocalizedName {
        LocalizedName::new()
    }

    fn clear(&mut self) {
        self.lg = ::std::option::Option::None;
        self.lc = ::std::option::Option::None;
        self.verifiedName = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocalizedName {
        static instance: LocalizedName = LocalizedName {
            lg: ::std::option::Option::None,
            lc: ::std::option::Option::None,
            verifiedName: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocalizedName {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocalizedName").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocalizedName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalizedName {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.BizIdentityInfo)
pub struct BizIdentityInfo {
    // message fields
    // @@protoc_insertion_point(field:proto.BizIdentityInfo.vlevel)
    pub vlevel: ::std::option::Option<::protobuf::EnumOrUnknown<biz_identity_info::VerifiedLevelValue>>,
    // @@protoc_insertion_point(field:proto.BizIdentityInfo.vnameCert)
    pub vnameCert: ::protobuf::MessageField<VerifiedNameCertificate>,
    // @@protoc_insertion_point(field:proto.BizIdentityInfo.signed)
    pub signed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.BizIdentityInfo.revoked)
    pub revoked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.BizIdentityInfo.hostStorage)
    pub hostStorage: ::std::option::Option<::protobuf::EnumOrUnknown<biz_identity_info::HostStorageType>>,
    // @@protoc_insertion_point(field:proto.BizIdentityInfo.actualActors)
    pub actualActors: ::std::option::Option<::protobuf::EnumOrUnknown<biz_identity_info::ActualActorsType>>,
    // @@protoc_insertion_point(field:proto.BizIdentityInfo.privacyModeTs)
    pub privacyModeTs: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.BizIdentityInfo.featureControls)
    pub featureControls: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.BizIdentityInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BizIdentityInfo {
    fn default() -> &'a BizIdentityInfo {
        <BizIdentityInfo as ::protobuf::Message>::default_instance()
    }
}

impl BizIdentityInfo {
    pub fn new() -> BizIdentityInfo {
        ::std::default::Default::default()
    }

    // optional .proto.BizIdentityInfo.VerifiedLevelValue vlevel = 1;

    pub fn vlevel(&self) -> biz_identity_info::VerifiedLevelValue {
        match self.vlevel {
            Some(e) => e.enum_value_or(biz_identity_info::VerifiedLevelValue::UNKNOWN),
            None => biz_identity_info::VerifiedLevelValue::UNKNOWN,
        }
    }

    pub fn clear_vlevel(&mut self) {
        self.vlevel = ::std::option::Option::None;
    }

    pub fn has_vlevel(&self) -> bool {
        self.vlevel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vlevel(&mut self, v: biz_identity_info::VerifiedLevelValue) {
        self.vlevel = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool signed = 3;

    pub fn signed(&self) -> bool {
        self.signed.unwrap_or(false)
    }

    pub fn clear_signed(&mut self) {
        self.signed = ::std::option::Option::None;
    }

    pub fn has_signed(&self) -> bool {
        self.signed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signed(&mut self, v: bool) {
        self.signed = ::std::option::Option::Some(v);
    }

    // optional bool revoked = 4;

    pub fn revoked(&self) -> bool {
        self.revoked.unwrap_or(false)
    }

    pub fn clear_revoked(&mut self) {
        self.revoked = ::std::option::Option::None;
    }

    pub fn has_revoked(&self) -> bool {
        self.revoked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revoked(&mut self, v: bool) {
        self.revoked = ::std::option::Option::Some(v);
    }

    // optional .proto.BizIdentityInfo.HostStorageType hostStorage = 5;

    pub fn hostStorage(&self) -> biz_identity_info::HostStorageType {
        match self.hostStorage {
            Some(e) => e.enum_value_or(biz_identity_info::HostStorageType::ON_PREMISE),
            None => biz_identity_info::HostStorageType::ON_PREMISE,
        }
    }

    pub fn clear_hostStorage(&mut self) {
        self.hostStorage = ::std::option::Option::None;
    }

    pub fn has_hostStorage(&self) -> bool {
        self.hostStorage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostStorage(&mut self, v: biz_identity_info::HostStorageType) {
        self.hostStorage = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.BizIdentityInfo.ActualActorsType actualActors = 6;

    pub fn actualActors(&self) -> biz_identity_info::ActualActorsType {
        match self.actualActors {
            Some(e) => e.enum_value_or(biz_identity_info::ActualActorsType::SELF),
            None => biz_identity_info::ActualActorsType::SELF,
        }
    }

    pub fn clear_actualActors(&mut self) {
        self.actualActors = ::std::option::Option::None;
    }

    pub fn has_actualActors(&self) -> bool {
        self.actualActors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actualActors(&mut self, v: biz_identity_info::ActualActorsType) {
        self.actualActors = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 privacyModeTs = 7;

    pub fn privacyModeTs(&self) -> u64 {
        self.privacyModeTs.unwrap_or(0)
    }

    pub fn clear_privacyModeTs(&mut self) {
        self.privacyModeTs = ::std::option::Option::None;
    }

    pub fn has_privacyModeTs(&self) -> bool {
        self.privacyModeTs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privacyModeTs(&mut self, v: u64) {
        self.privacyModeTs = ::std::option::Option::Some(v);
    }

    // optional uint64 featureControls = 8;

    pub fn featureControls(&self) -> u64 {
        self.featureControls.unwrap_or(0)
    }

    pub fn clear_featureControls(&mut self) {
        self.featureControls = ::std::option::Option::None;
    }

    pub fn has_featureControls(&self) -> bool {
        self.featureControls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featureControls(&mut self, v: u64) {
        self.featureControls = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vlevel",
            |m: &BizIdentityInfo| { &m.vlevel },
            |m: &mut BizIdentityInfo| { &mut m.vlevel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VerifiedNameCertificate>(
            "vnameCert",
            |m: &BizIdentityInfo| { &m.vnameCert },
            |m: &mut BizIdentityInfo| { &mut m.vnameCert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signed",
            |m: &BizIdentityInfo| { &m.signed },
            |m: &mut BizIdentityInfo| { &mut m.signed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revoked",
            |m: &BizIdentityInfo| { &m.revoked },
            |m: &mut BizIdentityInfo| { &mut m.revoked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostStorage",
            |m: &BizIdentityInfo| { &m.hostStorage },
            |m: &mut BizIdentityInfo| { &mut m.hostStorage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actualActors",
            |m: &BizIdentityInfo| { &m.actualActors },
            |m: &mut BizIdentityInfo| { &mut m.actualActors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "privacyModeTs",
            |m: &BizIdentityInfo| { &m.privacyModeTs },
            |m: &mut BizIdentityInfo| { &mut m.privacyModeTs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "featureControls",
            |m: &BizIdentityInfo| { &m.featureControls },
            |m: &mut BizIdentityInfo| { &mut m.featureControls },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BizIdentityInfo>(
            "BizIdentityInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BizIdentityInfo {
    const NAME: &'static str = "BizIdentityInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.vlevel = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vnameCert)?;
                },
                24 => {
                    self.signed = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.revoked = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.hostStorage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.actualActors = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.privacyModeTs = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.featureControls = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vlevel {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.vnameCert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.signed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.revoked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hostStorage {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.actualActors {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.privacyModeTs {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.featureControls {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vlevel {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.vnameCert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.signed {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.revoked {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.hostStorage {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.actualActors {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.privacyModeTs {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.featureControls {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BizIdentityInfo {
        BizIdentityInfo::new()
    }

    fn clear(&mut self) {
        self.vlevel = ::std::option::Option::None;
        self.vnameCert.clear();
        self.signed = ::std::option::Option::None;
        self.revoked = ::std::option::Option::None;
        self.hostStorage = ::std::option::Option::None;
        self.actualActors = ::std::option::Option::None;
        self.privacyModeTs = ::std::option::Option::None;
        self.featureControls = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BizIdentityInfo {
        static instance: BizIdentityInfo = BizIdentityInfo {
            vlevel: ::std::option::Option::None,
            vnameCert: ::protobuf::MessageField::none(),
            signed: ::std::option::Option::None,
            revoked: ::std::option::Option::None,
            hostStorage: ::std::option::Option::None,
            actualActors: ::std::option::Option::None,
            privacyModeTs: ::std::option::Option::None,
            featureControls: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BizIdentityInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BizIdentityInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BizIdentityInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BizIdentityInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BizIdentityInfo`
pub mod biz_identity_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.BizIdentityInfo.VerifiedLevelValue)
    pub enum VerifiedLevelValue {
        // @@protoc_insertion_point(enum_value:proto.BizIdentityInfo.VerifiedLevelValue.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.BizIdentityInfo.VerifiedLevelValue.LOW)
        LOW = 1,
        // @@protoc_insertion_point(enum_value:proto.BizIdentityInfo.VerifiedLevelValue.HIGH)
        HIGH = 2,
    }

    impl ::protobuf::Enum for VerifiedLevelValue {
        const NAME: &'static str = "VerifiedLevelValue";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<VerifiedLevelValue> {
            match value {
                0 => ::std::option::Option::Some(VerifiedLevelValue::UNKNOWN),
                1 => ::std::option::Option::Some(VerifiedLevelValue::LOW),
                2 => ::std::option::Option::Some(VerifiedLevelValue::HIGH),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [VerifiedLevelValue] = &[
            VerifiedLevelValue::UNKNOWN,
            VerifiedLevelValue::LOW,
            VerifiedLevelValue::HIGH,
        ];
    }

    impl ::protobuf::EnumFull for VerifiedLevelValue {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizIdentityInfo.VerifiedLevelValue").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for VerifiedLevelValue {
        fn default() -> Self {
            VerifiedLevelValue::UNKNOWN
        }
    }

    impl VerifiedLevelValue {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VerifiedLevelValue>("BizIdentityInfo.VerifiedLevelValue")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.BizIdentityInfo.HostStorageType)
    pub enum HostStorageType {
        // @@protoc_insertion_point(enum_value:proto.BizIdentityInfo.HostStorageType.ON_PREMISE)
        ON_PREMISE = 0,
        // @@protoc_insertion_point(enum_value:proto.BizIdentityInfo.HostStorageType.FACEBOOK)
        FACEBOOK = 1,
    }

    impl ::protobuf::Enum for HostStorageType {
        const NAME: &'static str = "HostStorageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HostStorageType> {
            match value {
                0 => ::std::option::Option::Some(HostStorageType::ON_PREMISE),
                1 => ::std::option::Option::Some(HostStorageType::FACEBOOK),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HostStorageType] = &[
            HostStorageType::ON_PREMISE,
            HostStorageType::FACEBOOK,
        ];
    }

    impl ::protobuf::EnumFull for HostStorageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizIdentityInfo.HostStorageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for HostStorageType {
        fn default() -> Self {
            HostStorageType::ON_PREMISE
        }
    }

    impl HostStorageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HostStorageType>("BizIdentityInfo.HostStorageType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.BizIdentityInfo.ActualActorsType)
    pub enum ActualActorsType {
        // @@protoc_insertion_point(enum_value:proto.BizIdentityInfo.ActualActorsType.SELF)
        SELF = 0,
        // @@protoc_insertion_point(enum_value:proto.BizIdentityInfo.ActualActorsType.BSP)
        BSP = 1,
    }

    impl ::protobuf::Enum for ActualActorsType {
        const NAME: &'static str = "ActualActorsType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ActualActorsType> {
            match value {
                0 => ::std::option::Option::Some(ActualActorsType::SELF),
                1 => ::std::option::Option::Some(ActualActorsType::BSP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ActualActorsType] = &[
            ActualActorsType::SELF,
            ActualActorsType::BSP,
        ];
    }

    impl ::protobuf::EnumFull for ActualActorsType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizIdentityInfo.ActualActorsType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ActualActorsType {
        fn default() -> Self {
            ActualActorsType::SELF
        }
    }

    impl ActualActorsType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ActualActorsType>("BizIdentityInfo.ActualActorsType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.BizAccountPayload)
pub struct BizAccountPayload {
    // message fields
    // @@protoc_insertion_point(field:proto.BizAccountPayload.vnameCert)
    pub vnameCert: ::protobuf::MessageField<VerifiedNameCertificate>,
    // @@protoc_insertion_point(field:proto.BizAccountPayload.bizAcctLinkInfo)
    pub bizAcctLinkInfo: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.BizAccountPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BizAccountPayload {
    fn default() -> &'a BizAccountPayload {
        <BizAccountPayload as ::protobuf::Message>::default_instance()
    }
}

impl BizAccountPayload {
    pub fn new() -> BizAccountPayload {
        ::std::default::Default::default()
    }

    // optional bytes bizAcctLinkInfo = 2;

    pub fn bizAcctLinkInfo(&self) -> &[u8] {
        match self.bizAcctLinkInfo.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_bizAcctLinkInfo(&mut self) {
        self.bizAcctLinkInfo = ::std::option::Option::None;
    }

    pub fn has_bizAcctLinkInfo(&self) -> bool {
        self.bizAcctLinkInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bizAcctLinkInfo(&mut self, v: ::std::vec::Vec<u8>) {
        self.bizAcctLinkInfo = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bizAcctLinkInfo(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.bizAcctLinkInfo.is_none() {
            self.bizAcctLinkInfo = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.bizAcctLinkInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_bizAcctLinkInfo(&mut self) -> ::std::vec::Vec<u8> {
        self.bizAcctLinkInfo.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VerifiedNameCertificate>(
            "vnameCert",
            |m: &BizAccountPayload| { &m.vnameCert },
            |m: &mut BizAccountPayload| { &mut m.vnameCert },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bizAcctLinkInfo",
            |m: &BizAccountPayload| { &m.bizAcctLinkInfo },
            |m: &mut BizAccountPayload| { &mut m.bizAcctLinkInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BizAccountPayload>(
            "BizAccountPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BizAccountPayload {
    const NAME: &'static str = "BizAccountPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vnameCert)?;
                },
                18 => {
                    self.bizAcctLinkInfo = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.vnameCert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bizAcctLinkInfo.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.vnameCert.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bizAcctLinkInfo.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BizAccountPayload {
        BizAccountPayload::new()
    }

    fn clear(&mut self) {
        self.vnameCert.clear();
        self.bizAcctLinkInfo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BizAccountPayload {
        static instance: BizAccountPayload = BizAccountPayload {
            vnameCert: ::protobuf::MessageField::none(),
            bizAcctLinkInfo: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BizAccountPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BizAccountPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BizAccountPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BizAccountPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.BizAccountLinkInfo)
pub struct BizAccountLinkInfo {
    // message fields
    // @@protoc_insertion_point(field:proto.BizAccountLinkInfo.whatsappBizAcctFbid)
    pub whatsappBizAcctFbid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.BizAccountLinkInfo.whatsappAcctNumber)
    pub whatsappAcctNumber: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.BizAccountLinkInfo.issueTime)
    pub issueTime: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.BizAccountLinkInfo.hostStorage)
    pub hostStorage: ::std::option::Option<::protobuf::EnumOrUnknown<biz_account_link_info::HostStorageType>>,
    // @@protoc_insertion_point(field:proto.BizAccountLinkInfo.accountType)
    pub accountType: ::std::option::Option<::protobuf::EnumOrUnknown<biz_account_link_info::AccountType>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.BizAccountLinkInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BizAccountLinkInfo {
    fn default() -> &'a BizAccountLinkInfo {
        <BizAccountLinkInfo as ::protobuf::Message>::default_instance()
    }
}

impl BizAccountLinkInfo {
    pub fn new() -> BizAccountLinkInfo {
        ::std::default::Default::default()
    }

    // optional uint64 whatsappBizAcctFbid = 1;

    pub fn whatsappBizAcctFbid(&self) -> u64 {
        self.whatsappBizAcctFbid.unwrap_or(0)
    }

    pub fn clear_whatsappBizAcctFbid(&mut self) {
        self.whatsappBizAcctFbid = ::std::option::Option::None;
    }

    pub fn has_whatsappBizAcctFbid(&self) -> bool {
        self.whatsappBizAcctFbid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whatsappBizAcctFbid(&mut self, v: u64) {
        self.whatsappBizAcctFbid = ::std::option::Option::Some(v);
    }

    // optional string whatsappAcctNumber = 2;

    pub fn whatsappAcctNumber(&self) -> &str {
        match self.whatsappAcctNumber.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_whatsappAcctNumber(&mut self) {
        self.whatsappAcctNumber = ::std::option::Option::None;
    }

    pub fn has_whatsappAcctNumber(&self) -> bool {
        self.whatsappAcctNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whatsappAcctNumber(&mut self, v: ::std::string::String) {
        self.whatsappAcctNumber = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whatsappAcctNumber(&mut self) -> &mut ::std::string::String {
        if self.whatsappAcctNumber.is_none() {
            self.whatsappAcctNumber = ::std::option::Option::Some(::std::string::String::new());
        }
        self.whatsappAcctNumber.as_mut().unwrap()
    }

    // Take field
    pub fn take_whatsappAcctNumber(&mut self) -> ::std::string::String {
        self.whatsappAcctNumber.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 issueTime = 3;

    pub fn issueTime(&self) -> u64 {
        self.issueTime.unwrap_or(0)
    }

    pub fn clear_issueTime(&mut self) {
        self.issueTime = ::std::option::Option::None;
    }

    pub fn has_issueTime(&self) -> bool {
        self.issueTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issueTime(&mut self, v: u64) {
        self.issueTime = ::std::option::Option::Some(v);
    }

    // optional .proto.BizAccountLinkInfo.HostStorageType hostStorage = 4;

    pub fn hostStorage(&self) -> biz_account_link_info::HostStorageType {
        match self.hostStorage {
            Some(e) => e.enum_value_or(biz_account_link_info::HostStorageType::ON_PREMISE),
            None => biz_account_link_info::HostStorageType::ON_PREMISE,
        }
    }

    pub fn clear_hostStorage(&mut self) {
        self.hostStorage = ::std::option::Option::None;
    }

    pub fn has_hostStorage(&self) -> bool {
        self.hostStorage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostStorage(&mut self, v: biz_account_link_info::HostStorageType) {
        self.hostStorage = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.BizAccountLinkInfo.AccountType accountType = 5;

    pub fn accountType(&self) -> biz_account_link_info::AccountType {
        match self.accountType {
            Some(e) => e.enum_value_or(biz_account_link_info::AccountType::ENTERPRISE),
            None => biz_account_link_info::AccountType::ENTERPRISE,
        }
    }

    pub fn clear_accountType(&mut self) {
        self.accountType = ::std::option::Option::None;
    }

    pub fn has_accountType(&self) -> bool {
        self.accountType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountType(&mut self, v: biz_account_link_info::AccountType) {
        self.accountType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whatsappBizAcctFbid",
            |m: &BizAccountLinkInfo| { &m.whatsappBizAcctFbid },
            |m: &mut BizAccountLinkInfo| { &mut m.whatsappBizAcctFbid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "whatsappAcctNumber",
            |m: &BizAccountLinkInfo| { &m.whatsappAcctNumber },
            |m: &mut BizAccountLinkInfo| { &mut m.whatsappAcctNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "issueTime",
            |m: &BizAccountLinkInfo| { &m.issueTime },
            |m: &mut BizAccountLinkInfo| { &mut m.issueTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostStorage",
            |m: &BizAccountLinkInfo| { &m.hostStorage },
            |m: &mut BizAccountLinkInfo| { &mut m.hostStorage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountType",
            |m: &BizAccountLinkInfo| { &m.accountType },
            |m: &mut BizAccountLinkInfo| { &mut m.accountType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BizAccountLinkInfo>(
            "BizAccountLinkInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BizAccountLinkInfo {
    const NAME: &'static str = "BizAccountLinkInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.whatsappBizAcctFbid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.whatsappAcctNumber = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.issueTime = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.hostStorage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.accountType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.whatsappBizAcctFbid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.whatsappAcctNumber.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.issueTime {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.hostStorage {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.accountType {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.whatsappBizAcctFbid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.whatsappAcctNumber.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.issueTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.hostStorage {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.accountType {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BizAccountLinkInfo {
        BizAccountLinkInfo::new()
    }

    fn clear(&mut self) {
        self.whatsappBizAcctFbid = ::std::option::Option::None;
        self.whatsappAcctNumber = ::std::option::Option::None;
        self.issueTime = ::std::option::Option::None;
        self.hostStorage = ::std::option::Option::None;
        self.accountType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BizAccountLinkInfo {
        static instance: BizAccountLinkInfo = BizAccountLinkInfo {
            whatsappBizAcctFbid: ::std::option::Option::None,
            whatsappAcctNumber: ::std::option::Option::None,
            issueTime: ::std::option::Option::None,
            hostStorage: ::std::option::Option::None,
            accountType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BizAccountLinkInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BizAccountLinkInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BizAccountLinkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BizAccountLinkInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BizAccountLinkInfo`
pub mod biz_account_link_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.BizAccountLinkInfo.HostStorageType)
    pub enum HostStorageType {
        // @@protoc_insertion_point(enum_value:proto.BizAccountLinkInfo.HostStorageType.ON_PREMISE)
        ON_PREMISE = 0,
        // @@protoc_insertion_point(enum_value:proto.BizAccountLinkInfo.HostStorageType.FACEBOOK)
        FACEBOOK = 1,
    }

    impl ::protobuf::Enum for HostStorageType {
        const NAME: &'static str = "HostStorageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<HostStorageType> {
            match value {
                0 => ::std::option::Option::Some(HostStorageType::ON_PREMISE),
                1 => ::std::option::Option::Some(HostStorageType::FACEBOOK),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [HostStorageType] = &[
            HostStorageType::ON_PREMISE,
            HostStorageType::FACEBOOK,
        ];
    }

    impl ::protobuf::EnumFull for HostStorageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizAccountLinkInfo.HostStorageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for HostStorageType {
        fn default() -> Self {
            HostStorageType::ON_PREMISE
        }
    }

    impl HostStorageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HostStorageType>("BizAccountLinkInfo.HostStorageType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.BizAccountLinkInfo.AccountType)
    pub enum AccountType {
        // @@protoc_insertion_point(enum_value:proto.BizAccountLinkInfo.AccountType.ENTERPRISE)
        ENTERPRISE = 0,
    }

    impl ::protobuf::Enum for AccountType {
        const NAME: &'static str = "AccountType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AccountType> {
            match value {
                0 => ::std::option::Option::Some(AccountType::ENTERPRISE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AccountType] = &[
            AccountType::ENTERPRISE,
        ];
    }

    impl ::protobuf::EnumFull for AccountType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BizAccountLinkInfo.AccountType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for AccountType {
        fn default() -> Self {
            AccountType::ENTERPRISE
        }
    }

    impl AccountType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AccountType>("BizAccountLinkInfo.AccountType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HandshakeMessage)
pub struct HandshakeMessage {
    // message fields
    // @@protoc_insertion_point(field:proto.HandshakeMessage.clientHello)
    pub clientHello: ::protobuf::MessageField<HandshakeClientHello>,
    // @@protoc_insertion_point(field:proto.HandshakeMessage.serverHello)
    pub serverHello: ::protobuf::MessageField<HandshakeServerHello>,
    // @@protoc_insertion_point(field:proto.HandshakeMessage.clientFinish)
    pub clientFinish: ::protobuf::MessageField<HandshakeClientFinish>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HandshakeMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeMessage {
    fn default() -> &'a HandshakeMessage {
        <HandshakeMessage as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeMessage {
    pub fn new() -> HandshakeMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HandshakeClientHello>(
            "clientHello",
            |m: &HandshakeMessage| { &m.clientHello },
            |m: &mut HandshakeMessage| { &mut m.clientHello },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HandshakeServerHello>(
            "serverHello",
            |m: &HandshakeMessage| { &m.serverHello },
            |m: &mut HandshakeMessage| { &mut m.serverHello },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, HandshakeClientFinish>(
            "clientFinish",
            |m: &HandshakeMessage| { &m.clientFinish },
            |m: &mut HandshakeMessage| { &mut m.clientFinish },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeMessage>(
            "HandshakeMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeMessage {
    const NAME: &'static str = "HandshakeMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientHello)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.serverHello)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clientFinish)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clientHello.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.serverHello.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clientFinish.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clientHello.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.serverHello.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.clientFinish.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeMessage {
        HandshakeMessage::new()
    }

    fn clear(&mut self) {
        self.clientHello.clear();
        self.serverHello.clear();
        self.clientFinish.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeMessage {
        static instance: HandshakeMessage = HandshakeMessage {
            clientHello: ::protobuf::MessageField::none(),
            serverHello: ::protobuf::MessageField::none(),
            clientFinish: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HandshakeMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HandshakeServerHello)
pub struct HandshakeServerHello {
    // message fields
    // @@protoc_insertion_point(field:proto.HandshakeServerHello.ephemeral)
    pub ephemeral: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HandshakeServerHello.static)
    pub static_: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HandshakeServerHello.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HandshakeServerHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeServerHello {
    fn default() -> &'a HandshakeServerHello {
        <HandshakeServerHello as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeServerHello {
    pub fn new() -> HandshakeServerHello {
        ::std::default::Default::default()
    }

    // optional bytes ephemeral = 1;

    pub fn ephemeral(&self) -> &[u8] {
        match self.ephemeral.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ephemeral(&mut self) {
        self.ephemeral = ::std::option::Option::None;
    }

    pub fn has_ephemeral(&self) -> bool {
        self.ephemeral.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeral(&mut self, v: ::std::vec::Vec<u8>) {
        self.ephemeral = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeral(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ephemeral.is_none() {
            self.ephemeral = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ephemeral.as_mut().unwrap()
    }

    // Take field
    pub fn take_ephemeral(&mut self) -> ::std::vec::Vec<u8> {
        self.ephemeral.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes static = 2;

    pub fn static_(&self) -> &[u8] {
        match self.static_.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_static_(&mut self) {
        self.static_ = ::std::option::Option::None;
    }

    pub fn has_static(&self) -> bool {
        self.static_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static(&mut self, v: ::std::vec::Vec<u8>) {
        self.static_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.static_.is_none() {
            self.static_ = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.static_.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_(&mut self) -> ::std::vec::Vec<u8> {
        self.static_.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeral",
            |m: &HandshakeServerHello| { &m.ephemeral },
            |m: &mut HandshakeServerHello| { &mut m.ephemeral },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "static",
            |m: &HandshakeServerHello| { &m.static_ },
            |m: &mut HandshakeServerHello| { &mut m.static_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &HandshakeServerHello| { &m.payload },
            |m: &mut HandshakeServerHello| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeServerHello>(
            "HandshakeServerHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeServerHello {
    const NAME: &'static str = "HandshakeServerHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ephemeral = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.static_ = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ephemeral.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.static_.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ephemeral.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.static_.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeServerHello {
        HandshakeServerHello::new()
    }

    fn clear(&mut self) {
        self.ephemeral = ::std::option::Option::None;
        self.static_ = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeServerHello {
        static instance: HandshakeServerHello = HandshakeServerHello {
            ephemeral: ::std::option::Option::None,
            static_: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HandshakeServerHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeServerHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeServerHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeServerHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HandshakeClientHello)
pub struct HandshakeClientHello {
    // message fields
    // @@protoc_insertion_point(field:proto.HandshakeClientHello.ephemeral)
    pub ephemeral: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HandshakeClientHello.static)
    pub static_: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HandshakeClientHello.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HandshakeClientHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeClientHello {
    fn default() -> &'a HandshakeClientHello {
        <HandshakeClientHello as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeClientHello {
    pub fn new() -> HandshakeClientHello {
        ::std::default::Default::default()
    }

    // optional bytes ephemeral = 1;

    pub fn ephemeral(&self) -> &[u8] {
        match self.ephemeral.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ephemeral(&mut self) {
        self.ephemeral = ::std::option::Option::None;
    }

    pub fn has_ephemeral(&self) -> bool {
        self.ephemeral.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeral(&mut self, v: ::std::vec::Vec<u8>) {
        self.ephemeral = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeral(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ephemeral.is_none() {
            self.ephemeral = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ephemeral.as_mut().unwrap()
    }

    // Take field
    pub fn take_ephemeral(&mut self) -> ::std::vec::Vec<u8> {
        self.ephemeral.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes static = 2;

    pub fn static_(&self) -> &[u8] {
        match self.static_.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_static_(&mut self) {
        self.static_ = ::std::option::Option::None;
    }

    pub fn has_static(&self) -> bool {
        self.static_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static(&mut self, v: ::std::vec::Vec<u8>) {
        self.static_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.static_.is_none() {
            self.static_ = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.static_.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_(&mut self) -> ::std::vec::Vec<u8> {
        self.static_.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeral",
            |m: &HandshakeClientHello| { &m.ephemeral },
            |m: &mut HandshakeClientHello| { &mut m.ephemeral },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "static",
            |m: &HandshakeClientHello| { &m.static_ },
            |m: &mut HandshakeClientHello| { &mut m.static_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &HandshakeClientHello| { &m.payload },
            |m: &mut HandshakeClientHello| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeClientHello>(
            "HandshakeClientHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeClientHello {
    const NAME: &'static str = "HandshakeClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ephemeral = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.static_ = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ephemeral.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.static_.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ephemeral.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.static_.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeClientHello {
        HandshakeClientHello::new()
    }

    fn clear(&mut self) {
        self.ephemeral = ::std::option::Option::None;
        self.static_ = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeClientHello {
        static instance: HandshakeClientHello = HandshakeClientHello {
            ephemeral: ::std::option::Option::None,
            static_: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HandshakeClientHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeClientHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeClientHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.HandshakeClientFinish)
pub struct HandshakeClientFinish {
    // message fields
    // @@protoc_insertion_point(field:proto.HandshakeClientFinish.static)
    pub static_: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.HandshakeClientFinish.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.HandshakeClientFinish.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeClientFinish {
    fn default() -> &'a HandshakeClientFinish {
        <HandshakeClientFinish as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeClientFinish {
    pub fn new() -> HandshakeClientFinish {
        ::std::default::Default::default()
    }

    // optional bytes static = 1;

    pub fn static_(&self) -> &[u8] {
        match self.static_.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_static_(&mut self) {
        self.static_ = ::std::option::Option::None;
    }

    pub fn has_static(&self) -> bool {
        self.static_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static(&mut self, v: ::std::vec::Vec<u8>) {
        self.static_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.static_.is_none() {
            self.static_ = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.static_.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_(&mut self) -> ::std::vec::Vec<u8> {
        self.static_.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "static",
            |m: &HandshakeClientFinish| { &m.static_ },
            |m: &mut HandshakeClientFinish| { &mut m.static_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &HandshakeClientFinish| { &m.payload },
            |m: &mut HandshakeClientFinish| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeClientFinish>(
            "HandshakeClientFinish",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeClientFinish {
    const NAME: &'static str = "HandshakeClientFinish";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.static_ = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.static_.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.static_.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeClientFinish {
        HandshakeClientFinish::new()
    }

    fn clear(&mut self) {
        self.static_ = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeClientFinish {
        static instance: HandshakeClientFinish = HandshakeClientFinish {
            static_: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HandshakeClientFinish {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeClientFinish").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeClientFinish {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeClientFinish {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.ClientPayload)
pub struct ClientPayload {
    // message fields
    // @@protoc_insertion_point(field:proto.ClientPayload.username)
    pub username: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.ClientPayload.passive)
    pub passive: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ClientPayload.userAgent)
    pub userAgent: ::protobuf::MessageField<client_payload::UserAgent>,
    // @@protoc_insertion_point(field:proto.ClientPayload.webInfo)
    pub webInfo: ::protobuf::MessageField<client_payload::WebInfo>,
    // @@protoc_insertion_point(field:proto.ClientPayload.pushName)
    pub pushName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.ClientPayload.sessionId)
    pub sessionId: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.ClientPayload.shortConnect)
    pub shortConnect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ClientPayload.connectType)
    pub connectType: ::std::option::Option<::protobuf::EnumOrUnknown<client_payload::ConnectType>>,
    // @@protoc_insertion_point(field:proto.ClientPayload.connectReason)
    pub connectReason: ::std::option::Option<::protobuf::EnumOrUnknown<client_payload::ConnectReason>>,
    // @@protoc_insertion_point(field:proto.ClientPayload.shards)
    pub shards: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:proto.ClientPayload.dnsSource)
    pub dnsSource: ::protobuf::MessageField<client_payload::DNSSource>,
    // @@protoc_insertion_point(field:proto.ClientPayload.connectAttemptCount)
    pub connectAttemptCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ClientPayload.device)
    pub device: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.ClientPayload.devicePairingData)
    pub devicePairingData: ::protobuf::MessageField<client_payload::DevicePairingRegistrationData>,
    // @@protoc_insertion_point(field:proto.ClientPayload.product)
    pub product: ::std::option::Option<::protobuf::EnumOrUnknown<client_payload::Product>>,
    // @@protoc_insertion_point(field:proto.ClientPayload.fbCat)
    pub fbCat: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ClientPayload.fbUserAgent)
    pub fbUserAgent: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ClientPayload.oc)
    pub oc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ClientPayload.lc)
    pub lc: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.ClientPayload.iosAppExtension)
    pub iosAppExtension: ::std::option::Option<::protobuf::EnumOrUnknown<client_payload::IOSAppExtension>>,
    // @@protoc_insertion_point(field:proto.ClientPayload.fbAppId)
    pub fbAppId: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.ClientPayload.fbDeviceId)
    pub fbDeviceId: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ClientPayload.pull)
    pub pull: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.ClientPayload.paddingBytes)
    pub paddingBytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.ClientPayload.yearClass)
    pub yearClass: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:proto.ClientPayload.memClass)
    pub memClass: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.ClientPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientPayload {
    fn default() -> &'a ClientPayload {
        <ClientPayload as ::protobuf::Message>::default_instance()
    }
}

impl ClientPayload {
    pub fn new() -> ClientPayload {
        ::std::default::Default::default()
    }

    // optional uint64 username = 1;

    pub fn username(&self) -> u64 {
        self.username.unwrap_or(0)
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: u64) {
        self.username = ::std::option::Option::Some(v);
    }

    // optional bool passive = 3;

    pub fn passive(&self) -> bool {
        self.passive.unwrap_or(false)
    }

    pub fn clear_passive(&mut self) {
        self.passive = ::std::option::Option::None;
    }

    pub fn has_passive(&self) -> bool {
        self.passive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passive(&mut self, v: bool) {
        self.passive = ::std::option::Option::Some(v);
    }

    // optional string pushName = 7;

    pub fn pushName(&self) -> &str {
        match self.pushName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pushName(&mut self) {
        self.pushName = ::std::option::Option::None;
    }

    pub fn has_pushName(&self) -> bool {
        self.pushName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pushName(&mut self, v: ::std::string::String) {
        self.pushName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pushName(&mut self) -> &mut ::std::string::String {
        if self.pushName.is_none() {
            self.pushName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pushName.as_mut().unwrap()
    }

    // Take field
    pub fn take_pushName(&mut self) -> ::std::string::String {
        self.pushName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sfixed32 sessionId = 9;

    pub fn sessionId(&self) -> i32 {
        self.sessionId.unwrap_or(0)
    }

    pub fn clear_sessionId(&mut self) {
        self.sessionId = ::std::option::Option::None;
    }

    pub fn has_sessionId(&self) -> bool {
        self.sessionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionId(&mut self, v: i32) {
        self.sessionId = ::std::option::Option::Some(v);
    }

    // optional bool shortConnect = 10;

    pub fn shortConnect(&self) -> bool {
        self.shortConnect.unwrap_or(false)
    }

    pub fn clear_shortConnect(&mut self) {
        self.shortConnect = ::std::option::Option::None;
    }

    pub fn has_shortConnect(&self) -> bool {
        self.shortConnect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortConnect(&mut self, v: bool) {
        self.shortConnect = ::std::option::Option::Some(v);
    }

    // optional .proto.ClientPayload.ConnectType connectType = 12;

    pub fn connectType(&self) -> client_payload::ConnectType {
        match self.connectType {
            Some(e) => e.enum_value_or(client_payload::ConnectType::CELLULAR_UNKNOWN),
            None => client_payload::ConnectType::CELLULAR_UNKNOWN,
        }
    }

    pub fn clear_connectType(&mut self) {
        self.connectType = ::std::option::Option::None;
    }

    pub fn has_connectType(&self) -> bool {
        self.connectType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectType(&mut self, v: client_payload::ConnectType) {
        self.connectType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.ClientPayload.ConnectReason connectReason = 13;

    pub fn connectReason(&self) -> client_payload::ConnectReason {
        match self.connectReason {
            Some(e) => e.enum_value_or(client_payload::ConnectReason::PUSH),
            None => client_payload::ConnectReason::PUSH,
        }
    }

    pub fn clear_connectReason(&mut self) {
        self.connectReason = ::std::option::Option::None;
    }

    pub fn has_connectReason(&self) -> bool {
        self.connectReason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectReason(&mut self, v: client_payload::ConnectReason) {
        self.connectReason = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 connectAttemptCount = 16;

    pub fn connectAttemptCount(&self) -> u32 {
        self.connectAttemptCount.unwrap_or(0)
    }

    pub fn clear_connectAttemptCount(&mut self) {
        self.connectAttemptCount = ::std::option::Option::None;
    }

    pub fn has_connectAttemptCount(&self) -> bool {
        self.connectAttemptCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connectAttemptCount(&mut self, v: u32) {
        self.connectAttemptCount = ::std::option::Option::Some(v);
    }

    // optional uint32 device = 18;

    pub fn device(&self) -> u32 {
        self.device.unwrap_or(0)
    }

    pub fn clear_device(&mut self) {
        self.device = ::std::option::Option::None;
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: u32) {
        self.device = ::std::option::Option::Some(v);
    }

    // optional .proto.ClientPayload.Product product = 20;

    pub fn product(&self) -> client_payload::Product {
        match self.product {
            Some(e) => e.enum_value_or(client_payload::Product::WHATSAPP),
            None => client_payload::Product::WHATSAPP,
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: client_payload::Product) {
        self.product = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes fbCat = 21;

    pub fn fbCat(&self) -> &[u8] {
        match self.fbCat.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fbCat(&mut self) {
        self.fbCat = ::std::option::Option::None;
    }

    pub fn has_fbCat(&self) -> bool {
        self.fbCat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbCat(&mut self, v: ::std::vec::Vec<u8>) {
        self.fbCat = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fbCat(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fbCat.is_none() {
            self.fbCat = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fbCat.as_mut().unwrap()
    }

    // Take field
    pub fn take_fbCat(&mut self) -> ::std::vec::Vec<u8> {
        self.fbCat.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes fbUserAgent = 22;

    pub fn fbUserAgent(&self) -> &[u8] {
        match self.fbUserAgent.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fbUserAgent(&mut self) {
        self.fbUserAgent = ::std::option::Option::None;
    }

    pub fn has_fbUserAgent(&self) -> bool {
        self.fbUserAgent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbUserAgent(&mut self, v: ::std::vec::Vec<u8>) {
        self.fbUserAgent = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fbUserAgent(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fbUserAgent.is_none() {
            self.fbUserAgent = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fbUserAgent.as_mut().unwrap()
    }

    // Take field
    pub fn take_fbUserAgent(&mut self) -> ::std::vec::Vec<u8> {
        self.fbUserAgent.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool oc = 23;

    pub fn oc(&self) -> bool {
        self.oc.unwrap_or(false)
    }

    pub fn clear_oc(&mut self) {
        self.oc = ::std::option::Option::None;
    }

    pub fn has_oc(&self) -> bool {
        self.oc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oc(&mut self, v: bool) {
        self.oc = ::std::option::Option::Some(v);
    }

    // optional int32 lc = 24;

    pub fn lc(&self) -> i32 {
        self.lc.unwrap_or(0)
    }

    pub fn clear_lc(&mut self) {
        self.lc = ::std::option::Option::None;
    }

    pub fn has_lc(&self) -> bool {
        self.lc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lc(&mut self, v: i32) {
        self.lc = ::std::option::Option::Some(v);
    }

    // optional .proto.ClientPayload.IOSAppExtension iosAppExtension = 30;

    pub fn iosAppExtension(&self) -> client_payload::IOSAppExtension {
        match self.iosAppExtension {
            Some(e) => e.enum_value_or(client_payload::IOSAppExtension::SHARE_EXTENSION),
            None => client_payload::IOSAppExtension::SHARE_EXTENSION,
        }
    }

    pub fn clear_iosAppExtension(&mut self) {
        self.iosAppExtension = ::std::option::Option::None;
    }

    pub fn has_iosAppExtension(&self) -> bool {
        self.iosAppExtension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iosAppExtension(&mut self, v: client_payload::IOSAppExtension) {
        self.iosAppExtension = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 fbAppId = 31;

    pub fn fbAppId(&self) -> u64 {
        self.fbAppId.unwrap_or(0)
    }

    pub fn clear_fbAppId(&mut self) {
        self.fbAppId = ::std::option::Option::None;
    }

    pub fn has_fbAppId(&self) -> bool {
        self.fbAppId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbAppId(&mut self, v: u64) {
        self.fbAppId = ::std::option::Option::Some(v);
    }

    // optional bytes fbDeviceId = 32;

    pub fn fbDeviceId(&self) -> &[u8] {
        match self.fbDeviceId.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_fbDeviceId(&mut self) {
        self.fbDeviceId = ::std::option::Option::None;
    }

    pub fn has_fbDeviceId(&self) -> bool {
        self.fbDeviceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fbDeviceId(&mut self, v: ::std::vec::Vec<u8>) {
        self.fbDeviceId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fbDeviceId(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fbDeviceId.is_none() {
            self.fbDeviceId = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.fbDeviceId.as_mut().unwrap()
    }

    // Take field
    pub fn take_fbDeviceId(&mut self) -> ::std::vec::Vec<u8> {
        self.fbDeviceId.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool pull = 33;

    pub fn pull(&self) -> bool {
        self.pull.unwrap_or(false)
    }

    pub fn clear_pull(&mut self) {
        self.pull = ::std::option::Option::None;
    }

    pub fn has_pull(&self) -> bool {
        self.pull.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pull(&mut self, v: bool) {
        self.pull = ::std::option::Option::Some(v);
    }

    // optional bytes paddingBytes = 34;

    pub fn paddingBytes(&self) -> &[u8] {
        match self.paddingBytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_paddingBytes(&mut self) {
        self.paddingBytes = ::std::option::Option::None;
    }

    pub fn has_paddingBytes(&self) -> bool {
        self.paddingBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paddingBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.paddingBytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paddingBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.paddingBytes.is_none() {
            self.paddingBytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.paddingBytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_paddingBytes(&mut self) -> ::std::vec::Vec<u8> {
        self.paddingBytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 yearClass = 36;

    pub fn yearClass(&self) -> i32 {
        self.yearClass.unwrap_or(0)
    }

    pub fn clear_yearClass(&mut self) {
        self.yearClass = ::std::option::Option::None;
    }

    pub fn has_yearClass(&self) -> bool {
        self.yearClass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_yearClass(&mut self, v: i32) {
        self.yearClass = ::std::option::Option::Some(v);
    }

    // optional int32 memClass = 37;

    pub fn memClass(&self) -> i32 {
        self.memClass.unwrap_or(0)
    }

    pub fn clear_memClass(&mut self) {
        self.memClass = ::std::option::Option::None;
    }

    pub fn has_memClass(&self) -> bool {
        self.memClass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memClass(&mut self, v: i32) {
        self.memClass = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "username",
            |m: &ClientPayload| { &m.username },
            |m: &mut ClientPayload| { &mut m.username },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passive",
            |m: &ClientPayload| { &m.passive },
            |m: &mut ClientPayload| { &mut m.passive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, client_payload::UserAgent>(
            "userAgent",
            |m: &ClientPayload| { &m.userAgent },
            |m: &mut ClientPayload| { &mut m.userAgent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, client_payload::WebInfo>(
            "webInfo",
            |m: &ClientPayload| { &m.webInfo },
            |m: &mut ClientPayload| { &mut m.webInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pushName",
            |m: &ClientPayload| { &m.pushName },
            |m: &mut ClientPayload| { &mut m.pushName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sessionId",
            |m: &ClientPayload| { &m.sessionId },
            |m: &mut ClientPayload| { &mut m.sessionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shortConnect",
            |m: &ClientPayload| { &m.shortConnect },
            |m: &mut ClientPayload| { &mut m.shortConnect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connectType",
            |m: &ClientPayload| { &m.connectType },
            |m: &mut ClientPayload| { &mut m.connectType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connectReason",
            |m: &ClientPayload| { &m.connectReason },
            |m: &mut ClientPayload| { &mut m.connectReason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "shards",
            |m: &ClientPayload| { &m.shards },
            |m: &mut ClientPayload| { &mut m.shards },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, client_payload::DNSSource>(
            "dnsSource",
            |m: &ClientPayload| { &m.dnsSource },
            |m: &mut ClientPayload| { &mut m.dnsSource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connectAttemptCount",
            |m: &ClientPayload| { &m.connectAttemptCount },
            |m: &mut ClientPayload| { &mut m.connectAttemptCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "device",
            |m: &ClientPayload| { &m.device },
            |m: &mut ClientPayload| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, client_payload::DevicePairingRegistrationData>(
            "devicePairingData",
            |m: &ClientPayload| { &m.devicePairingData },
            |m: &mut ClientPayload| { &mut m.devicePairingData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &ClientPayload| { &m.product },
            |m: &mut ClientPayload| { &mut m.product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbCat",
            |m: &ClientPayload| { &m.fbCat },
            |m: &mut ClientPayload| { &mut m.fbCat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbUserAgent",
            |m: &ClientPayload| { &m.fbUserAgent },
            |m: &mut ClientPayload| { &mut m.fbUserAgent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oc",
            |m: &ClientPayload| { &m.oc },
            |m: &mut ClientPayload| { &mut m.oc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lc",
            |m: &ClientPayload| { &m.lc },
            |m: &mut ClientPayload| { &mut m.lc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "iosAppExtension",
            |m: &ClientPayload| { &m.iosAppExtension },
            |m: &mut ClientPayload| { &mut m.iosAppExtension },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbAppId",
            |m: &ClientPayload| { &m.fbAppId },
            |m: &mut ClientPayload| { &mut m.fbAppId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fbDeviceId",
            |m: &ClientPayload| { &m.fbDeviceId },
            |m: &mut ClientPayload| { &mut m.fbDeviceId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pull",
            |m: &ClientPayload| { &m.pull },
            |m: &mut ClientPayload| { &mut m.pull },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paddingBytes",
            |m: &ClientPayload| { &m.paddingBytes },
            |m: &mut ClientPayload| { &mut m.paddingBytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "yearClass",
            |m: &ClientPayload| { &m.yearClass },
            |m: &mut ClientPayload| { &mut m.yearClass },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "memClass",
            |m: &ClientPayload| { &m.memClass },
            |m: &mut ClientPayload| { &mut m.memClass },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientPayload>(
            "ClientPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientPayload {
    const NAME: &'static str = "ClientPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.username = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.passive = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userAgent)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.webInfo)?;
                },
                58 => {
                    self.pushName = ::std::option::Option::Some(is.read_string()?);
                },
                77 => {
                    self.sessionId = ::std::option::Option::Some(is.read_sfixed32()?);
                },
                80 => {
                    self.shortConnect = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.connectType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.connectReason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                114 => {
                    is.read_repeated_packed_int32_into(&mut self.shards)?;
                },
                112 => {
                    self.shards.push(is.read_int32()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dnsSource)?;
                },
                128 => {
                    self.connectAttemptCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.device = ::std::option::Option::Some(is.read_uint32()?);
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.devicePairingData)?;
                },
                160 => {
                    self.product = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                170 => {
                    self.fbCat = ::std::option::Option::Some(is.read_bytes()?);
                },
                178 => {
                    self.fbUserAgent = ::std::option::Option::Some(is.read_bytes()?);
                },
                184 => {
                    self.oc = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.lc = ::std::option::Option::Some(is.read_int32()?);
                },
                240 => {
                    self.iosAppExtension = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                248 => {
                    self.fbAppId = ::std::option::Option::Some(is.read_uint64()?);
                },
                258 => {
                    self.fbDeviceId = ::std::option::Option::Some(is.read_bytes()?);
                },
                264 => {
                    self.pull = ::std::option::Option::Some(is.read_bool()?);
                },
                274 => {
                    self.paddingBytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                288 => {
                    self.yearClass = ::std::option::Option::Some(is.read_int32()?);
                },
                296 => {
                    self.memClass = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.username {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.passive {
            my_size += 1 + 1;
        }
        if let Some(v) = self.userAgent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.webInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.pushName.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.sessionId {
            my_size += 1 + 4;
        }
        if let Some(v) = self.shortConnect {
            my_size += 1 + 1;
        }
        if let Some(v) = self.connectType {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.connectReason {
            my_size += ::protobuf::rt::int32_size(13, v.value());
        }
        for value in &self.shards {
            my_size += ::protobuf::rt::int32_size(14, *value);
        };
        if let Some(v) = self.dnsSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.connectAttemptCount {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.device {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.devicePairingData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.product {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.fbCat.as_ref() {
            my_size += ::protobuf::rt::bytes_size(21, &v);
        }
        if let Some(v) = self.fbUserAgent.as_ref() {
            my_size += ::protobuf::rt::bytes_size(22, &v);
        }
        if let Some(v) = self.oc {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lc {
            my_size += ::protobuf::rt::int32_size(24, v);
        }
        if let Some(v) = self.iosAppExtension {
            my_size += ::protobuf::rt::int32_size(30, v.value());
        }
        if let Some(v) = self.fbAppId {
            my_size += ::protobuf::rt::uint64_size(31, v);
        }
        if let Some(v) = self.fbDeviceId.as_ref() {
            my_size += ::protobuf::rt::bytes_size(32, &v);
        }
        if let Some(v) = self.pull {
            my_size += 2 + 1;
        }
        if let Some(v) = self.paddingBytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(34, &v);
        }
        if let Some(v) = self.yearClass {
            my_size += ::protobuf::rt::int32_size(36, v);
        }
        if let Some(v) = self.memClass {
            my_size += ::protobuf::rt::int32_size(37, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.username {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.passive {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.userAgent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.webInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.pushName.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.sessionId {
            os.write_sfixed32(9, v)?;
        }
        if let Some(v) = self.shortConnect {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.connectType {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connectReason {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.shards {
            os.write_int32(14, *v)?;
        };
        if let Some(v) = self.dnsSource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.connectAttemptCount {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.device {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.devicePairingData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.product {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.fbCat.as_ref() {
            os.write_bytes(21, v)?;
        }
        if let Some(v) = self.fbUserAgent.as_ref() {
            os.write_bytes(22, v)?;
        }
        if let Some(v) = self.oc {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.lc {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.iosAppExtension {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.fbAppId {
            os.write_uint64(31, v)?;
        }
        if let Some(v) = self.fbDeviceId.as_ref() {
            os.write_bytes(32, v)?;
        }
        if let Some(v) = self.pull {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.paddingBytes.as_ref() {
            os.write_bytes(34, v)?;
        }
        if let Some(v) = self.yearClass {
            os.write_int32(36, v)?;
        }
        if let Some(v) = self.memClass {
            os.write_int32(37, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientPayload {
        ClientPayload::new()
    }

    fn clear(&mut self) {
        self.username = ::std::option::Option::None;
        self.passive = ::std::option::Option::None;
        self.userAgent.clear();
        self.webInfo.clear();
        self.pushName = ::std::option::Option::None;
        self.sessionId = ::std::option::Option::None;
        self.shortConnect = ::std::option::Option::None;
        self.connectType = ::std::option::Option::None;
        self.connectReason = ::std::option::Option::None;
        self.shards.clear();
        self.dnsSource.clear();
        self.connectAttemptCount = ::std::option::Option::None;
        self.device = ::std::option::Option::None;
        self.devicePairingData.clear();
        self.product = ::std::option::Option::None;
        self.fbCat = ::std::option::Option::None;
        self.fbUserAgent = ::std::option::Option::None;
        self.oc = ::std::option::Option::None;
        self.lc = ::std::option::Option::None;
        self.iosAppExtension = ::std::option::Option::None;
        self.fbAppId = ::std::option::Option::None;
        self.fbDeviceId = ::std::option::Option::None;
        self.pull = ::std::option::Option::None;
        self.paddingBytes = ::std::option::Option::None;
        self.yearClass = ::std::option::Option::None;
        self.memClass = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientPayload {
        static instance: ClientPayload = ClientPayload {
            username: ::std::option::Option::None,
            passive: ::std::option::Option::None,
            userAgent: ::protobuf::MessageField::none(),
            webInfo: ::protobuf::MessageField::none(),
            pushName: ::std::option::Option::None,
            sessionId: ::std::option::Option::None,
            shortConnect: ::std::option::Option::None,
            connectType: ::std::option::Option::None,
            connectReason: ::std::option::Option::None,
            shards: ::std::vec::Vec::new(),
            dnsSource: ::protobuf::MessageField::none(),
            connectAttemptCount: ::std::option::Option::None,
            device: ::std::option::Option::None,
            devicePairingData: ::protobuf::MessageField::none(),
            product: ::std::option::Option::None,
            fbCat: ::std::option::Option::None,
            fbUserAgent: ::std::option::Option::None,
            oc: ::std::option::Option::None,
            lc: ::std::option::Option::None,
            iosAppExtension: ::std::option::Option::None,
            fbAppId: ::std::option::Option::None,
            fbDeviceId: ::std::option::Option::None,
            pull: ::std::option::Option::None,
            paddingBytes: ::std::option::Option::None,
            yearClass: ::std::option::Option::None,
            memClass: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ClientPayload`
pub mod client_payload {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ClientPayload.WebInfo)
    pub struct WebInfo {
        // message fields
        // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.refToken)
        pub refToken: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.version)
        pub version: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.webdPayload)
        pub webdPayload: ::protobuf::MessageField<web_info::WebdPayload>,
        // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.webSubPlatform)
        pub webSubPlatform: ::std::option::Option<::protobuf::EnumOrUnknown<web_info::WebSubPlatform>>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ClientPayload.WebInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WebInfo {
        fn default() -> &'a WebInfo {
            <WebInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl WebInfo {
        pub fn new() -> WebInfo {
            ::std::default::Default::default()
        }

        // optional string refToken = 1;

        pub fn refToken(&self) -> &str {
            match self.refToken.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_refToken(&mut self) {
            self.refToken = ::std::option::Option::None;
        }

        pub fn has_refToken(&self) -> bool {
            self.refToken.is_some()
        }

        // Param is passed by value, moved
        pub fn set_refToken(&mut self, v: ::std::string::String) {
            self.refToken = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_refToken(&mut self) -> &mut ::std::string::String {
            if self.refToken.is_none() {
                self.refToken = ::std::option::Option::Some(::std::string::String::new());
            }
            self.refToken.as_mut().unwrap()
        }

        // Take field
        pub fn take_refToken(&mut self) -> ::std::string::String {
            self.refToken.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string version = 2;

        pub fn version(&self) -> &str {
            match self.version.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: ::std::string::String) {
            self.version = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_version(&mut self) -> &mut ::std::string::String {
            if self.version.is_none() {
                self.version = ::std::option::Option::Some(::std::string::String::new());
            }
            self.version.as_mut().unwrap()
        }

        // Take field
        pub fn take_version(&mut self) -> ::std::string::String {
            self.version.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .proto.ClientPayload.WebInfo.WebSubPlatform webSubPlatform = 4;

        pub fn webSubPlatform(&self) -> web_info::WebSubPlatform {
            match self.webSubPlatform {
                Some(e) => e.enum_value_or(web_info::WebSubPlatform::WEB_BROWSER),
                None => web_info::WebSubPlatform::WEB_BROWSER,
            }
        }

        pub fn clear_webSubPlatform(&mut self) {
            self.webSubPlatform = ::std::option::Option::None;
        }

        pub fn has_webSubPlatform(&self) -> bool {
            self.webSubPlatform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_webSubPlatform(&mut self, v: web_info::WebSubPlatform) {
            self.webSubPlatform = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "refToken",
                |m: &WebInfo| { &m.refToken },
                |m: &mut WebInfo| { &mut m.refToken },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &WebInfo| { &m.version },
                |m: &mut WebInfo| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, web_info::WebdPayload>(
                "webdPayload",
                |m: &WebInfo| { &m.webdPayload },
                |m: &mut WebInfo| { &mut m.webdPayload },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "webSubPlatform",
                |m: &WebInfo| { &m.webSubPlatform },
                |m: &mut WebInfo| { &mut m.webSubPlatform },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebInfo>(
                "ClientPayload.WebInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WebInfo {
        const NAME: &'static str = "WebInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.refToken = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.version = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.webdPayload)?;
                    },
                    32 => {
                        self.webSubPlatform = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.refToken.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.version.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.webdPayload.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.webSubPlatform {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.refToken.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.version.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.webdPayload.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.webSubPlatform {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WebInfo {
            WebInfo::new()
        }

        fn clear(&mut self) {
            self.refToken = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.webdPayload.clear();
            self.webSubPlatform = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WebInfo {
            static instance: WebInfo = WebInfo {
                refToken: ::std::option::Option::None,
                version: ::std::option::Option::None,
                webdPayload: ::protobuf::MessageField::none(),
                webSubPlatform: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WebInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ClientPayload.WebInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WebInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WebInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `WebInfo`
    pub mod web_info {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.ClientPayload.WebInfo.WebdPayload)
        pub struct WebdPayload {
            // message fields
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.usesParticipantInKey)
            pub usesParticipantInKey: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.supportsStarredMessages)
            pub supportsStarredMessages: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.supportsDocumentMessages)
            pub supportsDocumentMessages: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.supportsUrlMessages)
            pub supportsUrlMessages: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.supportsMediaRetry)
            pub supportsMediaRetry: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.supportsE2EImage)
            pub supportsE2EImage: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.supportsE2EVideo)
            pub supportsE2EVideo: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.supportsE2EAudio)
            pub supportsE2EAudio: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.supportsE2EDocument)
            pub supportsE2EDocument: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.documentTypes)
            pub documentTypes: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:proto.ClientPayload.WebInfo.WebdPayload.features)
            pub features: ::std::option::Option<::std::vec::Vec<u8>>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.ClientPayload.WebInfo.WebdPayload.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a WebdPayload {
            fn default() -> &'a WebdPayload {
                <WebdPayload as ::protobuf::Message>::default_instance()
            }
        }

        impl WebdPayload {
            pub fn new() -> WebdPayload {
                ::std::default::Default::default()
            }

            // optional bool usesParticipantInKey = 1;

            pub fn usesParticipantInKey(&self) -> bool {
                self.usesParticipantInKey.unwrap_or(false)
            }

            pub fn clear_usesParticipantInKey(&mut self) {
                self.usesParticipantInKey = ::std::option::Option::None;
            }

            pub fn has_usesParticipantInKey(&self) -> bool {
                self.usesParticipantInKey.is_some()
            }

            // Param is passed by value, moved
            pub fn set_usesParticipantInKey(&mut self, v: bool) {
                self.usesParticipantInKey = ::std::option::Option::Some(v);
            }

            // optional bool supportsStarredMessages = 2;

            pub fn supportsStarredMessages(&self) -> bool {
                self.supportsStarredMessages.unwrap_or(false)
            }

            pub fn clear_supportsStarredMessages(&mut self) {
                self.supportsStarredMessages = ::std::option::Option::None;
            }

            pub fn has_supportsStarredMessages(&self) -> bool {
                self.supportsStarredMessages.is_some()
            }

            // Param is passed by value, moved
            pub fn set_supportsStarredMessages(&mut self, v: bool) {
                self.supportsStarredMessages = ::std::option::Option::Some(v);
            }

            // optional bool supportsDocumentMessages = 3;

            pub fn supportsDocumentMessages(&self) -> bool {
                self.supportsDocumentMessages.unwrap_or(false)
            }

            pub fn clear_supportsDocumentMessages(&mut self) {
                self.supportsDocumentMessages = ::std::option::Option::None;
            }

            pub fn has_supportsDocumentMessages(&self) -> bool {
                self.supportsDocumentMessages.is_some()
            }

            // Param is passed by value, moved
            pub fn set_supportsDocumentMessages(&mut self, v: bool) {
                self.supportsDocumentMessages = ::std::option::Option::Some(v);
            }

            // optional bool supportsUrlMessages = 4;

            pub fn supportsUrlMessages(&self) -> bool {
                self.supportsUrlMessages.unwrap_or(false)
            }

            pub fn clear_supportsUrlMessages(&mut self) {
                self.supportsUrlMessages = ::std::option::Option::None;
            }

            pub fn has_supportsUrlMessages(&self) -> bool {
                self.supportsUrlMessages.is_some()
            }

            // Param is passed by value, moved
            pub fn set_supportsUrlMessages(&mut self, v: bool) {
                self.supportsUrlMessages = ::std::option::Option::Some(v);
            }

            // optional bool supportsMediaRetry = 5;

            pub fn supportsMediaRetry(&self) -> bool {
                self.supportsMediaRetry.unwrap_or(false)
            }

            pub fn clear_supportsMediaRetry(&mut self) {
                self.supportsMediaRetry = ::std::option::Option::None;
            }

            pub fn has_supportsMediaRetry(&self) -> bool {
                self.supportsMediaRetry.is_some()
            }

            // Param is passed by value, moved
            pub fn set_supportsMediaRetry(&mut self, v: bool) {
                self.supportsMediaRetry = ::std::option::Option::Some(v);
            }

            // optional bool supportsE2EImage = 6;

            pub fn supportsE2EImage(&self) -> bool {
                self.supportsE2EImage.unwrap_or(false)
            }

            pub fn clear_supportsE2EImage(&mut self) {
                self.supportsE2EImage = ::std::option::Option::None;
            }

            pub fn has_supportsE2EImage(&self) -> bool {
                self.supportsE2EImage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_supportsE2EImage(&mut self, v: bool) {
                self.supportsE2EImage = ::std::option::Option::Some(v);
            }

            // optional bool supportsE2EVideo = 7;

            pub fn supportsE2EVideo(&self) -> bool {
                self.supportsE2EVideo.unwrap_or(false)
            }

            pub fn clear_supportsE2EVideo(&mut self) {
                self.supportsE2EVideo = ::std::option::Option::None;
            }

            pub fn has_supportsE2EVideo(&self) -> bool {
                self.supportsE2EVideo.is_some()
            }

            // Param is passed by value, moved
            pub fn set_supportsE2EVideo(&mut self, v: bool) {
                self.supportsE2EVideo = ::std::option::Option::Some(v);
            }

            // optional bool supportsE2EAudio = 8;

            pub fn supportsE2EAudio(&self) -> bool {
                self.supportsE2EAudio.unwrap_or(false)
            }

            pub fn clear_supportsE2EAudio(&mut self) {
                self.supportsE2EAudio = ::std::option::Option::None;
            }

            pub fn has_supportsE2EAudio(&self) -> bool {
                self.supportsE2EAudio.is_some()
            }

            // Param is passed by value, moved
            pub fn set_supportsE2EAudio(&mut self, v: bool) {
                self.supportsE2EAudio = ::std::option::Option::Some(v);
            }

            // optional bool supportsE2EDocument = 9;

            pub fn supportsE2EDocument(&self) -> bool {
                self.supportsE2EDocument.unwrap_or(false)
            }

            pub fn clear_supportsE2EDocument(&mut self) {
                self.supportsE2EDocument = ::std::option::Option::None;
            }

            pub fn has_supportsE2EDocument(&self) -> bool {
                self.supportsE2EDocument.is_some()
            }

            // Param is passed by value, moved
            pub fn set_supportsE2EDocument(&mut self, v: bool) {
                self.supportsE2EDocument = ::std::option::Option::Some(v);
            }

            // optional string documentTypes = 10;

            pub fn documentTypes(&self) -> &str {
                match self.documentTypes.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_documentTypes(&mut self) {
                self.documentTypes = ::std::option::Option::None;
            }

            pub fn has_documentTypes(&self) -> bool {
                self.documentTypes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_documentTypes(&mut self, v: ::std::string::String) {
                self.documentTypes = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_documentTypes(&mut self) -> &mut ::std::string::String {
                if self.documentTypes.is_none() {
                    self.documentTypes = ::std::option::Option::Some(::std::string::String::new());
                }
                self.documentTypes.as_mut().unwrap()
            }

            // Take field
            pub fn take_documentTypes(&mut self) -> ::std::string::String {
                self.documentTypes.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional bytes features = 11;

            pub fn features(&self) -> &[u8] {
                match self.features.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_features(&mut self) {
                self.features = ::std::option::Option::None;
            }

            pub fn has_features(&self) -> bool {
                self.features.is_some()
            }

            // Param is passed by value, moved
            pub fn set_features(&mut self, v: ::std::vec::Vec<u8>) {
                self.features = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_features(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.features.is_none() {
                    self.features = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.features.as_mut().unwrap()
            }

            // Take field
            pub fn take_features(&mut self) -> ::std::vec::Vec<u8> {
                self.features.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(11);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "usesParticipantInKey",
                    |m: &WebdPayload| { &m.usesParticipantInKey },
                    |m: &mut WebdPayload| { &mut m.usesParticipantInKey },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "supportsStarredMessages",
                    |m: &WebdPayload| { &m.supportsStarredMessages },
                    |m: &mut WebdPayload| { &mut m.supportsStarredMessages },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "supportsDocumentMessages",
                    |m: &WebdPayload| { &m.supportsDocumentMessages },
                    |m: &mut WebdPayload| { &mut m.supportsDocumentMessages },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "supportsUrlMessages",
                    |m: &WebdPayload| { &m.supportsUrlMessages },
                    |m: &mut WebdPayload| { &mut m.supportsUrlMessages },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "supportsMediaRetry",
                    |m: &WebdPayload| { &m.supportsMediaRetry },
                    |m: &mut WebdPayload| { &mut m.supportsMediaRetry },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "supportsE2EImage",
                    |m: &WebdPayload| { &m.supportsE2EImage },
                    |m: &mut WebdPayload| { &mut m.supportsE2EImage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "supportsE2EVideo",
                    |m: &WebdPayload| { &m.supportsE2EVideo },
                    |m: &mut WebdPayload| { &mut m.supportsE2EVideo },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "supportsE2EAudio",
                    |m: &WebdPayload| { &m.supportsE2EAudio },
                    |m: &mut WebdPayload| { &mut m.supportsE2EAudio },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "supportsE2EDocument",
                    |m: &WebdPayload| { &m.supportsE2EDocument },
                    |m: &mut WebdPayload| { &mut m.supportsE2EDocument },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "documentTypes",
                    |m: &WebdPayload| { &m.documentTypes },
                    |m: &mut WebdPayload| { &mut m.documentTypes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "features",
                    |m: &WebdPayload| { &m.features },
                    |m: &mut WebdPayload| { &mut m.features },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebdPayload>(
                    "ClientPayload.WebInfo.WebdPayload",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for WebdPayload {
            const NAME: &'static str = "WebdPayload";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.usesParticipantInKey = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.supportsStarredMessages = ::std::option::Option::Some(is.read_bool()?);
                        },
                        24 => {
                            self.supportsDocumentMessages = ::std::option::Option::Some(is.read_bool()?);
                        },
                        32 => {
                            self.supportsUrlMessages = ::std::option::Option::Some(is.read_bool()?);
                        },
                        40 => {
                            self.supportsMediaRetry = ::std::option::Option::Some(is.read_bool()?);
                        },
                        48 => {
                            self.supportsE2EImage = ::std::option::Option::Some(is.read_bool()?);
                        },
                        56 => {
                            self.supportsE2EVideo = ::std::option::Option::Some(is.read_bool()?);
                        },
                        64 => {
                            self.supportsE2EAudio = ::std::option::Option::Some(is.read_bool()?);
                        },
                        72 => {
                            self.supportsE2EDocument = ::std::option::Option::Some(is.read_bool()?);
                        },
                        82 => {
                            self.documentTypes = ::std::option::Option::Some(is.read_string()?);
                        },
                        90 => {
                            self.features = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.usesParticipantInKey {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.supportsStarredMessages {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.supportsDocumentMessages {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.supportsUrlMessages {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.supportsMediaRetry {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.supportsE2EImage {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.supportsE2EVideo {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.supportsE2EAudio {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.supportsE2EDocument {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.documentTypes.as_ref() {
                    my_size += ::protobuf::rt::string_size(10, &v);
                }
                if let Some(v) = self.features.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(11, &v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.usesParticipantInKey {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.supportsStarredMessages {
                    os.write_bool(2, v)?;
                }
                if let Some(v) = self.supportsDocumentMessages {
                    os.write_bool(3, v)?;
                }
                if let Some(v) = self.supportsUrlMessages {
                    os.write_bool(4, v)?;
                }
                if let Some(v) = self.supportsMediaRetry {
                    os.write_bool(5, v)?;
                }
                if let Some(v) = self.supportsE2EImage {
                    os.write_bool(6, v)?;
                }
                if let Some(v) = self.supportsE2EVideo {
                    os.write_bool(7, v)?;
                }
                if let Some(v) = self.supportsE2EAudio {
                    os.write_bool(8, v)?;
                }
                if let Some(v) = self.supportsE2EDocument {
                    os.write_bool(9, v)?;
                }
                if let Some(v) = self.documentTypes.as_ref() {
                    os.write_string(10, v)?;
                }
                if let Some(v) = self.features.as_ref() {
                    os.write_bytes(11, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> WebdPayload {
                WebdPayload::new()
            }

            fn clear(&mut self) {
                self.usesParticipantInKey = ::std::option::Option::None;
                self.supportsStarredMessages = ::std::option::Option::None;
                self.supportsDocumentMessages = ::std::option::Option::None;
                self.supportsUrlMessages = ::std::option::Option::None;
                self.supportsMediaRetry = ::std::option::Option::None;
                self.supportsE2EImage = ::std::option::Option::None;
                self.supportsE2EVideo = ::std::option::Option::None;
                self.supportsE2EAudio = ::std::option::Option::None;
                self.supportsE2EDocument = ::std::option::Option::None;
                self.documentTypes = ::std::option::Option::None;
                self.features = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static WebdPayload {
                static instance: WebdPayload = WebdPayload {
                    usesParticipantInKey: ::std::option::Option::None,
                    supportsStarredMessages: ::std::option::Option::None,
                    supportsDocumentMessages: ::std::option::Option::None,
                    supportsUrlMessages: ::std::option::Option::None,
                    supportsMediaRetry: ::std::option::Option::None,
                    supportsE2EImage: ::std::option::Option::None,
                    supportsE2EVideo: ::std::option::Option::None,
                    supportsE2EAudio: ::std::option::Option::None,
                    supportsE2EDocument: ::std::option::Option::None,
                    documentTypes: ::std::option::Option::None,
                    features: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for WebdPayload {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ClientPayload.WebInfo.WebdPayload").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for WebdPayload {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for WebdPayload {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:proto.ClientPayload.WebInfo.WebSubPlatform)
        pub enum WebSubPlatform {
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.WebInfo.WebSubPlatform.WEB_BROWSER)
            WEB_BROWSER = 0,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.WebInfo.WebSubPlatform.APP_STORE)
            APP_STORE = 1,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.WebInfo.WebSubPlatform.WIN_STORE)
            WIN_STORE = 2,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.WebInfo.WebSubPlatform.DARWIN)
            DARWIN = 3,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.WebInfo.WebSubPlatform.WIN32)
            WIN32 = 4,
        }

        impl ::protobuf::Enum for WebSubPlatform {
            const NAME: &'static str = "WebSubPlatform";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<WebSubPlatform> {
                match value {
                    0 => ::std::option::Option::Some(WebSubPlatform::WEB_BROWSER),
                    1 => ::std::option::Option::Some(WebSubPlatform::APP_STORE),
                    2 => ::std::option::Option::Some(WebSubPlatform::WIN_STORE),
                    3 => ::std::option::Option::Some(WebSubPlatform::DARWIN),
                    4 => ::std::option::Option::Some(WebSubPlatform::WIN32),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [WebSubPlatform] = &[
                WebSubPlatform::WEB_BROWSER,
                WebSubPlatform::APP_STORE,
                WebSubPlatform::WIN_STORE,
                WebSubPlatform::DARWIN,
                WebSubPlatform::WIN32,
            ];
        }

        impl ::protobuf::EnumFull for WebSubPlatform {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("ClientPayload.WebInfo.WebSubPlatform").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for WebSubPlatform {
            fn default() -> Self {
                WebSubPlatform::WEB_BROWSER
            }
        }

        impl WebSubPlatform {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WebSubPlatform>("ClientPayload.WebInfo.WebSubPlatform")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ClientPayload.UserAgent)
    pub struct UserAgent {
        // message fields
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.platform)
        pub platform: ::std::option::Option<::protobuf::EnumOrUnknown<user_agent::Platform>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.appVersion)
        pub appVersion: ::protobuf::MessageField<user_agent::AppVersion>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.mcc)
        pub mcc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.mnc)
        pub mnc: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.osVersion)
        pub osVersion: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.manufacturer)
        pub manufacturer: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.device)
        pub device: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.osBuildNumber)
        pub osBuildNumber: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.phoneId)
        pub phoneId: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.releaseChannel)
        pub releaseChannel: ::std::option::Option<::protobuf::EnumOrUnknown<user_agent::ReleaseChannel>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.localeLanguageIso6391)
        pub localeLanguageIso6391: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.localeCountryIso31661Alpha2)
        pub localeCountryIso31661Alpha2: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.deviceBoard)
        pub deviceBoard: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ClientPayload.UserAgent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UserAgent {
        fn default() -> &'a UserAgent {
            <UserAgent as ::protobuf::Message>::default_instance()
        }
    }

    impl UserAgent {
        pub fn new() -> UserAgent {
            ::std::default::Default::default()
        }

        // optional .proto.ClientPayload.UserAgent.Platform platform = 1;

        pub fn platform(&self) -> user_agent::Platform {
            match self.platform {
                Some(e) => e.enum_value_or(user_agent::Platform::ANDROID),
                None => user_agent::Platform::ANDROID,
            }
        }

        pub fn clear_platform(&mut self) {
            self.platform = ::std::option::Option::None;
        }

        pub fn has_platform(&self) -> bool {
            self.platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_platform(&mut self, v: user_agent::Platform) {
            self.platform = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string mcc = 3;

        pub fn mcc(&self) -> &str {
            match self.mcc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mcc(&mut self) {
            self.mcc = ::std::option::Option::None;
        }

        pub fn has_mcc(&self) -> bool {
            self.mcc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mcc(&mut self, v: ::std::string::String) {
            self.mcc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mcc(&mut self) -> &mut ::std::string::String {
            if self.mcc.is_none() {
                self.mcc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mcc.as_mut().unwrap()
        }

        // Take field
        pub fn take_mcc(&mut self) -> ::std::string::String {
            self.mcc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string mnc = 4;

        pub fn mnc(&self) -> &str {
            match self.mnc.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_mnc(&mut self) {
            self.mnc = ::std::option::Option::None;
        }

        pub fn has_mnc(&self) -> bool {
            self.mnc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mnc(&mut self, v: ::std::string::String) {
            self.mnc = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_mnc(&mut self) -> &mut ::std::string::String {
            if self.mnc.is_none() {
                self.mnc = ::std::option::Option::Some(::std::string::String::new());
            }
            self.mnc.as_mut().unwrap()
        }

        // Take field
        pub fn take_mnc(&mut self) -> ::std::string::String {
            self.mnc.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string osVersion = 5;

        pub fn osVersion(&self) -> &str {
            match self.osVersion.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_osVersion(&mut self) {
            self.osVersion = ::std::option::Option::None;
        }

        pub fn has_osVersion(&self) -> bool {
            self.osVersion.is_some()
        }

        // Param is passed by value, moved
        pub fn set_osVersion(&mut self, v: ::std::string::String) {
            self.osVersion = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_osVersion(&mut self) -> &mut ::std::string::String {
            if self.osVersion.is_none() {
                self.osVersion = ::std::option::Option::Some(::std::string::String::new());
            }
            self.osVersion.as_mut().unwrap()
        }

        // Take field
        pub fn take_osVersion(&mut self) -> ::std::string::String {
            self.osVersion.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string manufacturer = 6;

        pub fn manufacturer(&self) -> &str {
            match self.manufacturer.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_manufacturer(&mut self) {
            self.manufacturer = ::std::option::Option::None;
        }

        pub fn has_manufacturer(&self) -> bool {
            self.manufacturer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manufacturer(&mut self, v: ::std::string::String) {
            self.manufacturer = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_manufacturer(&mut self) -> &mut ::std::string::String {
            if self.manufacturer.is_none() {
                self.manufacturer = ::std::option::Option::Some(::std::string::String::new());
            }
            self.manufacturer.as_mut().unwrap()
        }

        // Take field
        pub fn take_manufacturer(&mut self) -> ::std::string::String {
            self.manufacturer.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device = 7;

        pub fn device(&self) -> &str {
            match self.device.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: ::std::string::String) {
            self.device = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device(&mut self) -> &mut ::std::string::String {
            if self.device.is_none() {
                self.device = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device.as_mut().unwrap()
        }

        // Take field
        pub fn take_device(&mut self) -> ::std::string::String {
            self.device.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string osBuildNumber = 8;

        pub fn osBuildNumber(&self) -> &str {
            match self.osBuildNumber.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_osBuildNumber(&mut self) {
            self.osBuildNumber = ::std::option::Option::None;
        }

        pub fn has_osBuildNumber(&self) -> bool {
            self.osBuildNumber.is_some()
        }

        // Param is passed by value, moved
        pub fn set_osBuildNumber(&mut self, v: ::std::string::String) {
            self.osBuildNumber = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_osBuildNumber(&mut self) -> &mut ::std::string::String {
            if self.osBuildNumber.is_none() {
                self.osBuildNumber = ::std::option::Option::Some(::std::string::String::new());
            }
            self.osBuildNumber.as_mut().unwrap()
        }

        // Take field
        pub fn take_osBuildNumber(&mut self) -> ::std::string::String {
            self.osBuildNumber.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string phoneId = 9;

        pub fn phoneId(&self) -> &str {
            match self.phoneId.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_phoneId(&mut self) {
            self.phoneId = ::std::option::Option::None;
        }

        pub fn has_phoneId(&self) -> bool {
            self.phoneId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_phoneId(&mut self, v: ::std::string::String) {
            self.phoneId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_phoneId(&mut self) -> &mut ::std::string::String {
            if self.phoneId.is_none() {
                self.phoneId = ::std::option::Option::Some(::std::string::String::new());
            }
            self.phoneId.as_mut().unwrap()
        }

        // Take field
        pub fn take_phoneId(&mut self) -> ::std::string::String {
            self.phoneId.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .proto.ClientPayload.UserAgent.ReleaseChannel releaseChannel = 10;

        pub fn releaseChannel(&self) -> user_agent::ReleaseChannel {
            match self.releaseChannel {
                Some(e) => e.enum_value_or(user_agent::ReleaseChannel::RELEASE),
                None => user_agent::ReleaseChannel::RELEASE,
            }
        }

        pub fn clear_releaseChannel(&mut self) {
            self.releaseChannel = ::std::option::Option::None;
        }

        pub fn has_releaseChannel(&self) -> bool {
            self.releaseChannel.is_some()
        }

        // Param is passed by value, moved
        pub fn set_releaseChannel(&mut self, v: user_agent::ReleaseChannel) {
            self.releaseChannel = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string localeLanguageIso6391 = 11;

        pub fn localeLanguageIso6391(&self) -> &str {
            match self.localeLanguageIso6391.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_localeLanguageIso6391(&mut self) {
            self.localeLanguageIso6391 = ::std::option::Option::None;
        }

        pub fn has_localeLanguageIso6391(&self) -> bool {
            self.localeLanguageIso6391.is_some()
        }

        // Param is passed by value, moved
        pub fn set_localeLanguageIso6391(&mut self, v: ::std::string::String) {
            self.localeLanguageIso6391 = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_localeLanguageIso6391(&mut self) -> &mut ::std::string::String {
            if self.localeLanguageIso6391.is_none() {
                self.localeLanguageIso6391 = ::std::option::Option::Some(::std::string::String::new());
            }
            self.localeLanguageIso6391.as_mut().unwrap()
        }

        // Take field
        pub fn take_localeLanguageIso6391(&mut self) -> ::std::string::String {
            self.localeLanguageIso6391.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string localeCountryIso31661Alpha2 = 12;

        pub fn localeCountryIso31661Alpha2(&self) -> &str {
            match self.localeCountryIso31661Alpha2.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_localeCountryIso31661Alpha2(&mut self) {
            self.localeCountryIso31661Alpha2 = ::std::option::Option::None;
        }

        pub fn has_localeCountryIso31661Alpha2(&self) -> bool {
            self.localeCountryIso31661Alpha2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_localeCountryIso31661Alpha2(&mut self, v: ::std::string::String) {
            self.localeCountryIso31661Alpha2 = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_localeCountryIso31661Alpha2(&mut self) -> &mut ::std::string::String {
            if self.localeCountryIso31661Alpha2.is_none() {
                self.localeCountryIso31661Alpha2 = ::std::option::Option::Some(::std::string::String::new());
            }
            self.localeCountryIso31661Alpha2.as_mut().unwrap()
        }

        // Take field
        pub fn take_localeCountryIso31661Alpha2(&mut self) -> ::std::string::String {
            self.localeCountryIso31661Alpha2.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string deviceBoard = 13;

        pub fn deviceBoard(&self) -> &str {
            match self.deviceBoard.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_deviceBoard(&mut self) {
            self.deviceBoard = ::std::option::Option::None;
        }

        pub fn has_deviceBoard(&self) -> bool {
            self.deviceBoard.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deviceBoard(&mut self, v: ::std::string::String) {
            self.deviceBoard = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_deviceBoard(&mut self) -> &mut ::std::string::String {
            if self.deviceBoard.is_none() {
                self.deviceBoard = ::std::option::Option::Some(::std::string::String::new());
            }
            self.deviceBoard.as_mut().unwrap()
        }

        // Take field
        pub fn take_deviceBoard(&mut self) -> ::std::string::String {
            self.deviceBoard.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "platform",
                |m: &UserAgent| { &m.platform },
                |m: &mut UserAgent| { &mut m.platform },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, user_agent::AppVersion>(
                "appVersion",
                |m: &UserAgent| { &m.appVersion },
                |m: &mut UserAgent| { &mut m.appVersion },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mcc",
                |m: &UserAgent| { &m.mcc },
                |m: &mut UserAgent| { &mut m.mcc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mnc",
                |m: &UserAgent| { &m.mnc },
                |m: &mut UserAgent| { &mut m.mnc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "osVersion",
                |m: &UserAgent| { &m.osVersion },
                |m: &mut UserAgent| { &mut m.osVersion },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "manufacturer",
                |m: &UserAgent| { &m.manufacturer },
                |m: &mut UserAgent| { &mut m.manufacturer },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &UserAgent| { &m.device },
                |m: &mut UserAgent| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "osBuildNumber",
                |m: &UserAgent| { &m.osBuildNumber },
                |m: &mut UserAgent| { &mut m.osBuildNumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "phoneId",
                |m: &UserAgent| { &m.phoneId },
                |m: &mut UserAgent| { &mut m.phoneId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "releaseChannel",
                |m: &UserAgent| { &m.releaseChannel },
                |m: &mut UserAgent| { &mut m.releaseChannel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "localeLanguageIso6391",
                |m: &UserAgent| { &m.localeLanguageIso6391 },
                |m: &mut UserAgent| { &mut m.localeLanguageIso6391 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "localeCountryIso31661Alpha2",
                |m: &UserAgent| { &m.localeCountryIso31661Alpha2 },
                |m: &mut UserAgent| { &mut m.localeCountryIso31661Alpha2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deviceBoard",
                |m: &UserAgent| { &m.deviceBoard },
                |m: &mut UserAgent| { &mut m.deviceBoard },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAgent>(
                "ClientPayload.UserAgent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UserAgent {
        const NAME: &'static str = "UserAgent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.platform = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.appVersion)?;
                    },
                    26 => {
                        self.mcc = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.mnc = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.osVersion = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.manufacturer = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.device = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.osBuildNumber = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.phoneId = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.releaseChannel = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    90 => {
                        self.localeLanguageIso6391 = ::std::option::Option::Some(is.read_string()?);
                    },
                    98 => {
                        self.localeCountryIso31661Alpha2 = ::std::option::Option::Some(is.read_string()?);
                    },
                    106 => {
                        self.deviceBoard = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.platform {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.appVersion.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.mcc.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.mnc.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.osVersion.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.manufacturer.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.device.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.osBuildNumber.as_ref() {
                my_size += ::protobuf::rt::string_size(8, &v);
            }
            if let Some(v) = self.phoneId.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.releaseChannel {
                my_size += ::protobuf::rt::int32_size(10, v.value());
            }
            if let Some(v) = self.localeLanguageIso6391.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.localeCountryIso31661Alpha2.as_ref() {
                my_size += ::protobuf::rt::string_size(12, &v);
            }
            if let Some(v) = self.deviceBoard.as_ref() {
                my_size += ::protobuf::rt::string_size(13, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.platform {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.appVersion.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.mcc.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.mnc.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.osVersion.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.manufacturer.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.device.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.osBuildNumber.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.phoneId.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.releaseChannel {
                os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.localeLanguageIso6391.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.localeCountryIso31661Alpha2.as_ref() {
                os.write_string(12, v)?;
            }
            if let Some(v) = self.deviceBoard.as_ref() {
                os.write_string(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UserAgent {
            UserAgent::new()
        }

        fn clear(&mut self) {
            self.platform = ::std::option::Option::None;
            self.appVersion.clear();
            self.mcc = ::std::option::Option::None;
            self.mnc = ::std::option::Option::None;
            self.osVersion = ::std::option::Option::None;
            self.manufacturer = ::std::option::Option::None;
            self.device = ::std::option::Option::None;
            self.osBuildNumber = ::std::option::Option::None;
            self.phoneId = ::std::option::Option::None;
            self.releaseChannel = ::std::option::Option::None;
            self.localeLanguageIso6391 = ::std::option::Option::None;
            self.localeCountryIso31661Alpha2 = ::std::option::Option::None;
            self.deviceBoard = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UserAgent {
            static instance: UserAgent = UserAgent {
                platform: ::std::option::Option::None,
                appVersion: ::protobuf::MessageField::none(),
                mcc: ::std::option::Option::None,
                mnc: ::std::option::Option::None,
                osVersion: ::std::option::Option::None,
                manufacturer: ::std::option::Option::None,
                device: ::std::option::Option::None,
                osBuildNumber: ::std::option::Option::None,
                phoneId: ::std::option::Option::None,
                releaseChannel: ::std::option::Option::None,
                localeLanguageIso6391: ::std::option::Option::None,
                localeCountryIso31661Alpha2: ::std::option::Option::None,
                deviceBoard: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UserAgent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ClientPayload.UserAgent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UserAgent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UserAgent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `UserAgent`
    pub mod user_agent {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.ClientPayload.UserAgent.AppVersion)
        pub struct AppVersion {
            // message fields
            // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.AppVersion.primary)
            pub primary: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.AppVersion.secondary)
            pub secondary: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.AppVersion.tertiary)
            pub tertiary: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.AppVersion.quaternary)
            pub quaternary: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:proto.ClientPayload.UserAgent.AppVersion.quinary)
            pub quinary: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.ClientPayload.UserAgent.AppVersion.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AppVersion {
            fn default() -> &'a AppVersion {
                <AppVersion as ::protobuf::Message>::default_instance()
            }
        }

        impl AppVersion {
            pub fn new() -> AppVersion {
                ::std::default::Default::default()
            }

            // optional uint32 primary = 1;

            pub fn primary(&self) -> u32 {
                self.primary.unwrap_or(0)
            }

            pub fn clear_primary(&mut self) {
                self.primary = ::std::option::Option::None;
            }

            pub fn has_primary(&self) -> bool {
                self.primary.is_some()
            }

            // Param is passed by value, moved
            pub fn set_primary(&mut self, v: u32) {
                self.primary = ::std::option::Option::Some(v);
            }

            // optional uint32 secondary = 2;

            pub fn secondary(&self) -> u32 {
                self.secondary.unwrap_or(0)
            }

            pub fn clear_secondary(&mut self) {
                self.secondary = ::std::option::Option::None;
            }

            pub fn has_secondary(&self) -> bool {
                self.secondary.is_some()
            }

            // Param is passed by value, moved
            pub fn set_secondary(&mut self, v: u32) {
                self.secondary = ::std::option::Option::Some(v);
            }

            // optional uint32 tertiary = 3;

            pub fn tertiary(&self) -> u32 {
                self.tertiary.unwrap_or(0)
            }

            pub fn clear_tertiary(&mut self) {
                self.tertiary = ::std::option::Option::None;
            }

            pub fn has_tertiary(&self) -> bool {
                self.tertiary.is_some()
            }

            // Param is passed by value, moved
            pub fn set_tertiary(&mut self, v: u32) {
                self.tertiary = ::std::option::Option::Some(v);
            }

            // optional uint32 quaternary = 4;

            pub fn quaternary(&self) -> u32 {
                self.quaternary.unwrap_or(0)
            }

            pub fn clear_quaternary(&mut self) {
                self.quaternary = ::std::option::Option::None;
            }

            pub fn has_quaternary(&self) -> bool {
                self.quaternary.is_some()
            }

            // Param is passed by value, moved
            pub fn set_quaternary(&mut self, v: u32) {
                self.quaternary = ::std::option::Option::Some(v);
            }

            // optional uint32 quinary = 5;

            pub fn quinary(&self) -> u32 {
                self.quinary.unwrap_or(0)
            }

            pub fn clear_quinary(&mut self) {
                self.quinary = ::std::option::Option::None;
            }

            pub fn has_quinary(&self) -> bool {
                self.quinary.is_some()
            }

            // Param is passed by value, moved
            pub fn set_quinary(&mut self, v: u32) {
                self.quinary = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "primary",
                    |m: &AppVersion| { &m.primary },
                    |m: &mut AppVersion| { &mut m.primary },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "secondary",
                    |m: &AppVersion| { &m.secondary },
                    |m: &mut AppVersion| { &mut m.secondary },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "tertiary",
                    |m: &AppVersion| { &m.tertiary },
                    |m: &mut AppVersion| { &mut m.tertiary },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "quaternary",
                    |m: &AppVersion| { &m.quaternary },
                    |m: &mut AppVersion| { &mut m.quaternary },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "quinary",
                    |m: &AppVersion| { &m.quinary },
                    |m: &mut AppVersion| { &mut m.quinary },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppVersion>(
                    "ClientPayload.UserAgent.AppVersion",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AppVersion {
            const NAME: &'static str = "AppVersion";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.primary = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.secondary = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.tertiary = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.quaternary = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        40 => {
                            self.quinary = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.primary {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.secondary {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.tertiary {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                if let Some(v) = self.quaternary {
                    my_size += ::protobuf::rt::uint32_size(4, v);
                }
                if let Some(v) = self.quinary {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.primary {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.secondary {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.tertiary {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.quaternary {
                    os.write_uint32(4, v)?;
                }
                if let Some(v) = self.quinary {
                    os.write_uint32(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AppVersion {
                AppVersion::new()
            }

            fn clear(&mut self) {
                self.primary = ::std::option::Option::None;
                self.secondary = ::std::option::Option::None;
                self.tertiary = ::std::option::Option::None;
                self.quaternary = ::std::option::Option::None;
                self.quinary = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AppVersion {
                static instance: AppVersion = AppVersion {
                    primary: ::std::option::Option::None,
                    secondary: ::std::option::Option::None,
                    tertiary: ::std::option::Option::None,
                    quaternary: ::std::option::Option::None,
                    quinary: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for AppVersion {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ClientPayload.UserAgent.AppVersion").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AppVersion {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AppVersion {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:proto.ClientPayload.UserAgent.ReleaseChannel)
        pub enum ReleaseChannel {
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.ReleaseChannel.RELEASE)
            RELEASE = 0,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.ReleaseChannel.BETA)
            BETA = 1,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.ReleaseChannel.ALPHA)
            ALPHA = 2,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.ReleaseChannel.DEBUG)
            DEBUG = 3,
        }

        impl ::protobuf::Enum for ReleaseChannel {
            const NAME: &'static str = "ReleaseChannel";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<ReleaseChannel> {
                match value {
                    0 => ::std::option::Option::Some(ReleaseChannel::RELEASE),
                    1 => ::std::option::Option::Some(ReleaseChannel::BETA),
                    2 => ::std::option::Option::Some(ReleaseChannel::ALPHA),
                    3 => ::std::option::Option::Some(ReleaseChannel::DEBUG),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [ReleaseChannel] = &[
                ReleaseChannel::RELEASE,
                ReleaseChannel::BETA,
                ReleaseChannel::ALPHA,
                ReleaseChannel::DEBUG,
            ];
        }

        impl ::protobuf::EnumFull for ReleaseChannel {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("ClientPayload.UserAgent.ReleaseChannel").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for ReleaseChannel {
            fn default() -> Self {
                ReleaseChannel::RELEASE
            }
        }

        impl ReleaseChannel {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReleaseChannel>("ClientPayload.UserAgent.ReleaseChannel")
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:proto.ClientPayload.UserAgent.Platform)
        pub enum Platform {
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.ANDROID)
            ANDROID = 0,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.IOS)
            IOS = 1,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.WINDOWS_PHONE)
            WINDOWS_PHONE = 2,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.BLACKBERRY)
            BLACKBERRY = 3,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.BLACKBERRYX)
            BLACKBERRYX = 4,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.S40)
            S40 = 5,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.S60)
            S60 = 6,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.PYTHON_CLIENT)
            PYTHON_CLIENT = 7,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.TIZEN)
            TIZEN = 8,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.ENTERPRISE)
            ENTERPRISE = 9,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.SMB_ANDROID)
            SMB_ANDROID = 10,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.KAIOS)
            KAIOS = 11,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.SMB_IOS)
            SMB_IOS = 12,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.WINDOWS)
            WINDOWS = 13,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.WEB)
            WEB = 14,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.PORTAL)
            PORTAL = 15,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.GREEN_ANDROID)
            GREEN_ANDROID = 16,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.GREEN_IPHONE)
            GREEN_IPHONE = 17,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.BLUE_ANDROID)
            BLUE_ANDROID = 18,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.BLUE_IPHONE)
            BLUE_IPHONE = 19,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.FBLITE_ANDROID)
            FBLITE_ANDROID = 20,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.MLITE_ANDROID)
            MLITE_ANDROID = 21,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.IGLITE_ANDROID)
            IGLITE_ANDROID = 22,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.PAGE)
            PAGE = 23,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.MACOS)
            MACOS = 24,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.OCULUS_MSG)
            OCULUS_MSG = 25,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.OCULUS_CALL)
            OCULUS_CALL = 26,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.MILAN)
            MILAN = 27,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.CAPI)
            CAPI = 28,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.WEAROS)
            WEAROS = 29,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.ARDEVICE)
            ARDEVICE = 30,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.VRDEVICE)
            VRDEVICE = 31,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.UserAgent.Platform.BLUE_WEB)
            BLUE_WEB = 32,
        }

        impl ::protobuf::Enum for Platform {
            const NAME: &'static str = "Platform";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Platform> {
                match value {
                    0 => ::std::option::Option::Some(Platform::ANDROID),
                    1 => ::std::option::Option::Some(Platform::IOS),
                    2 => ::std::option::Option::Some(Platform::WINDOWS_PHONE),
                    3 => ::std::option::Option::Some(Platform::BLACKBERRY),
                    4 => ::std::option::Option::Some(Platform::BLACKBERRYX),
                    5 => ::std::option::Option::Some(Platform::S40),
                    6 => ::std::option::Option::Some(Platform::S60),
                    7 => ::std::option::Option::Some(Platform::PYTHON_CLIENT),
                    8 => ::std::option::Option::Some(Platform::TIZEN),
                    9 => ::std::option::Option::Some(Platform::ENTERPRISE),
                    10 => ::std::option::Option::Some(Platform::SMB_ANDROID),
                    11 => ::std::option::Option::Some(Platform::KAIOS),
                    12 => ::std::option::Option::Some(Platform::SMB_IOS),
                    13 => ::std::option::Option::Some(Platform::WINDOWS),
                    14 => ::std::option::Option::Some(Platform::WEB),
                    15 => ::std::option::Option::Some(Platform::PORTAL),
                    16 => ::std::option::Option::Some(Platform::GREEN_ANDROID),
                    17 => ::std::option::Option::Some(Platform::GREEN_IPHONE),
                    18 => ::std::option::Option::Some(Platform::BLUE_ANDROID),
                    19 => ::std::option::Option::Some(Platform::BLUE_IPHONE),
                    20 => ::std::option::Option::Some(Platform::FBLITE_ANDROID),
                    21 => ::std::option::Option::Some(Platform::MLITE_ANDROID),
                    22 => ::std::option::Option::Some(Platform::IGLITE_ANDROID),
                    23 => ::std::option::Option::Some(Platform::PAGE),
                    24 => ::std::option::Option::Some(Platform::MACOS),
                    25 => ::std::option::Option::Some(Platform::OCULUS_MSG),
                    26 => ::std::option::Option::Some(Platform::OCULUS_CALL),
                    27 => ::std::option::Option::Some(Platform::MILAN),
                    28 => ::std::option::Option::Some(Platform::CAPI),
                    29 => ::std::option::Option::Some(Platform::WEAROS),
                    30 => ::std::option::Option::Some(Platform::ARDEVICE),
                    31 => ::std::option::Option::Some(Platform::VRDEVICE),
                    32 => ::std::option::Option::Some(Platform::BLUE_WEB),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Platform] = &[
                Platform::ANDROID,
                Platform::IOS,
                Platform::WINDOWS_PHONE,
                Platform::BLACKBERRY,
                Platform::BLACKBERRYX,
                Platform::S40,
                Platform::S60,
                Platform::PYTHON_CLIENT,
                Platform::TIZEN,
                Platform::ENTERPRISE,
                Platform::SMB_ANDROID,
                Platform::KAIOS,
                Platform::SMB_IOS,
                Platform::WINDOWS,
                Platform::WEB,
                Platform::PORTAL,
                Platform::GREEN_ANDROID,
                Platform::GREEN_IPHONE,
                Platform::BLUE_ANDROID,
                Platform::BLUE_IPHONE,
                Platform::FBLITE_ANDROID,
                Platform::MLITE_ANDROID,
                Platform::IGLITE_ANDROID,
                Platform::PAGE,
                Platform::MACOS,
                Platform::OCULUS_MSG,
                Platform::OCULUS_CALL,
                Platform::MILAN,
                Platform::CAPI,
                Platform::WEAROS,
                Platform::ARDEVICE,
                Platform::VRDEVICE,
                Platform::BLUE_WEB,
            ];
        }

        impl ::protobuf::EnumFull for Platform {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("ClientPayload.UserAgent.Platform").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Platform {
            fn default() -> Self {
                Platform::ANDROID
            }
        }

        impl Platform {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Platform>("ClientPayload.UserAgent.Platform")
            }
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ClientPayload.DevicePairingRegistrationData)
    pub struct DevicePairingRegistrationData {
        // message fields
        // @@protoc_insertion_point(field:proto.ClientPayload.DevicePairingRegistrationData.eRegid)
        pub eRegid: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.DevicePairingRegistrationData.eKeytype)
        pub eKeytype: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.DevicePairingRegistrationData.eIdent)
        pub eIdent: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.DevicePairingRegistrationData.eSkeyId)
        pub eSkeyId: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.DevicePairingRegistrationData.eSkeyVal)
        pub eSkeyVal: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.DevicePairingRegistrationData.eSkeySig)
        pub eSkeySig: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.DevicePairingRegistrationData.buildHash)
        pub buildHash: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.DevicePairingRegistrationData.deviceProps)
        pub deviceProps: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ClientPayload.DevicePairingRegistrationData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DevicePairingRegistrationData {
        fn default() -> &'a DevicePairingRegistrationData {
            <DevicePairingRegistrationData as ::protobuf::Message>::default_instance()
        }
    }

    impl DevicePairingRegistrationData {
        pub fn new() -> DevicePairingRegistrationData {
            ::std::default::Default::default()
        }

        // optional bytes eRegid = 1;

        pub fn eRegid(&self) -> &[u8] {
            match self.eRegid.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_eRegid(&mut self) {
            self.eRegid = ::std::option::Option::None;
        }

        pub fn has_eRegid(&self) -> bool {
            self.eRegid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eRegid(&mut self, v: ::std::vec::Vec<u8>) {
            self.eRegid = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_eRegid(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.eRegid.is_none() {
                self.eRegid = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.eRegid.as_mut().unwrap()
        }

        // Take field
        pub fn take_eRegid(&mut self) -> ::std::vec::Vec<u8> {
            self.eRegid.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes eKeytype = 2;

        pub fn eKeytype(&self) -> &[u8] {
            match self.eKeytype.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_eKeytype(&mut self) {
            self.eKeytype = ::std::option::Option::None;
        }

        pub fn has_eKeytype(&self) -> bool {
            self.eKeytype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eKeytype(&mut self, v: ::std::vec::Vec<u8>) {
            self.eKeytype = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_eKeytype(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.eKeytype.is_none() {
                self.eKeytype = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.eKeytype.as_mut().unwrap()
        }

        // Take field
        pub fn take_eKeytype(&mut self) -> ::std::vec::Vec<u8> {
            self.eKeytype.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes eIdent = 3;

        pub fn eIdent(&self) -> &[u8] {
            match self.eIdent.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_eIdent(&mut self) {
            self.eIdent = ::std::option::Option::None;
        }

        pub fn has_eIdent(&self) -> bool {
            self.eIdent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eIdent(&mut self, v: ::std::vec::Vec<u8>) {
            self.eIdent = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_eIdent(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.eIdent.is_none() {
                self.eIdent = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.eIdent.as_mut().unwrap()
        }

        // Take field
        pub fn take_eIdent(&mut self) -> ::std::vec::Vec<u8> {
            self.eIdent.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes eSkeyId = 4;

        pub fn eSkeyId(&self) -> &[u8] {
            match self.eSkeyId.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_eSkeyId(&mut self) {
            self.eSkeyId = ::std::option::Option::None;
        }

        pub fn has_eSkeyId(&self) -> bool {
            self.eSkeyId.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eSkeyId(&mut self, v: ::std::vec::Vec<u8>) {
            self.eSkeyId = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_eSkeyId(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.eSkeyId.is_none() {
                self.eSkeyId = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.eSkeyId.as_mut().unwrap()
        }

        // Take field
        pub fn take_eSkeyId(&mut self) -> ::std::vec::Vec<u8> {
            self.eSkeyId.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes eSkeyVal = 5;

        pub fn eSkeyVal(&self) -> &[u8] {
            match self.eSkeyVal.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_eSkeyVal(&mut self) {
            self.eSkeyVal = ::std::option::Option::None;
        }

        pub fn has_eSkeyVal(&self) -> bool {
            self.eSkeyVal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eSkeyVal(&mut self, v: ::std::vec::Vec<u8>) {
            self.eSkeyVal = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_eSkeyVal(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.eSkeyVal.is_none() {
                self.eSkeyVal = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.eSkeyVal.as_mut().unwrap()
        }

        // Take field
        pub fn take_eSkeyVal(&mut self) -> ::std::vec::Vec<u8> {
            self.eSkeyVal.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes eSkeySig = 6;

        pub fn eSkeySig(&self) -> &[u8] {
            match self.eSkeySig.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_eSkeySig(&mut self) {
            self.eSkeySig = ::std::option::Option::None;
        }

        pub fn has_eSkeySig(&self) -> bool {
            self.eSkeySig.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eSkeySig(&mut self, v: ::std::vec::Vec<u8>) {
            self.eSkeySig = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_eSkeySig(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.eSkeySig.is_none() {
                self.eSkeySig = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.eSkeySig.as_mut().unwrap()
        }

        // Take field
        pub fn take_eSkeySig(&mut self) -> ::std::vec::Vec<u8> {
            self.eSkeySig.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes buildHash = 7;

        pub fn buildHash(&self) -> &[u8] {
            match self.buildHash.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_buildHash(&mut self) {
            self.buildHash = ::std::option::Option::None;
        }

        pub fn has_buildHash(&self) -> bool {
            self.buildHash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_buildHash(&mut self, v: ::std::vec::Vec<u8>) {
            self.buildHash = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_buildHash(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.buildHash.is_none() {
                self.buildHash = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.buildHash.as_mut().unwrap()
        }

        // Take field
        pub fn take_buildHash(&mut self) -> ::std::vec::Vec<u8> {
            self.buildHash.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes deviceProps = 8;

        pub fn deviceProps(&self) -> &[u8] {
            match self.deviceProps.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_deviceProps(&mut self) {
            self.deviceProps = ::std::option::Option::None;
        }

        pub fn has_deviceProps(&self) -> bool {
            self.deviceProps.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deviceProps(&mut self, v: ::std::vec::Vec<u8>) {
            self.deviceProps = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_deviceProps(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.deviceProps.is_none() {
                self.deviceProps = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.deviceProps.as_mut().unwrap()
        }

        // Take field
        pub fn take_deviceProps(&mut self) -> ::std::vec::Vec<u8> {
            self.deviceProps.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eRegid",
                |m: &DevicePairingRegistrationData| { &m.eRegid },
                |m: &mut DevicePairingRegistrationData| { &mut m.eRegid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eKeytype",
                |m: &DevicePairingRegistrationData| { &m.eKeytype },
                |m: &mut DevicePairingRegistrationData| { &mut m.eKeytype },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eIdent",
                |m: &DevicePairingRegistrationData| { &m.eIdent },
                |m: &mut DevicePairingRegistrationData| { &mut m.eIdent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eSkeyId",
                |m: &DevicePairingRegistrationData| { &m.eSkeyId },
                |m: &mut DevicePairingRegistrationData| { &mut m.eSkeyId },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eSkeyVal",
                |m: &DevicePairingRegistrationData| { &m.eSkeyVal },
                |m: &mut DevicePairingRegistrationData| { &mut m.eSkeyVal },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eSkeySig",
                |m: &DevicePairingRegistrationData| { &m.eSkeySig },
                |m: &mut DevicePairingRegistrationData| { &mut m.eSkeySig },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "buildHash",
                |m: &DevicePairingRegistrationData| { &m.buildHash },
                |m: &mut DevicePairingRegistrationData| { &mut m.buildHash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "deviceProps",
                |m: &DevicePairingRegistrationData| { &m.deviceProps },
                |m: &mut DevicePairingRegistrationData| { &mut m.deviceProps },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DevicePairingRegistrationData>(
                "ClientPayload.DevicePairingRegistrationData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DevicePairingRegistrationData {
        const NAME: &'static str = "DevicePairingRegistrationData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.eRegid = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.eKeytype = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    26 => {
                        self.eIdent = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    34 => {
                        self.eSkeyId = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    42 => {
                        self.eSkeyVal = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    50 => {
                        self.eSkeySig = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    58 => {
                        self.buildHash = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    66 => {
                        self.deviceProps = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eRegid.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.eKeytype.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.eIdent.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.eSkeyId.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.eSkeyVal.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.eSkeySig.as_ref() {
                my_size += ::protobuf::rt::bytes_size(6, &v);
            }
            if let Some(v) = self.buildHash.as_ref() {
                my_size += ::protobuf::rt::bytes_size(7, &v);
            }
            if let Some(v) = self.deviceProps.as_ref() {
                my_size += ::protobuf::rt::bytes_size(8, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eRegid.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.eKeytype.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.eIdent.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.eSkeyId.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.eSkeyVal.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.eSkeySig.as_ref() {
                os.write_bytes(6, v)?;
            }
            if let Some(v) = self.buildHash.as_ref() {
                os.write_bytes(7, v)?;
            }
            if let Some(v) = self.deviceProps.as_ref() {
                os.write_bytes(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DevicePairingRegistrationData {
            DevicePairingRegistrationData::new()
        }

        fn clear(&mut self) {
            self.eRegid = ::std::option::Option::None;
            self.eKeytype = ::std::option::Option::None;
            self.eIdent = ::std::option::Option::None;
            self.eSkeyId = ::std::option::Option::None;
            self.eSkeyVal = ::std::option::Option::None;
            self.eSkeySig = ::std::option::Option::None;
            self.buildHash = ::std::option::Option::None;
            self.deviceProps = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DevicePairingRegistrationData {
            static instance: DevicePairingRegistrationData = DevicePairingRegistrationData {
                eRegid: ::std::option::Option::None,
                eKeytype: ::std::option::Option::None,
                eIdent: ::std::option::Option::None,
                eSkeyId: ::std::option::Option::None,
                eSkeyVal: ::std::option::Option::None,
                eSkeySig: ::std::option::Option::None,
                buildHash: ::std::option::Option::None,
                deviceProps: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DevicePairingRegistrationData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ClientPayload.DevicePairingRegistrationData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DevicePairingRegistrationData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DevicePairingRegistrationData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.ClientPayload.DNSSource)
    pub struct DNSSource {
        // message fields
        // @@protoc_insertion_point(field:proto.ClientPayload.DNSSource.dnsMethod)
        pub dnsMethod: ::std::option::Option<::protobuf::EnumOrUnknown<dnssource::DNSResolutionMethod>>,
        // @@protoc_insertion_point(field:proto.ClientPayload.DNSSource.appCached)
        pub appCached: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.ClientPayload.DNSSource.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DNSSource {
        fn default() -> &'a DNSSource {
            <DNSSource as ::protobuf::Message>::default_instance()
        }
    }

    impl DNSSource {
        pub fn new() -> DNSSource {
            ::std::default::Default::default()
        }

        // optional .proto.ClientPayload.DNSSource.DNSResolutionMethod dnsMethod = 15;

        pub fn dnsMethod(&self) -> dnssource::DNSResolutionMethod {
            match self.dnsMethod {
                Some(e) => e.enum_value_or(dnssource::DNSResolutionMethod::SYSTEM),
                None => dnssource::DNSResolutionMethod::SYSTEM,
            }
        }

        pub fn clear_dnsMethod(&mut self) {
            self.dnsMethod = ::std::option::Option::None;
        }

        pub fn has_dnsMethod(&self) -> bool {
            self.dnsMethod.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dnsMethod(&mut self, v: dnssource::DNSResolutionMethod) {
            self.dnsMethod = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool appCached = 16;

        pub fn appCached(&self) -> bool {
            self.appCached.unwrap_or(false)
        }

        pub fn clear_appCached(&mut self) {
            self.appCached = ::std::option::Option::None;
        }

        pub fn has_appCached(&self) -> bool {
            self.appCached.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appCached(&mut self, v: bool) {
            self.appCached = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dnsMethod",
                |m: &DNSSource| { &m.dnsMethod },
                |m: &mut DNSSource| { &mut m.dnsMethod },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "appCached",
                |m: &DNSSource| { &m.appCached },
                |m: &mut DNSSource| { &mut m.appCached },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DNSSource>(
                "ClientPayload.DNSSource",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DNSSource {
        const NAME: &'static str = "DNSSource";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    120 => {
                        self.dnsMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    128 => {
                        self.appCached = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dnsMethod {
                my_size += ::protobuf::rt::int32_size(15, v.value());
            }
            if let Some(v) = self.appCached {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.dnsMethod {
                os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.appCached {
                os.write_bool(16, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DNSSource {
            DNSSource::new()
        }

        fn clear(&mut self) {
            self.dnsMethod = ::std::option::Option::None;
            self.appCached = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DNSSource {
            static instance: DNSSource = DNSSource {
                dnsMethod: ::std::option::Option::None,
                appCached: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DNSSource {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ClientPayload.DNSSource").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DNSSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DNSSource {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `DNSSource`
    pub mod dnssource {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:proto.ClientPayload.DNSSource.DNSResolutionMethod)
        pub enum DNSResolutionMethod {
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.DNSSource.DNSResolutionMethod.SYSTEM)
            SYSTEM = 0,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.DNSSource.DNSResolutionMethod.GOOGLE)
            GOOGLE = 1,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.DNSSource.DNSResolutionMethod.HARDCODED)
            HARDCODED = 2,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.DNSSource.DNSResolutionMethod.OVERRIDE)
            OVERRIDE = 3,
            // @@protoc_insertion_point(enum_value:proto.ClientPayload.DNSSource.DNSResolutionMethod.FALLBACK)
            FALLBACK = 4,
        }

        impl ::protobuf::Enum for DNSResolutionMethod {
            const NAME: &'static str = "DNSResolutionMethod";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<DNSResolutionMethod> {
                match value {
                    0 => ::std::option::Option::Some(DNSResolutionMethod::SYSTEM),
                    1 => ::std::option::Option::Some(DNSResolutionMethod::GOOGLE),
                    2 => ::std::option::Option::Some(DNSResolutionMethod::HARDCODED),
                    3 => ::std::option::Option::Some(DNSResolutionMethod::OVERRIDE),
                    4 => ::std::option::Option::Some(DNSResolutionMethod::FALLBACK),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [DNSResolutionMethod] = &[
                DNSResolutionMethod::SYSTEM,
                DNSResolutionMethod::GOOGLE,
                DNSResolutionMethod::HARDCODED,
                DNSResolutionMethod::OVERRIDE,
                DNSResolutionMethod::FALLBACK,
            ];
        }

        impl ::protobuf::EnumFull for DNSResolutionMethod {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("ClientPayload.DNSSource.DNSResolutionMethod").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for DNSResolutionMethod {
            fn default() -> Self {
                DNSResolutionMethod::SYSTEM
            }
        }

        impl DNSResolutionMethod {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DNSResolutionMethod>("ClientPayload.DNSSource.DNSResolutionMethod")
            }
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ClientPayload.Product)
    pub enum Product {
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.Product.WHATSAPP)
        WHATSAPP = 0,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.Product.MESSENGER)
        MESSENGER = 1,
    }

    impl ::protobuf::Enum for Product {
        const NAME: &'static str = "Product";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Product> {
            match value {
                0 => ::std::option::Option::Some(Product::WHATSAPP),
                1 => ::std::option::Option::Some(Product::MESSENGER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Product] = &[
            Product::WHATSAPP,
            Product::MESSENGER,
        ];
    }

    impl ::protobuf::EnumFull for Product {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClientPayload.Product").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Product {
        fn default() -> Self {
            Product::WHATSAPP
        }
    }

    impl Product {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Product>("ClientPayload.Product")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ClientPayload.IOSAppExtension)
    pub enum IOSAppExtension {
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.IOSAppExtension.SHARE_EXTENSION)
        SHARE_EXTENSION = 0,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.IOSAppExtension.SERVICE_EXTENSION)
        SERVICE_EXTENSION = 1,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.IOSAppExtension.INTENTS_EXTENSION)
        INTENTS_EXTENSION = 2,
    }

    impl ::protobuf::Enum for IOSAppExtension {
        const NAME: &'static str = "IOSAppExtension";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<IOSAppExtension> {
            match value {
                0 => ::std::option::Option::Some(IOSAppExtension::SHARE_EXTENSION),
                1 => ::std::option::Option::Some(IOSAppExtension::SERVICE_EXTENSION),
                2 => ::std::option::Option::Some(IOSAppExtension::INTENTS_EXTENSION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [IOSAppExtension] = &[
            IOSAppExtension::SHARE_EXTENSION,
            IOSAppExtension::SERVICE_EXTENSION,
            IOSAppExtension::INTENTS_EXTENSION,
        ];
    }

    impl ::protobuf::EnumFull for IOSAppExtension {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClientPayload.IOSAppExtension").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for IOSAppExtension {
        fn default() -> Self {
            IOSAppExtension::SHARE_EXTENSION
        }
    }

    impl IOSAppExtension {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<IOSAppExtension>("ClientPayload.IOSAppExtension")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ClientPayload.ConnectType)
    pub enum ConnectType {
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_UNKNOWN)
        CELLULAR_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.WIFI_UNKNOWN)
        WIFI_UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_EDGE)
        CELLULAR_EDGE = 100,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_IDEN)
        CELLULAR_IDEN = 101,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_UMTS)
        CELLULAR_UMTS = 102,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_EVDO)
        CELLULAR_EVDO = 103,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_GPRS)
        CELLULAR_GPRS = 104,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_HSDPA)
        CELLULAR_HSDPA = 105,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_HSUPA)
        CELLULAR_HSUPA = 106,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_HSPA)
        CELLULAR_HSPA = 107,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_CDMA)
        CELLULAR_CDMA = 108,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_1XRTT)
        CELLULAR_1XRTT = 109,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_EHRPD)
        CELLULAR_EHRPD = 110,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_LTE)
        CELLULAR_LTE = 111,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectType.CELLULAR_HSPAP)
        CELLULAR_HSPAP = 112,
    }

    impl ::protobuf::Enum for ConnectType {
        const NAME: &'static str = "ConnectType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ConnectType> {
            match value {
                0 => ::std::option::Option::Some(ConnectType::CELLULAR_UNKNOWN),
                1 => ::std::option::Option::Some(ConnectType::WIFI_UNKNOWN),
                100 => ::std::option::Option::Some(ConnectType::CELLULAR_EDGE),
                101 => ::std::option::Option::Some(ConnectType::CELLULAR_IDEN),
                102 => ::std::option::Option::Some(ConnectType::CELLULAR_UMTS),
                103 => ::std::option::Option::Some(ConnectType::CELLULAR_EVDO),
                104 => ::std::option::Option::Some(ConnectType::CELLULAR_GPRS),
                105 => ::std::option::Option::Some(ConnectType::CELLULAR_HSDPA),
                106 => ::std::option::Option::Some(ConnectType::CELLULAR_HSUPA),
                107 => ::std::option::Option::Some(ConnectType::CELLULAR_HSPA),
                108 => ::std::option::Option::Some(ConnectType::CELLULAR_CDMA),
                109 => ::std::option::Option::Some(ConnectType::CELLULAR_1XRTT),
                110 => ::std::option::Option::Some(ConnectType::CELLULAR_EHRPD),
                111 => ::std::option::Option::Some(ConnectType::CELLULAR_LTE),
                112 => ::std::option::Option::Some(ConnectType::CELLULAR_HSPAP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ConnectType] = &[
            ConnectType::CELLULAR_UNKNOWN,
            ConnectType::WIFI_UNKNOWN,
            ConnectType::CELLULAR_EDGE,
            ConnectType::CELLULAR_IDEN,
            ConnectType::CELLULAR_UMTS,
            ConnectType::CELLULAR_EVDO,
            ConnectType::CELLULAR_GPRS,
            ConnectType::CELLULAR_HSDPA,
            ConnectType::CELLULAR_HSUPA,
            ConnectType::CELLULAR_HSPA,
            ConnectType::CELLULAR_CDMA,
            ConnectType::CELLULAR_1XRTT,
            ConnectType::CELLULAR_EHRPD,
            ConnectType::CELLULAR_LTE,
            ConnectType::CELLULAR_HSPAP,
        ];
    }

    impl ::protobuf::EnumFull for ConnectType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClientPayload.ConnectType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                ConnectType::CELLULAR_UNKNOWN => 0,
                ConnectType::WIFI_UNKNOWN => 1,
                ConnectType::CELLULAR_EDGE => 2,
                ConnectType::CELLULAR_IDEN => 3,
                ConnectType::CELLULAR_UMTS => 4,
                ConnectType::CELLULAR_EVDO => 5,
                ConnectType::CELLULAR_GPRS => 6,
                ConnectType::CELLULAR_HSDPA => 7,
                ConnectType::CELLULAR_HSUPA => 8,
                ConnectType::CELLULAR_HSPA => 9,
                ConnectType::CELLULAR_CDMA => 10,
                ConnectType::CELLULAR_1XRTT => 11,
                ConnectType::CELLULAR_EHRPD => 12,
                ConnectType::CELLULAR_LTE => 13,
                ConnectType::CELLULAR_HSPAP => 14,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ConnectType {
        fn default() -> Self {
            ConnectType::CELLULAR_UNKNOWN
        }
    }

    impl ConnectType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ConnectType>("ClientPayload.ConnectType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.ClientPayload.ConnectReason)
    pub enum ConnectReason {
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectReason.PUSH)
        PUSH = 0,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectReason.USER_ACTIVATED)
        USER_ACTIVATED = 1,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectReason.SCHEDULED)
        SCHEDULED = 2,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectReason.ERROR_RECONNECT)
        ERROR_RECONNECT = 3,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectReason.NETWORK_SWITCH)
        NETWORK_SWITCH = 4,
        // @@protoc_insertion_point(enum_value:proto.ClientPayload.ConnectReason.PING_RECONNECT)
        PING_RECONNECT = 5,
    }

    impl ::protobuf::Enum for ConnectReason {
        const NAME: &'static str = "ConnectReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ConnectReason> {
            match value {
                0 => ::std::option::Option::Some(ConnectReason::PUSH),
                1 => ::std::option::Option::Some(ConnectReason::USER_ACTIVATED),
                2 => ::std::option::Option::Some(ConnectReason::SCHEDULED),
                3 => ::std::option::Option::Some(ConnectReason::ERROR_RECONNECT),
                4 => ::std::option::Option::Some(ConnectReason::NETWORK_SWITCH),
                5 => ::std::option::Option::Some(ConnectReason::PING_RECONNECT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ConnectReason] = &[
            ConnectReason::PUSH,
            ConnectReason::USER_ACTIVATED,
            ConnectReason::SCHEDULED,
            ConnectReason::ERROR_RECONNECT,
            ConnectReason::NETWORK_SWITCH,
            ConnectReason::PING_RECONNECT,
        ];
    }

    impl ::protobuf::EnumFull for ConnectReason {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("ClientPayload.ConnectReason").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ConnectReason {
        fn default() -> Self {
            ConnectReason::PUSH
        }
    }

    impl ConnectReason {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ConnectReason>("ClientPayload.ConnectReason")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.WebNotificationsInfo)
pub struct WebNotificationsInfo {
    // message fields
    // @@protoc_insertion_point(field:proto.WebNotificationsInfo.timestamp)
    pub timestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.WebNotificationsInfo.unreadChats)
    pub unreadChats: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.WebNotificationsInfo.notifyMessageCount)
    pub notifyMessageCount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.WebNotificationsInfo.notifyMessages)
    pub notifyMessages: ::std::vec::Vec<WebMessageInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.WebNotificationsInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebNotificationsInfo {
    fn default() -> &'a WebNotificationsInfo {
        <WebNotificationsInfo as ::protobuf::Message>::default_instance()
    }
}

impl WebNotificationsInfo {
    pub fn new() -> WebNotificationsInfo {
        ::std::default::Default::default()
    }

    // optional uint64 timestamp = 2;

    pub fn timestamp(&self) -> u64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 unreadChats = 3;

    pub fn unreadChats(&self) -> u32 {
        self.unreadChats.unwrap_or(0)
    }

    pub fn clear_unreadChats(&mut self) {
        self.unreadChats = ::std::option::Option::None;
    }

    pub fn has_unreadChats(&self) -> bool {
        self.unreadChats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreadChats(&mut self, v: u32) {
        self.unreadChats = ::std::option::Option::Some(v);
    }

    // optional uint32 notifyMessageCount = 4;

    pub fn notifyMessageCount(&self) -> u32 {
        self.notifyMessageCount.unwrap_or(0)
    }

    pub fn clear_notifyMessageCount(&mut self) {
        self.notifyMessageCount = ::std::option::Option::None;
    }

    pub fn has_notifyMessageCount(&self) -> bool {
        self.notifyMessageCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notifyMessageCount(&mut self, v: u32) {
        self.notifyMessageCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &WebNotificationsInfo| { &m.timestamp },
            |m: &mut WebNotificationsInfo| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unreadChats",
            |m: &WebNotificationsInfo| { &m.unreadChats },
            |m: &mut WebNotificationsInfo| { &mut m.unreadChats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notifyMessageCount",
            |m: &WebNotificationsInfo| { &m.notifyMessageCount },
            |m: &mut WebNotificationsInfo| { &mut m.notifyMessageCount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notifyMessages",
            |m: &WebNotificationsInfo| { &m.notifyMessages },
            |m: &mut WebNotificationsInfo| { &mut m.notifyMessages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebNotificationsInfo>(
            "WebNotificationsInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebNotificationsInfo {
    const NAME: &'static str = "WebNotificationsInfo";

    fn is_initialized(&self) -> bool {
        for v in &self.notifyMessages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.unreadChats = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.notifyMessageCount = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.notifyMessages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.unreadChats {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.notifyMessageCount {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.notifyMessages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.unreadChats {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.notifyMessageCount {
            os.write_uint32(4, v)?;
        }
        for v in &self.notifyMessages {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebNotificationsInfo {
        WebNotificationsInfo::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.unreadChats = ::std::option::Option::None;
        self.notifyMessageCount = ::std::option::Option::None;
        self.notifyMessages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebNotificationsInfo {
        static instance: WebNotificationsInfo = WebNotificationsInfo {
            timestamp: ::std::option::Option::None,
            unreadChats: ::std::option::Option::None,
            notifyMessageCount: ::std::option::Option::None,
            notifyMessages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebNotificationsInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebNotificationsInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebNotificationsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebNotificationsInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.WebMessageInfo)
pub struct WebMessageInfo {
    // message fields
    // @@protoc_insertion_point(field:proto.WebMessageInfo.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.message)
    pub message: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.messageTimestamp)
    pub messageTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<web_message_info::Status>>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.messageC2STimestamp)
    pub messageC2STimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.ignore)
    pub ignore: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.starred)
    pub starred: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.broadcast)
    pub broadcast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.pushName)
    pub pushName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.mediaCiphertextSha256)
    pub mediaCiphertextSha256: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.multicast)
    pub multicast: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.urlText)
    pub urlText: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.urlNumber)
    pub urlNumber: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.messageStubType)
    pub messageStubType: ::std::option::Option<::protobuf::EnumOrUnknown<web_message_info::StubType>>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.clearMedia)
    pub clearMedia: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.messageStubParameters)
    pub messageStubParameters: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.labels)
    pub labels: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.paymentInfo)
    pub paymentInfo: ::protobuf::MessageField<PaymentInfo>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.finalLiveLocation)
    pub finalLiveLocation: ::protobuf::MessageField<LiveLocationMessage>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.quotedPaymentInfo)
    pub quotedPaymentInfo: ::protobuf::MessageField<PaymentInfo>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.ephemeralStartTimestamp)
    pub ephemeralStartTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.ephemeralDuration)
    pub ephemeralDuration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.ephemeralOffToOn)
    pub ephemeralOffToOn: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.ephemeralOutOfSync)
    pub ephemeralOutOfSync: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.bizPrivacyStatus)
    pub bizPrivacyStatus: ::std::option::Option<::protobuf::EnumOrUnknown<web_message_info::BizPrivacyStatus>>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.verifiedBizName)
    pub verifiedBizName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.mediaData)
    pub mediaData: ::protobuf::MessageField<MediaData>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.photoChange)
    pub photoChange: ::protobuf::MessageField<PhotoChange>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.userReceipt)
    pub userReceipt: ::std::vec::Vec<UserReceipt>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.reactions)
    pub reactions: ::std::vec::Vec<Reaction>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.quotedStickerData)
    pub quotedStickerData: ::protobuf::MessageField<MediaData>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.futureproofData)
    pub futureproofData: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.statusPsa)
    pub statusPsa: ::protobuf::MessageField<StatusPSA>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.pollUpdates)
    pub pollUpdates: ::std::vec::Vec<PollUpdate>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.pollAdditionalMetadata)
    pub pollAdditionalMetadata: ::protobuf::MessageField<PollAdditionalMetadata>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.agentId)
    pub agentId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.statusAlreadyViewed)
    pub statusAlreadyViewed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.messageSecret)
    pub messageSecret: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.keepInChat)
    pub keepInChat: ::protobuf::MessageField<KeepInChat>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.originalSelfAuthorUserJidString)
    pub originalSelfAuthorUserJidString: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.WebMessageInfo.revokeMessageTimestamp)
    pub revokeMessageTimestamp: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.WebMessageInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebMessageInfo {
    fn default() -> &'a WebMessageInfo {
        <WebMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl WebMessageInfo {
    pub fn new() -> WebMessageInfo {
        ::std::default::Default::default()
    }

    // optional uint64 messageTimestamp = 3;

    pub fn messageTimestamp(&self) -> u64 {
        self.messageTimestamp.unwrap_or(0)
    }

    pub fn clear_messageTimestamp(&mut self) {
        self.messageTimestamp = ::std::option::Option::None;
    }

    pub fn has_messageTimestamp(&self) -> bool {
        self.messageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageTimestamp(&mut self, v: u64) {
        self.messageTimestamp = ::std::option::Option::Some(v);
    }

    // optional .proto.WebMessageInfo.Status status = 4;

    pub fn status(&self) -> web_message_info::Status {
        match self.status {
            Some(e) => e.enum_value_or(web_message_info::Status::ERROR),
            None => web_message_info::Status::ERROR,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: web_message_info::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string participant = 5;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 messageC2STimestamp = 6;

    pub fn messageC2STimestamp(&self) -> u64 {
        self.messageC2STimestamp.unwrap_or(0)
    }

    pub fn clear_messageC2STimestamp(&mut self) {
        self.messageC2STimestamp = ::std::option::Option::None;
    }

    pub fn has_messageC2STimestamp(&self) -> bool {
        self.messageC2STimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageC2STimestamp(&mut self, v: u64) {
        self.messageC2STimestamp = ::std::option::Option::Some(v);
    }

    // optional bool ignore = 16;

    pub fn ignore(&self) -> bool {
        self.ignore.unwrap_or(false)
    }

    pub fn clear_ignore(&mut self) {
        self.ignore = ::std::option::Option::None;
    }

    pub fn has_ignore(&self) -> bool {
        self.ignore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore(&mut self, v: bool) {
        self.ignore = ::std::option::Option::Some(v);
    }

    // optional bool starred = 17;

    pub fn starred(&self) -> bool {
        self.starred.unwrap_or(false)
    }

    pub fn clear_starred(&mut self) {
        self.starred = ::std::option::Option::None;
    }

    pub fn has_starred(&self) -> bool {
        self.starred.is_some()
    }

    // Param is passed by value, moved
    pub fn set_starred(&mut self, v: bool) {
        self.starred = ::std::option::Option::Some(v);
    }

    // optional bool broadcast = 18;

    pub fn broadcast(&self) -> bool {
        self.broadcast.unwrap_or(false)
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast = ::std::option::Option::None;
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: bool) {
        self.broadcast = ::std::option::Option::Some(v);
    }

    // optional string pushName = 19;

    pub fn pushName(&self) -> &str {
        match self.pushName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pushName(&mut self) {
        self.pushName = ::std::option::Option::None;
    }

    pub fn has_pushName(&self) -> bool {
        self.pushName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pushName(&mut self, v: ::std::string::String) {
        self.pushName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pushName(&mut self) -> &mut ::std::string::String {
        if self.pushName.is_none() {
            self.pushName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pushName.as_mut().unwrap()
    }

    // Take field
    pub fn take_pushName(&mut self) -> ::std::string::String {
        self.pushName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes mediaCiphertextSha256 = 20;

    pub fn mediaCiphertextSha256(&self) -> &[u8] {
        match self.mediaCiphertextSha256.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_mediaCiphertextSha256(&mut self) {
        self.mediaCiphertextSha256 = ::std::option::Option::None;
    }

    pub fn has_mediaCiphertextSha256(&self) -> bool {
        self.mediaCiphertextSha256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaCiphertextSha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.mediaCiphertextSha256 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mediaCiphertextSha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mediaCiphertextSha256.is_none() {
            self.mediaCiphertextSha256 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.mediaCiphertextSha256.as_mut().unwrap()
    }

    // Take field
    pub fn take_mediaCiphertextSha256(&mut self) -> ::std::vec::Vec<u8> {
        self.mediaCiphertextSha256.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool multicast = 21;

    pub fn multicast(&self) -> bool {
        self.multicast.unwrap_or(false)
    }

    pub fn clear_multicast(&mut self) {
        self.multicast = ::std::option::Option::None;
    }

    pub fn has_multicast(&self) -> bool {
        self.multicast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multicast(&mut self, v: bool) {
        self.multicast = ::std::option::Option::Some(v);
    }

    // optional bool urlText = 22;

    pub fn urlText(&self) -> bool {
        self.urlText.unwrap_or(false)
    }

    pub fn clear_urlText(&mut self) {
        self.urlText = ::std::option::Option::None;
    }

    pub fn has_urlText(&self) -> bool {
        self.urlText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_urlText(&mut self, v: bool) {
        self.urlText = ::std::option::Option::Some(v);
    }

    // optional bool urlNumber = 23;

    pub fn urlNumber(&self) -> bool {
        self.urlNumber.unwrap_or(false)
    }

    pub fn clear_urlNumber(&mut self) {
        self.urlNumber = ::std::option::Option::None;
    }

    pub fn has_urlNumber(&self) -> bool {
        self.urlNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_urlNumber(&mut self, v: bool) {
        self.urlNumber = ::std::option::Option::Some(v);
    }

    // optional .proto.WebMessageInfo.StubType messageStubType = 24;

    pub fn messageStubType(&self) -> web_message_info::StubType {
        match self.messageStubType {
            Some(e) => e.enum_value_or(web_message_info::StubType::UNKNOWN),
            None => web_message_info::StubType::UNKNOWN,
        }
    }

    pub fn clear_messageStubType(&mut self) {
        self.messageStubType = ::std::option::Option::None;
    }

    pub fn has_messageStubType(&self) -> bool {
        self.messageStubType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageStubType(&mut self, v: web_message_info::StubType) {
        self.messageStubType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool clearMedia = 25;

    pub fn clearMedia(&self) -> bool {
        self.clearMedia.unwrap_or(false)
    }

    pub fn clear_clearMedia(&mut self) {
        self.clearMedia = ::std::option::Option::None;
    }

    pub fn has_clearMedia(&self) -> bool {
        self.clearMedia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clearMedia(&mut self, v: bool) {
        self.clearMedia = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 27;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint64 ephemeralStartTimestamp = 32;

    pub fn ephemeralStartTimestamp(&self) -> u64 {
        self.ephemeralStartTimestamp.unwrap_or(0)
    }

    pub fn clear_ephemeralStartTimestamp(&mut self) {
        self.ephemeralStartTimestamp = ::std::option::Option::None;
    }

    pub fn has_ephemeralStartTimestamp(&self) -> bool {
        self.ephemeralStartTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralStartTimestamp(&mut self, v: u64) {
        self.ephemeralStartTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ephemeralDuration = 33;

    pub fn ephemeralDuration(&self) -> u32 {
        self.ephemeralDuration.unwrap_or(0)
    }

    pub fn clear_ephemeralDuration(&mut self) {
        self.ephemeralDuration = ::std::option::Option::None;
    }

    pub fn has_ephemeralDuration(&self) -> bool {
        self.ephemeralDuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralDuration(&mut self, v: u32) {
        self.ephemeralDuration = ::std::option::Option::Some(v);
    }

    // optional bool ephemeralOffToOn = 34;

    pub fn ephemeralOffToOn(&self) -> bool {
        self.ephemeralOffToOn.unwrap_or(false)
    }

    pub fn clear_ephemeralOffToOn(&mut self) {
        self.ephemeralOffToOn = ::std::option::Option::None;
    }

    pub fn has_ephemeralOffToOn(&self) -> bool {
        self.ephemeralOffToOn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralOffToOn(&mut self, v: bool) {
        self.ephemeralOffToOn = ::std::option::Option::Some(v);
    }

    // optional bool ephemeralOutOfSync = 35;

    pub fn ephemeralOutOfSync(&self) -> bool {
        self.ephemeralOutOfSync.unwrap_or(false)
    }

    pub fn clear_ephemeralOutOfSync(&mut self) {
        self.ephemeralOutOfSync = ::std::option::Option::None;
    }

    pub fn has_ephemeralOutOfSync(&self) -> bool {
        self.ephemeralOutOfSync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralOutOfSync(&mut self, v: bool) {
        self.ephemeralOutOfSync = ::std::option::Option::Some(v);
    }

    // optional .proto.WebMessageInfo.BizPrivacyStatus bizPrivacyStatus = 36;

    pub fn bizPrivacyStatus(&self) -> web_message_info::BizPrivacyStatus {
        match self.bizPrivacyStatus {
            Some(e) => e.enum_value_or(web_message_info::BizPrivacyStatus::E2EE),
            None => web_message_info::BizPrivacyStatus::E2EE,
        }
    }

    pub fn clear_bizPrivacyStatus(&mut self) {
        self.bizPrivacyStatus = ::std::option::Option::None;
    }

    pub fn has_bizPrivacyStatus(&self) -> bool {
        self.bizPrivacyStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bizPrivacyStatus(&mut self, v: web_message_info::BizPrivacyStatus) {
        self.bizPrivacyStatus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string verifiedBizName = 37;

    pub fn verifiedBizName(&self) -> &str {
        match self.verifiedBizName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_verifiedBizName(&mut self) {
        self.verifiedBizName = ::std::option::Option::None;
    }

    pub fn has_verifiedBizName(&self) -> bool {
        self.verifiedBizName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verifiedBizName(&mut self, v: ::std::string::String) {
        self.verifiedBizName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verifiedBizName(&mut self) -> &mut ::std::string::String {
        if self.verifiedBizName.is_none() {
            self.verifiedBizName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.verifiedBizName.as_mut().unwrap()
    }

    // Take field
    pub fn take_verifiedBizName(&mut self) -> ::std::string::String {
        self.verifiedBizName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes futureproofData = 43;

    pub fn futureproofData(&self) -> &[u8] {
        match self.futureproofData.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_futureproofData(&mut self) {
        self.futureproofData = ::std::option::Option::None;
    }

    pub fn has_futureproofData(&self) -> bool {
        self.futureproofData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_futureproofData(&mut self, v: ::std::vec::Vec<u8>) {
        self.futureproofData = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_futureproofData(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.futureproofData.is_none() {
            self.futureproofData = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.futureproofData.as_mut().unwrap()
    }

    // Take field
    pub fn take_futureproofData(&mut self) -> ::std::vec::Vec<u8> {
        self.futureproofData.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string agentId = 47;

    pub fn agentId(&self) -> &str {
        match self.agentId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_agentId(&mut self) {
        self.agentId = ::std::option::Option::None;
    }

    pub fn has_agentId(&self) -> bool {
        self.agentId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agentId(&mut self, v: ::std::string::String) {
        self.agentId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agentId(&mut self) -> &mut ::std::string::String {
        if self.agentId.is_none() {
            self.agentId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.agentId.as_mut().unwrap()
    }

    // Take field
    pub fn take_agentId(&mut self) -> ::std::string::String {
        self.agentId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool statusAlreadyViewed = 48;

    pub fn statusAlreadyViewed(&self) -> bool {
        self.statusAlreadyViewed.unwrap_or(false)
    }

    pub fn clear_statusAlreadyViewed(&mut self) {
        self.statusAlreadyViewed = ::std::option::Option::None;
    }

    pub fn has_statusAlreadyViewed(&self) -> bool {
        self.statusAlreadyViewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusAlreadyViewed(&mut self, v: bool) {
        self.statusAlreadyViewed = ::std::option::Option::Some(v);
    }

    // optional bytes messageSecret = 49;

    pub fn messageSecret(&self) -> &[u8] {
        match self.messageSecret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_messageSecret(&mut self) {
        self.messageSecret = ::std::option::Option::None;
    }

    pub fn has_messageSecret(&self) -> bool {
        self.messageSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageSecret(&mut self, v: ::std::vec::Vec<u8>) {
        self.messageSecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messageSecret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.messageSecret.is_none() {
            self.messageSecret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.messageSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_messageSecret(&mut self) -> ::std::vec::Vec<u8> {
        self.messageSecret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string originalSelfAuthorUserJidString = 51;

    pub fn originalSelfAuthorUserJidString(&self) -> &str {
        match self.originalSelfAuthorUserJidString.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_originalSelfAuthorUserJidString(&mut self) {
        self.originalSelfAuthorUserJidString = ::std::option::Option::None;
    }

    pub fn has_originalSelfAuthorUserJidString(&self) -> bool {
        self.originalSelfAuthorUserJidString.is_some()
    }

    // Param is passed by value, moved
    pub fn set_originalSelfAuthorUserJidString(&mut self, v: ::std::string::String) {
        self.originalSelfAuthorUserJidString = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originalSelfAuthorUserJidString(&mut self) -> &mut ::std::string::String {
        if self.originalSelfAuthorUserJidString.is_none() {
            self.originalSelfAuthorUserJidString = ::std::option::Option::Some(::std::string::String::new());
        }
        self.originalSelfAuthorUserJidString.as_mut().unwrap()
    }

    // Take field
    pub fn take_originalSelfAuthorUserJidString(&mut self) -> ::std::string::String {
        self.originalSelfAuthorUserJidString.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 revokeMessageTimestamp = 52;

    pub fn revokeMessageTimestamp(&self) -> u64 {
        self.revokeMessageTimestamp.unwrap_or(0)
    }

    pub fn clear_revokeMessageTimestamp(&mut self) {
        self.revokeMessageTimestamp = ::std::option::Option::None;
    }

    pub fn has_revokeMessageTimestamp(&self) -> bool {
        self.revokeMessageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revokeMessageTimestamp(&mut self, v: u64) {
        self.revokeMessageTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(43);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &WebMessageInfo| { &m.key },
            |m: &mut WebMessageInfo| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "message",
            |m: &WebMessageInfo| { &m.message },
            |m: &mut WebMessageInfo| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageTimestamp",
            |m: &WebMessageInfo| { &m.messageTimestamp },
            |m: &mut WebMessageInfo| { &mut m.messageTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &WebMessageInfo| { &m.status },
            |m: &mut WebMessageInfo| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &WebMessageInfo| { &m.participant },
            |m: &mut WebMessageInfo| { &mut m.participant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageC2STimestamp",
            |m: &WebMessageInfo| { &m.messageC2STimestamp },
            |m: &mut WebMessageInfo| { &mut m.messageC2STimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore",
            |m: &WebMessageInfo| { &m.ignore },
            |m: &mut WebMessageInfo| { &mut m.ignore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "starred",
            |m: &WebMessageInfo| { &m.starred },
            |m: &mut WebMessageInfo| { &mut m.starred },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast",
            |m: &WebMessageInfo| { &m.broadcast },
            |m: &mut WebMessageInfo| { &mut m.broadcast },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pushName",
            |m: &WebMessageInfo| { &m.pushName },
            |m: &mut WebMessageInfo| { &mut m.pushName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaCiphertextSha256",
            |m: &WebMessageInfo| { &m.mediaCiphertextSha256 },
            |m: &mut WebMessageInfo| { &mut m.mediaCiphertextSha256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multicast",
            |m: &WebMessageInfo| { &m.multicast },
            |m: &mut WebMessageInfo| { &mut m.multicast },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "urlText",
            |m: &WebMessageInfo| { &m.urlText },
            |m: &mut WebMessageInfo| { &mut m.urlText },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "urlNumber",
            |m: &WebMessageInfo| { &m.urlNumber },
            |m: &mut WebMessageInfo| { &mut m.urlNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageStubType",
            |m: &WebMessageInfo| { &m.messageStubType },
            |m: &mut WebMessageInfo| { &mut m.messageStubType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clearMedia",
            |m: &WebMessageInfo| { &m.clearMedia },
            |m: &mut WebMessageInfo| { &mut m.clearMedia },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messageStubParameters",
            |m: &WebMessageInfo| { &m.messageStubParameters },
            |m: &mut WebMessageInfo| { &mut m.messageStubParameters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &WebMessageInfo| { &m.duration },
            |m: &mut WebMessageInfo| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "labels",
            |m: &WebMessageInfo| { &m.labels },
            |m: &mut WebMessageInfo| { &mut m.labels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentInfo>(
            "paymentInfo",
            |m: &WebMessageInfo| { &m.paymentInfo },
            |m: &mut WebMessageInfo| { &mut m.paymentInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LiveLocationMessage>(
            "finalLiveLocation",
            |m: &WebMessageInfo| { &m.finalLiveLocation },
            |m: &mut WebMessageInfo| { &mut m.finalLiveLocation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PaymentInfo>(
            "quotedPaymentInfo",
            |m: &WebMessageInfo| { &m.quotedPaymentInfo },
            |m: &mut WebMessageInfo| { &mut m.quotedPaymentInfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralStartTimestamp",
            |m: &WebMessageInfo| { &m.ephemeralStartTimestamp },
            |m: &mut WebMessageInfo| { &mut m.ephemeralStartTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralDuration",
            |m: &WebMessageInfo| { &m.ephemeralDuration },
            |m: &mut WebMessageInfo| { &mut m.ephemeralDuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralOffToOn",
            |m: &WebMessageInfo| { &m.ephemeralOffToOn },
            |m: &mut WebMessageInfo| { &mut m.ephemeralOffToOn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralOutOfSync",
            |m: &WebMessageInfo| { &m.ephemeralOutOfSync },
            |m: &mut WebMessageInfo| { &mut m.ephemeralOutOfSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bizPrivacyStatus",
            |m: &WebMessageInfo| { &m.bizPrivacyStatus },
            |m: &mut WebMessageInfo| { &mut m.bizPrivacyStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verifiedBizName",
            |m: &WebMessageInfo| { &m.verifiedBizName },
            |m: &mut WebMessageInfo| { &mut m.verifiedBizName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaData>(
            "mediaData",
            |m: &WebMessageInfo| { &m.mediaData },
            |m: &mut WebMessageInfo| { &mut m.mediaData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PhotoChange>(
            "photoChange",
            |m: &WebMessageInfo| { &m.photoChange },
            |m: &mut WebMessageInfo| { &mut m.photoChange },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userReceipt",
            |m: &WebMessageInfo| { &m.userReceipt },
            |m: &mut WebMessageInfo| { &mut m.userReceipt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reactions",
            |m: &WebMessageInfo| { &m.reactions },
            |m: &mut WebMessageInfo| { &mut m.reactions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MediaData>(
            "quotedStickerData",
            |m: &WebMessageInfo| { &m.quotedStickerData },
            |m: &mut WebMessageInfo| { &mut m.quotedStickerData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "futureproofData",
            |m: &WebMessageInfo| { &m.futureproofData },
            |m: &mut WebMessageInfo| { &mut m.futureproofData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StatusPSA>(
            "statusPsa",
            |m: &WebMessageInfo| { &m.statusPsa },
            |m: &mut WebMessageInfo| { &mut m.statusPsa },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pollUpdates",
            |m: &WebMessageInfo| { &m.pollUpdates },
            |m: &mut WebMessageInfo| { &mut m.pollUpdates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollAdditionalMetadata>(
            "pollAdditionalMetadata",
            |m: &WebMessageInfo| { &m.pollAdditionalMetadata },
            |m: &mut WebMessageInfo| { &mut m.pollAdditionalMetadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "agentId",
            |m: &WebMessageInfo| { &m.agentId },
            |m: &mut WebMessageInfo| { &mut m.agentId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "statusAlreadyViewed",
            |m: &WebMessageInfo| { &m.statusAlreadyViewed },
            |m: &mut WebMessageInfo| { &mut m.statusAlreadyViewed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageSecret",
            |m: &WebMessageInfo| { &m.messageSecret },
            |m: &mut WebMessageInfo| { &mut m.messageSecret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KeepInChat>(
            "keepInChat",
            |m: &WebMessageInfo| { &m.keepInChat },
            |m: &mut WebMessageInfo| { &mut m.keepInChat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "originalSelfAuthorUserJidString",
            |m: &WebMessageInfo| { &m.originalSelfAuthorUserJidString },
            |m: &mut WebMessageInfo| { &mut m.originalSelfAuthorUserJidString },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "revokeMessageTimestamp",
            |m: &WebMessageInfo| { &m.revokeMessageTimestamp },
            |m: &mut WebMessageInfo| { &mut m.revokeMessageTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebMessageInfo>(
            "WebMessageInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebMessageInfo {
    const NAME: &'static str = "WebMessageInfo";

    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paymentInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finalLiveLocation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quotedPaymentInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mediaData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.photoChange {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.userReceipt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quotedStickerData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statusPsa {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pollUpdates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pollAdditionalMetadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.keepInChat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                24 => {
                    self.messageTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.messageC2STimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                128 => {
                    self.ignore = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.starred = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                154 => {
                    self.pushName = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.mediaCiphertextSha256 = ::std::option::Option::Some(is.read_bytes()?);
                },
                168 => {
                    self.multicast = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.urlText = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.urlNumber = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.messageStubType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.clearMedia = ::std::option::Option::Some(is.read_bool()?);
                },
                210 => {
                    self.messageStubParameters.push(is.read_string()?);
                },
                216 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                226 => {
                    self.labels.push(is.read_string()?);
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.paymentInfo)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.finalLiveLocation)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedPaymentInfo)?;
                },
                256 => {
                    self.ephemeralStartTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                264 => {
                    self.ephemeralDuration = ::std::option::Option::Some(is.read_uint32()?);
                },
                272 => {
                    self.ephemeralOffToOn = ::std::option::Option::Some(is.read_bool()?);
                },
                280 => {
                    self.ephemeralOutOfSync = ::std::option::Option::Some(is.read_bool()?);
                },
                288 => {
                    self.bizPrivacyStatus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                298 => {
                    self.verifiedBizName = ::std::option::Option::Some(is.read_string()?);
                },
                306 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mediaData)?;
                },
                314 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.photoChange)?;
                },
                322 => {
                    self.userReceipt.push(is.read_message()?);
                },
                330 => {
                    self.reactions.push(is.read_message()?);
                },
                338 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quotedStickerData)?;
                },
                346 => {
                    self.futureproofData = ::std::option::Option::Some(is.read_bytes()?);
                },
                354 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.statusPsa)?;
                },
                362 => {
                    self.pollUpdates.push(is.read_message()?);
                },
                370 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pollAdditionalMetadata)?;
                },
                378 => {
                    self.agentId = ::std::option::Option::Some(is.read_string()?);
                },
                384 => {
                    self.statusAlreadyViewed = ::std::option::Option::Some(is.read_bool()?);
                },
                394 => {
                    self.messageSecret = ::std::option::Option::Some(is.read_bytes()?);
                },
                402 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keepInChat)?;
                },
                410 => {
                    self.originalSelfAuthorUserJidString = ::std::option::Option::Some(is.read_string()?);
                },
                416 => {
                    self.revokeMessageTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.messageTimestamp {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.messageC2STimestamp {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.ignore {
            my_size += 2 + 1;
        }
        if let Some(v) = self.starred {
            my_size += 2 + 1;
        }
        if let Some(v) = self.broadcast {
            my_size += 2 + 1;
        }
        if let Some(v) = self.pushName.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.mediaCiphertextSha256.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        if let Some(v) = self.multicast {
            my_size += 2 + 1;
        }
        if let Some(v) = self.urlText {
            my_size += 2 + 1;
        }
        if let Some(v) = self.urlNumber {
            my_size += 2 + 1;
        }
        if let Some(v) = self.messageStubType {
            my_size += ::protobuf::rt::int32_size(24, v.value());
        }
        if let Some(v) = self.clearMedia {
            my_size += 2 + 1;
        }
        for value in &self.messageStubParameters {
            my_size += ::protobuf::rt::string_size(26, &value);
        };
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::string_size(28, &value);
        };
        if let Some(v) = self.paymentInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.finalLiveLocation.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quotedPaymentInfo.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ephemeralStartTimestamp {
            my_size += ::protobuf::rt::uint64_size(32, v);
        }
        if let Some(v) = self.ephemeralDuration {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.ephemeralOffToOn {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ephemeralOutOfSync {
            my_size += 2 + 1;
        }
        if let Some(v) = self.bizPrivacyStatus {
            my_size += ::protobuf::rt::int32_size(36, v.value());
        }
        if let Some(v) = self.verifiedBizName.as_ref() {
            my_size += ::protobuf::rt::string_size(37, &v);
        }
        if let Some(v) = self.mediaData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.photoChange.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.userReceipt {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reactions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.quotedStickerData.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.futureproofData.as_ref() {
            my_size += ::protobuf::rt::bytes_size(43, &v);
        }
        if let Some(v) = self.statusPsa.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.pollUpdates {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pollAdditionalMetadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.agentId.as_ref() {
            my_size += ::protobuf::rt::string_size(47, &v);
        }
        if let Some(v) = self.statusAlreadyViewed {
            my_size += 2 + 1;
        }
        if let Some(v) = self.messageSecret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(49, &v);
        }
        if let Some(v) = self.keepInChat.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.originalSelfAuthorUserJidString.as_ref() {
            my_size += ::protobuf::rt::string_size(51, &v);
        }
        if let Some(v) = self.revokeMessageTimestamp {
            my_size += ::protobuf::rt::uint64_size(52, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.messageTimestamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.messageC2STimestamp {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.ignore {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.starred {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.broadcast {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.pushName.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.mediaCiphertextSha256.as_ref() {
            os.write_bytes(20, v)?;
        }
        if let Some(v) = self.multicast {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.urlText {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.urlNumber {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.messageStubType {
            os.write_enum(24, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.clearMedia {
            os.write_bool(25, v)?;
        }
        for v in &self.messageStubParameters {
            os.write_string(26, &v)?;
        };
        if let Some(v) = self.duration {
            os.write_uint32(27, v)?;
        }
        for v in &self.labels {
            os.write_string(28, &v)?;
        };
        if let Some(v) = self.paymentInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.finalLiveLocation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.quotedPaymentInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.ephemeralStartTimestamp {
            os.write_uint64(32, v)?;
        }
        if let Some(v) = self.ephemeralDuration {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.ephemeralOffToOn {
            os.write_bool(34, v)?;
        }
        if let Some(v) = self.ephemeralOutOfSync {
            os.write_bool(35, v)?;
        }
        if let Some(v) = self.bizPrivacyStatus {
            os.write_enum(36, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.verifiedBizName.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.mediaData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(38, v, os)?;
        }
        if let Some(v) = self.photoChange.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        }
        for v in &self.userReceipt {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        };
        for v in &self.reactions {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        };
        if let Some(v) = self.quotedStickerData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        }
        if let Some(v) = self.futureproofData.as_ref() {
            os.write_bytes(43, v)?;
        }
        if let Some(v) = self.statusPsa.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        for v in &self.pollUpdates {
            ::protobuf::rt::write_message_field_with_cached_size(45, v, os)?;
        };
        if let Some(v) = self.pollAdditionalMetadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(46, v, os)?;
        }
        if let Some(v) = self.agentId.as_ref() {
            os.write_string(47, v)?;
        }
        if let Some(v) = self.statusAlreadyViewed {
            os.write_bool(48, v)?;
        }
        if let Some(v) = self.messageSecret.as_ref() {
            os.write_bytes(49, v)?;
        }
        if let Some(v) = self.keepInChat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        if let Some(v) = self.originalSelfAuthorUserJidString.as_ref() {
            os.write_string(51, v)?;
        }
        if let Some(v) = self.revokeMessageTimestamp {
            os.write_uint64(52, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebMessageInfo {
        WebMessageInfo::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.message.clear();
        self.messageTimestamp = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.messageC2STimestamp = ::std::option::Option::None;
        self.ignore = ::std::option::Option::None;
        self.starred = ::std::option::Option::None;
        self.broadcast = ::std::option::Option::None;
        self.pushName = ::std::option::Option::None;
        self.mediaCiphertextSha256 = ::std::option::Option::None;
        self.multicast = ::std::option::Option::None;
        self.urlText = ::std::option::Option::None;
        self.urlNumber = ::std::option::Option::None;
        self.messageStubType = ::std::option::Option::None;
        self.clearMedia = ::std::option::Option::None;
        self.messageStubParameters.clear();
        self.duration = ::std::option::Option::None;
        self.labels.clear();
        self.paymentInfo.clear();
        self.finalLiveLocation.clear();
        self.quotedPaymentInfo.clear();
        self.ephemeralStartTimestamp = ::std::option::Option::None;
        self.ephemeralDuration = ::std::option::Option::None;
        self.ephemeralOffToOn = ::std::option::Option::None;
        self.ephemeralOutOfSync = ::std::option::Option::None;
        self.bizPrivacyStatus = ::std::option::Option::None;
        self.verifiedBizName = ::std::option::Option::None;
        self.mediaData.clear();
        self.photoChange.clear();
        self.userReceipt.clear();
        self.reactions.clear();
        self.quotedStickerData.clear();
        self.futureproofData = ::std::option::Option::None;
        self.statusPsa.clear();
        self.pollUpdates.clear();
        self.pollAdditionalMetadata.clear();
        self.agentId = ::std::option::Option::None;
        self.statusAlreadyViewed = ::std::option::Option::None;
        self.messageSecret = ::std::option::Option::None;
        self.keepInChat.clear();
        self.originalSelfAuthorUserJidString = ::std::option::Option::None;
        self.revokeMessageTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebMessageInfo {
        static instance: WebMessageInfo = WebMessageInfo {
            key: ::protobuf::MessageField::none(),
            message: ::protobuf::MessageField::none(),
            messageTimestamp: ::std::option::Option::None,
            status: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            messageC2STimestamp: ::std::option::Option::None,
            ignore: ::std::option::Option::None,
            starred: ::std::option::Option::None,
            broadcast: ::std::option::Option::None,
            pushName: ::std::option::Option::None,
            mediaCiphertextSha256: ::std::option::Option::None,
            multicast: ::std::option::Option::None,
            urlText: ::std::option::Option::None,
            urlNumber: ::std::option::Option::None,
            messageStubType: ::std::option::Option::None,
            clearMedia: ::std::option::Option::None,
            messageStubParameters: ::std::vec::Vec::new(),
            duration: ::std::option::Option::None,
            labels: ::std::vec::Vec::new(),
            paymentInfo: ::protobuf::MessageField::none(),
            finalLiveLocation: ::protobuf::MessageField::none(),
            quotedPaymentInfo: ::protobuf::MessageField::none(),
            ephemeralStartTimestamp: ::std::option::Option::None,
            ephemeralDuration: ::std::option::Option::None,
            ephemeralOffToOn: ::std::option::Option::None,
            ephemeralOutOfSync: ::std::option::Option::None,
            bizPrivacyStatus: ::std::option::Option::None,
            verifiedBizName: ::std::option::Option::None,
            mediaData: ::protobuf::MessageField::none(),
            photoChange: ::protobuf::MessageField::none(),
            userReceipt: ::std::vec::Vec::new(),
            reactions: ::std::vec::Vec::new(),
            quotedStickerData: ::protobuf::MessageField::none(),
            futureproofData: ::std::option::Option::None,
            statusPsa: ::protobuf::MessageField::none(),
            pollUpdates: ::std::vec::Vec::new(),
            pollAdditionalMetadata: ::protobuf::MessageField::none(),
            agentId: ::std::option::Option::None,
            statusAlreadyViewed: ::std::option::Option::None,
            messageSecret: ::std::option::Option::None,
            keepInChat: ::protobuf::MessageField::none(),
            originalSelfAuthorUserJidString: ::std::option::Option::None,
            revokeMessageTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebMessageInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebMessageInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebMessageInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebMessageInfo`
pub mod web_message_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.WebMessageInfo.StubType)
    pub enum StubType {
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.REVOKE)
        REVOKE = 1,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CIPHERTEXT)
        CIPHERTEXT = 2,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.FUTUREPROOF)
        FUTUREPROOF = 3,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.NON_VERIFIED_TRANSITION)
        NON_VERIFIED_TRANSITION = 4,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.UNVERIFIED_TRANSITION)
        UNVERIFIED_TRANSITION = 5,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION)
        VERIFIED_TRANSITION = 6,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_LOW_UNKNOWN)
        VERIFIED_LOW_UNKNOWN = 7,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_HIGH)
        VERIFIED_HIGH = 8,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_INITIAL_UNKNOWN)
        VERIFIED_INITIAL_UNKNOWN = 9,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_INITIAL_LOW)
        VERIFIED_INITIAL_LOW = 10,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_INITIAL_HIGH)
        VERIFIED_INITIAL_HIGH = 11,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION_ANY_TO_NONE)
        VERIFIED_TRANSITION_ANY_TO_NONE = 12,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION_ANY_TO_HIGH)
        VERIFIED_TRANSITION_ANY_TO_HIGH = 13,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION_HIGH_TO_LOW)
        VERIFIED_TRANSITION_HIGH_TO_LOW = 14,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION_HIGH_TO_UNKNOWN)
        VERIFIED_TRANSITION_HIGH_TO_UNKNOWN = 15,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION_UNKNOWN_TO_LOW)
        VERIFIED_TRANSITION_UNKNOWN_TO_LOW = 16,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION_LOW_TO_UNKNOWN)
        VERIFIED_TRANSITION_LOW_TO_UNKNOWN = 17,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION_NONE_TO_LOW)
        VERIFIED_TRANSITION_NONE_TO_LOW = 18,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VERIFIED_TRANSITION_NONE_TO_UNKNOWN)
        VERIFIED_TRANSITION_NONE_TO_UNKNOWN = 19,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CREATE)
        GROUP_CREATE = 20,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CHANGE_SUBJECT)
        GROUP_CHANGE_SUBJECT = 21,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CHANGE_ICON)
        GROUP_CHANGE_ICON = 22,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CHANGE_INVITE_LINK)
        GROUP_CHANGE_INVITE_LINK = 23,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CHANGE_DESCRIPTION)
        GROUP_CHANGE_DESCRIPTION = 24,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CHANGE_RESTRICT)
        GROUP_CHANGE_RESTRICT = 25,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CHANGE_ANNOUNCE)
        GROUP_CHANGE_ANNOUNCE = 26,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_ADD)
        GROUP_PARTICIPANT_ADD = 27,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_REMOVE)
        GROUP_PARTICIPANT_REMOVE = 28,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_PROMOTE)
        GROUP_PARTICIPANT_PROMOTE = 29,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_DEMOTE)
        GROUP_PARTICIPANT_DEMOTE = 30,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_INVITE)
        GROUP_PARTICIPANT_INVITE = 31,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_LEAVE)
        GROUP_PARTICIPANT_LEAVE = 32,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_CHANGE_NUMBER)
        GROUP_PARTICIPANT_CHANGE_NUMBER = 33,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BROADCAST_CREATE)
        BROADCAST_CREATE = 34,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BROADCAST_ADD)
        BROADCAST_ADD = 35,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BROADCAST_REMOVE)
        BROADCAST_REMOVE = 36,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GENERIC_NOTIFICATION)
        GENERIC_NOTIFICATION = 37,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.E2E_IDENTITY_CHANGED)
        E2E_IDENTITY_CHANGED = 38,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.E2E_ENCRYPTED)
        E2E_ENCRYPTED = 39,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CALL_MISSED_VOICE)
        CALL_MISSED_VOICE = 40,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CALL_MISSED_VIDEO)
        CALL_MISSED_VIDEO = 41,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.INDIVIDUAL_CHANGE_NUMBER)
        INDIVIDUAL_CHANGE_NUMBER = 42,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_DELETE)
        GROUP_DELETE = 43,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE)
        GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE = 44,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CALL_MISSED_GROUP_VOICE)
        CALL_MISSED_GROUP_VOICE = 45,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CALL_MISSED_GROUP_VIDEO)
        CALL_MISSED_GROUP_VIDEO = 46,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_CIPHERTEXT)
        PAYMENT_CIPHERTEXT = 47,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_FUTUREPROOF)
        PAYMENT_FUTUREPROOF = 48,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED)
        PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED = 49,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED)
        PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED = 50,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED)
        PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED = 51,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP)
        PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP = 52,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP)
        PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP = 53,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER)
        PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER = 54,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_ACTION_SEND_PAYMENT_REMINDER)
        PAYMENT_ACTION_SEND_PAYMENT_REMINDER = 55,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_ACTION_SEND_PAYMENT_INVITATION)
        PAYMENT_ACTION_SEND_PAYMENT_INVITATION = 56,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_ACTION_REQUEST_DECLINED)
        PAYMENT_ACTION_REQUEST_DECLINED = 57,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_ACTION_REQUEST_EXPIRED)
        PAYMENT_ACTION_REQUEST_EXPIRED = 58,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.PAYMENT_ACTION_REQUEST_CANCELLED)
        PAYMENT_ACTION_REQUEST_CANCELLED = 59,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM)
        BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM = 60,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP)
        BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP = 61,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_INTRO_TOP)
        BIZ_INTRO_TOP = 62,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_INTRO_BOTTOM)
        BIZ_INTRO_BOTTOM = 63,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_NAME_CHANGE)
        BIZ_NAME_CHANGE = 64,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_MOVE_TO_CONSUMER_APP)
        BIZ_MOVE_TO_CONSUMER_APP = 65,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_TWO_TIER_MIGRATION_TOP)
        BIZ_TWO_TIER_MIGRATION_TOP = 66,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_TWO_TIER_MIGRATION_BOTTOM)
        BIZ_TWO_TIER_MIGRATION_BOTTOM = 67,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.OVERSIZED)
        OVERSIZED = 68,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CHANGE_NO_FREQUENTLY_FORWARDED)
        GROUP_CHANGE_NO_FREQUENTLY_FORWARDED = 69,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_V4_ADD_INVITE_SENT)
        GROUP_V4_ADD_INVITE_SENT = 70,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_ADD_REQUEST_JOIN)
        GROUP_PARTICIPANT_ADD_REQUEST_JOIN = 71,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CHANGE_EPHEMERAL_SETTING)
        CHANGE_EPHEMERAL_SETTING = 72,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.E2E_DEVICE_CHANGED)
        E2E_DEVICE_CHANGED = 73,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.VIEWED_ONCE)
        VIEWED_ONCE = 74,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.E2E_ENCRYPTED_NOW)
        E2E_ENCRYPTED_NOW = 75,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_TO_BSP_PREMISE)
        BLUE_MSG_BSP_FB_TO_BSP_PREMISE = 76,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_TO_SELF_FB)
        BLUE_MSG_BSP_FB_TO_SELF_FB = 77,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_TO_SELF_PREMISE)
        BLUE_MSG_BSP_FB_TO_SELF_PREMISE = 78,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_UNVERIFIED)
        BLUE_MSG_BSP_FB_UNVERIFIED = 79,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED)
        BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 80,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_VERIFIED)
        BLUE_MSG_BSP_FB_VERIFIED = 81,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 82,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE)
        BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE = 83,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_BSP_PREMISE_UNVERIFIED = 84,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED)
        BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 85,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_PREMISE_VERIFIED)
        BLUE_MSG_BSP_PREMISE_VERIFIED = 86,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 87,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED)
        BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED = 88,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED = 89,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED)
        BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED = 90,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED = 91,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_FB_TO_BSP_PREMISE)
        BLUE_MSG_SELF_FB_TO_BSP_PREMISE = 92,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_FB_TO_SELF_PREMISE)
        BLUE_MSG_SELF_FB_TO_SELF_PREMISE = 93,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_FB_UNVERIFIED)
        BLUE_MSG_SELF_FB_UNVERIFIED = 94,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED)
        BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED = 95,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_FB_VERIFIED)
        BLUE_MSG_SELF_FB_VERIFIED = 96,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED = 97,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE)
        BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE = 98,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_PREMISE_UNVERIFIED)
        BLUE_MSG_SELF_PREMISE_UNVERIFIED = 99,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_PREMISE_VERIFIED)
        BLUE_MSG_SELF_PREMISE_VERIFIED = 100,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_TO_BSP_FB)
        BLUE_MSG_TO_BSP_FB = 101,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_TO_CONSUMER)
        BLUE_MSG_TO_CONSUMER = 102,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_TO_SELF_FB)
        BLUE_MSG_TO_SELF_FB = 103,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED)
        BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED = 104,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED)
        BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 105,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED)
        BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED = 106,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_UNVERIFIED_TO_VERIFIED)
        BLUE_MSG_UNVERIFIED_TO_VERIFIED = 107,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED)
        BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED = 108,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 109,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED)
        BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED = 110,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_VERIFIED_TO_UNVERIFIED)
        BLUE_MSG_VERIFIED_TO_UNVERIFIED = 111,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED)
        BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 112,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED)
        BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED = 113,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 114,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED)
        BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED = 115,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED)
        BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED = 116,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED)
        BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED = 117,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.E2E_IDENTITY_UNAVAILABLE)
        E2E_IDENTITY_UNAVAILABLE = 118,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CREATING)
        GROUP_CREATING = 119,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_CREATE_FAILED)
        GROUP_CREATE_FAILED = 120,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_BOUNCED)
        GROUP_BOUNCED = 121,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BLOCK_CONTACT)
        BLOCK_CONTACT = 122,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.EPHEMERAL_SETTING_NOT_APPLIED)
        EPHEMERAL_SETTING_NOT_APPLIED = 123,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.SYNC_FAILED)
        SYNC_FAILED = 124,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.SYNCING)
        SYNCING = 125,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_PRIVACY_MODE_INIT_FB)
        BIZ_PRIVACY_MODE_INIT_FB = 126,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_PRIVACY_MODE_INIT_BSP)
        BIZ_PRIVACY_MODE_INIT_BSP = 127,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_PRIVACY_MODE_TO_FB)
        BIZ_PRIVACY_MODE_TO_FB = 128,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_PRIVACY_MODE_TO_BSP)
        BIZ_PRIVACY_MODE_TO_BSP = 129,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.DISAPPEARING_MODE)
        DISAPPEARING_MODE = 130,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.E2E_DEVICE_FETCH_FAILED)
        E2E_DEVICE_FETCH_FAILED = 131,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.ADMIN_REVOKE)
        ADMIN_REVOKE = 132,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_INVITE_LINK_GROWTH_LOCKED)
        GROUP_INVITE_LINK_GROWTH_LOCKED = 133,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_LINK_PARENT_GROUP)
        COMMUNITY_LINK_PARENT_GROUP = 134,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_LINK_SIBLING_GROUP)
        COMMUNITY_LINK_SIBLING_GROUP = 135,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_LINK_SUB_GROUP)
        COMMUNITY_LINK_SUB_GROUP = 136,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_UNLINK_PARENT_GROUP)
        COMMUNITY_UNLINK_PARENT_GROUP = 137,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_UNLINK_SIBLING_GROUP)
        COMMUNITY_UNLINK_SIBLING_GROUP = 138,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_UNLINK_SUB_GROUP)
        COMMUNITY_UNLINK_SUB_GROUP = 139,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_ACCEPT)
        GROUP_PARTICIPANT_ACCEPT = 140,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_LINKED_GROUP_JOIN)
        GROUP_PARTICIPANT_LINKED_GROUP_JOIN = 141,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_CREATE)
        COMMUNITY_CREATE = 142,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.EPHEMERAL_KEEP_IN_CHAT)
        EPHEMERAL_KEEP_IN_CHAT = 143,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST)
        GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST = 144,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE)
        GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE = 145,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.INTEGRITY_UNLINK_PARENT_GROUP)
        INTEGRITY_UNLINK_PARENT_GROUP = 146,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_PARTICIPANT_PROMOTE)
        COMMUNITY_PARTICIPANT_PROMOTE = 147,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_PARTICIPANT_DEMOTE)
        COMMUNITY_PARTICIPANT_DEMOTE = 148,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_PARENT_GROUP_DELETED)
        COMMUNITY_PARENT_GROUP_DELETED = 149,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL)
        COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL = 150,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP)
        GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP = 151,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.MASKED_THREAD_CREATED)
        MASKED_THREAD_CREATED = 152,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.MASKED_THREAD_UNMASKED)
        MASKED_THREAD_UNMASKED = 153,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_CHAT_ASSIGNMENT)
        BIZ_CHAT_ASSIGNMENT = 154,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CHAT_PSA)
        CHAT_PSA = 155,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CHAT_POLL_CREATION_MESSAGE)
        CHAT_POLL_CREATION_MESSAGE = 156,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CAG_MASKED_THREAD_CREATED)
        CAG_MASKED_THREAD_CREATED = 157,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED)
        COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED = 158,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CAG_INVITE_AUTO_ADD)
        CAG_INVITE_AUTO_ADD = 159,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.BIZ_CHAT_ASSIGNMENT_UNASSIGN)
        BIZ_CHAT_ASSIGNMENT_UNASSIGN = 160,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.StubType.CAG_INVITE_AUTO_JOINED)
        CAG_INVITE_AUTO_JOINED = 161,
    }

    impl ::protobuf::Enum for StubType {
        const NAME: &'static str = "StubType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<StubType> {
            match value {
                0 => ::std::option::Option::Some(StubType::UNKNOWN),
                1 => ::std::option::Option::Some(StubType::REVOKE),
                2 => ::std::option::Option::Some(StubType::CIPHERTEXT),
                3 => ::std::option::Option::Some(StubType::FUTUREPROOF),
                4 => ::std::option::Option::Some(StubType::NON_VERIFIED_TRANSITION),
                5 => ::std::option::Option::Some(StubType::UNVERIFIED_TRANSITION),
                6 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION),
                7 => ::std::option::Option::Some(StubType::VERIFIED_LOW_UNKNOWN),
                8 => ::std::option::Option::Some(StubType::VERIFIED_HIGH),
                9 => ::std::option::Option::Some(StubType::VERIFIED_INITIAL_UNKNOWN),
                10 => ::std::option::Option::Some(StubType::VERIFIED_INITIAL_LOW),
                11 => ::std::option::Option::Some(StubType::VERIFIED_INITIAL_HIGH),
                12 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION_ANY_TO_NONE),
                13 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION_ANY_TO_HIGH),
                14 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION_HIGH_TO_LOW),
                15 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION_HIGH_TO_UNKNOWN),
                16 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION_UNKNOWN_TO_LOW),
                17 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION_LOW_TO_UNKNOWN),
                18 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION_NONE_TO_LOW),
                19 => ::std::option::Option::Some(StubType::VERIFIED_TRANSITION_NONE_TO_UNKNOWN),
                20 => ::std::option::Option::Some(StubType::GROUP_CREATE),
                21 => ::std::option::Option::Some(StubType::GROUP_CHANGE_SUBJECT),
                22 => ::std::option::Option::Some(StubType::GROUP_CHANGE_ICON),
                23 => ::std::option::Option::Some(StubType::GROUP_CHANGE_INVITE_LINK),
                24 => ::std::option::Option::Some(StubType::GROUP_CHANGE_DESCRIPTION),
                25 => ::std::option::Option::Some(StubType::GROUP_CHANGE_RESTRICT),
                26 => ::std::option::Option::Some(StubType::GROUP_CHANGE_ANNOUNCE),
                27 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_ADD),
                28 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_REMOVE),
                29 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_PROMOTE),
                30 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_DEMOTE),
                31 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_INVITE),
                32 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_LEAVE),
                33 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_CHANGE_NUMBER),
                34 => ::std::option::Option::Some(StubType::BROADCAST_CREATE),
                35 => ::std::option::Option::Some(StubType::BROADCAST_ADD),
                36 => ::std::option::Option::Some(StubType::BROADCAST_REMOVE),
                37 => ::std::option::Option::Some(StubType::GENERIC_NOTIFICATION),
                38 => ::std::option::Option::Some(StubType::E2E_IDENTITY_CHANGED),
                39 => ::std::option::Option::Some(StubType::E2E_ENCRYPTED),
                40 => ::std::option::Option::Some(StubType::CALL_MISSED_VOICE),
                41 => ::std::option::Option::Some(StubType::CALL_MISSED_VIDEO),
                42 => ::std::option::Option::Some(StubType::INDIVIDUAL_CHANGE_NUMBER),
                43 => ::std::option::Option::Some(StubType::GROUP_DELETE),
                44 => ::std::option::Option::Some(StubType::GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE),
                45 => ::std::option::Option::Some(StubType::CALL_MISSED_GROUP_VOICE),
                46 => ::std::option::Option::Some(StubType::CALL_MISSED_GROUP_VIDEO),
                47 => ::std::option::Option::Some(StubType::PAYMENT_CIPHERTEXT),
                48 => ::std::option::Option::Some(StubType::PAYMENT_FUTUREPROOF),
                49 => ::std::option::Option::Some(StubType::PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED),
                50 => ::std::option::Option::Some(StubType::PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED),
                51 => ::std::option::Option::Some(StubType::PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED),
                52 => ::std::option::Option::Some(StubType::PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP),
                53 => ::std::option::Option::Some(StubType::PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP),
                54 => ::std::option::Option::Some(StubType::PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER),
                55 => ::std::option::Option::Some(StubType::PAYMENT_ACTION_SEND_PAYMENT_REMINDER),
                56 => ::std::option::Option::Some(StubType::PAYMENT_ACTION_SEND_PAYMENT_INVITATION),
                57 => ::std::option::Option::Some(StubType::PAYMENT_ACTION_REQUEST_DECLINED),
                58 => ::std::option::Option::Some(StubType::PAYMENT_ACTION_REQUEST_EXPIRED),
                59 => ::std::option::Option::Some(StubType::PAYMENT_ACTION_REQUEST_CANCELLED),
                60 => ::std::option::Option::Some(StubType::BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM),
                61 => ::std::option::Option::Some(StubType::BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP),
                62 => ::std::option::Option::Some(StubType::BIZ_INTRO_TOP),
                63 => ::std::option::Option::Some(StubType::BIZ_INTRO_BOTTOM),
                64 => ::std::option::Option::Some(StubType::BIZ_NAME_CHANGE),
                65 => ::std::option::Option::Some(StubType::BIZ_MOVE_TO_CONSUMER_APP),
                66 => ::std::option::Option::Some(StubType::BIZ_TWO_TIER_MIGRATION_TOP),
                67 => ::std::option::Option::Some(StubType::BIZ_TWO_TIER_MIGRATION_BOTTOM),
                68 => ::std::option::Option::Some(StubType::OVERSIZED),
                69 => ::std::option::Option::Some(StubType::GROUP_CHANGE_NO_FREQUENTLY_FORWARDED),
                70 => ::std::option::Option::Some(StubType::GROUP_V4_ADD_INVITE_SENT),
                71 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_ADD_REQUEST_JOIN),
                72 => ::std::option::Option::Some(StubType::CHANGE_EPHEMERAL_SETTING),
                73 => ::std::option::Option::Some(StubType::E2E_DEVICE_CHANGED),
                74 => ::std::option::Option::Some(StubType::VIEWED_ONCE),
                75 => ::std::option::Option::Some(StubType::E2E_ENCRYPTED_NOW),
                76 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_TO_BSP_PREMISE),
                77 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_TO_SELF_FB),
                78 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_TO_SELF_PREMISE),
                79 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_UNVERIFIED),
                80 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED),
                81 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_VERIFIED),
                82 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED),
                83 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE),
                84 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_PREMISE_UNVERIFIED),
                85 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED),
                86 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_PREMISE_VERIFIED),
                87 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED),
                88 => ::std::option::Option::Some(StubType::BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED),
                89 => ::std::option::Option::Some(StubType::BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED),
                90 => ::std::option::Option::Some(StubType::BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED),
                91 => ::std::option::Option::Some(StubType::BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED),
                92 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_FB_TO_BSP_PREMISE),
                93 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_FB_TO_SELF_PREMISE),
                94 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_FB_UNVERIFIED),
                95 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED),
                96 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_FB_VERIFIED),
                97 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED),
                98 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE),
                99 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_PREMISE_UNVERIFIED),
                100 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_PREMISE_VERIFIED),
                101 => ::std::option::Option::Some(StubType::BLUE_MSG_TO_BSP_FB),
                102 => ::std::option::Option::Some(StubType::BLUE_MSG_TO_CONSUMER),
                103 => ::std::option::Option::Some(StubType::BLUE_MSG_TO_SELF_FB),
                104 => ::std::option::Option::Some(StubType::BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED),
                105 => ::std::option::Option::Some(StubType::BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED),
                106 => ::std::option::Option::Some(StubType::BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED),
                107 => ::std::option::Option::Some(StubType::BLUE_MSG_UNVERIFIED_TO_VERIFIED),
                108 => ::std::option::Option::Some(StubType::BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED),
                109 => ::std::option::Option::Some(StubType::BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED),
                110 => ::std::option::Option::Some(StubType::BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED),
                111 => ::std::option::Option::Some(StubType::BLUE_MSG_VERIFIED_TO_UNVERIFIED),
                112 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED),
                113 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED),
                114 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED),
                115 => ::std::option::Option::Some(StubType::BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED),
                116 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED),
                117 => ::std::option::Option::Some(StubType::BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED),
                118 => ::std::option::Option::Some(StubType::E2E_IDENTITY_UNAVAILABLE),
                119 => ::std::option::Option::Some(StubType::GROUP_CREATING),
                120 => ::std::option::Option::Some(StubType::GROUP_CREATE_FAILED),
                121 => ::std::option::Option::Some(StubType::GROUP_BOUNCED),
                122 => ::std::option::Option::Some(StubType::BLOCK_CONTACT),
                123 => ::std::option::Option::Some(StubType::EPHEMERAL_SETTING_NOT_APPLIED),
                124 => ::std::option::Option::Some(StubType::SYNC_FAILED),
                125 => ::std::option::Option::Some(StubType::SYNCING),
                126 => ::std::option::Option::Some(StubType::BIZ_PRIVACY_MODE_INIT_FB),
                127 => ::std::option::Option::Some(StubType::BIZ_PRIVACY_MODE_INIT_BSP),
                128 => ::std::option::Option::Some(StubType::BIZ_PRIVACY_MODE_TO_FB),
                129 => ::std::option::Option::Some(StubType::BIZ_PRIVACY_MODE_TO_BSP),
                130 => ::std::option::Option::Some(StubType::DISAPPEARING_MODE),
                131 => ::std::option::Option::Some(StubType::E2E_DEVICE_FETCH_FAILED),
                132 => ::std::option::Option::Some(StubType::ADMIN_REVOKE),
                133 => ::std::option::Option::Some(StubType::GROUP_INVITE_LINK_GROWTH_LOCKED),
                134 => ::std::option::Option::Some(StubType::COMMUNITY_LINK_PARENT_GROUP),
                135 => ::std::option::Option::Some(StubType::COMMUNITY_LINK_SIBLING_GROUP),
                136 => ::std::option::Option::Some(StubType::COMMUNITY_LINK_SUB_GROUP),
                137 => ::std::option::Option::Some(StubType::COMMUNITY_UNLINK_PARENT_GROUP),
                138 => ::std::option::Option::Some(StubType::COMMUNITY_UNLINK_SIBLING_GROUP),
                139 => ::std::option::Option::Some(StubType::COMMUNITY_UNLINK_SUB_GROUP),
                140 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_ACCEPT),
                141 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_LINKED_GROUP_JOIN),
                142 => ::std::option::Option::Some(StubType::COMMUNITY_CREATE),
                143 => ::std::option::Option::Some(StubType::EPHEMERAL_KEEP_IN_CHAT),
                144 => ::std::option::Option::Some(StubType::GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST),
                145 => ::std::option::Option::Some(StubType::GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE),
                146 => ::std::option::Option::Some(StubType::INTEGRITY_UNLINK_PARENT_GROUP),
                147 => ::std::option::Option::Some(StubType::COMMUNITY_PARTICIPANT_PROMOTE),
                148 => ::std::option::Option::Some(StubType::COMMUNITY_PARTICIPANT_DEMOTE),
                149 => ::std::option::Option::Some(StubType::COMMUNITY_PARENT_GROUP_DELETED),
                150 => ::std::option::Option::Some(StubType::COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL),
                151 => ::std::option::Option::Some(StubType::GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP),
                152 => ::std::option::Option::Some(StubType::MASKED_THREAD_CREATED),
                153 => ::std::option::Option::Some(StubType::MASKED_THREAD_UNMASKED),
                154 => ::std::option::Option::Some(StubType::BIZ_CHAT_ASSIGNMENT),
                155 => ::std::option::Option::Some(StubType::CHAT_PSA),
                156 => ::std::option::Option::Some(StubType::CHAT_POLL_CREATION_MESSAGE),
                157 => ::std::option::Option::Some(StubType::CAG_MASKED_THREAD_CREATED),
                158 => ::std::option::Option::Some(StubType::COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED),
                159 => ::std::option::Option::Some(StubType::CAG_INVITE_AUTO_ADD),
                160 => ::std::option::Option::Some(StubType::BIZ_CHAT_ASSIGNMENT_UNASSIGN),
                161 => ::std::option::Option::Some(StubType::CAG_INVITE_AUTO_JOINED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [StubType] = &[
            StubType::UNKNOWN,
            StubType::REVOKE,
            StubType::CIPHERTEXT,
            StubType::FUTUREPROOF,
            StubType::NON_VERIFIED_TRANSITION,
            StubType::UNVERIFIED_TRANSITION,
            StubType::VERIFIED_TRANSITION,
            StubType::VERIFIED_LOW_UNKNOWN,
            StubType::VERIFIED_HIGH,
            StubType::VERIFIED_INITIAL_UNKNOWN,
            StubType::VERIFIED_INITIAL_LOW,
            StubType::VERIFIED_INITIAL_HIGH,
            StubType::VERIFIED_TRANSITION_ANY_TO_NONE,
            StubType::VERIFIED_TRANSITION_ANY_TO_HIGH,
            StubType::VERIFIED_TRANSITION_HIGH_TO_LOW,
            StubType::VERIFIED_TRANSITION_HIGH_TO_UNKNOWN,
            StubType::VERIFIED_TRANSITION_UNKNOWN_TO_LOW,
            StubType::VERIFIED_TRANSITION_LOW_TO_UNKNOWN,
            StubType::VERIFIED_TRANSITION_NONE_TO_LOW,
            StubType::VERIFIED_TRANSITION_NONE_TO_UNKNOWN,
            StubType::GROUP_CREATE,
            StubType::GROUP_CHANGE_SUBJECT,
            StubType::GROUP_CHANGE_ICON,
            StubType::GROUP_CHANGE_INVITE_LINK,
            StubType::GROUP_CHANGE_DESCRIPTION,
            StubType::GROUP_CHANGE_RESTRICT,
            StubType::GROUP_CHANGE_ANNOUNCE,
            StubType::GROUP_PARTICIPANT_ADD,
            StubType::GROUP_PARTICIPANT_REMOVE,
            StubType::GROUP_PARTICIPANT_PROMOTE,
            StubType::GROUP_PARTICIPANT_DEMOTE,
            StubType::GROUP_PARTICIPANT_INVITE,
            StubType::GROUP_PARTICIPANT_LEAVE,
            StubType::GROUP_PARTICIPANT_CHANGE_NUMBER,
            StubType::BROADCAST_CREATE,
            StubType::BROADCAST_ADD,
            StubType::BROADCAST_REMOVE,
            StubType::GENERIC_NOTIFICATION,
            StubType::E2E_IDENTITY_CHANGED,
            StubType::E2E_ENCRYPTED,
            StubType::CALL_MISSED_VOICE,
            StubType::CALL_MISSED_VIDEO,
            StubType::INDIVIDUAL_CHANGE_NUMBER,
            StubType::GROUP_DELETE,
            StubType::GROUP_ANNOUNCE_MODE_MESSAGE_BOUNCE,
            StubType::CALL_MISSED_GROUP_VOICE,
            StubType::CALL_MISSED_GROUP_VIDEO,
            StubType::PAYMENT_CIPHERTEXT,
            StubType::PAYMENT_FUTUREPROOF,
            StubType::PAYMENT_TRANSACTION_STATUS_UPDATE_FAILED,
            StubType::PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED,
            StubType::PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED,
            StubType::PAYMENT_TRANSACTION_STATUS_RECEIVER_PENDING_SETUP,
            StubType::PAYMENT_TRANSACTION_STATUS_RECEIVER_SUCCESS_AFTER_HICCUP,
            StubType::PAYMENT_ACTION_ACCOUNT_SETUP_REMINDER,
            StubType::PAYMENT_ACTION_SEND_PAYMENT_REMINDER,
            StubType::PAYMENT_ACTION_SEND_PAYMENT_INVITATION,
            StubType::PAYMENT_ACTION_REQUEST_DECLINED,
            StubType::PAYMENT_ACTION_REQUEST_EXPIRED,
            StubType::PAYMENT_ACTION_REQUEST_CANCELLED,
            StubType::BIZ_VERIFIED_TRANSITION_TOP_TO_BOTTOM,
            StubType::BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP,
            StubType::BIZ_INTRO_TOP,
            StubType::BIZ_INTRO_BOTTOM,
            StubType::BIZ_NAME_CHANGE,
            StubType::BIZ_MOVE_TO_CONSUMER_APP,
            StubType::BIZ_TWO_TIER_MIGRATION_TOP,
            StubType::BIZ_TWO_TIER_MIGRATION_BOTTOM,
            StubType::OVERSIZED,
            StubType::GROUP_CHANGE_NO_FREQUENTLY_FORWARDED,
            StubType::GROUP_V4_ADD_INVITE_SENT,
            StubType::GROUP_PARTICIPANT_ADD_REQUEST_JOIN,
            StubType::CHANGE_EPHEMERAL_SETTING,
            StubType::E2E_DEVICE_CHANGED,
            StubType::VIEWED_ONCE,
            StubType::E2E_ENCRYPTED_NOW,
            StubType::BLUE_MSG_BSP_FB_TO_BSP_PREMISE,
            StubType::BLUE_MSG_BSP_FB_TO_SELF_FB,
            StubType::BLUE_MSG_BSP_FB_TO_SELF_PREMISE,
            StubType::BLUE_MSG_BSP_FB_UNVERIFIED,
            StubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED,
            StubType::BLUE_MSG_BSP_FB_VERIFIED,
            StubType::BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_BSP_PREMISE_TO_SELF_PREMISE,
            StubType::BLUE_MSG_BSP_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED,
            StubType::BLUE_MSG_BSP_PREMISE_VERIFIED,
            StubType::BLUE_MSG_BSP_PREMISE_VERIFIED_TO_SELF_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_CONSUMER_TO_BSP_FB_UNVERIFIED,
            StubType::BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED,
            StubType::BLUE_MSG_CONSUMER_TO_SELF_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_SELF_FB_TO_BSP_PREMISE,
            StubType::BLUE_MSG_SELF_FB_TO_SELF_PREMISE,
            StubType::BLUE_MSG_SELF_FB_UNVERIFIED,
            StubType::BLUE_MSG_SELF_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED,
            StubType::BLUE_MSG_SELF_FB_VERIFIED,
            StubType::BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_SELF_PREMISE_TO_BSP_PREMISE,
            StubType::BLUE_MSG_SELF_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_SELF_PREMISE_VERIFIED,
            StubType::BLUE_MSG_TO_BSP_FB,
            StubType::BLUE_MSG_TO_CONSUMER,
            StubType::BLUE_MSG_TO_SELF_FB,
            StubType::BLUE_MSG_UNVERIFIED_TO_BSP_FB_VERIFIED,
            StubType::BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED,
            StubType::BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED,
            StubType::BLUE_MSG_UNVERIFIED_TO_VERIFIED,
            StubType::BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIED,
            StubType::BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED,
            StubType::BLUE_MSG_VERIFIED_TO_UNVERIFIED,
            StubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED,
            StubType::BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED,
            StubType::BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED,
            StubType::BLUE_MSG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED,
            StubType::BLUE_MSG_SELF_FB_UNVERIFIED_TO_BSP_PREMISE_VERIFIED,
            StubType::BLUE_MSG_SELF_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED,
            StubType::E2E_IDENTITY_UNAVAILABLE,
            StubType::GROUP_CREATING,
            StubType::GROUP_CREATE_FAILED,
            StubType::GROUP_BOUNCED,
            StubType::BLOCK_CONTACT,
            StubType::EPHEMERAL_SETTING_NOT_APPLIED,
            StubType::SYNC_FAILED,
            StubType::SYNCING,
            StubType::BIZ_PRIVACY_MODE_INIT_FB,
            StubType::BIZ_PRIVACY_MODE_INIT_BSP,
            StubType::BIZ_PRIVACY_MODE_TO_FB,
            StubType::BIZ_PRIVACY_MODE_TO_BSP,
            StubType::DISAPPEARING_MODE,
            StubType::E2E_DEVICE_FETCH_FAILED,
            StubType::ADMIN_REVOKE,
            StubType::GROUP_INVITE_LINK_GROWTH_LOCKED,
            StubType::COMMUNITY_LINK_PARENT_GROUP,
            StubType::COMMUNITY_LINK_SIBLING_GROUP,
            StubType::COMMUNITY_LINK_SUB_GROUP,
            StubType::COMMUNITY_UNLINK_PARENT_GROUP,
            StubType::COMMUNITY_UNLINK_SIBLING_GROUP,
            StubType::COMMUNITY_UNLINK_SUB_GROUP,
            StubType::GROUP_PARTICIPANT_ACCEPT,
            StubType::GROUP_PARTICIPANT_LINKED_GROUP_JOIN,
            StubType::COMMUNITY_CREATE,
            StubType::EPHEMERAL_KEEP_IN_CHAT,
            StubType::GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST,
            StubType::GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE,
            StubType::INTEGRITY_UNLINK_PARENT_GROUP,
            StubType::COMMUNITY_PARTICIPANT_PROMOTE,
            StubType::COMMUNITY_PARTICIPANT_DEMOTE,
            StubType::COMMUNITY_PARENT_GROUP_DELETED,
            StubType::COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL,
            StubType::GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP,
            StubType::MASKED_THREAD_CREATED,
            StubType::MASKED_THREAD_UNMASKED,
            StubType::BIZ_CHAT_ASSIGNMENT,
            StubType::CHAT_PSA,
            StubType::CHAT_POLL_CREATION_MESSAGE,
            StubType::CAG_MASKED_THREAD_CREATED,
            StubType::COMMUNITY_PARENT_GROUP_SUBJECT_CHANGED,
            StubType::CAG_INVITE_AUTO_ADD,
            StubType::BIZ_CHAT_ASSIGNMENT_UNASSIGN,
            StubType::CAG_INVITE_AUTO_JOINED,
        ];
    }

    impl ::protobuf::EnumFull for StubType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebMessageInfo.StubType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for StubType {
        fn default() -> Self {
            StubType::UNKNOWN
        }
    }

    impl StubType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StubType>("WebMessageInfo.StubType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.WebMessageInfo.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.Status.ERROR)
        ERROR = 0,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.Status.PENDING)
        PENDING = 1,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.Status.SERVER_ACK)
        SERVER_ACK = 2,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.Status.DELIVERY_ACK)
        DELIVERY_ACK = 3,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.Status.READ)
        READ = 4,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.Status.PLAYED)
        PLAYED = 5,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::ERROR),
                1 => ::std::option::Option::Some(Status::PENDING),
                2 => ::std::option::Option::Some(Status::SERVER_ACK),
                3 => ::std::option::Option::Some(Status::DELIVERY_ACK),
                4 => ::std::option::Option::Some(Status::READ),
                5 => ::std::option::Option::Some(Status::PLAYED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::ERROR,
            Status::PENDING,
            Status::SERVER_ACK,
            Status::DELIVERY_ACK,
            Status::READ,
            Status::PLAYED,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebMessageInfo.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::ERROR
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("WebMessageInfo.Status")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.WebMessageInfo.BizPrivacyStatus)
    pub enum BizPrivacyStatus {
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.BizPrivacyStatus.E2EE)
        E2EE = 0,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.BizPrivacyStatus.FB)
        FB = 2,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.BizPrivacyStatus.BSP)
        BSP = 1,
        // @@protoc_insertion_point(enum_value:proto.WebMessageInfo.BizPrivacyStatus.BSP_AND_FB)
        BSP_AND_FB = 3,
    }

    impl ::protobuf::Enum for BizPrivacyStatus {
        const NAME: &'static str = "BizPrivacyStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BizPrivacyStatus> {
            match value {
                0 => ::std::option::Option::Some(BizPrivacyStatus::E2EE),
                2 => ::std::option::Option::Some(BizPrivacyStatus::FB),
                1 => ::std::option::Option::Some(BizPrivacyStatus::BSP),
                3 => ::std::option::Option::Some(BizPrivacyStatus::BSP_AND_FB),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BizPrivacyStatus] = &[
            BizPrivacyStatus::E2EE,
            BizPrivacyStatus::FB,
            BizPrivacyStatus::BSP,
            BizPrivacyStatus::BSP_AND_FB,
        ];
    }

    impl ::protobuf::EnumFull for BizPrivacyStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebMessageInfo.BizPrivacyStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                BizPrivacyStatus::E2EE => 0,
                BizPrivacyStatus::FB => 1,
                BizPrivacyStatus::BSP => 2,
                BizPrivacyStatus::BSP_AND_FB => 3,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BizPrivacyStatus {
        fn default() -> Self {
            BizPrivacyStatus::E2EE
        }
    }

    impl BizPrivacyStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BizPrivacyStatus>("WebMessageInfo.BizPrivacyStatus")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.WebFeatures)
pub struct WebFeatures {
    // message fields
    // @@protoc_insertion_point(field:proto.WebFeatures.labelsDisplay)
    pub labelsDisplay: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.voipIndividualOutgoing)
    pub voipIndividualOutgoing: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.groupsV3)
    pub groupsV3: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.groupsV3Create)
    pub groupsV3Create: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.changeNumberV2)
    pub changeNumberV2: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.queryStatusV3Thumbnail)
    pub queryStatusV3Thumbnail: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.liveLocations)
    pub liveLocations: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.queryVname)
    pub queryVname: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.voipIndividualIncoming)
    pub voipIndividualIncoming: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.quickRepliesQuery)
    pub quickRepliesQuery: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.payments)
    pub payments: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.stickerPackQuery)
    pub stickerPackQuery: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.liveLocationsFinal)
    pub liveLocationsFinal: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.labelsEdit)
    pub labelsEdit: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.mediaUpload)
    pub mediaUpload: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.mediaUploadRichQuickReplies)
    pub mediaUploadRichQuickReplies: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.vnameV2)
    pub vnameV2: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.videoPlaybackUrl)
    pub videoPlaybackUrl: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.statusRanking)
    pub statusRanking: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.voipIndividualVideo)
    pub voipIndividualVideo: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.thirdPartyStickers)
    pub thirdPartyStickers: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.frequentlyForwardedSetting)
    pub frequentlyForwardedSetting: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.groupsV4JoinPermission)
    pub groupsV4JoinPermission: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.recentStickers)
    pub recentStickers: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.catalog)
    pub catalog: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.starredStickers)
    pub starredStickers: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.voipGroupCall)
    pub voipGroupCall: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.templateMessage)
    pub templateMessage: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.templateMessageInteractivity)
    pub templateMessageInteractivity: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.ephemeralMessages)
    pub ephemeralMessages: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.e2ENotificationSync)
    pub e2ENotificationSync: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.recentStickersV2)
    pub recentStickersV2: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.recentStickersV3)
    pub recentStickersV3: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.userNotice)
    pub userNotice: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.support)
    pub support: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.groupUiiCleanup)
    pub groupUiiCleanup: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.groupDogfoodingInternalOnly)
    pub groupDogfoodingInternalOnly: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.settingsSync)
    pub settingsSync: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.archiveV2)
    pub archiveV2: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.ephemeralAllowGroupMembers)
    pub ephemeralAllowGroupMembers: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.ephemeral24HDuration)
    pub ephemeral24HDuration: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.mdForceUpgrade)
    pub mdForceUpgrade: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.disappearingMode)
    pub disappearingMode: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.externalMdOptInAvailable)
    pub externalMdOptInAvailable: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // @@protoc_insertion_point(field:proto.WebFeatures.noDeleteMessageTimeLimit)
    pub noDeleteMessageTimeLimit: ::std::option::Option<::protobuf::EnumOrUnknown<web_features::Flag>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.WebFeatures.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WebFeatures {
    fn default() -> &'a WebFeatures {
        <WebFeatures as ::protobuf::Message>::default_instance()
    }
}

impl WebFeatures {
    pub fn new() -> WebFeatures {
        ::std::default::Default::default()
    }

    // optional .proto.WebFeatures.Flag labelsDisplay = 1;

    pub fn labelsDisplay(&self) -> web_features::Flag {
        match self.labelsDisplay {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_labelsDisplay(&mut self) {
        self.labelsDisplay = ::std::option::Option::None;
    }

    pub fn has_labelsDisplay(&self) -> bool {
        self.labelsDisplay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelsDisplay(&mut self, v: web_features::Flag) {
        self.labelsDisplay = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag voipIndividualOutgoing = 2;

    pub fn voipIndividualOutgoing(&self) -> web_features::Flag {
        match self.voipIndividualOutgoing {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_voipIndividualOutgoing(&mut self) {
        self.voipIndividualOutgoing = ::std::option::Option::None;
    }

    pub fn has_voipIndividualOutgoing(&self) -> bool {
        self.voipIndividualOutgoing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voipIndividualOutgoing(&mut self, v: web_features::Flag) {
        self.voipIndividualOutgoing = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag groupsV3 = 3;

    pub fn groupsV3(&self) -> web_features::Flag {
        match self.groupsV3 {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_groupsV3(&mut self) {
        self.groupsV3 = ::std::option::Option::None;
    }

    pub fn has_groupsV3(&self) -> bool {
        self.groupsV3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupsV3(&mut self, v: web_features::Flag) {
        self.groupsV3 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag groupsV3Create = 4;

    pub fn groupsV3Create(&self) -> web_features::Flag {
        match self.groupsV3Create {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_groupsV3Create(&mut self) {
        self.groupsV3Create = ::std::option::Option::None;
    }

    pub fn has_groupsV3Create(&self) -> bool {
        self.groupsV3Create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupsV3Create(&mut self, v: web_features::Flag) {
        self.groupsV3Create = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag changeNumberV2 = 5;

    pub fn changeNumberV2(&self) -> web_features::Flag {
        match self.changeNumberV2 {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_changeNumberV2(&mut self) {
        self.changeNumberV2 = ::std::option::Option::None;
    }

    pub fn has_changeNumberV2(&self) -> bool {
        self.changeNumberV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeNumberV2(&mut self, v: web_features::Flag) {
        self.changeNumberV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag queryStatusV3Thumbnail = 6;

    pub fn queryStatusV3Thumbnail(&self) -> web_features::Flag {
        match self.queryStatusV3Thumbnail {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_queryStatusV3Thumbnail(&mut self) {
        self.queryStatusV3Thumbnail = ::std::option::Option::None;
    }

    pub fn has_queryStatusV3Thumbnail(&self) -> bool {
        self.queryStatusV3Thumbnail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queryStatusV3Thumbnail(&mut self, v: web_features::Flag) {
        self.queryStatusV3Thumbnail = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag liveLocations = 7;

    pub fn liveLocations(&self) -> web_features::Flag {
        match self.liveLocations {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_liveLocations(&mut self) {
        self.liveLocations = ::std::option::Option::None;
    }

    pub fn has_liveLocations(&self) -> bool {
        self.liveLocations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_liveLocations(&mut self, v: web_features::Flag) {
        self.liveLocations = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag queryVname = 8;

    pub fn queryVname(&self) -> web_features::Flag {
        match self.queryVname {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_queryVname(&mut self) {
        self.queryVname = ::std::option::Option::None;
    }

    pub fn has_queryVname(&self) -> bool {
        self.queryVname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queryVname(&mut self, v: web_features::Flag) {
        self.queryVname = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag voipIndividualIncoming = 9;

    pub fn voipIndividualIncoming(&self) -> web_features::Flag {
        match self.voipIndividualIncoming {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_voipIndividualIncoming(&mut self) {
        self.voipIndividualIncoming = ::std::option::Option::None;
    }

    pub fn has_voipIndividualIncoming(&self) -> bool {
        self.voipIndividualIncoming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voipIndividualIncoming(&mut self, v: web_features::Flag) {
        self.voipIndividualIncoming = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag quickRepliesQuery = 10;

    pub fn quickRepliesQuery(&self) -> web_features::Flag {
        match self.quickRepliesQuery {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_quickRepliesQuery(&mut self) {
        self.quickRepliesQuery = ::std::option::Option::None;
    }

    pub fn has_quickRepliesQuery(&self) -> bool {
        self.quickRepliesQuery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quickRepliesQuery(&mut self, v: web_features::Flag) {
        self.quickRepliesQuery = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag payments = 11;

    pub fn payments(&self) -> web_features::Flag {
        match self.payments {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_payments(&mut self) {
        self.payments = ::std::option::Option::None;
    }

    pub fn has_payments(&self) -> bool {
        self.payments.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payments(&mut self, v: web_features::Flag) {
        self.payments = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag stickerPackQuery = 12;

    pub fn stickerPackQuery(&self) -> web_features::Flag {
        match self.stickerPackQuery {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_stickerPackQuery(&mut self) {
        self.stickerPackQuery = ::std::option::Option::None;
    }

    pub fn has_stickerPackQuery(&self) -> bool {
        self.stickerPackQuery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stickerPackQuery(&mut self, v: web_features::Flag) {
        self.stickerPackQuery = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag liveLocationsFinal = 13;

    pub fn liveLocationsFinal(&self) -> web_features::Flag {
        match self.liveLocationsFinal {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_liveLocationsFinal(&mut self) {
        self.liveLocationsFinal = ::std::option::Option::None;
    }

    pub fn has_liveLocationsFinal(&self) -> bool {
        self.liveLocationsFinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_liveLocationsFinal(&mut self, v: web_features::Flag) {
        self.liveLocationsFinal = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag labelsEdit = 14;

    pub fn labelsEdit(&self) -> web_features::Flag {
        match self.labelsEdit {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_labelsEdit(&mut self) {
        self.labelsEdit = ::std::option::Option::None;
    }

    pub fn has_labelsEdit(&self) -> bool {
        self.labelsEdit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelsEdit(&mut self, v: web_features::Flag) {
        self.labelsEdit = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag mediaUpload = 15;

    pub fn mediaUpload(&self) -> web_features::Flag {
        match self.mediaUpload {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_mediaUpload(&mut self) {
        self.mediaUpload = ::std::option::Option::None;
    }

    pub fn has_mediaUpload(&self) -> bool {
        self.mediaUpload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaUpload(&mut self, v: web_features::Flag) {
        self.mediaUpload = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag mediaUploadRichQuickReplies = 18;

    pub fn mediaUploadRichQuickReplies(&self) -> web_features::Flag {
        match self.mediaUploadRichQuickReplies {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_mediaUploadRichQuickReplies(&mut self) {
        self.mediaUploadRichQuickReplies = ::std::option::Option::None;
    }

    pub fn has_mediaUploadRichQuickReplies(&self) -> bool {
        self.mediaUploadRichQuickReplies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mediaUploadRichQuickReplies(&mut self, v: web_features::Flag) {
        self.mediaUploadRichQuickReplies = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag vnameV2 = 19;

    pub fn vnameV2(&self) -> web_features::Flag {
        match self.vnameV2 {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_vnameV2(&mut self) {
        self.vnameV2 = ::std::option::Option::None;
    }

    pub fn has_vnameV2(&self) -> bool {
        self.vnameV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vnameV2(&mut self, v: web_features::Flag) {
        self.vnameV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag videoPlaybackUrl = 20;

    pub fn videoPlaybackUrl(&self) -> web_features::Flag {
        match self.videoPlaybackUrl {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_videoPlaybackUrl(&mut self) {
        self.videoPlaybackUrl = ::std::option::Option::None;
    }

    pub fn has_videoPlaybackUrl(&self) -> bool {
        self.videoPlaybackUrl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_videoPlaybackUrl(&mut self, v: web_features::Flag) {
        self.videoPlaybackUrl = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag statusRanking = 21;

    pub fn statusRanking(&self) -> web_features::Flag {
        match self.statusRanking {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_statusRanking(&mut self) {
        self.statusRanking = ::std::option::Option::None;
    }

    pub fn has_statusRanking(&self) -> bool {
        self.statusRanking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusRanking(&mut self, v: web_features::Flag) {
        self.statusRanking = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag voipIndividualVideo = 22;

    pub fn voipIndividualVideo(&self) -> web_features::Flag {
        match self.voipIndividualVideo {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_voipIndividualVideo(&mut self) {
        self.voipIndividualVideo = ::std::option::Option::None;
    }

    pub fn has_voipIndividualVideo(&self) -> bool {
        self.voipIndividualVideo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voipIndividualVideo(&mut self, v: web_features::Flag) {
        self.voipIndividualVideo = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag thirdPartyStickers = 23;

    pub fn thirdPartyStickers(&self) -> web_features::Flag {
        match self.thirdPartyStickers {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_thirdPartyStickers(&mut self) {
        self.thirdPartyStickers = ::std::option::Option::None;
    }

    pub fn has_thirdPartyStickers(&self) -> bool {
        self.thirdPartyStickers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thirdPartyStickers(&mut self, v: web_features::Flag) {
        self.thirdPartyStickers = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag frequentlyForwardedSetting = 24;

    pub fn frequentlyForwardedSetting(&self) -> web_features::Flag {
        match self.frequentlyForwardedSetting {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_frequentlyForwardedSetting(&mut self) {
        self.frequentlyForwardedSetting = ::std::option::Option::None;
    }

    pub fn has_frequentlyForwardedSetting(&self) -> bool {
        self.frequentlyForwardedSetting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequentlyForwardedSetting(&mut self, v: web_features::Flag) {
        self.frequentlyForwardedSetting = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag groupsV4JoinPermission = 25;

    pub fn groupsV4JoinPermission(&self) -> web_features::Flag {
        match self.groupsV4JoinPermission {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_groupsV4JoinPermission(&mut self) {
        self.groupsV4JoinPermission = ::std::option::Option::None;
    }

    pub fn has_groupsV4JoinPermission(&self) -> bool {
        self.groupsV4JoinPermission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupsV4JoinPermission(&mut self, v: web_features::Flag) {
        self.groupsV4JoinPermission = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag recentStickers = 26;

    pub fn recentStickers(&self) -> web_features::Flag {
        match self.recentStickers {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_recentStickers(&mut self) {
        self.recentStickers = ::std::option::Option::None;
    }

    pub fn has_recentStickers(&self) -> bool {
        self.recentStickers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recentStickers(&mut self, v: web_features::Flag) {
        self.recentStickers = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag catalog = 27;

    pub fn catalog(&self) -> web_features::Flag {
        match self.catalog {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_catalog(&mut self) {
        self.catalog = ::std::option::Option::None;
    }

    pub fn has_catalog(&self) -> bool {
        self.catalog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_catalog(&mut self, v: web_features::Flag) {
        self.catalog = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag starredStickers = 28;

    pub fn starredStickers(&self) -> web_features::Flag {
        match self.starredStickers {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_starredStickers(&mut self) {
        self.starredStickers = ::std::option::Option::None;
    }

    pub fn has_starredStickers(&self) -> bool {
        self.starredStickers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_starredStickers(&mut self, v: web_features::Flag) {
        self.starredStickers = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag voipGroupCall = 29;

    pub fn voipGroupCall(&self) -> web_features::Flag {
        match self.voipGroupCall {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_voipGroupCall(&mut self) {
        self.voipGroupCall = ::std::option::Option::None;
    }

    pub fn has_voipGroupCall(&self) -> bool {
        self.voipGroupCall.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voipGroupCall(&mut self, v: web_features::Flag) {
        self.voipGroupCall = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag templateMessage = 30;

    pub fn templateMessage(&self) -> web_features::Flag {
        match self.templateMessage {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_templateMessage(&mut self) {
        self.templateMessage = ::std::option::Option::None;
    }

    pub fn has_templateMessage(&self) -> bool {
        self.templateMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_templateMessage(&mut self, v: web_features::Flag) {
        self.templateMessage = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag templateMessageInteractivity = 31;

    pub fn templateMessageInteractivity(&self) -> web_features::Flag {
        match self.templateMessageInteractivity {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_templateMessageInteractivity(&mut self) {
        self.templateMessageInteractivity = ::std::option::Option::None;
    }

    pub fn has_templateMessageInteractivity(&self) -> bool {
        self.templateMessageInteractivity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_templateMessageInteractivity(&mut self, v: web_features::Flag) {
        self.templateMessageInteractivity = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag ephemeralMessages = 32;

    pub fn ephemeralMessages(&self) -> web_features::Flag {
        match self.ephemeralMessages {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_ephemeralMessages(&mut self) {
        self.ephemeralMessages = ::std::option::Option::None;
    }

    pub fn has_ephemeralMessages(&self) -> bool {
        self.ephemeralMessages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralMessages(&mut self, v: web_features::Flag) {
        self.ephemeralMessages = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag e2ENotificationSync = 33;

    pub fn e2ENotificationSync(&self) -> web_features::Flag {
        match self.e2ENotificationSync {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_e2ENotificationSync(&mut self) {
        self.e2ENotificationSync = ::std::option::Option::None;
    }

    pub fn has_e2ENotificationSync(&self) -> bool {
        self.e2ENotificationSync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2ENotificationSync(&mut self, v: web_features::Flag) {
        self.e2ENotificationSync = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag recentStickersV2 = 34;

    pub fn recentStickersV2(&self) -> web_features::Flag {
        match self.recentStickersV2 {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_recentStickersV2(&mut self) {
        self.recentStickersV2 = ::std::option::Option::None;
    }

    pub fn has_recentStickersV2(&self) -> bool {
        self.recentStickersV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recentStickersV2(&mut self, v: web_features::Flag) {
        self.recentStickersV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag recentStickersV3 = 36;

    pub fn recentStickersV3(&self) -> web_features::Flag {
        match self.recentStickersV3 {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_recentStickersV3(&mut self) {
        self.recentStickersV3 = ::std::option::Option::None;
    }

    pub fn has_recentStickersV3(&self) -> bool {
        self.recentStickersV3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recentStickersV3(&mut self, v: web_features::Flag) {
        self.recentStickersV3 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag userNotice = 37;

    pub fn userNotice(&self) -> web_features::Flag {
        match self.userNotice {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_userNotice(&mut self) {
        self.userNotice = ::std::option::Option::None;
    }

    pub fn has_userNotice(&self) -> bool {
        self.userNotice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userNotice(&mut self, v: web_features::Flag) {
        self.userNotice = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag support = 39;

    pub fn support(&self) -> web_features::Flag {
        match self.support {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: web_features::Flag) {
        self.support = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag groupUiiCleanup = 40;

    pub fn groupUiiCleanup(&self) -> web_features::Flag {
        match self.groupUiiCleanup {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_groupUiiCleanup(&mut self) {
        self.groupUiiCleanup = ::std::option::Option::None;
    }

    pub fn has_groupUiiCleanup(&self) -> bool {
        self.groupUiiCleanup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupUiiCleanup(&mut self, v: web_features::Flag) {
        self.groupUiiCleanup = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag groupDogfoodingInternalOnly = 41;

    pub fn groupDogfoodingInternalOnly(&self) -> web_features::Flag {
        match self.groupDogfoodingInternalOnly {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_groupDogfoodingInternalOnly(&mut self) {
        self.groupDogfoodingInternalOnly = ::std::option::Option::None;
    }

    pub fn has_groupDogfoodingInternalOnly(&self) -> bool {
        self.groupDogfoodingInternalOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupDogfoodingInternalOnly(&mut self, v: web_features::Flag) {
        self.groupDogfoodingInternalOnly = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag settingsSync = 42;

    pub fn settingsSync(&self) -> web_features::Flag {
        match self.settingsSync {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_settingsSync(&mut self) {
        self.settingsSync = ::std::option::Option::None;
    }

    pub fn has_settingsSync(&self) -> bool {
        self.settingsSync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settingsSync(&mut self, v: web_features::Flag) {
        self.settingsSync = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag archiveV2 = 43;

    pub fn archiveV2(&self) -> web_features::Flag {
        match self.archiveV2 {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_archiveV2(&mut self) {
        self.archiveV2 = ::std::option::Option::None;
    }

    pub fn has_archiveV2(&self) -> bool {
        self.archiveV2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archiveV2(&mut self, v: web_features::Flag) {
        self.archiveV2 = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag ephemeralAllowGroupMembers = 44;

    pub fn ephemeralAllowGroupMembers(&self) -> web_features::Flag {
        match self.ephemeralAllowGroupMembers {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_ephemeralAllowGroupMembers(&mut self) {
        self.ephemeralAllowGroupMembers = ::std::option::Option::None;
    }

    pub fn has_ephemeralAllowGroupMembers(&self) -> bool {
        self.ephemeralAllowGroupMembers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralAllowGroupMembers(&mut self, v: web_features::Flag) {
        self.ephemeralAllowGroupMembers = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag ephemeral24HDuration = 45;

    pub fn ephemeral24HDuration(&self) -> web_features::Flag {
        match self.ephemeral24HDuration {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_ephemeral24HDuration(&mut self) {
        self.ephemeral24HDuration = ::std::option::Option::None;
    }

    pub fn has_ephemeral24HDuration(&self) -> bool {
        self.ephemeral24HDuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeral24HDuration(&mut self, v: web_features::Flag) {
        self.ephemeral24HDuration = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag mdForceUpgrade = 46;

    pub fn mdForceUpgrade(&self) -> web_features::Flag {
        match self.mdForceUpgrade {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_mdForceUpgrade(&mut self) {
        self.mdForceUpgrade = ::std::option::Option::None;
    }

    pub fn has_mdForceUpgrade(&self) -> bool {
        self.mdForceUpgrade.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mdForceUpgrade(&mut self, v: web_features::Flag) {
        self.mdForceUpgrade = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag disappearingMode = 47;

    pub fn disappearingMode(&self) -> web_features::Flag {
        match self.disappearingMode {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_disappearingMode(&mut self) {
        self.disappearingMode = ::std::option::Option::None;
    }

    pub fn has_disappearingMode(&self) -> bool {
        self.disappearingMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disappearingMode(&mut self, v: web_features::Flag) {
        self.disappearingMode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag externalMdOptInAvailable = 48;

    pub fn externalMdOptInAvailable(&self) -> web_features::Flag {
        match self.externalMdOptInAvailable {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_externalMdOptInAvailable(&mut self) {
        self.externalMdOptInAvailable = ::std::option::Option::None;
    }

    pub fn has_externalMdOptInAvailable(&self) -> bool {
        self.externalMdOptInAvailable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalMdOptInAvailable(&mut self, v: web_features::Flag) {
        self.externalMdOptInAvailable = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .proto.WebFeatures.Flag noDeleteMessageTimeLimit = 49;

    pub fn noDeleteMessageTimeLimit(&self) -> web_features::Flag {
        match self.noDeleteMessageTimeLimit {
            Some(e) => e.enum_value_or(web_features::Flag::NOT_STARTED),
            None => web_features::Flag::NOT_STARTED,
        }
    }

    pub fn clear_noDeleteMessageTimeLimit(&mut self) {
        self.noDeleteMessageTimeLimit = ::std::option::Option::None;
    }

    pub fn has_noDeleteMessageTimeLimit(&self) -> bool {
        self.noDeleteMessageTimeLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_noDeleteMessageTimeLimit(&mut self, v: web_features::Flag) {
        self.noDeleteMessageTimeLimit = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(45);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labelsDisplay",
            |m: &WebFeatures| { &m.labelsDisplay },
            |m: &mut WebFeatures| { &mut m.labelsDisplay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voipIndividualOutgoing",
            |m: &WebFeatures| { &m.voipIndividualOutgoing },
            |m: &mut WebFeatures| { &mut m.voipIndividualOutgoing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupsV3",
            |m: &WebFeatures| { &m.groupsV3 },
            |m: &mut WebFeatures| { &mut m.groupsV3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupsV3Create",
            |m: &WebFeatures| { &m.groupsV3Create },
            |m: &mut WebFeatures| { &mut m.groupsV3Create },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "changeNumberV2",
            |m: &WebFeatures| { &m.changeNumberV2 },
            |m: &mut WebFeatures| { &mut m.changeNumberV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queryStatusV3Thumbnail",
            |m: &WebFeatures| { &m.queryStatusV3Thumbnail },
            |m: &mut WebFeatures| { &mut m.queryStatusV3Thumbnail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "liveLocations",
            |m: &WebFeatures| { &m.liveLocations },
            |m: &mut WebFeatures| { &mut m.liveLocations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queryVname",
            |m: &WebFeatures| { &m.queryVname },
            |m: &mut WebFeatures| { &mut m.queryVname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voipIndividualIncoming",
            |m: &WebFeatures| { &m.voipIndividualIncoming },
            |m: &mut WebFeatures| { &mut m.voipIndividualIncoming },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quickRepliesQuery",
            |m: &WebFeatures| { &m.quickRepliesQuery },
            |m: &mut WebFeatures| { &mut m.quickRepliesQuery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payments",
            |m: &WebFeatures| { &m.payments },
            |m: &mut WebFeatures| { &mut m.payments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stickerPackQuery",
            |m: &WebFeatures| { &m.stickerPackQuery },
            |m: &mut WebFeatures| { &mut m.stickerPackQuery },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "liveLocationsFinal",
            |m: &WebFeatures| { &m.liveLocationsFinal },
            |m: &mut WebFeatures| { &mut m.liveLocationsFinal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "labelsEdit",
            |m: &WebFeatures| { &m.labelsEdit },
            |m: &mut WebFeatures| { &mut m.labelsEdit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaUpload",
            |m: &WebFeatures| { &m.mediaUpload },
            |m: &mut WebFeatures| { &mut m.mediaUpload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mediaUploadRichQuickReplies",
            |m: &WebFeatures| { &m.mediaUploadRichQuickReplies },
            |m: &mut WebFeatures| { &mut m.mediaUploadRichQuickReplies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vnameV2",
            |m: &WebFeatures| { &m.vnameV2 },
            |m: &mut WebFeatures| { &mut m.vnameV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "videoPlaybackUrl",
            |m: &WebFeatures| { &m.videoPlaybackUrl },
            |m: &mut WebFeatures| { &mut m.videoPlaybackUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "statusRanking",
            |m: &WebFeatures| { &m.statusRanking },
            |m: &mut WebFeatures| { &mut m.statusRanking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voipIndividualVideo",
            |m: &WebFeatures| { &m.voipIndividualVideo },
            |m: &mut WebFeatures| { &mut m.voipIndividualVideo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thirdPartyStickers",
            |m: &WebFeatures| { &m.thirdPartyStickers },
            |m: &mut WebFeatures| { &mut m.thirdPartyStickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frequentlyForwardedSetting",
            |m: &WebFeatures| { &m.frequentlyForwardedSetting },
            |m: &mut WebFeatures| { &mut m.frequentlyForwardedSetting },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupsV4JoinPermission",
            |m: &WebFeatures| { &m.groupsV4JoinPermission },
            |m: &mut WebFeatures| { &mut m.groupsV4JoinPermission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recentStickers",
            |m: &WebFeatures| { &m.recentStickers },
            |m: &mut WebFeatures| { &mut m.recentStickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "catalog",
            |m: &WebFeatures| { &m.catalog },
            |m: &mut WebFeatures| { &mut m.catalog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "starredStickers",
            |m: &WebFeatures| { &m.starredStickers },
            |m: &mut WebFeatures| { &mut m.starredStickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voipGroupCall",
            |m: &WebFeatures| { &m.voipGroupCall },
            |m: &mut WebFeatures| { &mut m.voipGroupCall },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "templateMessage",
            |m: &WebFeatures| { &m.templateMessage },
            |m: &mut WebFeatures| { &mut m.templateMessage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "templateMessageInteractivity",
            |m: &WebFeatures| { &m.templateMessageInteractivity },
            |m: &mut WebFeatures| { &mut m.templateMessageInteractivity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralMessages",
            |m: &WebFeatures| { &m.ephemeralMessages },
            |m: &mut WebFeatures| { &mut m.ephemeralMessages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "e2ENotificationSync",
            |m: &WebFeatures| { &m.e2ENotificationSync },
            |m: &mut WebFeatures| { &mut m.e2ENotificationSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recentStickersV2",
            |m: &WebFeatures| { &m.recentStickersV2 },
            |m: &mut WebFeatures| { &mut m.recentStickersV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recentStickersV3",
            |m: &WebFeatures| { &m.recentStickersV3 },
            |m: &mut WebFeatures| { &mut m.recentStickersV3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userNotice",
            |m: &WebFeatures| { &m.userNotice },
            |m: &mut WebFeatures| { &mut m.userNotice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "support",
            |m: &WebFeatures| { &m.support },
            |m: &mut WebFeatures| { &mut m.support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupUiiCleanup",
            |m: &WebFeatures| { &m.groupUiiCleanup },
            |m: &mut WebFeatures| { &mut m.groupUiiCleanup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupDogfoodingInternalOnly",
            |m: &WebFeatures| { &m.groupDogfoodingInternalOnly },
            |m: &mut WebFeatures| { &mut m.groupDogfoodingInternalOnly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "settingsSync",
            |m: &WebFeatures| { &m.settingsSync },
            |m: &mut WebFeatures| { &mut m.settingsSync },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "archiveV2",
            |m: &WebFeatures| { &m.archiveV2 },
            |m: &mut WebFeatures| { &mut m.archiveV2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeralAllowGroupMembers",
            |m: &WebFeatures| { &m.ephemeralAllowGroupMembers },
            |m: &mut WebFeatures| { &mut m.ephemeralAllowGroupMembers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ephemeral24HDuration",
            |m: &WebFeatures| { &m.ephemeral24HDuration },
            |m: &mut WebFeatures| { &mut m.ephemeral24HDuration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mdForceUpgrade",
            |m: &WebFeatures| { &m.mdForceUpgrade },
            |m: &mut WebFeatures| { &mut m.mdForceUpgrade },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disappearingMode",
            |m: &WebFeatures| { &m.disappearingMode },
            |m: &mut WebFeatures| { &mut m.disappearingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "externalMdOptInAvailable",
            |m: &WebFeatures| { &m.externalMdOptInAvailable },
            |m: &mut WebFeatures| { &mut m.externalMdOptInAvailable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "noDeleteMessageTimeLimit",
            |m: &WebFeatures| { &m.noDeleteMessageTimeLimit },
            |m: &mut WebFeatures| { &mut m.noDeleteMessageTimeLimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WebFeatures>(
            "WebFeatures",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WebFeatures {
    const NAME: &'static str = "WebFeatures";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.labelsDisplay = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.voipIndividualOutgoing = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.groupsV3 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.groupsV3Create = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.changeNumberV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.queryStatusV3Thumbnail = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.liveLocations = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.queryVname = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.voipIndividualIncoming = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.quickRepliesQuery = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.payments = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.stickerPackQuery = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.liveLocationsFinal = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                112 => {
                    self.labelsEdit = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                120 => {
                    self.mediaUpload = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                144 => {
                    self.mediaUploadRichQuickReplies = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                152 => {
                    self.vnameV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.videoPlaybackUrl = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                168 => {
                    self.statusRanking = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                176 => {
                    self.voipIndividualVideo = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                184 => {
                    self.thirdPartyStickers = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                192 => {
                    self.frequentlyForwardedSetting = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.groupsV4JoinPermission = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                208 => {
                    self.recentStickers = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                216 => {
                    self.catalog = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                224 => {
                    self.starredStickers = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                232 => {
                    self.voipGroupCall = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                240 => {
                    self.templateMessage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                248 => {
                    self.templateMessageInteractivity = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                256 => {
                    self.ephemeralMessages = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                264 => {
                    self.e2ENotificationSync = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                272 => {
                    self.recentStickersV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                288 => {
                    self.recentStickersV3 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                296 => {
                    self.userNotice = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                312 => {
                    self.support = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                320 => {
                    self.groupUiiCleanup = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                328 => {
                    self.groupDogfoodingInternalOnly = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                336 => {
                    self.settingsSync = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                344 => {
                    self.archiveV2 = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                352 => {
                    self.ephemeralAllowGroupMembers = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                360 => {
                    self.ephemeral24HDuration = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                368 => {
                    self.mdForceUpgrade = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                376 => {
                    self.disappearingMode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                384 => {
                    self.externalMdOptInAvailable = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                392 => {
                    self.noDeleteMessageTimeLimit = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.labelsDisplay {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.voipIndividualOutgoing {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.groupsV3 {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.groupsV3Create {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.changeNumberV2 {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.queryStatusV3Thumbnail {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.liveLocations {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.queryVname {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.voipIndividualIncoming {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.quickRepliesQuery {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.payments {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.stickerPackQuery {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.liveLocationsFinal {
            my_size += ::protobuf::rt::int32_size(13, v.value());
        }
        if let Some(v) = self.labelsEdit {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        if let Some(v) = self.mediaUpload {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.mediaUploadRichQuickReplies {
            my_size += ::protobuf::rt::int32_size(18, v.value());
        }
        if let Some(v) = self.vnameV2 {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.videoPlaybackUrl {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.statusRanking {
            my_size += ::protobuf::rt::int32_size(21, v.value());
        }
        if let Some(v) = self.voipIndividualVideo {
            my_size += ::protobuf::rt::int32_size(22, v.value());
        }
        if let Some(v) = self.thirdPartyStickers {
            my_size += ::protobuf::rt::int32_size(23, v.value());
        }
        if let Some(v) = self.frequentlyForwardedSetting {
            my_size += ::protobuf::rt::int32_size(24, v.value());
        }
        if let Some(v) = self.groupsV4JoinPermission {
            my_size += ::protobuf::rt::int32_size(25, v.value());
        }
        if let Some(v) = self.recentStickers {
            my_size += ::protobuf::rt::int32_size(26, v.value());
        }
        if let Some(v) = self.catalog {
            my_size += ::protobuf::rt::int32_size(27, v.value());
        }
        if let Some(v) = self.starredStickers {
            my_size += ::protobuf::rt::int32_size(28, v.value());
        }
        if let Some(v) = self.voipGroupCall {
            my_size += ::protobuf::rt::int32_size(29, v.value());
        }
        if let Some(v) = self.templateMessage {
            my_size += ::protobuf::rt::int32_size(30, v.value());
        }
        if let Some(v) = self.templateMessageInteractivity {
            my_size += ::protobuf::rt::int32_size(31, v.value());
        }
        if let Some(v) = self.ephemeralMessages {
            my_size += ::protobuf::rt::int32_size(32, v.value());
        }
        if let Some(v) = self.e2ENotificationSync {
            my_size += ::protobuf::rt::int32_size(33, v.value());
        }
        if let Some(v) = self.recentStickersV2 {
            my_size += ::protobuf::rt::int32_size(34, v.value());
        }
        if let Some(v) = self.recentStickersV3 {
            my_size += ::protobuf::rt::int32_size(36, v.value());
        }
        if let Some(v) = self.userNotice {
            my_size += ::protobuf::rt::int32_size(37, v.value());
        }
        if let Some(v) = self.support {
            my_size += ::protobuf::rt::int32_size(39, v.value());
        }
        if let Some(v) = self.groupUiiCleanup {
            my_size += ::protobuf::rt::int32_size(40, v.value());
        }
        if let Some(v) = self.groupDogfoodingInternalOnly {
            my_size += ::protobuf::rt::int32_size(41, v.value());
        }
        if let Some(v) = self.settingsSync {
            my_size += ::protobuf::rt::int32_size(42, v.value());
        }
        if let Some(v) = self.archiveV2 {
            my_size += ::protobuf::rt::int32_size(43, v.value());
        }
        if let Some(v) = self.ephemeralAllowGroupMembers {
            my_size += ::protobuf::rt::int32_size(44, v.value());
        }
        if let Some(v) = self.ephemeral24HDuration {
            my_size += ::protobuf::rt::int32_size(45, v.value());
        }
        if let Some(v) = self.mdForceUpgrade {
            my_size += ::protobuf::rt::int32_size(46, v.value());
        }
        if let Some(v) = self.disappearingMode {
            my_size += ::protobuf::rt::int32_size(47, v.value());
        }
        if let Some(v) = self.externalMdOptInAvailable {
            my_size += ::protobuf::rt::int32_size(48, v.value());
        }
        if let Some(v) = self.noDeleteMessageTimeLimit {
            my_size += ::protobuf::rt::int32_size(49, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.labelsDisplay {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voipIndividualOutgoing {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupsV3 {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupsV3Create {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.changeNumberV2 {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.queryStatusV3Thumbnail {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.liveLocations {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.queryVname {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voipIndividualIncoming {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.quickRepliesQuery {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.payments {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.stickerPackQuery {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.liveLocationsFinal {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.labelsEdit {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mediaUpload {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mediaUploadRichQuickReplies {
            os.write_enum(18, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.vnameV2 {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.videoPlaybackUrl {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.statusRanking {
            os.write_enum(21, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voipIndividualVideo {
            os.write_enum(22, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.thirdPartyStickers {
            os.write_enum(23, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frequentlyForwardedSetting {
            os.write_enum(24, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupsV4JoinPermission {
            os.write_enum(25, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.recentStickers {
            os.write_enum(26, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.catalog {
            os.write_enum(27, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.starredStickers {
            os.write_enum(28, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voipGroupCall {
            os.write_enum(29, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.templateMessage {
            os.write_enum(30, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.templateMessageInteractivity {
            os.write_enum(31, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ephemeralMessages {
            os.write_enum(32, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.e2ENotificationSync {
            os.write_enum(33, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.recentStickersV2 {
            os.write_enum(34, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.recentStickersV3 {
            os.write_enum(36, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.userNotice {
            os.write_enum(37, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.support {
            os.write_enum(39, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupUiiCleanup {
            os.write_enum(40, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.groupDogfoodingInternalOnly {
            os.write_enum(41, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.settingsSync {
            os.write_enum(42, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.archiveV2 {
            os.write_enum(43, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ephemeralAllowGroupMembers {
            os.write_enum(44, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ephemeral24HDuration {
            os.write_enum(45, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mdForceUpgrade {
            os.write_enum(46, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.disappearingMode {
            os.write_enum(47, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.externalMdOptInAvailable {
            os.write_enum(48, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.noDeleteMessageTimeLimit {
            os.write_enum(49, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WebFeatures {
        WebFeatures::new()
    }

    fn clear(&mut self) {
        self.labelsDisplay = ::std::option::Option::None;
        self.voipIndividualOutgoing = ::std::option::Option::None;
        self.groupsV3 = ::std::option::Option::None;
        self.groupsV3Create = ::std::option::Option::None;
        self.changeNumberV2 = ::std::option::Option::None;
        self.queryStatusV3Thumbnail = ::std::option::Option::None;
        self.liveLocations = ::std::option::Option::None;
        self.queryVname = ::std::option::Option::None;
        self.voipIndividualIncoming = ::std::option::Option::None;
        self.quickRepliesQuery = ::std::option::Option::None;
        self.payments = ::std::option::Option::None;
        self.stickerPackQuery = ::std::option::Option::None;
        self.liveLocationsFinal = ::std::option::Option::None;
        self.labelsEdit = ::std::option::Option::None;
        self.mediaUpload = ::std::option::Option::None;
        self.mediaUploadRichQuickReplies = ::std::option::Option::None;
        self.vnameV2 = ::std::option::Option::None;
        self.videoPlaybackUrl = ::std::option::Option::None;
        self.statusRanking = ::std::option::Option::None;
        self.voipIndividualVideo = ::std::option::Option::None;
        self.thirdPartyStickers = ::std::option::Option::None;
        self.frequentlyForwardedSetting = ::std::option::Option::None;
        self.groupsV4JoinPermission = ::std::option::Option::None;
        self.recentStickers = ::std::option::Option::None;
        self.catalog = ::std::option::Option::None;
        self.starredStickers = ::std::option::Option::None;
        self.voipGroupCall = ::std::option::Option::None;
        self.templateMessage = ::std::option::Option::None;
        self.templateMessageInteractivity = ::std::option::Option::None;
        self.ephemeralMessages = ::std::option::Option::None;
        self.e2ENotificationSync = ::std::option::Option::None;
        self.recentStickersV2 = ::std::option::Option::None;
        self.recentStickersV3 = ::std::option::Option::None;
        self.userNotice = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.groupUiiCleanup = ::std::option::Option::None;
        self.groupDogfoodingInternalOnly = ::std::option::Option::None;
        self.settingsSync = ::std::option::Option::None;
        self.archiveV2 = ::std::option::Option::None;
        self.ephemeralAllowGroupMembers = ::std::option::Option::None;
        self.ephemeral24HDuration = ::std::option::Option::None;
        self.mdForceUpgrade = ::std::option::Option::None;
        self.disappearingMode = ::std::option::Option::None;
        self.externalMdOptInAvailable = ::std::option::Option::None;
        self.noDeleteMessageTimeLimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WebFeatures {
        static instance: WebFeatures = WebFeatures {
            labelsDisplay: ::std::option::Option::None,
            voipIndividualOutgoing: ::std::option::Option::None,
            groupsV3: ::std::option::Option::None,
            groupsV3Create: ::std::option::Option::None,
            changeNumberV2: ::std::option::Option::None,
            queryStatusV3Thumbnail: ::std::option::Option::None,
            liveLocations: ::std::option::Option::None,
            queryVname: ::std::option::Option::None,
            voipIndividualIncoming: ::std::option::Option::None,
            quickRepliesQuery: ::std::option::Option::None,
            payments: ::std::option::Option::None,
            stickerPackQuery: ::std::option::Option::None,
            liveLocationsFinal: ::std::option::Option::None,
            labelsEdit: ::std::option::Option::None,
            mediaUpload: ::std::option::Option::None,
            mediaUploadRichQuickReplies: ::std::option::Option::None,
            vnameV2: ::std::option::Option::None,
            videoPlaybackUrl: ::std::option::Option::None,
            statusRanking: ::std::option::Option::None,
            voipIndividualVideo: ::std::option::Option::None,
            thirdPartyStickers: ::std::option::Option::None,
            frequentlyForwardedSetting: ::std::option::Option::None,
            groupsV4JoinPermission: ::std::option::Option::None,
            recentStickers: ::std::option::Option::None,
            catalog: ::std::option::Option::None,
            starredStickers: ::std::option::Option::None,
            voipGroupCall: ::std::option::Option::None,
            templateMessage: ::std::option::Option::None,
            templateMessageInteractivity: ::std::option::Option::None,
            ephemeralMessages: ::std::option::Option::None,
            e2ENotificationSync: ::std::option::Option::None,
            recentStickersV2: ::std::option::Option::None,
            recentStickersV3: ::std::option::Option::None,
            userNotice: ::std::option::Option::None,
            support: ::std::option::Option::None,
            groupUiiCleanup: ::std::option::Option::None,
            groupDogfoodingInternalOnly: ::std::option::Option::None,
            settingsSync: ::std::option::Option::None,
            archiveV2: ::std::option::Option::None,
            ephemeralAllowGroupMembers: ::std::option::Option::None,
            ephemeral24HDuration: ::std::option::Option::None,
            mdForceUpgrade: ::std::option::Option::None,
            disappearingMode: ::std::option::Option::None,
            externalMdOptInAvailable: ::std::option::Option::None,
            noDeleteMessageTimeLimit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WebFeatures {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WebFeatures").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WebFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WebFeatures {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WebFeatures`
pub mod web_features {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.WebFeatures.Flag)
    pub enum Flag {
        // @@protoc_insertion_point(enum_value:proto.WebFeatures.Flag.NOT_STARTED)
        NOT_STARTED = 0,
        // @@protoc_insertion_point(enum_value:proto.WebFeatures.Flag.FORCE_UPGRADE)
        FORCE_UPGRADE = 1,
        // @@protoc_insertion_point(enum_value:proto.WebFeatures.Flag.DEVELOPMENT)
        DEVELOPMENT = 2,
        // @@protoc_insertion_point(enum_value:proto.WebFeatures.Flag.PRODUCTION)
        PRODUCTION = 3,
    }

    impl ::protobuf::Enum for Flag {
        const NAME: &'static str = "Flag";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Flag> {
            match value {
                0 => ::std::option::Option::Some(Flag::NOT_STARTED),
                1 => ::std::option::Option::Some(Flag::FORCE_UPGRADE),
                2 => ::std::option::Option::Some(Flag::DEVELOPMENT),
                3 => ::std::option::Option::Some(Flag::PRODUCTION),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Flag] = &[
            Flag::NOT_STARTED,
            Flag::FORCE_UPGRADE,
            Flag::DEVELOPMENT,
            Flag::PRODUCTION,
        ];
    }

    impl ::protobuf::EnumFull for Flag {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WebFeatures.Flag").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Flag {
        fn default() -> Self {
            Flag::NOT_STARTED
        }
    }

    impl Flag {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Flag>("WebFeatures.Flag")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.UserReceipt)
pub struct UserReceipt {
    // message fields
    // @@protoc_insertion_point(field:proto.UserReceipt.userJid)
    pub userJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.UserReceipt.receiptTimestamp)
    pub receiptTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.UserReceipt.readTimestamp)
    pub readTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.UserReceipt.playedTimestamp)
    pub playedTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.UserReceipt.pendingDeviceJid)
    pub pendingDeviceJid: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:proto.UserReceipt.deliveredDeviceJid)
    pub deliveredDeviceJid: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.UserReceipt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserReceipt {
    fn default() -> &'a UserReceipt {
        <UserReceipt as ::protobuf::Message>::default_instance()
    }
}

impl UserReceipt {
    pub fn new() -> UserReceipt {
        ::std::default::Default::default()
    }

    // required string userJid = 1;

    pub fn userJid(&self) -> &str {
        match self.userJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_userJid(&mut self) {
        self.userJid = ::std::option::Option::None;
    }

    pub fn has_userJid(&self) -> bool {
        self.userJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userJid(&mut self, v: ::std::string::String) {
        self.userJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userJid(&mut self) -> &mut ::std::string::String {
        if self.userJid.is_none() {
            self.userJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.userJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_userJid(&mut self) -> ::std::string::String {
        self.userJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 receiptTimestamp = 2;

    pub fn receiptTimestamp(&self) -> i64 {
        self.receiptTimestamp.unwrap_or(0)
    }

    pub fn clear_receiptTimestamp(&mut self) {
        self.receiptTimestamp = ::std::option::Option::None;
    }

    pub fn has_receiptTimestamp(&self) -> bool {
        self.receiptTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiptTimestamp(&mut self, v: i64) {
        self.receiptTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 readTimestamp = 3;

    pub fn readTimestamp(&self) -> i64 {
        self.readTimestamp.unwrap_or(0)
    }

    pub fn clear_readTimestamp(&mut self) {
        self.readTimestamp = ::std::option::Option::None;
    }

    pub fn has_readTimestamp(&self) -> bool {
        self.readTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readTimestamp(&mut self, v: i64) {
        self.readTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 playedTimestamp = 4;

    pub fn playedTimestamp(&self) -> i64 {
        self.playedTimestamp.unwrap_or(0)
    }

    pub fn clear_playedTimestamp(&mut self) {
        self.playedTimestamp = ::std::option::Option::None;
    }

    pub fn has_playedTimestamp(&self) -> bool {
        self.playedTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playedTimestamp(&mut self, v: i64) {
        self.playedTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userJid",
            |m: &UserReceipt| { &m.userJid },
            |m: &mut UserReceipt| { &mut m.userJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiptTimestamp",
            |m: &UserReceipt| { &m.receiptTimestamp },
            |m: &mut UserReceipt| { &mut m.receiptTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "readTimestamp",
            |m: &UserReceipt| { &m.readTimestamp },
            |m: &mut UserReceipt| { &mut m.readTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playedTimestamp",
            |m: &UserReceipt| { &m.playedTimestamp },
            |m: &mut UserReceipt| { &mut m.playedTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pendingDeviceJid",
            |m: &UserReceipt| { &m.pendingDeviceJid },
            |m: &mut UserReceipt| { &mut m.pendingDeviceJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deliveredDeviceJid",
            |m: &UserReceipt| { &m.deliveredDeviceJid },
            |m: &mut UserReceipt| { &mut m.deliveredDeviceJid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserReceipt>(
            "UserReceipt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserReceipt {
    const NAME: &'static str = "UserReceipt";

    fn is_initialized(&self) -> bool {
        if self.userJid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.userJid = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.receiptTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.readTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.playedTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    self.pendingDeviceJid.push(is.read_string()?);
                },
                50 => {
                    self.deliveredDeviceJid.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.userJid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.receiptTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.readTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.playedTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        for value in &self.pendingDeviceJid {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.deliveredDeviceJid {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.userJid.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.receiptTimestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.readTimestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.playedTimestamp {
            os.write_int64(4, v)?;
        }
        for v in &self.pendingDeviceJid {
            os.write_string(5, &v)?;
        };
        for v in &self.deliveredDeviceJid {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserReceipt {
        UserReceipt::new()
    }

    fn clear(&mut self) {
        self.userJid = ::std::option::Option::None;
        self.receiptTimestamp = ::std::option::Option::None;
        self.readTimestamp = ::std::option::Option::None;
        self.playedTimestamp = ::std::option::Option::None;
        self.pendingDeviceJid.clear();
        self.deliveredDeviceJid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserReceipt {
        static instance: UserReceipt = UserReceipt {
            userJid: ::std::option::Option::None,
            receiptTimestamp: ::std::option::Option::None,
            readTimestamp: ::std::option::Option::None,
            playedTimestamp: ::std::option::Option::None,
            pendingDeviceJid: ::std::vec::Vec::new(),
            deliveredDeviceJid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserReceipt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserReceipt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserReceipt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.StatusPSA)
pub struct StatusPSA {
    // message fields
    // @@protoc_insertion_point(field:proto.StatusPSA.campaignId)
    pub campaignId: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.StatusPSA.campaignExpirationTimestamp)
    pub campaignExpirationTimestamp: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.StatusPSA.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatusPSA {
    fn default() -> &'a StatusPSA {
        <StatusPSA as ::protobuf::Message>::default_instance()
    }
}

impl StatusPSA {
    pub fn new() -> StatusPSA {
        ::std::default::Default::default()
    }

    // required uint64 campaignId = 44;

    pub fn campaignId(&self) -> u64 {
        self.campaignId.unwrap_or(0)
    }

    pub fn clear_campaignId(&mut self) {
        self.campaignId = ::std::option::Option::None;
    }

    pub fn has_campaignId(&self) -> bool {
        self.campaignId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaignId(&mut self, v: u64) {
        self.campaignId = ::std::option::Option::Some(v);
    }

    // optional uint64 campaignExpirationTimestamp = 45;

    pub fn campaignExpirationTimestamp(&self) -> u64 {
        self.campaignExpirationTimestamp.unwrap_or(0)
    }

    pub fn clear_campaignExpirationTimestamp(&mut self) {
        self.campaignExpirationTimestamp = ::std::option::Option::None;
    }

    pub fn has_campaignExpirationTimestamp(&self) -> bool {
        self.campaignExpirationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaignExpirationTimestamp(&mut self, v: u64) {
        self.campaignExpirationTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "campaignId",
            |m: &StatusPSA| { &m.campaignId },
            |m: &mut StatusPSA| { &mut m.campaignId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "campaignExpirationTimestamp",
            |m: &StatusPSA| { &m.campaignExpirationTimestamp },
            |m: &mut StatusPSA| { &mut m.campaignExpirationTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatusPSA>(
            "StatusPSA",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatusPSA {
    const NAME: &'static str = "StatusPSA";

    fn is_initialized(&self) -> bool {
        if self.campaignId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                352 => {
                    self.campaignId = ::std::option::Option::Some(is.read_uint64()?);
                },
                360 => {
                    self.campaignExpirationTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.campaignId {
            my_size += ::protobuf::rt::uint64_size(44, v);
        }
        if let Some(v) = self.campaignExpirationTimestamp {
            my_size += ::protobuf::rt::uint64_size(45, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.campaignId {
            os.write_uint64(44, v)?;
        }
        if let Some(v) = self.campaignExpirationTimestamp {
            os.write_uint64(45, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatusPSA {
        StatusPSA::new()
    }

    fn clear(&mut self) {
        self.campaignId = ::std::option::Option::None;
        self.campaignExpirationTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatusPSA {
        static instance: StatusPSA = StatusPSA {
            campaignId: ::std::option::Option::None,
            campaignExpirationTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatusPSA {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatusPSA").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatusPSA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusPSA {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.Reaction)
pub struct Reaction {
    // message fields
    // @@protoc_insertion_point(field:proto.Reaction.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.Reaction.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Reaction.groupingKey)
    pub groupingKey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.Reaction.senderTimestampMs)
    pub senderTimestampMs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.Reaction.unread)
    pub unread: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.Reaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Reaction {
    fn default() -> &'a Reaction {
        <Reaction as ::protobuf::Message>::default_instance()
    }
}

impl Reaction {
    pub fn new() -> Reaction {
        ::std::default::Default::default()
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupingKey = 3;

    pub fn groupingKey(&self) -> &str {
        match self.groupingKey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_groupingKey(&mut self) {
        self.groupingKey = ::std::option::Option::None;
    }

    pub fn has_groupingKey(&self) -> bool {
        self.groupingKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupingKey(&mut self, v: ::std::string::String) {
        self.groupingKey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupingKey(&mut self) -> &mut ::std::string::String {
        if self.groupingKey.is_none() {
            self.groupingKey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.groupingKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupingKey(&mut self) -> ::std::string::String {
        self.groupingKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 senderTimestampMs = 4;

    pub fn senderTimestampMs(&self) -> i64 {
        self.senderTimestampMs.unwrap_or(0)
    }

    pub fn clear_senderTimestampMs(&mut self) {
        self.senderTimestampMs = ::std::option::Option::None;
    }

    pub fn has_senderTimestampMs(&self) -> bool {
        self.senderTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestampMs(&mut self, v: i64) {
        self.senderTimestampMs = ::std::option::Option::Some(v);
    }

    // optional bool unread = 5;

    pub fn unread(&self) -> bool {
        self.unread.unwrap_or(false)
    }

    pub fn clear_unread(&mut self) {
        self.unread = ::std::option::Option::None;
    }

    pub fn has_unread(&self) -> bool {
        self.unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread(&mut self, v: bool) {
        self.unread = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &Reaction| { &m.key },
            |m: &mut Reaction| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &Reaction| { &m.text },
            |m: &mut Reaction| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupingKey",
            |m: &Reaction| { &m.groupingKey },
            |m: &mut Reaction| { &mut m.groupingKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestampMs",
            |m: &Reaction| { &m.senderTimestampMs },
            |m: &mut Reaction| { &mut m.senderTimestampMs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unread",
            |m: &Reaction| { &m.unread },
            |m: &mut Reaction| { &mut m.unread },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Reaction>(
            "Reaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Reaction {
    const NAME: &'static str = "Reaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.groupingKey = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.senderTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.unread = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.groupingKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.senderTimestampMs {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.unread {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.groupingKey.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.senderTimestampMs {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.unread {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Reaction {
        Reaction::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.text = ::std::option::Option::None;
        self.groupingKey = ::std::option::Option::None;
        self.senderTimestampMs = ::std::option::Option::None;
        self.unread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Reaction {
        static instance: Reaction = Reaction {
            key: ::protobuf::MessageField::none(),
            text: ::std::option::Option::None,
            groupingKey: ::std::option::Option::None,
            senderTimestampMs: ::std::option::Option::None,
            unread: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Reaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Reaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Reaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PollUpdate)
pub struct PollUpdate {
    // message fields
    // @@protoc_insertion_point(field:proto.PollUpdate.pollUpdateMessageKey)
    pub pollUpdateMessageKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.PollUpdate.vote)
    pub vote: ::protobuf::MessageField<PollVoteMessage>,
    // @@protoc_insertion_point(field:proto.PollUpdate.senderTimestampMs)
    pub senderTimestampMs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.PollUpdate.serverTimestampMs)
    pub serverTimestampMs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.PollUpdate.unread)
    pub unread: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PollUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollUpdate {
    fn default() -> &'a PollUpdate {
        <PollUpdate as ::protobuf::Message>::default_instance()
    }
}

impl PollUpdate {
    pub fn new() -> PollUpdate {
        ::std::default::Default::default()
    }

    // optional int64 senderTimestampMs = 3;

    pub fn senderTimestampMs(&self) -> i64 {
        self.senderTimestampMs.unwrap_or(0)
    }

    pub fn clear_senderTimestampMs(&mut self) {
        self.senderTimestampMs = ::std::option::Option::None;
    }

    pub fn has_senderTimestampMs(&self) -> bool {
        self.senderTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_senderTimestampMs(&mut self, v: i64) {
        self.senderTimestampMs = ::std::option::Option::Some(v);
    }

    // optional int64 serverTimestampMs = 4;

    pub fn serverTimestampMs(&self) -> i64 {
        self.serverTimestampMs.unwrap_or(0)
    }

    pub fn clear_serverTimestampMs(&mut self) {
        self.serverTimestampMs = ::std::option::Option::None;
    }

    pub fn has_serverTimestampMs(&self) -> bool {
        self.serverTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverTimestampMs(&mut self, v: i64) {
        self.serverTimestampMs = ::std::option::Option::Some(v);
    }

    // optional bool unread = 5;

    pub fn unread(&self) -> bool {
        self.unread.unwrap_or(false)
    }

    pub fn clear_unread(&mut self) {
        self.unread = ::std::option::Option::None;
    }

    pub fn has_unread(&self) -> bool {
        self.unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread(&mut self, v: bool) {
        self.unread = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "pollUpdateMessageKey",
            |m: &PollUpdate| { &m.pollUpdateMessageKey },
            |m: &mut PollUpdate| { &mut m.pollUpdateMessageKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PollVoteMessage>(
            "vote",
            |m: &PollUpdate| { &m.vote },
            |m: &mut PollUpdate| { &mut m.vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "senderTimestampMs",
            |m: &PollUpdate| { &m.senderTimestampMs },
            |m: &mut PollUpdate| { &mut m.senderTimestampMs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverTimestampMs",
            |m: &PollUpdate| { &m.serverTimestampMs },
            |m: &mut PollUpdate| { &mut m.serverTimestampMs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unread",
            |m: &PollUpdate| { &m.unread },
            |m: &mut PollUpdate| { &mut m.unread },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollUpdate>(
            "PollUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollUpdate {
    const NAME: &'static str = "PollUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pollUpdateMessageKey)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vote)?;
                },
                24 => {
                    self.senderTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.serverTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.unread = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pollUpdateMessageKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.senderTimestampMs {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.serverTimestampMs {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.unread {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pollUpdateMessageKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.senderTimestampMs {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.serverTimestampMs {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.unread {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollUpdate {
        PollUpdate::new()
    }

    fn clear(&mut self) {
        self.pollUpdateMessageKey.clear();
        self.vote.clear();
        self.senderTimestampMs = ::std::option::Option::None;
        self.serverTimestampMs = ::std::option::Option::None;
        self.unread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollUpdate {
        static instance: PollUpdate = PollUpdate {
            pollUpdateMessageKey: ::protobuf::MessageField::none(),
            vote: ::protobuf::MessageField::none(),
            senderTimestampMs: ::std::option::Option::None,
            serverTimestampMs: ::std::option::Option::None,
            unread: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PollAdditionalMetadata)
pub struct PollAdditionalMetadata {
    // message fields
    // @@protoc_insertion_point(field:proto.PollAdditionalMetadata.pollInvalidated)
    pub pollInvalidated: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PollAdditionalMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PollAdditionalMetadata {
    fn default() -> &'a PollAdditionalMetadata {
        <PollAdditionalMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PollAdditionalMetadata {
    pub fn new() -> PollAdditionalMetadata {
        ::std::default::Default::default()
    }

    // optional bool pollInvalidated = 1;

    pub fn pollInvalidated(&self) -> bool {
        self.pollInvalidated.unwrap_or(false)
    }

    pub fn clear_pollInvalidated(&mut self) {
        self.pollInvalidated = ::std::option::Option::None;
    }

    pub fn has_pollInvalidated(&self) -> bool {
        self.pollInvalidated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pollInvalidated(&mut self, v: bool) {
        self.pollInvalidated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pollInvalidated",
            |m: &PollAdditionalMetadata| { &m.pollInvalidated },
            |m: &mut PollAdditionalMetadata| { &mut m.pollInvalidated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PollAdditionalMetadata>(
            "PollAdditionalMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PollAdditionalMetadata {
    const NAME: &'static str = "PollAdditionalMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pollInvalidated = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pollInvalidated {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pollInvalidated {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PollAdditionalMetadata {
        PollAdditionalMetadata::new()
    }

    fn clear(&mut self) {
        self.pollInvalidated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PollAdditionalMetadata {
        static instance: PollAdditionalMetadata = PollAdditionalMetadata {
            pollInvalidated: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PollAdditionalMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PollAdditionalMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PollAdditionalMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PollAdditionalMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PhotoChange)
pub struct PhotoChange {
    // message fields
    // @@protoc_insertion_point(field:proto.PhotoChange.oldPhoto)
    pub oldPhoto: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.PhotoChange.newPhoto)
    pub newPhoto: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.PhotoChange.newPhotoId)
    pub newPhotoId: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PhotoChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PhotoChange {
    fn default() -> &'a PhotoChange {
        <PhotoChange as ::protobuf::Message>::default_instance()
    }
}

impl PhotoChange {
    pub fn new() -> PhotoChange {
        ::std::default::Default::default()
    }

    // optional bytes oldPhoto = 1;

    pub fn oldPhoto(&self) -> &[u8] {
        match self.oldPhoto.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_oldPhoto(&mut self) {
        self.oldPhoto = ::std::option::Option::None;
    }

    pub fn has_oldPhoto(&self) -> bool {
        self.oldPhoto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldPhoto(&mut self, v: ::std::vec::Vec<u8>) {
        self.oldPhoto = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldPhoto(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.oldPhoto.is_none() {
            self.oldPhoto = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.oldPhoto.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldPhoto(&mut self) -> ::std::vec::Vec<u8> {
        self.oldPhoto.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes newPhoto = 2;

    pub fn newPhoto(&self) -> &[u8] {
        match self.newPhoto.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_newPhoto(&mut self) {
        self.newPhoto = ::std::option::Option::None;
    }

    pub fn has_newPhoto(&self) -> bool {
        self.newPhoto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newPhoto(&mut self, v: ::std::vec::Vec<u8>) {
        self.newPhoto = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newPhoto(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.newPhoto.is_none() {
            self.newPhoto = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.newPhoto.as_mut().unwrap()
    }

    // Take field
    pub fn take_newPhoto(&mut self) -> ::std::vec::Vec<u8> {
        self.newPhoto.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 newPhotoId = 3;

    pub fn newPhotoId(&self) -> u32 {
        self.newPhotoId.unwrap_or(0)
    }

    pub fn clear_newPhotoId(&mut self) {
        self.newPhotoId = ::std::option::Option::None;
    }

    pub fn has_newPhotoId(&self) -> bool {
        self.newPhotoId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newPhotoId(&mut self, v: u32) {
        self.newPhotoId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "oldPhoto",
            |m: &PhotoChange| { &m.oldPhoto },
            |m: &mut PhotoChange| { &mut m.oldPhoto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "newPhoto",
            |m: &PhotoChange| { &m.newPhoto },
            |m: &mut PhotoChange| { &mut m.newPhoto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "newPhotoId",
            |m: &PhotoChange| { &m.newPhotoId },
            |m: &mut PhotoChange| { &mut m.newPhotoId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhotoChange>(
            "PhotoChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PhotoChange {
    const NAME: &'static str = "PhotoChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.oldPhoto = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.newPhoto = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.newPhotoId = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.oldPhoto.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.newPhoto.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.newPhotoId {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.oldPhoto.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.newPhoto.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.newPhotoId {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PhotoChange {
        PhotoChange::new()
    }

    fn clear(&mut self) {
        self.oldPhoto = ::std::option::Option::None;
        self.newPhoto = ::std::option::Option::None;
        self.newPhotoId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PhotoChange {
        static instance: PhotoChange = PhotoChange {
            oldPhoto: ::std::option::Option::None,
            newPhoto: ::std::option::Option::None,
            newPhotoId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PhotoChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PhotoChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PhotoChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhotoChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.PaymentInfo)
pub struct PaymentInfo {
    // message fields
    // @@protoc_insertion_point(field:proto.PaymentInfo.currencyDeprecated)
    pub currencyDeprecated: ::std::option::Option<::protobuf::EnumOrUnknown<payment_info::Currency>>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.amount1000)
    pub amount1000: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.receiverJid)
    pub receiverJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<payment_info::Status>>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.transactionTimestamp)
    pub transactionTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.requestMessageKey)
    pub requestMessageKey: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.expiryTimestamp)
    pub expiryTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.futureproofed)
    pub futureproofed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.currency)
    pub currency: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.txnStatus)
    pub txnStatus: ::std::option::Option<::protobuf::EnumOrUnknown<payment_info::TxnStatus>>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.useNoviFiatFormat)
    pub useNoviFiatFormat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.primaryAmount)
    pub primaryAmount: ::protobuf::MessageField<Money>,
    // @@protoc_insertion_point(field:proto.PaymentInfo.exchangeAmount)
    pub exchangeAmount: ::protobuf::MessageField<Money>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.PaymentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PaymentInfo {
    fn default() -> &'a PaymentInfo {
        <PaymentInfo as ::protobuf::Message>::default_instance()
    }
}

impl PaymentInfo {
    pub fn new() -> PaymentInfo {
        ::std::default::Default::default()
    }

    // optional .proto.PaymentInfo.Currency currencyDeprecated = 1;

    pub fn currencyDeprecated(&self) -> payment_info::Currency {
        match self.currencyDeprecated {
            Some(e) => e.enum_value_or(payment_info::Currency::UNKNOWN_CURRENCY),
            None => payment_info::Currency::UNKNOWN_CURRENCY,
        }
    }

    pub fn clear_currencyDeprecated(&mut self) {
        self.currencyDeprecated = ::std::option::Option::None;
    }

    pub fn has_currencyDeprecated(&self) -> bool {
        self.currencyDeprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currencyDeprecated(&mut self, v: payment_info::Currency) {
        self.currencyDeprecated = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 amount1000 = 2;

    pub fn amount1000(&self) -> u64 {
        self.amount1000.unwrap_or(0)
    }

    pub fn clear_amount1000(&mut self) {
        self.amount1000 = ::std::option::Option::None;
    }

    pub fn has_amount1000(&self) -> bool {
        self.amount1000.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount1000(&mut self, v: u64) {
        self.amount1000 = ::std::option::Option::Some(v);
    }

    // optional string receiverJid = 3;

    pub fn receiverJid(&self) -> &str {
        match self.receiverJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_receiverJid(&mut self) {
        self.receiverJid = ::std::option::Option::None;
    }

    pub fn has_receiverJid(&self) -> bool {
        self.receiverJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiverJid(&mut self, v: ::std::string::String) {
        self.receiverJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiverJid(&mut self) -> &mut ::std::string::String {
        if self.receiverJid.is_none() {
            self.receiverJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.receiverJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_receiverJid(&mut self) -> ::std::string::String {
        self.receiverJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.PaymentInfo.Status status = 4;

    pub fn status(&self) -> payment_info::Status {
        match self.status {
            Some(e) => e.enum_value_or(payment_info::Status::UNKNOWN_STATUS),
            None => payment_info::Status::UNKNOWN_STATUS,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: payment_info::Status) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 transactionTimestamp = 5;

    pub fn transactionTimestamp(&self) -> u64 {
        self.transactionTimestamp.unwrap_or(0)
    }

    pub fn clear_transactionTimestamp(&mut self) {
        self.transactionTimestamp = ::std::option::Option::None;
    }

    pub fn has_transactionTimestamp(&self) -> bool {
        self.transactionTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transactionTimestamp(&mut self, v: u64) {
        self.transactionTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 expiryTimestamp = 7;

    pub fn expiryTimestamp(&self) -> u64 {
        self.expiryTimestamp.unwrap_or(0)
    }

    pub fn clear_expiryTimestamp(&mut self) {
        self.expiryTimestamp = ::std::option::Option::None;
    }

    pub fn has_expiryTimestamp(&self) -> bool {
        self.expiryTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryTimestamp(&mut self, v: u64) {
        self.expiryTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool futureproofed = 8;

    pub fn futureproofed(&self) -> bool {
        self.futureproofed.unwrap_or(false)
    }

    pub fn clear_futureproofed(&mut self) {
        self.futureproofed = ::std::option::Option::None;
    }

    pub fn has_futureproofed(&self) -> bool {
        self.futureproofed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_futureproofed(&mut self, v: bool) {
        self.futureproofed = ::std::option::Option::Some(v);
    }

    // optional string currency = 9;

    pub fn currency(&self) -> &str {
        match self.currency.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: ::std::string::String) {
        self.currency = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currency(&mut self) -> &mut ::std::string::String {
        if self.currency.is_none() {
            self.currency = ::std::option::Option::Some(::std::string::String::new());
        }
        self.currency.as_mut().unwrap()
    }

    // Take field
    pub fn take_currency(&mut self) -> ::std::string::String {
        self.currency.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.PaymentInfo.TxnStatus txnStatus = 10;

    pub fn txnStatus(&self) -> payment_info::TxnStatus {
        match self.txnStatus {
            Some(e) => e.enum_value_or(payment_info::TxnStatus::UNKNOWN),
            None => payment_info::TxnStatus::UNKNOWN,
        }
    }

    pub fn clear_txnStatus(&mut self) {
        self.txnStatus = ::std::option::Option::None;
    }

    pub fn has_txnStatus(&self) -> bool {
        self.txnStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txnStatus(&mut self, v: payment_info::TxnStatus) {
        self.txnStatus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool useNoviFiatFormat = 11;

    pub fn useNoviFiatFormat(&self) -> bool {
        self.useNoviFiatFormat.unwrap_or(false)
    }

    pub fn clear_useNoviFiatFormat(&mut self) {
        self.useNoviFiatFormat = ::std::option::Option::None;
    }

    pub fn has_useNoviFiatFormat(&self) -> bool {
        self.useNoviFiatFormat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_useNoviFiatFormat(&mut self, v: bool) {
        self.useNoviFiatFormat = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currencyDeprecated",
            |m: &PaymentInfo| { &m.currencyDeprecated },
            |m: &mut PaymentInfo| { &mut m.currencyDeprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount1000",
            |m: &PaymentInfo| { &m.amount1000 },
            |m: &mut PaymentInfo| { &mut m.amount1000 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiverJid",
            |m: &PaymentInfo| { &m.receiverJid },
            |m: &mut PaymentInfo| { &mut m.receiverJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &PaymentInfo| { &m.status },
            |m: &mut PaymentInfo| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transactionTimestamp",
            |m: &PaymentInfo| { &m.transactionTimestamp },
            |m: &mut PaymentInfo| { &mut m.transactionTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "requestMessageKey",
            |m: &PaymentInfo| { &m.requestMessageKey },
            |m: &mut PaymentInfo| { &mut m.requestMessageKey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiryTimestamp",
            |m: &PaymentInfo| { &m.expiryTimestamp },
            |m: &mut PaymentInfo| { &mut m.expiryTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "futureproofed",
            |m: &PaymentInfo| { &m.futureproofed },
            |m: &mut PaymentInfo| { &mut m.futureproofed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &PaymentInfo| { &m.currency },
            |m: &mut PaymentInfo| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txnStatus",
            |m: &PaymentInfo| { &m.txnStatus },
            |m: &mut PaymentInfo| { &mut m.txnStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "useNoviFiatFormat",
            |m: &PaymentInfo| { &m.useNoviFiatFormat },
            |m: &mut PaymentInfo| { &mut m.useNoviFiatFormat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Money>(
            "primaryAmount",
            |m: &PaymentInfo| { &m.primaryAmount },
            |m: &mut PaymentInfo| { &mut m.primaryAmount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Money>(
            "exchangeAmount",
            |m: &PaymentInfo| { &m.exchangeAmount },
            |m: &mut PaymentInfo| { &mut m.exchangeAmount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PaymentInfo>(
            "PaymentInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PaymentInfo {
    const NAME: &'static str = "PaymentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.currencyDeprecated = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.amount1000 = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.receiverJid = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.transactionTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.requestMessageKey)?;
                },
                56 => {
                    self.expiryTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.futureproofed = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.currency = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.txnStatus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.useNoviFiatFormat = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.primaryAmount)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.exchangeAmount)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currencyDeprecated {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.amount1000 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.receiverJid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.transactionTimestamp {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.requestMessageKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.expiryTimestamp {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.futureproofed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.currency.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.txnStatus {
            my_size += ::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.useNoviFiatFormat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.primaryAmount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.exchangeAmount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.currencyDeprecated {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.amount1000 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.receiverJid.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.transactionTimestamp {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.requestMessageKey.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.expiryTimestamp {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.futureproofed {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.currency.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.txnStatus {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.useNoviFiatFormat {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.primaryAmount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.exchangeAmount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PaymentInfo {
        PaymentInfo::new()
    }

    fn clear(&mut self) {
        self.currencyDeprecated = ::std::option::Option::None;
        self.amount1000 = ::std::option::Option::None;
        self.receiverJid = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.transactionTimestamp = ::std::option::Option::None;
        self.requestMessageKey.clear();
        self.expiryTimestamp = ::std::option::Option::None;
        self.futureproofed = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.txnStatus = ::std::option::Option::None;
        self.useNoviFiatFormat = ::std::option::Option::None;
        self.primaryAmount.clear();
        self.exchangeAmount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PaymentInfo {
        static instance: PaymentInfo = PaymentInfo {
            currencyDeprecated: ::std::option::Option::None,
            amount1000: ::std::option::Option::None,
            receiverJid: ::std::option::Option::None,
            status: ::std::option::Option::None,
            transactionTimestamp: ::std::option::Option::None,
            requestMessageKey: ::protobuf::MessageField::none(),
            expiryTimestamp: ::std::option::Option::None,
            futureproofed: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            txnStatus: ::std::option::Option::None,
            useNoviFiatFormat: ::std::option::Option::None,
            primaryAmount: ::protobuf::MessageField::none(),
            exchangeAmount: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PaymentInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PaymentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PaymentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaymentInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PaymentInfo`
pub mod payment_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.PaymentInfo.TxnStatus)
    pub enum TxnStatus {
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.PENDING_SETUP)
        PENDING_SETUP = 1,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.PENDING_RECEIVER_SETUP)
        PENDING_RECEIVER_SETUP = 2,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.INIT)
        INIT = 3,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.SUCCESS)
        SUCCESS = 4,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COMPLETED)
        COMPLETED = 5,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.FAILED)
        FAILED = 6,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.FAILED_RISK)
        FAILED_RISK = 7,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.FAILED_PROCESSING)
        FAILED_PROCESSING = 8,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.FAILED_RECEIVER_PROCESSING)
        FAILED_RECEIVER_PROCESSING = 9,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.FAILED_DA)
        FAILED_DA = 10,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.FAILED_DA_FINAL)
        FAILED_DA_FINAL = 11,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.REFUNDED_TXN)
        REFUNDED_TXN = 12,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.REFUND_FAILED)
        REFUND_FAILED = 13,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.REFUND_FAILED_PROCESSING)
        REFUND_FAILED_PROCESSING = 14,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.REFUND_FAILED_DA)
        REFUND_FAILED_DA = 15,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.EXPIRED_TXN)
        EXPIRED_TXN = 16,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.AUTH_CANCELED)
        AUTH_CANCELED = 17,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.AUTH_CANCEL_FAILED_PROCESSING)
        AUTH_CANCEL_FAILED_PROCESSING = 18,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.AUTH_CANCEL_FAILED)
        AUTH_CANCEL_FAILED = 19,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COLLECT_INIT)
        COLLECT_INIT = 20,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COLLECT_SUCCESS)
        COLLECT_SUCCESS = 21,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COLLECT_FAILED)
        COLLECT_FAILED = 22,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COLLECT_FAILED_RISK)
        COLLECT_FAILED_RISK = 23,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COLLECT_REJECTED)
        COLLECT_REJECTED = 24,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COLLECT_EXPIRED)
        COLLECT_EXPIRED = 25,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COLLECT_CANCELED)
        COLLECT_CANCELED = 26,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.COLLECT_CANCELLING)
        COLLECT_CANCELLING = 27,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.IN_REVIEW)
        IN_REVIEW = 28,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.REVERSAL_SUCCESS)
        REVERSAL_SUCCESS = 29,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.REVERSAL_PENDING)
        REVERSAL_PENDING = 30,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.TxnStatus.REFUND_PENDING)
        REFUND_PENDING = 31,
    }

    impl ::protobuf::Enum for TxnStatus {
        const NAME: &'static str = "TxnStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TxnStatus> {
            match value {
                0 => ::std::option::Option::Some(TxnStatus::UNKNOWN),
                1 => ::std::option::Option::Some(TxnStatus::PENDING_SETUP),
                2 => ::std::option::Option::Some(TxnStatus::PENDING_RECEIVER_SETUP),
                3 => ::std::option::Option::Some(TxnStatus::INIT),
                4 => ::std::option::Option::Some(TxnStatus::SUCCESS),
                5 => ::std::option::Option::Some(TxnStatus::COMPLETED),
                6 => ::std::option::Option::Some(TxnStatus::FAILED),
                7 => ::std::option::Option::Some(TxnStatus::FAILED_RISK),
                8 => ::std::option::Option::Some(TxnStatus::FAILED_PROCESSING),
                9 => ::std::option::Option::Some(TxnStatus::FAILED_RECEIVER_PROCESSING),
                10 => ::std::option::Option::Some(TxnStatus::FAILED_DA),
                11 => ::std::option::Option::Some(TxnStatus::FAILED_DA_FINAL),
                12 => ::std::option::Option::Some(TxnStatus::REFUNDED_TXN),
                13 => ::std::option::Option::Some(TxnStatus::REFUND_FAILED),
                14 => ::std::option::Option::Some(TxnStatus::REFUND_FAILED_PROCESSING),
                15 => ::std::option::Option::Some(TxnStatus::REFUND_FAILED_DA),
                16 => ::std::option::Option::Some(TxnStatus::EXPIRED_TXN),
                17 => ::std::option::Option::Some(TxnStatus::AUTH_CANCELED),
                18 => ::std::option::Option::Some(TxnStatus::AUTH_CANCEL_FAILED_PROCESSING),
                19 => ::std::option::Option::Some(TxnStatus::AUTH_CANCEL_FAILED),
                20 => ::std::option::Option::Some(TxnStatus::COLLECT_INIT),
                21 => ::std::option::Option::Some(TxnStatus::COLLECT_SUCCESS),
                22 => ::std::option::Option::Some(TxnStatus::COLLECT_FAILED),
                23 => ::std::option::Option::Some(TxnStatus::COLLECT_FAILED_RISK),
                24 => ::std::option::Option::Some(TxnStatus::COLLECT_REJECTED),
                25 => ::std::option::Option::Some(TxnStatus::COLLECT_EXPIRED),
                26 => ::std::option::Option::Some(TxnStatus::COLLECT_CANCELED),
                27 => ::std::option::Option::Some(TxnStatus::COLLECT_CANCELLING),
                28 => ::std::option::Option::Some(TxnStatus::IN_REVIEW),
                29 => ::std::option::Option::Some(TxnStatus::REVERSAL_SUCCESS),
                30 => ::std::option::Option::Some(TxnStatus::REVERSAL_PENDING),
                31 => ::std::option::Option::Some(TxnStatus::REFUND_PENDING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TxnStatus] = &[
            TxnStatus::UNKNOWN,
            TxnStatus::PENDING_SETUP,
            TxnStatus::PENDING_RECEIVER_SETUP,
            TxnStatus::INIT,
            TxnStatus::SUCCESS,
            TxnStatus::COMPLETED,
            TxnStatus::FAILED,
            TxnStatus::FAILED_RISK,
            TxnStatus::FAILED_PROCESSING,
            TxnStatus::FAILED_RECEIVER_PROCESSING,
            TxnStatus::FAILED_DA,
            TxnStatus::FAILED_DA_FINAL,
            TxnStatus::REFUNDED_TXN,
            TxnStatus::REFUND_FAILED,
            TxnStatus::REFUND_FAILED_PROCESSING,
            TxnStatus::REFUND_FAILED_DA,
            TxnStatus::EXPIRED_TXN,
            TxnStatus::AUTH_CANCELED,
            TxnStatus::AUTH_CANCEL_FAILED_PROCESSING,
            TxnStatus::AUTH_CANCEL_FAILED,
            TxnStatus::COLLECT_INIT,
            TxnStatus::COLLECT_SUCCESS,
            TxnStatus::COLLECT_FAILED,
            TxnStatus::COLLECT_FAILED_RISK,
            TxnStatus::COLLECT_REJECTED,
            TxnStatus::COLLECT_EXPIRED,
            TxnStatus::COLLECT_CANCELED,
            TxnStatus::COLLECT_CANCELLING,
            TxnStatus::IN_REVIEW,
            TxnStatus::REVERSAL_SUCCESS,
            TxnStatus::REVERSAL_PENDING,
            TxnStatus::REFUND_PENDING,
        ];
    }

    impl ::protobuf::EnumFull for TxnStatus {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentInfo.TxnStatus").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TxnStatus {
        fn default() -> Self {
            TxnStatus::UNKNOWN
        }
    }

    impl TxnStatus {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TxnStatus>("PaymentInfo.TxnStatus")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.PaymentInfo.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.UNKNOWN_STATUS)
        UNKNOWN_STATUS = 0,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.PROCESSING)
        PROCESSING = 1,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.SENT)
        SENT = 2,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.NEED_TO_ACCEPT)
        NEED_TO_ACCEPT = 3,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.COMPLETE)
        COMPLETE = 4,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.COULD_NOT_COMPLETE)
        COULD_NOT_COMPLETE = 5,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.REFUNDED)
        REFUNDED = 6,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.EXPIRED)
        EXPIRED = 7,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.REJECTED)
        REJECTED = 8,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.CANCELLED)
        CANCELLED = 9,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.WAITING_FOR_PAYER)
        WAITING_FOR_PAYER = 10,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Status.WAITING)
        WAITING = 11,
    }

    impl ::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::UNKNOWN_STATUS),
                1 => ::std::option::Option::Some(Status::PROCESSING),
                2 => ::std::option::Option::Some(Status::SENT),
                3 => ::std::option::Option::Some(Status::NEED_TO_ACCEPT),
                4 => ::std::option::Option::Some(Status::COMPLETE),
                5 => ::std::option::Option::Some(Status::COULD_NOT_COMPLETE),
                6 => ::std::option::Option::Some(Status::REFUNDED),
                7 => ::std::option::Option::Some(Status::EXPIRED),
                8 => ::std::option::Option::Some(Status::REJECTED),
                9 => ::std::option::Option::Some(Status::CANCELLED),
                10 => ::std::option::Option::Some(Status::WAITING_FOR_PAYER),
                11 => ::std::option::Option::Some(Status::WAITING),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::UNKNOWN_STATUS,
            Status::PROCESSING,
            Status::SENT,
            Status::NEED_TO_ACCEPT,
            Status::COMPLETE,
            Status::COULD_NOT_COMPLETE,
            Status::REFUNDED,
            Status::EXPIRED,
            Status::REJECTED,
            Status::CANCELLED,
            Status::WAITING_FOR_PAYER,
            Status::WAITING,
        ];
    }

    impl ::protobuf::EnumFull for Status {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentInfo.Status").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::UNKNOWN_STATUS
        }
    }

    impl Status {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Status>("PaymentInfo.Status")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:proto.PaymentInfo.Currency)
    pub enum Currency {
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Currency.UNKNOWN_CURRENCY)
        UNKNOWN_CURRENCY = 0,
        // @@protoc_insertion_point(enum_value:proto.PaymentInfo.Currency.INR)
        INR = 1,
    }

    impl ::protobuf::Enum for Currency {
        const NAME: &'static str = "Currency";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Currency> {
            match value {
                0 => ::std::option::Option::Some(Currency::UNKNOWN_CURRENCY),
                1 => ::std::option::Option::Some(Currency::INR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Currency] = &[
            Currency::UNKNOWN_CURRENCY,
            Currency::INR,
        ];
    }

    impl ::protobuf::EnumFull for Currency {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("PaymentInfo.Currency").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Currency {
        fn default() -> Self {
            Currency::UNKNOWN_CURRENCY
        }
    }

    impl Currency {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Currency>("PaymentInfo.Currency")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.NotificationMessageInfo)
pub struct NotificationMessageInfo {
    // message fields
    // @@protoc_insertion_point(field:proto.NotificationMessageInfo.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.NotificationMessageInfo.message)
    pub message: ::protobuf::MessageField<Message>,
    // @@protoc_insertion_point(field:proto.NotificationMessageInfo.messageTimestamp)
    pub messageTimestamp: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:proto.NotificationMessageInfo.participant)
    pub participant: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.NotificationMessageInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NotificationMessageInfo {
    fn default() -> &'a NotificationMessageInfo {
        <NotificationMessageInfo as ::protobuf::Message>::default_instance()
    }
}

impl NotificationMessageInfo {
    pub fn new() -> NotificationMessageInfo {
        ::std::default::Default::default()
    }

    // optional uint64 messageTimestamp = 3;

    pub fn messageTimestamp(&self) -> u64 {
        self.messageTimestamp.unwrap_or(0)
    }

    pub fn clear_messageTimestamp(&mut self) {
        self.messageTimestamp = ::std::option::Option::None;
    }

    pub fn has_messageTimestamp(&self) -> bool {
        self.messageTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageTimestamp(&mut self, v: u64) {
        self.messageTimestamp = ::std::option::Option::Some(v);
    }

    // optional string participant = 4;

    pub fn participant(&self) -> &str {
        match self.participant.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_participant(&mut self) {
        self.participant = ::std::option::Option::None;
    }

    pub fn has_participant(&self) -> bool {
        self.participant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_participant(&mut self, v: ::std::string::String) {
        self.participant = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_participant(&mut self) -> &mut ::std::string::String {
        if self.participant.is_none() {
            self.participant = ::std::option::Option::Some(::std::string::String::new());
        }
        self.participant.as_mut().unwrap()
    }

    // Take field
    pub fn take_participant(&mut self) -> ::std::string::String {
        self.participant.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &NotificationMessageInfo| { &m.key },
            |m: &mut NotificationMessageInfo| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Message>(
            "message",
            |m: &NotificationMessageInfo| { &m.message },
            |m: &mut NotificationMessageInfo| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageTimestamp",
            |m: &NotificationMessageInfo| { &m.messageTimestamp },
            |m: &mut NotificationMessageInfo| { &mut m.messageTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "participant",
            |m: &NotificationMessageInfo| { &m.participant },
            |m: &mut NotificationMessageInfo| { &mut m.participant },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NotificationMessageInfo>(
            "NotificationMessageInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NotificationMessageInfo {
    const NAME: &'static str = "NotificationMessageInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                24 => {
                    self.messageTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.participant = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.messageTimestamp {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.participant.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.message.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.messageTimestamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.participant.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NotificationMessageInfo {
        NotificationMessageInfo::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.message.clear();
        self.messageTimestamp = ::std::option::Option::None;
        self.participant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NotificationMessageInfo {
        static instance: NotificationMessageInfo = NotificationMessageInfo {
            key: ::protobuf::MessageField::none(),
            message: ::protobuf::MessageField::none(),
            messageTimestamp: ::std::option::Option::None,
            participant: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NotificationMessageInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NotificationMessageInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NotificationMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NotificationMessageInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.MediaData)
pub struct MediaData {
    // message fields
    // @@protoc_insertion_point(field:proto.MediaData.localPath)
    pub localPath: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.MediaData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaData {
    fn default() -> &'a MediaData {
        <MediaData as ::protobuf::Message>::default_instance()
    }
}

impl MediaData {
    pub fn new() -> MediaData {
        ::std::default::Default::default()
    }

    // optional string localPath = 1;

    pub fn localPath(&self) -> &str {
        match self.localPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localPath(&mut self) {
        self.localPath = ::std::option::Option::None;
    }

    pub fn has_localPath(&self) -> bool {
        self.localPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localPath(&mut self, v: ::std::string::String) {
        self.localPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localPath(&mut self) -> &mut ::std::string::String {
        if self.localPath.is_none() {
            self.localPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_localPath(&mut self) -> ::std::string::String {
        self.localPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localPath",
            |m: &MediaData| { &m.localPath },
            |m: &mut MediaData| { &mut m.localPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaData>(
            "MediaData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaData {
    const NAME: &'static str = "MediaData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.localPath = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.localPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.localPath.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaData {
        MediaData::new()
    }

    fn clear(&mut self) {
        self.localPath = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaData {
        static instance: MediaData = MediaData {
            localPath: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.KeepInChat)
pub struct KeepInChat {
    // message fields
    // @@protoc_insertion_point(field:proto.KeepInChat.keepType)
    pub keepType: ::std::option::Option<::protobuf::EnumOrUnknown<KeepType>>,
    // @@protoc_insertion_point(field:proto.KeepInChat.serverTimestamp)
    pub serverTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.KeepInChat.key)
    pub key: ::protobuf::MessageField<MessageKey>,
    // @@protoc_insertion_point(field:proto.KeepInChat.deviceJid)
    pub deviceJid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:proto.KeepInChat.clientTimestampMs)
    pub clientTimestampMs: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:proto.KeepInChat.serverTimestampMs)
    pub serverTimestampMs: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.KeepInChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeepInChat {
    fn default() -> &'a KeepInChat {
        <KeepInChat as ::protobuf::Message>::default_instance()
    }
}

impl KeepInChat {
    pub fn new() -> KeepInChat {
        ::std::default::Default::default()
    }

    // optional .proto.KeepType keepType = 1;

    pub fn keepType(&self) -> KeepType {
        match self.keepType {
            Some(e) => e.enum_value_or(KeepType::UNKNOWN),
            None => KeepType::UNKNOWN,
        }
    }

    pub fn clear_keepType(&mut self) {
        self.keepType = ::std::option::Option::None;
    }

    pub fn has_keepType(&self) -> bool {
        self.keepType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keepType(&mut self, v: KeepType) {
        self.keepType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 serverTimestamp = 2;

    pub fn serverTimestamp(&self) -> i64 {
        self.serverTimestamp.unwrap_or(0)
    }

    pub fn clear_serverTimestamp(&mut self) {
        self.serverTimestamp = ::std::option::Option::None;
    }

    pub fn has_serverTimestamp(&self) -> bool {
        self.serverTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverTimestamp(&mut self, v: i64) {
        self.serverTimestamp = ::std::option::Option::Some(v);
    }

    // optional string deviceJid = 4;

    pub fn deviceJid(&self) -> &str {
        match self.deviceJid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_deviceJid(&mut self) {
        self.deviceJid = ::std::option::Option::None;
    }

    pub fn has_deviceJid(&self) -> bool {
        self.deviceJid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviceJid(&mut self, v: ::std::string::String) {
        self.deviceJid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deviceJid(&mut self) -> &mut ::std::string::String {
        if self.deviceJid.is_none() {
            self.deviceJid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.deviceJid.as_mut().unwrap()
    }

    // Take field
    pub fn take_deviceJid(&mut self) -> ::std::string::String {
        self.deviceJid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 clientTimestampMs = 5;

    pub fn clientTimestampMs(&self) -> i64 {
        self.clientTimestampMs.unwrap_or(0)
    }

    pub fn clear_clientTimestampMs(&mut self) {
        self.clientTimestampMs = ::std::option::Option::None;
    }

    pub fn has_clientTimestampMs(&self) -> bool {
        self.clientTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientTimestampMs(&mut self, v: i64) {
        self.clientTimestampMs = ::std::option::Option::Some(v);
    }

    // optional int64 serverTimestampMs = 6;

    pub fn serverTimestampMs(&self) -> i64 {
        self.serverTimestampMs.unwrap_or(0)
    }

    pub fn clear_serverTimestampMs(&mut self) {
        self.serverTimestampMs = ::std::option::Option::None;
    }

    pub fn has_serverTimestampMs(&self) -> bool {
        self.serverTimestampMs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverTimestampMs(&mut self, v: i64) {
        self.serverTimestampMs = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keepType",
            |m: &KeepInChat| { &m.keepType },
            |m: &mut KeepInChat| { &mut m.keepType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverTimestamp",
            |m: &KeepInChat| { &m.serverTimestamp },
            |m: &mut KeepInChat| { &mut m.serverTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageKey>(
            "key",
            |m: &KeepInChat| { &m.key },
            |m: &mut KeepInChat| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deviceJid",
            |m: &KeepInChat| { &m.deviceJid },
            |m: &mut KeepInChat| { &mut m.deviceJid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientTimestampMs",
            |m: &KeepInChat| { &m.clientTimestampMs },
            |m: &mut KeepInChat| { &mut m.clientTimestampMs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverTimestampMs",
            |m: &KeepInChat| { &m.serverTimestampMs },
            |m: &mut KeepInChat| { &mut m.serverTimestampMs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeepInChat>(
            "KeepInChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeepInChat {
    const NAME: &'static str = "KeepInChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.keepType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.serverTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                34 => {
                    self.deviceJid = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.clientTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.serverTimestampMs = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keepType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.serverTimestamp {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deviceJid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.clientTimestampMs {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.serverTimestampMs {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keepType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.serverTimestamp {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.deviceJid.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.clientTimestampMs {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.serverTimestampMs {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeepInChat {
        KeepInChat::new()
    }

    fn clear(&mut self) {
        self.keepType = ::std::option::Option::None;
        self.serverTimestamp = ::std::option::Option::None;
        self.key.clear();
        self.deviceJid = ::std::option::Option::None;
        self.clientTimestampMs = ::std::option::Option::None;
        self.serverTimestampMs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeepInChat {
        static instance: KeepInChat = KeepInChat {
            keepType: ::std::option::Option::None,
            serverTimestamp: ::std::option::Option::None,
            key: ::protobuf::MessageField::none(),
            deviceJid: ::std::option::Option::None,
            clientTimestampMs: ::std::option::Option::None,
            serverTimestampMs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeepInChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeepInChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeepInChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeepInChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.NoiseCertificate)
pub struct NoiseCertificate {
    // message fields
    // @@protoc_insertion_point(field:proto.NoiseCertificate.details)
    pub details: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:proto.NoiseCertificate.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.NoiseCertificate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoiseCertificate {
    fn default() -> &'a NoiseCertificate {
        <NoiseCertificate as ::protobuf::Message>::default_instance()
    }
}

impl NoiseCertificate {
    pub fn new() -> NoiseCertificate {
        ::std::default::Default::default()
    }

    // optional bytes details = 1;

    pub fn details(&self) -> &[u8] {
        match self.details.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &NoiseCertificate| { &m.details },
            |m: &mut NoiseCertificate| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &NoiseCertificate| { &m.signature },
            |m: &mut NoiseCertificate| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoiseCertificate>(
            "NoiseCertificate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoiseCertificate {
    const NAME: &'static str = "NoiseCertificate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.details.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoiseCertificate {
        NoiseCertificate::new()
    }

    fn clear(&mut self) {
        self.details = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoiseCertificate {
        static instance: NoiseCertificate = NoiseCertificate {
            details: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoiseCertificate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoiseCertificate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoiseCertificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoiseCertificate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NoiseCertificate`
pub mod noise_certificate {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.NoiseCertificate.Details)
    pub struct Details {
        // message fields
        // @@protoc_insertion_point(field:proto.NoiseCertificate.Details.serial)
        pub serial: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:proto.NoiseCertificate.Details.issuer)
        pub issuer: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.NoiseCertificate.Details.expires)
        pub expires: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:proto.NoiseCertificate.Details.subject)
        pub subject: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:proto.NoiseCertificate.Details.key)
        pub key: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.NoiseCertificate.Details.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Details {
        fn default() -> &'a Details {
            <Details as ::protobuf::Message>::default_instance()
        }
    }

    impl Details {
        pub fn new() -> Details {
            ::std::default::Default::default()
        }

        // optional uint32 serial = 1;

        pub fn serial(&self) -> u32 {
            self.serial.unwrap_or(0)
        }

        pub fn clear_serial(&mut self) {
            self.serial = ::std::option::Option::None;
        }

        pub fn has_serial(&self) -> bool {
            self.serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_serial(&mut self, v: u32) {
            self.serial = ::std::option::Option::Some(v);
        }

        // optional string issuer = 2;

        pub fn issuer(&self) -> &str {
            match self.issuer.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_issuer(&mut self) {
            self.issuer = ::std::option::Option::None;
        }

        pub fn has_issuer(&self) -> bool {
            self.issuer.is_some()
        }

        // Param is passed by value, moved
        pub fn set_issuer(&mut self, v: ::std::string::String) {
            self.issuer = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
            if self.issuer.is_none() {
                self.issuer = ::std::option::Option::Some(::std::string::String::new());
            }
            self.issuer.as_mut().unwrap()
        }

        // Take field
        pub fn take_issuer(&mut self) -> ::std::string::String {
            self.issuer.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 expires = 3;

        pub fn expires(&self) -> u64 {
            self.expires.unwrap_or(0)
        }

        pub fn clear_expires(&mut self) {
            self.expires = ::std::option::Option::None;
        }

        pub fn has_expires(&self) -> bool {
            self.expires.is_some()
        }

        // Param is passed by value, moved
        pub fn set_expires(&mut self, v: u64) {
            self.expires = ::std::option::Option::Some(v);
        }

        // optional string subject = 4;

        pub fn subject(&self) -> &str {
            match self.subject.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_subject(&mut self) {
            self.subject = ::std::option::Option::None;
        }

        pub fn has_subject(&self) -> bool {
            self.subject.is_some()
        }

        // Param is passed by value, moved
        pub fn set_subject(&mut self, v: ::std::string::String) {
            self.subject = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_subject(&mut self) -> &mut ::std::string::String {
            if self.subject.is_none() {
                self.subject = ::std::option::Option::Some(::std::string::String::new());
            }
            self.subject.as_mut().unwrap()
        }

        // Take field
        pub fn take_subject(&mut self) -> ::std::string::String {
            self.subject.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes key = 5;

        pub fn key(&self) -> &[u8] {
            match self.key.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
            self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "serial",
                |m: &Details| { &m.serial },
                |m: &mut Details| { &mut m.serial },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "issuer",
                |m: &Details| { &m.issuer },
                |m: &mut Details| { &mut m.issuer },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "expires",
                |m: &Details| { &m.expires },
                |m: &mut Details| { &mut m.expires },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "subject",
                |m: &Details| { &m.subject },
                |m: &mut Details| { &mut m.subject },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &Details| { &m.key },
                |m: &mut Details| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Details>(
                "NoiseCertificate.Details",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Details {
        const NAME: &'static str = "Details";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.serial = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.issuer = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.expires = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.subject = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.key = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.serial {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.issuer.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.expires {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.subject.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.serial {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.issuer.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.expires {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.subject.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.key.as_ref() {
                os.write_bytes(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Details {
            Details::new()
        }

        fn clear(&mut self) {
            self.serial = ::std::option::Option::None;
            self.issuer = ::std::option::Option::None;
            self.expires = ::std::option::Option::None;
            self.subject = ::std::option::Option::None;
            self.key = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Details {
            static instance: Details = Details {
                serial: ::std::option::Option::None,
                issuer: ::std::option::Option::None,
                expires: ::std::option::Option::None,
                subject: ::std::option::Option::None,
                key: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Details {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NoiseCertificate.Details").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Details {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Details {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:proto.CertChain)
pub struct CertChain {
    // message fields
    // @@protoc_insertion_point(field:proto.CertChain.leaf)
    pub leaf: ::protobuf::MessageField<cert_chain::NoiseCertificate>,
    // @@protoc_insertion_point(field:proto.CertChain.intermediate)
    pub intermediate: ::protobuf::MessageField<cert_chain::NoiseCertificate>,
    // special fields
    // @@protoc_insertion_point(special_field:proto.CertChain.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CertChain {
    fn default() -> &'a CertChain {
        <CertChain as ::protobuf::Message>::default_instance()
    }
}

impl CertChain {
    pub fn new() -> CertChain {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cert_chain::NoiseCertificate>(
            "leaf",
            |m: &CertChain| { &m.leaf },
            |m: &mut CertChain| { &mut m.leaf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cert_chain::NoiseCertificate>(
            "intermediate",
            |m: &CertChain| { &m.intermediate },
            |m: &mut CertChain| { &mut m.intermediate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CertChain>(
            "CertChain",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CertChain {
    const NAME: &'static str = "CertChain";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leaf)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.intermediate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.leaf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.intermediate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.leaf.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.intermediate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CertChain {
        CertChain::new()
    }

    fn clear(&mut self) {
        self.leaf.clear();
        self.intermediate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CertChain {
        static instance: CertChain = CertChain {
            leaf: ::protobuf::MessageField::none(),
            intermediate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CertChain {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CertChain").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CertChain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CertChain {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CertChain`
pub mod cert_chain {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:proto.CertChain.NoiseCertificate)
    pub struct NoiseCertificate {
        // message fields
        // @@protoc_insertion_point(field:proto.CertChain.NoiseCertificate.details)
        pub details: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:proto.CertChain.NoiseCertificate.signature)
        pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:proto.CertChain.NoiseCertificate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NoiseCertificate {
        fn default() -> &'a NoiseCertificate {
            <NoiseCertificate as ::protobuf::Message>::default_instance()
        }
    }

    impl NoiseCertificate {
        pub fn new() -> NoiseCertificate {
            ::std::default::Default::default()
        }

        // optional bytes details = 1;

        pub fn details(&self) -> &[u8] {
            match self.details.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_details(&mut self) {
            self.details = ::std::option::Option::None;
        }

        pub fn has_details(&self) -> bool {
            self.details.is_some()
        }

        // Param is passed by value, moved
        pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
            self.details = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.details.is_none() {
                self.details = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.details.as_mut().unwrap()
        }

        // Take field
        pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
            self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes signature = 2;

        pub fn signature(&self) -> &[u8] {
            match self.signature.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_signature(&mut self) {
            self.signature = ::std::option::Option::None;
        }

        pub fn has_signature(&self) -> bool {
            self.signature.is_some()
        }

        // Param is passed by value, moved
        pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
            self.signature = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.signature.is_none() {
                self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.signature.as_mut().unwrap()
        }

        // Take field
        pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
            self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "details",
                |m: &NoiseCertificate| { &m.details },
                |m: &mut NoiseCertificate| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "signature",
                |m: &NoiseCertificate| { &m.signature },
                |m: &mut NoiseCertificate| { &mut m.signature },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoiseCertificate>(
                "CertChain.NoiseCertificate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for NoiseCertificate {
        const NAME: &'static str = "NoiseCertificate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.details = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    18 => {
                        self.signature = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.details.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.signature.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.details.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.signature.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NoiseCertificate {
            NoiseCertificate::new()
        }

        fn clear(&mut self) {
            self.details = ::std::option::Option::None;
            self.signature = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NoiseCertificate {
            static instance: NoiseCertificate = NoiseCertificate {
                details: ::std::option::Option::None,
                signature: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for NoiseCertificate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CertChain.NoiseCertificate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NoiseCertificate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for NoiseCertificate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `NoiseCertificate`
    pub mod noise_certificate {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:proto.CertChain.NoiseCertificate.Details)
        pub struct Details {
            // message fields
            // @@protoc_insertion_point(field:proto.CertChain.NoiseCertificate.Details.serial)
            pub serial: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:proto.CertChain.NoiseCertificate.Details.issuerSerial)
            pub issuerSerial: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:proto.CertChain.NoiseCertificate.Details.key)
            pub key: ::std::option::Option<::std::vec::Vec<u8>>,
            // @@protoc_insertion_point(field:proto.CertChain.NoiseCertificate.Details.notBefore)
            pub notBefore: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:proto.CertChain.NoiseCertificate.Details.notAfter)
            pub notAfter: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:proto.CertChain.NoiseCertificate.Details.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Details {
            fn default() -> &'a Details {
                <Details as ::protobuf::Message>::default_instance()
            }
        }

        impl Details {
            pub fn new() -> Details {
                ::std::default::Default::default()
            }

            // optional uint32 serial = 1;

            pub fn serial(&self) -> u32 {
                self.serial.unwrap_or(0)
            }

            pub fn clear_serial(&mut self) {
                self.serial = ::std::option::Option::None;
            }

            pub fn has_serial(&self) -> bool {
                self.serial.is_some()
            }

            // Param is passed by value, moved
            pub fn set_serial(&mut self, v: u32) {
                self.serial = ::std::option::Option::Some(v);
            }

            // optional uint32 issuerSerial = 2;

            pub fn issuerSerial(&self) -> u32 {
                self.issuerSerial.unwrap_or(0)
            }

            pub fn clear_issuerSerial(&mut self) {
                self.issuerSerial = ::std::option::Option::None;
            }

            pub fn has_issuerSerial(&self) -> bool {
                self.issuerSerial.is_some()
            }

            // Param is passed by value, moved
            pub fn set_issuerSerial(&mut self, v: u32) {
                self.issuerSerial = ::std::option::Option::Some(v);
            }

            // optional bytes key = 3;

            pub fn key(&self) -> &[u8] {
                match self.key.as_ref() {
                    Some(v) => v,
                    None => &[],
                }
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
                self.key = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
                if self.key.is_none() {
                    self.key = ::std::option::Option::Some(::std::vec::Vec::new());
                }
                self.key.as_mut().unwrap()
            }

            // Take field
            pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
                self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
            }

            // optional uint64 notBefore = 4;

            pub fn notBefore(&self) -> u64 {
                self.notBefore.unwrap_or(0)
            }

            pub fn clear_notBefore(&mut self) {
                self.notBefore = ::std::option::Option::None;
            }

            pub fn has_notBefore(&self) -> bool {
                self.notBefore.is_some()
            }

            // Param is passed by value, moved
            pub fn set_notBefore(&mut self, v: u64) {
                self.notBefore = ::std::option::Option::Some(v);
            }

            // optional uint64 notAfter = 5;

            pub fn notAfter(&self) -> u64 {
                self.notAfter.unwrap_or(0)
            }

            pub fn clear_notAfter(&mut self) {
                self.notAfter = ::std::option::Option::None;
            }

            pub fn has_notAfter(&self) -> bool {
                self.notAfter.is_some()
            }

            // Param is passed by value, moved
            pub fn set_notAfter(&mut self, v: u64) {
                self.notAfter = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "serial",
                    |m: &Details| { &m.serial },
                    |m: &mut Details| { &mut m.serial },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "issuerSerial",
                    |m: &Details| { &m.issuerSerial },
                    |m: &mut Details| { &mut m.issuerSerial },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "key",
                    |m: &Details| { &m.key },
                    |m: &mut Details| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "notBefore",
                    |m: &Details| { &m.notBefore },
                    |m: &mut Details| { &mut m.notBefore },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "notAfter",
                    |m: &Details| { &m.notAfter },
                    |m: &mut Details| { &mut m.notAfter },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Details>(
                    "CertChain.NoiseCertificate.Details",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Details {
            const NAME: &'static str = "Details";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.serial = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.issuerSerial = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        26 => {
                            self.key = ::std::option::Option::Some(is.read_bytes()?);
                        },
                        32 => {
                            self.notBefore = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        40 => {
                            self.notAfter = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.serial {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.issuerSerial {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.key.as_ref() {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                }
                if let Some(v) = self.notBefore {
                    my_size += ::protobuf::rt::uint64_size(4, v);
                }
                if let Some(v) = self.notAfter {
                    my_size += ::protobuf::rt::uint64_size(5, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.serial {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.issuerSerial {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.key.as_ref() {
                    os.write_bytes(3, v)?;
                }
                if let Some(v) = self.notBefore {
                    os.write_uint64(4, v)?;
                }
                if let Some(v) = self.notAfter {
                    os.write_uint64(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Details {
                Details::new()
            }

            fn clear(&mut self) {
                self.serial = ::std::option::Option::None;
                self.issuerSerial = ::std::option::Option::None;
                self.key = ::std::option::Option::None;
                self.notBefore = ::std::option::Option::None;
                self.notAfter = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Details {
                static instance: Details = Details {
                    serial: ::std::option::Option::None,
                    issuerSerial: ::std::option::Option::None,
                    key: ::std::option::Option::None,
                    notBefore: ::std::option::Option::None,
                    notAfter: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Details {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CertChain.NoiseCertificate.Details").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Details {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Details {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.KeepType)
pub enum KeepType {
    // @@protoc_insertion_point(enum_value:proto.KeepType.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:proto.KeepType.KEEP_FOR_ALL)
    KEEP_FOR_ALL = 1,
    // @@protoc_insertion_point(enum_value:proto.KeepType.UNDO_KEEP_FOR_ALL)
    UNDO_KEEP_FOR_ALL = 2,
}

impl ::protobuf::Enum for KeepType {
    const NAME: &'static str = "KeepType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KeepType> {
        match value {
            0 => ::std::option::Option::Some(KeepType::UNKNOWN),
            1 => ::std::option::Option::Some(KeepType::KEEP_FOR_ALL),
            2 => ::std::option::Option::Some(KeepType::UNDO_KEEP_FOR_ALL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KeepType] = &[
        KeepType::UNKNOWN,
        KeepType::KEEP_FOR_ALL,
        KeepType::UNDO_KEEP_FOR_ALL,
    ];
}

impl ::protobuf::EnumFull for KeepType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KeepType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for KeepType {
    fn default() -> Self {
        KeepType::UNKNOWN
    }
}

impl KeepType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KeepType>("KeepType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.PeerDataOperationRequestType)
pub enum PeerDataOperationRequestType {
    // @@protoc_insertion_point(enum_value:proto.PeerDataOperationRequestType.UPLOAD_STICKER)
    UPLOAD_STICKER = 0,
    // @@protoc_insertion_point(enum_value:proto.PeerDataOperationRequestType.SEND_RECENT_STICKER_BOOTSTRAP)
    SEND_RECENT_STICKER_BOOTSTRAP = 1,
    // @@protoc_insertion_point(enum_value:proto.PeerDataOperationRequestType.GENERATE_LINK_PREVIEW)
    GENERATE_LINK_PREVIEW = 2,
}

impl ::protobuf::Enum for PeerDataOperationRequestType {
    const NAME: &'static str = "PeerDataOperationRequestType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PeerDataOperationRequestType> {
        match value {
            0 => ::std::option::Option::Some(PeerDataOperationRequestType::UPLOAD_STICKER),
            1 => ::std::option::Option::Some(PeerDataOperationRequestType::SEND_RECENT_STICKER_BOOTSTRAP),
            2 => ::std::option::Option::Some(PeerDataOperationRequestType::GENERATE_LINK_PREVIEW),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PeerDataOperationRequestType] = &[
        PeerDataOperationRequestType::UPLOAD_STICKER,
        PeerDataOperationRequestType::SEND_RECENT_STICKER_BOOTSTRAP,
        PeerDataOperationRequestType::GENERATE_LINK_PREVIEW,
    ];
}

impl ::protobuf::EnumFull for PeerDataOperationRequestType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PeerDataOperationRequestType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PeerDataOperationRequestType {
    fn default() -> Self {
        PeerDataOperationRequestType::UPLOAD_STICKER
    }
}

impl PeerDataOperationRequestType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PeerDataOperationRequestType>("PeerDataOperationRequestType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:proto.MediaVisibility)
pub enum MediaVisibility {
    // @@protoc_insertion_point(enum_value:proto.MediaVisibility.DEFAULT)
    DEFAULT = 0,
    // @@protoc_insertion_point(enum_value:proto.MediaVisibility.OFF)
    OFF = 1,
    // @@protoc_insertion_point(enum_value:proto.MediaVisibility.ON)
    ON = 2,
}

impl ::protobuf::Enum for MediaVisibility {
    const NAME: &'static str = "MediaVisibility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaVisibility> {
        match value {
            0 => ::std::option::Option::Some(MediaVisibility::DEFAULT),
            1 => ::std::option::Option::Some(MediaVisibility::OFF),
            2 => ::std::option::Option::Some(MediaVisibility::ON),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaVisibility] = &[
        MediaVisibility::DEFAULT,
        MediaVisibility::OFF,
        MediaVisibility::ON,
    ];
}

impl ::protobuf::EnumFull for MediaVisibility {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaVisibility").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MediaVisibility {
    fn default() -> Self {
        MediaVisibility::DEFAULT
    }
}

impl MediaVisibility {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaVisibility>("MediaVisibility")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tdef.proto\x12\x05proto\"]\n\x15ADVSignedKeyIndexList\x12\x18\n\x07de\
    tails\x18\x01\x20\x01(\x0cR\x07details\x12*\n\x10accountSignature\x18\
    \x02\x20\x01(\x0cR\x10accountSignature\"\xbb\x01\n\x17ADVSignedDeviceIde\
    ntity\x12\x18\n\x07details\x18\x01\x20\x01(\x0cR\x07details\x120\n\x13ac\
    countSignatureKey\x18\x02\x20\x01(\x0cR\x13accountSignatureKey\x12*\n\
    \x10accountSignature\x18\x03\x20\x01(\x0cR\x10accountSignature\x12(\n\
    \x0fdeviceSignature\x18\x04\x20\x01(\x0cR\x0fdeviceSignature\"K\n\x1bADV\
    SignedDeviceIdentityHMAC\x12\x18\n\x07details\x18\x01\x20\x01(\x0cR\x07d\
    etails\x12\x12\n\x04hmac\x18\x02\x20\x01(\x0cR\x04hmac\"\x91\x01\n\x0fAD\
    VKeyIndexList\x12\x14\n\x05rawId\x18\x01\x20\x01(\rR\x05rawId\x12\x1c\n\
    \ttimestamp\x18\x02\x20\x01(\x04R\ttimestamp\x12\"\n\x0ccurrentIndex\x18\
    \x03\x20\x01(\rR\x0ccurrentIndex\x12&\n\x0cvalidIndexes\x18\x04\x20\x03(\
    \rR\x0cvalidIndexesB\x02\x10\x01\"c\n\x11ADVDeviceIdentity\x12\x14\n\x05\
    rawId\x18\x01\x20\x01(\rR\x05rawId\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\
    \x04R\ttimestamp\x12\x1a\n\x08keyIndex\x18\x03\x20\x01(\rR\x08keyIndex\"\
    \x8f\x06\n\x0bDeviceProps\x12\x0e\n\x02os\x18\x01\x20\x01(\tR\x02os\x127\
    \n\x07version\x18\x02\x20\x01(\x0b2\x1d.proto.DeviceProps.AppVersionR\
    \x07version\x12C\n\x0cplatformType\x18\x03\x20\x01(\x0e2\x1f.proto.Devic\
    eProps.PlatformTypeR\x0cplatformType\x12(\n\x0frequireFullSync\x18\x04\
    \x20\x01(\x08R\x0frequireFullSync\x12R\n\x11historySyncConfig\x18\x05\
    \x20\x01(\x0b2$.proto.DeviceProps.HistorySyncConfigR\x11historySyncConfi\
    g\x1a\x9b\x01\n\x11HistorySyncConfig\x12,\n\x11fullSyncDaysLimit\x18\x01\
    \x20\x01(\rR\x11fullSyncDaysLimit\x120\n\x13fullSyncSizeMbLimit\x18\x02\
    \x20\x01(\rR\x13fullSyncSizeMbLimit\x12&\n\x0estorageQuotaMb\x18\x03\x20\
    \x01(\rR\x0estorageQuotaMb\x1a\x9a\x01\n\nAppVersion\x12\x18\n\x07primar\
    y\x18\x01\x20\x01(\rR\x07primary\x12\x1c\n\tsecondary\x18\x02\x20\x01(\r\
    R\tsecondary\x12\x1a\n\x08tertiary\x18\x03\x20\x01(\rR\x08tertiary\x12\
    \x1e\n\nquaternary\x18\x04\x20\x01(\rR\nquaternary\x12\x18\n\x07quinary\
    \x18\x05\x20\x01(\rR\x07quinary\"\xb8\x01\n\x0cPlatformType\x12\x0b\n\
    \x07UNKNOWN\x10\0\x12\n\n\x06CHROME\x10\x01\x12\x0b\n\x07FIREFOX\x10\x02\
    \x12\x06\n\x02IE\x10\x03\x12\t\n\x05OPERA\x10\x04\x12\n\n\x06SAFARI\x10\
    \x05\x12\x08\n\x04EDGE\x10\x06\x12\x0b\n\x07DESKTOP\x10\x07\x12\x08\n\
    \x04IPAD\x10\x08\x12\x12\n\x0eANDROID_TABLET\x10\t\x12\t\n\x05OHANA\x10\
    \n\x12\t\n\x05ALOHA\x10\x0b\x12\x0c\n\x08CATALINA\x10\x0c\x12\n\n\x06TCL\
    _TV\x10\r\"\xca\x03\n\x1fPeerDataOperationRequestMessage\x12g\n\x1cpeerD\
    ataOperationRequestType\x18\x01\x20\x01(\x0e2#.proto.PeerDataOperationRe\
    questTypeR\x1cpeerDataOperationRequestType\x12u\n\x16requestStickerReupl\
    oad\x18\x02\x20\x03(\x0b2=.proto.PeerDataOperationRequestMessage.Request\
    StickerReuploadR\x16requestStickerReupload\x12f\n\x11requestUrlPreview\
    \x18\x03\x20\x03(\x0b28.proto.PeerDataOperationRequestMessage.RequestUrl\
    PreviewR\x11requestUrlPreview\x1a%\n\x11RequestUrlPreview\x12\x10\n\x03u\
    rl\x18\x01\x20\x01(\tR\x03url\x1a8\n\x16RequestStickerReupload\x12\x1e\n\
    \nfileSha256\x18\x01\x20\x01(\tR\nfileSha256\"\xc5\x01\n\x14PaymentInvit\
    eMessage\x12I\n\x0bserviceType\x18\x01\x20\x01(\x0e2'.proto.PaymentInvit\
    eMessage.ServiceTypeR\x0bserviceType\x12(\n\x0fexpiryTimestamp\x18\x02\
    \x20\x01(\x03R\x0fexpiryTimestamp\"8\n\x0bServiceType\x12\x0b\n\x07UNKNO\
    WN\x10\0\x12\t\n\x05FBPAY\x10\x01\x12\x08\n\x04NOVI\x10\x02\x12\x07\n\
    \x03UPI\x10\x03\"\x8e\x04\n\x0cOrderMessage\x12\x18\n\x07orderId\x18\x01\
    \x20\x01(\tR\x07orderId\x12\x1c\n\tthumbnail\x18\x02\x20\x01(\x0cR\tthum\
    bnail\x12\x1c\n\titemCount\x18\x03\x20\x01(\x05R\titemCount\x127\n\x06st\
    atus\x18\x04\x20\x01(\x0e2\x1f.proto.OrderMessage.OrderStatusR\x06status\
    \x12:\n\x07surface\x18\x05\x20\x01(\x0e2\x20.proto.OrderMessage.OrderSur\
    faceR\x07surface\x12\x18\n\x07message\x18\x06\x20\x01(\tR\x07message\x12\
    \x1e\n\norderTitle\x18\x07\x20\x01(\tR\norderTitle\x12\x1c\n\tsellerJid\
    \x18\x08\x20\x01(\tR\tsellerJid\x12\x14\n\x05token\x18\t\x20\x01(\tR\x05\
    token\x12(\n\x0ftotalAmount1000\x18\n\x20\x01(\x03R\x0ftotalAmount1000\
    \x12,\n\x11totalCurrencyCode\x18\x0b\x20\x01(\tR\x11totalCurrencyCode\
    \x124\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bc\
    ontextInfo\"\x1b\n\x0cOrderSurface\x12\x0b\n\x07CATALOG\x10\x01\"\x1a\n\
    \x0bOrderStatus\x12\x0b\n\x07INQUIRY\x10\x01\"\xcf\x03\n\x0fLocationMess\
    age\x12(\n\x0fdegreesLatitude\x18\x01\x20\x01(\x01R\x0fdegreesLatitude\
    \x12*\n\x10degreesLongitude\x18\x02\x20\x01(\x01R\x10degreesLongitude\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x18\n\x07address\x18\
    \x04\x20\x01(\tR\x07address\x12\x10\n\x03url\x18\x05\x20\x01(\tR\x03url\
    \x12\x16\n\x06isLive\x18\x06\x20\x01(\x08R\x06isLive\x12*\n\x10accuracyI\
    nMeters\x18\x07\x20\x01(\rR\x10accuracyInMeters\x12\x1e\n\nspeedInMps\
    \x18\x08\x20\x01(\x02R\nspeedInMps\x12L\n!degreesClockwiseFromMagneticNo\
    rth\x18\t\x20\x01(\rR!degreesClockwiseFromMagneticNorth\x12\x18\n\x07com\
    ment\x18\x0b\x20\x01(\tR\x07comment\x12$\n\rjpegThumbnail\x18\x10\x20\
    \x01(\x0cR\rjpegThumbnail\x124\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\
    \x12.proto.ContextInfoR\x0bcontextInfo\"\xc3\x03\n\x13LiveLocationMessag\
    e\x12(\n\x0fdegreesLatitude\x18\x01\x20\x01(\x01R\x0fdegreesLatitude\x12\
    *\n\x10degreesLongitude\x18\x02\x20\x01(\x01R\x10degreesLongitude\x12*\n\
    \x10accuracyInMeters\x18\x03\x20\x01(\rR\x10accuracyInMeters\x12\x1e\n\n\
    speedInMps\x18\x04\x20\x01(\x02R\nspeedInMps\x12L\n!degreesClockwiseFrom\
    MagneticNorth\x18\x05\x20\x01(\rR!degreesClockwiseFromMagneticNorth\x12\
    \x18\n\x07caption\x18\x06\x20\x01(\tR\x07caption\x12&\n\x0esequenceNumbe\
    r\x18\x07\x20\x01(\x03R\x0esequenceNumber\x12\x1e\n\ntimeOffset\x18\x08\
    \x20\x01(\rR\ntimeOffset\x12$\n\rjpegThumbnail\x18\x10\x20\x01(\x0cR\rjp\
    egThumbnail\x124\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x12.proto.Contex\
    tInfoR\x0bcontextInfo\"\x87\x03\n\x13ListResponseMessage\x12\x14\n\x05ti\
    tle\x18\x01\x20\x01(\tR\x05title\x12?\n\x08listType\x18\x02\x20\x01(\x0e\
    2#.proto.ListResponseMessage.ListTypeR\x08listType\x12Z\n\x11singleSelec\
    tReply\x18\x03\x20\x01(\x0b2,.proto.ListResponseMessage.SingleSelectRepl\
    yR\x11singleSelectReply\x124\n\x0bcontextInfo\x18\x04\x20\x01(\x0b2\x12.\
    proto.ContextInfoR\x0bcontextInfo\x12\x20\n\x0bdescription\x18\x05\x20\
    \x01(\tR\x0bdescription\x1a9\n\x11SingleSelectReply\x12$\n\rselectedRowI\
    d\x18\x01\x20\x01(\tR\rselectedRowId\"*\n\x08ListType\x12\x0b\n\x07UNKNO\
    WN\x10\0\x12\x11\n\rSINGLE_SELECT\x10\x01\"\x9b\x08\n\x0bListMessage\x12\
    \x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x20\n\x0bdescription\
    \x18\x02\x20\x01(\tR\x0bdescription\x12\x1e\n\nbuttonText\x18\x03\x20\
    \x01(\tR\nbuttonText\x127\n\x08listType\x18\x04\x20\x01(\x0e2\x1b.proto.\
    ListMessage.ListTypeR\x08listType\x126\n\x08sections\x18\x05\x20\x03(\
    \x0b2\x1a.proto.ListMessage.SectionR\x08sections\x12L\n\x0fproductListIn\
    fo\x18\x06\x20\x01(\x0b2\".proto.ListMessage.ProductListInfoR\x0fproduct\
    ListInfo\x12\x1e\n\nfooterText\x18\x07\x20\x01(\tR\nfooterText\x124\n\
    \x0bcontextInfo\x18\x08\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextI\
    nfo\x1aK\n\x07Section\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\
    \x12*\n\x04rows\x18\x02\x20\x03(\x0b2\x16.proto.ListMessage.RowR\x04rows\
    \x1aS\n\x03Row\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x20\n\
    \x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12\x14\n\x05rowId\
    \x18\x03\x20\x01(\tR\x05rowId\x1a'\n\x07Product\x12\x1c\n\tproductId\x18\
    \x01\x20\x01(\tR\tproductId\x1a^\n\x0eProductSection\x12\x14\n\x05title\
    \x18\x01\x20\x01(\tR\x05title\x126\n\x08products\x18\x02\x20\x03(\x0b2\
    \x1a.proto.ListMessage.ProductR\x08products\x1a\xd7\x01\n\x0fProductList\
    Info\x12K\n\x0fproductSections\x18\x01\x20\x03(\x0b2!.proto.ListMessage.\
    ProductSectionR\x0fproductSections\x12K\n\x0bheaderImage\x18\x02\x20\x01\
    (\x0b2).proto.ListMessage.ProductListHeaderImageR\x0bheaderImage\x12*\n\
    \x10businessOwnerJid\x18\x03\x20\x01(\tR\x10businessOwnerJid\x1a\\\n\x16\
    ProductListHeaderImage\x12\x1c\n\tproductId\x18\x01\x20\x01(\tR\tproduct\
    Id\x12$\n\rjpegThumbnail\x18\x02\x20\x01(\x0cR\rjpegThumbnail\"<\n\x08Li\
    stType\x12\x0b\n\x07UNKNOWN\x10\0\x12\x11\n\rSINGLE_SELECT\x10\x01\x12\
    \x10\n\x0cPRODUCT_LIST\x10\x02\"\x87\x01\n\x11KeepInChatMessage\x12#\n\
    \x03key\x18\x01\x20\x01(\x0b2\x11.proto.MessageKeyR\x03key\x12+\n\x08kee\
    pType\x18\x02\x20\x01(\x0e2\x0f.proto.KeepTypeR\x08keepType\x12\x20\n\
    \x0btimestampMs\x18\x03\x20\x01(\x03R\x0btimestampMs\"\xac\x04\n\x0eInvo\
    iceMessage\x12\x12\n\x04note\x18\x01\x20\x01(\tR\x04note\x12\x14\n\x05to\
    ken\x18\x02\x20\x01(\tR\x05token\x12L\n\x0eattachmentType\x18\x03\x20\
    \x01(\x0e2$.proto.InvoiceMessage.AttachmentTypeR\x0eattachmentType\x12.\
    \n\x12attachmentMimetype\x18\x04\x20\x01(\tR\x12attachmentMimetype\x12.\
    \n\x12attachmentMediaKey\x18\x05\x20\x01(\x0cR\x12attachmentMediaKey\x12\
    @\n\x1battachmentMediaKeyTimestamp\x18\x06\x20\x01(\x03R\x1battachmentMe\
    diaKeyTimestamp\x122\n\x14attachmentFileSha256\x18\x07\x20\x01(\x0cR\x14\
    attachmentFileSha256\x128\n\x17attachmentFileEncSha256\x18\x08\x20\x01(\
    \x0cR\x17attachmentFileEncSha256\x122\n\x14attachmentDirectPath\x18\t\
    \x20\x01(\tR\x14attachmentDirectPath\x128\n\x17attachmentJpegThumbnail\
    \x18\n\x20\x01(\x0cR\x17attachmentJpegThumbnail\"$\n\x0eAttachmentType\
    \x12\t\n\x05IMAGE\x10\0\x12\x07\n\x03PDF\x10\x01\"\xb0\x03\n\x1aInteract\
    iveResponseMessage\x12:\n\x04body\x18\x01\x20\x01(\x0b2&.proto.Interacti\
    veResponseMessage.BodyR\x04body\x124\n\x0bcontextInfo\x18\x0f\x20\x01(\
    \x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x12{\n\x19nativeFlowResponse\
    Message\x18\x02\x20\x01(\x0b2;.proto.InteractiveResponseMessage.NativeFl\
    owResponseMessageH\0R\x19nativeFlowResponseMessage\x1ai\n\x19NativeFlowR\
    esponseMessage\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1e\n\n\
    paramsJson\x18\x02\x20\x01(\tR\nparamsJson\x12\x18\n\x07version\x18\x03\
    \x20\x01(\x05R\x07version\x1a\x1a\n\x04Body\x12\x12\n\x04text\x18\x01\
    \x20\x01(\tR\x04textB\x1c\n\x1ainteractiveResponseMessage\"\xf9\x0b\n\
    \x12InteractiveMessage\x128\n\x06header\x18\x01\x20\x01(\x0b2\x20.proto.\
    InteractiveMessage.HeaderR\x06header\x122\n\x04body\x18\x02\x20\x01(\x0b\
    2\x1e.proto.InteractiveMessage.BodyR\x04body\x128\n\x06footer\x18\x03\
    \x20\x01(\x0b2\x20.proto.InteractiveMessage.FooterR\x06footer\x124\n\x0b\
    contextInfo\x18\x0f\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\
    \x12]\n\x15shopStorefrontMessage\x18\x04\x20\x01(\x0b2%.proto.Interactiv\
    eMessage.ShopMessageH\0R\x15shopStorefrontMessage\x12[\n\x11collectionMe\
    ssage\x18\x05\x20\x01(\x0b2+.proto.InteractiveMessage.CollectionMessageH\
    \0R\x11collectionMessage\x12[\n\x11nativeFlowMessage\x18\x06\x20\x01(\
    \x0b2+.proto.InteractiveMessage.NativeFlowMessageH\0R\x11nativeFlowMessa\
    ge\x1a\xc6\x01\n\x0bShopMessage\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02i\
    d\x12G\n\x07surface\x18\x02\x20\x01(\x0e2-.proto.InteractiveMessage.Shop\
    Message.SurfaceR\x07surface\x12&\n\x0emessageVersion\x18\x03\x20\x01(\
    \x05R\x0emessageVersion\"6\n\x07Surface\x12\x13\n\x0fUNKNOWN_SURFACE\x10\
    \0\x12\x06\n\x02FB\x10\x01\x12\x06\n\x02IG\x10\x02\x12\x06\n\x02WA\x10\
    \x03\x1a\x95\x02\n\x11NativeFlowMessage\x12V\n\x07buttons\x18\x01\x20\
    \x03(\x0b2<.proto.InteractiveMessage.NativeFlowMessage.NativeFlowButtonR\
    \x07buttons\x12,\n\x11messageParamsJson\x18\x02\x20\x01(\tR\x11messagePa\
    ramsJson\x12&\n\x0emessageVersion\x18\x03\x20\x01(\x05R\x0emessageVersio\
    n\x1aR\n\x10NativeFlowButton\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x12*\n\x10buttonParamsJson\x18\x02\x20\x01(\tR\x10buttonParamsJson\
    \x1a\xd5\x02\n\x06Header\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\
    \x12\x1a\n\x08subtitle\x18\x02\x20\x01(\tR\x08subtitle\x12.\n\x12hasMedi\
    aAttachment\x18\x05\x20\x01(\x08R\x12hasMediaAttachment\x12B\n\x0fdocume\
    ntMessage\x18\x03\x20\x01(\x0b2\x16.proto.DocumentMessageH\0R\x0fdocumen\
    tMessage\x129\n\x0cimageMessage\x18\x04\x20\x01(\x0b2\x13.proto.ImageMes\
    sageH\0R\x0cimageMessage\x12&\n\rjpegThumbnail\x18\x06\x20\x01(\x0cH\0R\
    \rjpegThumbnail\x129\n\x0cvideoMessage\x18\x07\x20\x01(\x0b2\x13.proto.V\
    ideoMessageH\0R\x0cvideoMessageB\x07\n\x05media\x1a\x1c\n\x06Footer\x12\
    \x12\n\x04text\x18\x01\x20\x01(\tR\x04text\x1ac\n\x11CollectionMessage\
    \x12\x16\n\x06bizJid\x18\x01\x20\x01(\tR\x06bizJid\x12\x0e\n\x02id\x18\
    \x02\x20\x01(\tR\x02id\x12&\n\x0emessageVersion\x18\x03\x20\x01(\x05R\
    \x0emessageVersion\x1a\x1a\n\x04Body\x12\x12\n\x04text\x18\x01\x20\x01(\
    \tR\x04textB\x14\n\x12interactiveMessage\"j\n&InitialSecurityNotificatio\
    nSettingSync\x12@\n\x1bsecurityNotificationEnabled\x18\x01\x20\x01(\x08R\
    \x1bsecurityNotificationEnabled\"\x84\x08\n\x0cImageMessage\x12\x10\n\
    \x03url\x18\x01\x20\x01(\tR\x03url\x12\x1a\n\x08mimetype\x18\x02\x20\x01\
    (\tR\x08mimetype\x12\x18\n\x07caption\x18\x03\x20\x01(\tR\x07caption\x12\
    \x1e\n\nfileSha256\x18\x04\x20\x01(\x0cR\nfileSha256\x12\x1e\n\nfileLeng\
    th\x18\x05\x20\x01(\x04R\nfileLength\x12\x16\n\x06height\x18\x06\x20\x01\
    (\rR\x06height\x12\x14\n\x05width\x18\x07\x20\x01(\rR\x05width\x12\x1a\n\
    \x08mediaKey\x18\x08\x20\x01(\x0cR\x08mediaKey\x12$\n\rfileEncSha256\x18\
    \t\x20\x01(\x0cR\rfileEncSha256\x12T\n\x16interactiveAnnotations\x18\n\
    \x20\x03(\x0b2\x1c.proto.InteractiveAnnotationR\x16interactiveAnnotation\
    s\x12\x1e\n\ndirectPath\x18\x0b\x20\x01(\tR\ndirectPath\x12,\n\x11mediaK\
    eyTimestamp\x18\x0c\x20\x01(\x03R\x11mediaKeyTimestamp\x12$\n\rjpegThumb\
    nail\x18\x10\x20\x01(\x0cR\rjpegThumbnail\x124\n\x0bcontextInfo\x18\x11\
    \x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x12*\n\x10firstScan\
    Sidecar\x18\x12\x20\x01(\x0cR\x10firstScanSidecar\x12(\n\x0ffirstScanLen\
    gth\x18\x13\x20\x01(\rR\x0ffirstScanLength\x12,\n\x11experimentGroupId\
    \x18\x14\x20\x01(\rR\x11experimentGroupId\x12\"\n\x0cscansSidecar\x18\
    \x15\x20\x01(\x0cR\x0cscansSidecar\x12\x20\n\x0bscanLengths\x18\x16\x20\
    \x03(\rR\x0bscanLengths\x122\n\x14midQualityFileSha256\x18\x17\x20\x01(\
    \x0cR\x14midQualityFileSha256\x128\n\x17midQualityFileEncSha256\x18\x18\
    \x20\x01(\x0cR\x17midQualityFileEncSha256\x12\x1a\n\x08viewOnce\x18\x19\
    \x20\x01(\x08R\x08viewOnce\x120\n\x13thumbnailDirectPath\x18\x1a\x20\x01\
    (\tR\x13thumbnailDirectPath\x12(\n\x0fthumbnailSha256\x18\x1b\x20\x01(\
    \x0cR\x0fthumbnailSha256\x12.\n\x12thumbnailEncSha256\x18\x1c\x20\x01(\
    \x0cR\x12thumbnailEncSha256\x12\x1c\n\tstaticUrl\x18\x1d\x20\x01(\tR\tst\
    aticUrl\"\xb2\x04\n\x17HistorySyncNotification\x12\x1e\n\nfileSha256\x18\
    \x01\x20\x01(\x0cR\nfileSha256\x12\x1e\n\nfileLength\x18\x02\x20\x01(\
    \x04R\nfileLength\x12\x1a\n\x08mediaKey\x18\x03\x20\x01(\x0cR\x08mediaKe\
    y\x12$\n\rfileEncSha256\x18\x04\x20\x01(\x0cR\rfileEncSha256\x12\x1e\n\n\
    directPath\x18\x05\x20\x01(\tR\ndirectPath\x12J\n\x08syncType\x18\x06\
    \x20\x01(\x0e2..proto.HistorySyncNotification.HistorySyncTypeR\x08syncTy\
    pe\x12\x1e\n\nchunkOrder\x18\x07\x20\x01(\rR\nchunkOrder\x12,\n\x11origi\
    nalMessageId\x18\x08\x20\x01(\tR\x11originalMessageId\x12\x1a\n\x08progr\
    ess\x18\t\x20\x01(\rR\x08progress\x12B\n\x1coldestMsgInChunkTimestampSec\
    \x18\n\x20\x01(\x03R\x1coldestMsgInChunkTimestampSec\"{\n\x0fHistorySync\
    Type\x12\x15\n\x11INITIAL_BOOTSTRAP\x10\0\x12\x15\n\x11INITIAL_STATUS_V3\
    \x10\x01\x12\x08\n\x04FULL\x10\x02\x12\n\n\x06RECENT\x10\x03\x12\r\n\tPU\
    SH_NAME\x10\x04\x12\x15\n\x11NON_BLOCKING_DATA\x10\x05\"\xfe\x0c\n\x17Hi\
    ghlyStructuredMessage\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespac\
    e\x12\x20\n\x0belementName\x18\x02\x20\x01(\tR\x0belementName\x12\x16\n\
    \x06params\x18\x03\x20\x03(\tR\x06params\x12\x1e\n\nfallbackLg\x18\x04\
    \x20\x01(\tR\nfallbackLg\x12\x1e\n\nfallbackLc\x18\x05\x20\x01(\tR\nfall\
    backLc\x12d\n\x11localizableParams\x18\x06\x20\x03(\x0b26.proto.HighlySt\
    ructuredMessage.HSMLocalizableParameterR\x11localizableParams\x12(\n\x0f\
    deterministicLg\x18\x07\x20\x01(\tR\x0fdeterministicLg\x12(\n\x0fdetermi\
    nisticLc\x18\x08\x20\x01(\tR\x0fdeterministicLc\x128\n\x0bhydratedHsm\
    \x18\t\x20\x01(\x0b2\x16.proto.TemplateMessageR\x0bhydratedHsm\x1a\xd6\t\
    \n\x17HSMLocalizableParameter\x12\x18\n\x07default\x18\x01\x20\x01(\tR\
    \x07default\x12`\n\x08currency\x18\x02\x20\x01(\x0b2B.proto.HighlyStruct\
    uredMessage.HSMLocalizableParameter.HSMCurrencyH\0R\x08currency\x12`\n\
    \x08dateTime\x18\x03\x20\x01(\x0b2B.proto.HighlyStructuredMessage.HSMLoc\
    alizableParameter.HSMDateTimeH\0R\x08dateTime\x1a\xfb\x06\n\x0bHSMDateTi\
    me\x12w\n\tcomponent\x18\x01\x20\x01(\x0b2W.proto.HighlyStructuredMessag\
    e.HSMLocalizableParameter.HSMDateTime.HSMDateTimeComponentH\0R\tcomponen\
    t\x12w\n\tunixEpoch\x18\x02\x20\x01(\x0b2W.proto.HighlyStructuredMessage\
    .HSMLocalizableParameter.HSMDateTime.HSMDateTimeUnixEpochH\0R\tunixEpoch\
    \x1a4\n\x14HSMDateTimeUnixEpoch\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\
    \x03R\ttimestamp\x1a\xb2\x04\n\x14HSMDateTimeComponent\x12\x83\x01\n\tda\
    yOfWeek\x18\x01\x20\x01(\x0e2e.proto.HighlyStructuredMessage.HSMLocaliza\
    bleParameter.HSMDateTime.HSMDateTimeComponent.DayOfWeekTypeR\tdayOfWeek\
    \x12\x12\n\x04year\x18\x02\x20\x01(\rR\x04year\x12\x14\n\x05month\x18\
    \x03\x20\x01(\rR\x05month\x12\x1e\n\ndayOfMonth\x18\x04\x20\x01(\rR\nday\
    OfMonth\x12\x12\n\x04hour\x18\x05\x20\x01(\rR\x04hour\x12\x16\n\x06minut\
    e\x18\x06\x20\x01(\rR\x06minute\x12\x80\x01\n\x08calendar\x18\x07\x20\
    \x01(\x0e2d.proto.HighlyStructuredMessage.HSMLocalizableParameter.HSMDat\
    eTime.HSMDateTimeComponent.CalendarTypeR\x08calendar\"k\n\rDayOfWeekType\
    \x12\n\n\x06MONDAY\x10\x01\x12\x0b\n\x07TUESDAY\x10\x02\x12\r\n\tWEDNESD\
    AY\x10\x03\x12\x0c\n\x08THURSDAY\x10\x04\x12\n\n\x06FRIDAY\x10\x05\x12\
    \x0c\n\x08SATURDAY\x10\x06\x12\n\n\x06SUNDAY\x10\x07\".\n\x0cCalendarTyp\
    e\x12\r\n\tGREGORIAN\x10\x01\x12\x0f\n\x0bSOLAR_HIJRI\x10\x02B\x0f\n\rda\
    tetimeOneof\x1aQ\n\x0bHSMCurrency\x12\"\n\x0ccurrencyCode\x18\x01\x20\
    \x01(\tR\x0ccurrencyCode\x12\x1e\n\namount1000\x18\x02\x20\x01(\x03R\nam\
    ount1000B\x0c\n\nparamOneof\"\xf9\x02\n\x12GroupInviteMessage\x12\x1a\n\
    \x08groupJid\x18\x01\x20\x01(\tR\x08groupJid\x12\x1e\n\ninviteCode\x18\
    \x02\x20\x01(\tR\ninviteCode\x12*\n\x10inviteExpiration\x18\x03\x20\x01(\
    \x03R\x10inviteExpiration\x12\x1c\n\tgroupName\x18\x04\x20\x01(\tR\tgrou\
    pName\x12$\n\rjpegThumbnail\x18\x05\x20\x01(\x0cR\rjpegThumbnail\x12\x18\
    \n\x07caption\x18\x06\x20\x01(\tR\x07caption\x124\n\x0bcontextInfo\x18\
    \x07\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x12A\n\tgroupTy\
    pe\x18\x08\x20\x01(\x0e2#.proto.GroupInviteMessage.GroupTypeR\tgroupType\
    \"$\n\tGroupType\x12\x0b\n\x07DEFAULT\x10\0\x12\n\n\x06PARENT\x10\x01\">\
    \n\x12FutureProofMessage\x12(\n\x07message\x18\x01\x20\x01(\x0b2\x0e.pro\
    to.MessageR\x07message\"\xec\x0b\n\x13ExtendedTextMessage\x12\x12\n\x04t\
    ext\x18\x01\x20\x01(\tR\x04text\x12\x20\n\x0bmatchedText\x18\x02\x20\x01\
    (\tR\x0bmatchedText\x12\"\n\x0ccanonicalUrl\x18\x04\x20\x01(\tR\x0ccanon\
    icalUrl\x12\x20\n\x0bdescription\x18\x05\x20\x01(\tR\x0bdescription\x12\
    \x14\n\x05title\x18\x06\x20\x01(\tR\x05title\x12\x1a\n\x08textArgb\x18\
    \x07\x20\x01(\x07R\x08textArgb\x12&\n\x0ebackgroundArgb\x18\x08\x20\x01(\
    \x07R\x0ebackgroundArgb\x127\n\x04font\x18\t\x20\x01(\x0e2#.proto.Extend\
    edTextMessage.FontTypeR\x04font\x12H\n\x0bpreviewType\x18\n\x20\x01(\x0e\
    2&.proto.ExtendedTextMessage.PreviewTypeR\x0bpreviewType\x12$\n\rjpegThu\
    mbnail\x18\x10\x20\x01(\x0cR\rjpegThumbnail\x124\n\x0bcontextInfo\x18\
    \x11\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x12(\n\x0fdoNot\
    PlayInline\x18\x12\x20\x01(\x08R\x0fdoNotPlayInline\x120\n\x13thumbnailD\
    irectPath\x18\x13\x20\x01(\tR\x13thumbnailDirectPath\x12(\n\x0fthumbnail\
    Sha256\x18\x14\x20\x01(\x0cR\x0fthumbnailSha256\x12.\n\x12thumbnailEncSh\
    a256\x18\x15\x20\x01(\x0cR\x12thumbnailEncSha256\x12\x1a\n\x08mediaKey\
    \x18\x16\x20\x01(\x0cR\x08mediaKey\x12,\n\x11mediaKeyTimestamp\x18\x17\
    \x20\x01(\x03R\x11mediaKeyTimestamp\x12(\n\x0fthumbnailHeight\x18\x18\
    \x20\x01(\rR\x0fthumbnailHeight\x12&\n\x0ethumbnailWidth\x18\x19\x20\x01\
    (\rR\x0ethumbnailWidth\x12`\n\x13inviteLinkGroupType\x18\x1a\x20\x01(\
    \x0e2..proto.ExtendedTextMessage.InviteLinkGroupTypeR\x13inviteLinkGroup\
    Type\x12F\n\x1einviteLinkParentGroupSubjectV2\x18\x1b\x20\x01(\tR\x1einv\
    iteLinkParentGroupSubjectV2\x12J\n\x20inviteLinkParentGroupThumbnailV2\
    \x18\x1c\x20\x01(\x0cR\x20inviteLinkParentGroupThumbnailV2\x12d\n\x15inv\
    iteLinkGroupTypeV2\x18\x1d\x20\x01(\x0e2..proto.ExtendedTextMessage.Invi\
    teLinkGroupTypeR\x15inviteLinkGroupTypeV2\x12\x1a\n\x08viewOnce\x18\x1e\
    \x20\x01(\x08R\x08viewOnce\"\"\n\x0bPreviewType\x12\x08\n\x04NONE\x10\0\
    \x12\t\n\x05VIDEO\x10\x01\"H\n\x13InviteLinkGroupType\x12\x0b\n\x07DEFAU\
    LT\x10\0\x12\n\n\x06PARENT\x10\x01\x12\x07\n\x03SUB\x10\x02\x12\x0f\n\
    \x0bDEFAULT_SUB\x10\x03\"\xe7\x01\n\x08FontType\x12\x0e\n\nSANS_SERIF\
    \x10\0\x12\t\n\x05SERIF\x10\x01\x12\x13\n\x0fNORICAN_REGULAR\x10\x02\x12\
    \x11\n\rBRYNDAN_WRITE\x10\x03\x12\x15\n\x11BEBASNEUE_REGULAR\x10\x04\x12\
    \x10\n\x0cOSWALD_HEAVY\x10\x05\x12\x12\n\x0eDAMION_REGULAR\x10\x06\x12\
    \x19\n\x15MORNINGBREEZE_REGULAR\x10\x07\x12\x15\n\x11CALISTOGA_REGULAR\
    \x10\x08\x12\x12\n\x0eEXO2_EXTRABOLD\x10\t\x12\x15\n\x11COURIERPRIME_BOL\
    D\x10\n\"\x89\x01\n\x12EncReactionMessage\x12=\n\x10targetMessageKey\x18\
    \x01\x20\x01(\x0b2\x11.proto.MessageKeyR\x10targetMessageKey\x12\x1e\n\n\
    encPayload\x18\x02\x20\x01(\x0cR\nencPayload\x12\x14\n\x05encIv\x18\x03\
    \x20\x01(\x0cR\x05encIv\"\xd7\x05\n\x0fDocumentMessage\x12\x10\n\x03url\
    \x18\x01\x20\x01(\tR\x03url\x12\x1a\n\x08mimetype\x18\x02\x20\x01(\tR\
    \x08mimetype\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x1e\n\n\
    fileSha256\x18\x04\x20\x01(\x0cR\nfileSha256\x12\x1e\n\nfileLength\x18\
    \x05\x20\x01(\x04R\nfileLength\x12\x1c\n\tpageCount\x18\x06\x20\x01(\rR\
    \tpageCount\x12\x1a\n\x08mediaKey\x18\x07\x20\x01(\x0cR\x08mediaKey\x12\
    \x1a\n\x08fileName\x18\x08\x20\x01(\tR\x08fileName\x12$\n\rfileEncSha256\
    \x18\t\x20\x01(\x0cR\rfileEncSha256\x12\x1e\n\ndirectPath\x18\n\x20\x01(\
    \tR\ndirectPath\x12,\n\x11mediaKeyTimestamp\x18\x0b\x20\x01(\x03R\x11med\
    iaKeyTimestamp\x12\"\n\x0ccontactVcard\x18\x0c\x20\x01(\x08R\x0ccontactV\
    card\x120\n\x13thumbnailDirectPath\x18\r\x20\x01(\tR\x13thumbnailDirectP\
    ath\x12(\n\x0fthumbnailSha256\x18\x0e\x20\x01(\x0cR\x0fthumbnailSha256\
    \x12.\n\x12thumbnailEncSha256\x18\x0f\x20\x01(\x0cR\x12thumbnailEncSha25\
    6\x12$\n\rjpegThumbnail\x18\x10\x20\x01(\x0cR\rjpegThumbnail\x124\n\x0bc\
    ontextInfo\x18\x11\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\
    \x12(\n\x0fthumbnailHeight\x18\x12\x20\x01(\rR\x0fthumbnailHeight\x12&\n\
    \x0ethumbnailWidth\x18\x13\x20\x01(\rR\x0ethumbnailWidth\x12\x18\n\x07ca\
    ption\x18\x14\x20\x01(\tR\x07caption\"{\n\x11DeviceSentMessage\x12&\n\
    \x0edestinationJid\x18\x01\x20\x01(\tR\x0edestinationJid\x12(\n\x07messa\
    ge\x18\x02\x20\x01(\x0b2\x0e.proto.MessageR\x07message\x12\x14\n\x05phas\
    h\x18\x03\x20\x01(\tR\x05phash\"C\n\x1cDeclinePaymentRequestMessage\x12#\
    \n\x03key\x18\x01\x20\x01(\x0b2\x11.proto.MessageKeyR\x03key\"\xa1\x01\n\
    \x14ContactsArrayMessage\x12\x20\n\x0bdisplayName\x18\x01\x20\x01(\tR\
    \x0bdisplayName\x121\n\x08contacts\x18\x02\x20\x03(\x0b2\x15.proto.Conta\
    ctMessageR\x08contacts\x124\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x12.p\
    roto.ContextInfoR\x0bcontextInfo\"~\n\x0eContactMessage\x12\x20\n\x0bdis\
    playName\x18\x01\x20\x01(\tR\x0bdisplayName\x12\x14\n\x05vcard\x18\x10\
    \x20\x01(\tR\x05vcard\x124\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x12.pr\
    oto.ContextInfoR\x0bcontextInfo\"8\n\x04Chat\x12\x20\n\x0bdisplayName\
    \x18\x01\x20\x01(\tR\x0bdisplayName\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\
    \x02id\"B\n\x1bCancelPaymentRequestMessage\x12#\n\x03key\x18\x01\x20\x01\
    (\x0b2\x11.proto.MessageKeyR\x03key\"\xac\x01\n\x04Call\x12\x18\n\x07cal\
    lKey\x18\x01\x20\x01(\x0cR\x07callKey\x12*\n\x10conversionSource\x18\x02\
    \x20\x01(\tR\x10conversionSource\x12&\n\x0econversionData\x18\x03\x20\
    \x01(\x0cR\x0econversionData\x126\n\x16conversionDelaySeconds\x18\x04\
    \x20\x01(\rR\x16conversionDelaySeconds\"\x99\x02\n\x16ButtonsResponseMes\
    sage\x12*\n\x10selectedButtonId\x18\x01\x20\x01(\tR\x10selectedButtonId\
    \x124\n\x0bcontextInfo\x18\x03\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bc\
    ontextInfo\x126\n\x04type\x18\x04\x20\x01(\x0e2\".proto.ButtonsResponseM\
    essage.TypeR\x04type\x122\n\x13selectedDisplayText\x18\x02\x20\x01(\tH\0\
    R\x13selectedDisplayText\"%\n\x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x10\
    \n\x0cDISPLAY_TEXT\x10\x01B\n\n\x08response\"\xa8\x08\n\x0eButtonsMessag\
    e\x12\x20\n\x0bcontentText\x18\x06\x20\x01(\tR\x0bcontentText\x12\x1e\n\
    \nfooterText\x18\x07\x20\x01(\tR\nfooterText\x124\n\x0bcontextInfo\x18\
    \x08\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x126\n\x07butto\
    ns\x18\t\x20\x03(\x0b2\x1c.proto.ButtonsMessage.ButtonR\x07buttons\x12@\
    \n\nheaderType\x18\n\x20\x01(\x0e2\x20.proto.ButtonsMessage.HeaderTypeR\
    \nheaderType\x12\x14\n\x04text\x18\x01\x20\x01(\tH\0R\x04text\x12B\n\x0f\
    documentMessage\x18\x02\x20\x01(\x0b2\x16.proto.DocumentMessageH\0R\x0fd\
    ocumentMessage\x129\n\x0cimageMessage\x18\x03\x20\x01(\x0b2\x13.proto.Im\
    ageMessageH\0R\x0cimageMessage\x129\n\x0cvideoMessage\x18\x04\x20\x01(\
    \x0b2\x13.proto.VideoMessageH\0R\x0cvideoMessage\x12B\n\x0flocationMessa\
    ge\x18\x05\x20\x01(\x0b2\x16.proto.LocationMessageH\0R\x0flocationMessag\
    e\x1a\xa3\x03\n\x06Button\x12\x1a\n\x08buttonId\x18\x01\x20\x01(\tR\x08b\
    uttonId\x12G\n\nbuttonText\x18\x02\x20\x01(\x0b2'.proto.ButtonsMessage.B\
    utton.ButtonTextR\nbuttonText\x125\n\x04type\x18\x03\x20\x01(\x0e2!.prot\
    o.ButtonsMessage.Button.TypeR\x04type\x12S\n\x0enativeFlowInfo\x18\x04\
    \x20\x01(\x0b2+.proto.ButtonsMessage.Button.NativeFlowInfoR\x0enativeFlo\
    wInfo\x1aD\n\x0eNativeFlowInfo\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12\x1e\n\nparamsJson\x18\x02\x20\x01(\tR\nparamsJson\x1a.\n\nButto\
    nText\x12\x20\n\x0bdisplayText\x18\x01\x20\x01(\tR\x0bdisplayText\"2\n\
    \x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0c\n\x08RESPONSE\x10\x01\x12\
    \x0f\n\x0bNATIVE_FLOW\x10\x02\"`\n\nHeaderType\x12\x0b\n\x07UNKNOWN\x10\
    \0\x12\t\n\x05EMPTY\x10\x01\x12\x08\n\x04TEXT\x10\x02\x12\x0c\n\x08DOCUM\
    ENT\x10\x03\x12\t\n\x05IMAGE\x10\x04\x12\t\n\x05VIDEO\x10\x05\x12\x0c\n\
    \x08LOCATION\x10\x06B\x08\n\x06header\"\xde\x03\n\x0cAudioMessage\x12\
    \x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x1a\n\x08mimetype\x18\x02\
    \x20\x01(\tR\x08mimetype\x12\x1e\n\nfileSha256\x18\x03\x20\x01(\x0cR\nfi\
    leSha256\x12\x1e\n\nfileLength\x18\x04\x20\x01(\x04R\nfileLength\x12\x18\
    \n\x07seconds\x18\x05\x20\x01(\rR\x07seconds\x12\x10\n\x03ptt\x18\x06\
    \x20\x01(\x08R\x03ptt\x12\x1a\n\x08mediaKey\x18\x07\x20\x01(\x0cR\x08med\
    iaKey\x12$\n\rfileEncSha256\x18\x08\x20\x01(\x0cR\rfileEncSha256\x12\x1e\
    \n\ndirectPath\x18\t\x20\x01(\tR\ndirectPath\x12,\n\x11mediaKeyTimestamp\
    \x18\n\x20\x01(\x03R\x11mediaKeyTimestamp\x124\n\x0bcontextInfo\x18\x11\
    \x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x12*\n\x10streaming\
    Sidecar\x18\x12\x20\x01(\x0cR\x10streamingSidecar\x12\x1a\n\x08waveform\
    \x18\x13\x20\x01(\x0cR\x08waveform\x12&\n\x0ebackgroundArgb\x18\x14\x20\
    \x01(\x07R\x0ebackgroundArgb\"w\n\x0fAppStateSyncKey\x12.\n\x05keyId\x18\
    \x01\x20\x01(\x0b2\x18.proto.AppStateSyncKeyIdR\x05keyId\x124\n\x07keyDa\
    ta\x18\x02\x20\x01(\x0b2\x1a.proto.AppStateSyncKeyDataR\x07keyData\"B\n\
    \x14AppStateSyncKeyShare\x12*\n\x04keys\x18\x01\x20\x03(\x0b2\x16.proto.\
    AppStateSyncKeyR\x04keys\"J\n\x16AppStateSyncKeyRequest\x120\n\x06keyIds\
    \x18\x01\x20\x03(\x0b2\x18.proto.AppStateSyncKeyIdR\x06keyIds\")\n\x11Ap\
    pStateSyncKeyId\x12\x14\n\x05keyId\x18\x01\x20\x01(\x0cR\x05keyId\"\x80\
    \x01\n\x1aAppStateSyncKeyFingerprint\x12\x14\n\x05rawId\x18\x01\x20\x01(\
    \rR\x05rawId\x12\"\n\x0ccurrentIndex\x18\x02\x20\x01(\rR\x0ccurrentIndex\
    \x12(\n\rdeviceIndexes\x18\x03\x20\x03(\rR\rdeviceIndexesB\x02\x10\x01\"\
    \x92\x01\n\x13AppStateSyncKeyData\x12\x18\n\x07keyData\x18\x01\x20\x01(\
    \x0cR\x07keyData\x12C\n\x0bfingerprint\x18\x02\x20\x01(\x0b2!.proto.AppS\
    tateSyncKeyFingerprintR\x0bfingerprint\x12\x1c\n\ttimestamp\x18\x03\x20\
    \x01(\x03R\ttimestamp\"l\n\"AppStateFatalExceptionNotification\x12(\n\
    \x0fcollectionNames\x18\x01\x20\x03(\tR\x0fcollectionNames\x12\x1c\n\tti\
    mestamp\x18\x02\x20\x01(\x03R\ttimestamp\"t\n\x08Location\x12(\n\x0fdegr\
    eesLatitude\x18\x01\x20\x01(\x01R\x0fdegreesLatitude\x12*\n\x10degreesLo\
    ngitude\x18\x02\x20\x01(\x01R\x10degreesLongitude\x12\x12\n\x04name\x18\
    \x03\x20\x01(\tR\x04name\"\x88\x01\n\x15InteractiveAnnotation\x126\n\x0f\
    polygonVertices\x18\x01\x20\x03(\x0b2\x0c.proto.PointR\x0fpolygonVertice\
    s\x12-\n\x08location\x18\x02\x20\x01(\x0b2\x0f.proto.LocationH\0R\x08loc\
    ationB\x08\n\x06action\"\xbc\x04\n\x16HydratedTemplateButton\x12\x14\n\
    \x05index\x18\x04\x20\x01(\rR\x05index\x12d\n\x10quickReplyButton\x18\
    \x01\x20\x01(\x0b26.proto.HydratedTemplateButton.HydratedQuickReplyButto\
    nH\0R\x10quickReplyButton\x12O\n\turlButton\x18\x02\x20\x01(\x0b2/.proto\
    .HydratedTemplateButton.HydratedURLButtonH\0R\turlButton\x12R\n\ncallBut\
    ton\x18\x03\x20\x01(\x0b20.proto.HydratedTemplateButton.HydratedCallButt\
    onH\0R\ncallButton\x1aG\n\x11HydratedURLButton\x12\x20\n\x0bdisplayText\
    \x18\x01\x20\x01(\tR\x0bdisplayText\x12\x10\n\x03url\x18\x02\x20\x01(\tR\
    \x03url\x1aL\n\x18HydratedQuickReplyButton\x12\x20\n\x0bdisplayText\x18\
    \x01\x20\x01(\tR\x0bdisplayText\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02i\
    d\x1aX\n\x12HydratedCallButton\x12\x20\n\x0bdisplayText\x18\x01\x20\x01(\
    \tR\x0bdisplayText\x12\x20\n\x0bphoneNumber\x18\x02\x20\x01(\tR\x0bphone\
    NumberB\x10\n\x0ehydratedButton\"N\n\x0cGroupMention\x12\x1a\n\x08groupJ\
    id\x18\x01\x20\x01(\tR\x08groupJid\x12\"\n\x0cgroupSubject\x18\x02\x20\
    \x01(\tR\x0cgroupSubject\"\xa2\x01\n\x10DisappearingMode\x12?\n\tinitiat\
    or\x18\x01\x20\x01(\x0e2!.proto.DisappearingMode.InitiatorR\tinitiator\"\
    M\n\tInitiator\x12\x13\n\x0fCHANGED_IN_CHAT\x10\0\x12\x13\n\x0fINITIATED\
    _BY_ME\x10\x01\x12\x16\n\x12INITIATED_BY_OTHER\x10\x02\"\xa6\x02\n\x12De\
    viceListMetadata\x12$\n\rsenderKeyHash\x18\x01\x20\x01(\x0cR\rsenderKeyH\
    ash\x12(\n\x0fsenderTimestamp\x18\x02\x20\x01(\x04R\x0fsenderTimestamp\
    \x12.\n\x10senderKeyIndexes\x18\x03\x20\x03(\rR\x10senderKeyIndexesB\x02\
    \x10\x01\x12*\n\x10recipientKeyHash\x18\x08\x20\x01(\x0cR\x10recipientKe\
    yHash\x12.\n\x12recipientTimestamp\x18\t\x20\x01(\x04R\x12recipientTimes\
    tamp\x124\n\x13recipientKeyIndexes\x18\n\x20\x03(\rR\x13recipientKeyInde\
    xesB\x02\x10\x01\"\xbe\x11\n\x0bContextInfo\x12\x1a\n\x08stanzaId\x18\
    \x01\x20\x01(\tR\x08stanzaId\x12\x20\n\x0bparticipant\x18\x02\x20\x01(\t\
    R\x0bparticipant\x124\n\rquotedMessage\x18\x03\x20\x01(\x0b2\x0e.proto.M\
    essageR\rquotedMessage\x12\x1c\n\tremoteJid\x18\x04\x20\x01(\tR\tremoteJ\
    id\x12\"\n\x0cmentionedJid\x18\x0f\x20\x03(\tR\x0cmentionedJid\x12*\n\
    \x10conversionSource\x18\x12\x20\x01(\tR\x10conversionSource\x12&\n\x0ec\
    onversionData\x18\x13\x20\x01(\x0cR\x0econversionData\x126\n\x16conversi\
    onDelaySeconds\x18\x14\x20\x01(\rR\x16conversionDelaySeconds\x12(\n\x0ff\
    orwardingScore\x18\x15\x20\x01(\rR\x0fforwardingScore\x12\x20\n\x0bisFor\
    warded\x18\x16\x20\x01(\x08R\x0bisForwarded\x12:\n\x08quotedAd\x18\x17\
    \x20\x01(\x0b2\x1e.proto.ContextInfo.AdReplyInfoR\x08quotedAd\x129\n\x0e\
    placeholderKey\x18\x18\x20\x01(\x0b2\x11.proto.MessageKeyR\x0eplaceholde\
    rKey\x12\x1e\n\nexpiration\x18\x19\x20\x01(\rR\nexpiration\x12<\n\x19eph\
    emeralSettingTimestamp\x18\x1a\x20\x01(\x03R\x19ephemeralSettingTimestam\
    p\x124\n\x15ephemeralSharedSecret\x18\x1b\x20\x01(\x0cR\x15ephemeralShar\
    edSecret\x12P\n\x0fexternalAdReply\x18\x1c\x20\x01(\x0b2&.proto.ContextI\
    nfo.ExternalAdReplyInfoR\x0fexternalAdReply\x12>\n\x1aentryPointConversi\
    onSource\x18\x1d\x20\x01(\tR\x1aentryPointConversionSource\x128\n\x17ent\
    ryPointConversionApp\x18\x1e\x20\x01(\tR\x17entryPointConversionApp\x12J\
    \n\x20entryPointConversionDelaySeconds\x18\x1f\x20\x01(\rR\x20entryPoint\
    ConversionDelaySeconds\x12C\n\x10disappearingMode\x18\x20\x20\x01(\x0b2\
    \x17.proto.DisappearingModeR\x10disappearingMode\x121\n\nactionLink\x18!\
    \x20\x01(\x0b2\x11.proto.ActionLinkR\nactionLink\x12\"\n\x0cgroupSubject\
    \x18\"\x20\x01(\tR\x0cgroupSubject\x12&\n\x0eparentGroupJid\x18#\x20\x01\
    (\tR\x0eparentGroupJid\x12(\n\x0ftrustBannerType\x18%\x20\x01(\tR\x0ftru\
    stBannerType\x12,\n\x11trustBannerAction\x18&\x20\x01(\rR\x11trustBanner\
    Action\x12\x1c\n\tisSampled\x18'\x20\x01(\x08R\tisSampled\x129\n\rgroupM\
    entions\x18(\x20\x03(\x0b2\x13.proto.GroupMentionR\rgroupMentions\x12,\n\
    \x03utm\x18)\x20\x01(\x0b2\x1a.proto.ContextInfo.UTMInfoR\x03utm\x1aI\n\
    \x07UTMInfo\x12\x1c\n\tutmSource\x18\x01\x20\x01(\tR\tutmSource\x12\x20\
    \n\x0butmCampaign\x18\x02\x20\x01(\tR\x0butmCampaign\x1a\xa2\x04\n\x13Ex\
    ternalAdReplyInfo\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\
    \x12\n\x04body\x18\x02\x20\x01(\tR\x04body\x12N\n\tmediaType\x18\x03\x20\
    \x01(\x0e20.proto.ContextInfo.ExternalAdReplyInfo.MediaTypeR\tmediaType\
    \x12\"\n\x0cthumbnailUrl\x18\x04\x20\x01(\tR\x0cthumbnailUrl\x12\x1a\n\
    \x08mediaUrl\x18\x05\x20\x01(\tR\x08mediaUrl\x12\x1c\n\tthumbnail\x18\
    \x06\x20\x01(\x0cR\tthumbnail\x12\x1e\n\nsourceType\x18\x07\x20\x01(\tR\
    \nsourceType\x12\x1a\n\x08sourceId\x18\x08\x20\x01(\tR\x08sourceId\x12\
    \x1c\n\tsourceUrl\x18\t\x20\x01(\tR\tsourceUrl\x12,\n\x11containsAutoRep\
    ly\x18\n\x20\x01(\x08R\x11containsAutoReply\x124\n\x15renderLargerThumbn\
    ail\x18\x0b\x20\x01(\x08R\x15renderLargerThumbnail\x12,\n\x11showAdAttri\
    bution\x18\x0c\x20\x01(\x08R\x11showAdAttribution\x12\x1a\n\x08ctwaClid\
    \x18\r\x20\x01(\tR\x08ctwaClid\"+\n\tMediaType\x12\x08\n\x04NONE\x10\0\
    \x12\t\n\x05IMAGE\x10\x01\x12\t\n\x05VIDEO\x10\x02\x1a\xea\x01\n\x0bAdRe\
    plyInfo\x12&\n\x0eadvertiserName\x18\x01\x20\x01(\tR\x0eadvertiserName\
    \x12F\n\tmediaType\x18\x02\x20\x01(\x0e2(.proto.ContextInfo.AdReplyInfo.\
    MediaTypeR\tmediaType\x12$\n\rjpegThumbnail\x18\x10\x20\x01(\x0cR\rjpegT\
    humbnail\x12\x18\n\x07caption\x18\x11\x20\x01(\tR\x07caption\"+\n\tMedia\
    Type\x12\x08\n\x04NONE\x10\0\x12\t\n\x05IMAGE\x10\x01\x12\t\n\x05VIDEO\
    \x10\x02\"@\n\nActionLink\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\
    \x12\x20\n\x0bbuttonTitle\x18\x02\x20\x01(\tR\x0bbuttonTitle\"\x85\x05\n\
    \x0eTemplateButton\x12\x14\n\x05index\x18\x04\x20\x01(\rR\x05index\x12T\
    \n\x10quickReplyButton\x18\x01\x20\x01(\x0b2&.proto.TemplateButton.Quick\
    ReplyButtonH\0R\x10quickReplyButton\x12?\n\turlButton\x18\x02\x20\x01(\
    \x0b2\x1f.proto.TemplateButton.URLButtonH\0R\turlButton\x12B\n\ncallButt\
    on\x18\x03\x20\x01(\x0b2\x20.proto.TemplateButton.CallButtonH\0R\ncallBu\
    tton\x1a\x7f\n\tURLButton\x12@\n\x0bdisplayText\x18\x01\x20\x01(\x0b2\
    \x1e.proto.HighlyStructuredMessageR\x0bdisplayText\x120\n\x03url\x18\x02\
    \x20\x01(\x0b2\x1e.proto.HighlyStructuredMessageR\x03url\x1ad\n\x10Quick\
    ReplyButton\x12@\n\x0bdisplayText\x18\x01\x20\x01(\x0b2\x1e.proto.Highly\
    StructuredMessageR\x0bdisplayText\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\
    \x02id\x1a\x90\x01\n\nCallButton\x12@\n\x0bdisplayText\x18\x01\x20\x01(\
    \x0b2\x1e.proto.HighlyStructuredMessageR\x0bdisplayText\x12@\n\x0bphoneN\
    umber\x18\x02\x20\x01(\x0b2\x1e.proto.HighlyStructuredMessageR\x0bphoneN\
    umberB\x08\n\x06button\"g\n\x05Point\x12\x20\n\x0bxDeprecated\x18\x01\
    \x20\x01(\x05R\x0bxDeprecated\x12\x20\n\x0byDeprecated\x18\x02\x20\x01(\
    \x05R\x0byDeprecated\x12\x0c\n\x01x\x18\x03\x20\x01(\x01R\x01x\x12\x0c\n\
    \x01y\x18\x04\x20\x01(\x01R\x01y\"\xca\x04\n\x11PaymentBackground\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1e\n\nfileLength\x18\x02\x20\
    \x01(\x04R\nfileLength\x12\x14\n\x05width\x18\x03\x20\x01(\rR\x05width\
    \x12\x16\n\x06height\x18\x04\x20\x01(\rR\x06height\x12\x1a\n\x08mimetype\
    \x18\x05\x20\x01(\tR\x08mimetype\x12(\n\x0fplaceholderArgb\x18\x06\x20\
    \x01(\x07R\x0fplaceholderArgb\x12\x1a\n\x08textArgb\x18\x07\x20\x01(\x07\
    R\x08textArgb\x12\x20\n\x0bsubtextArgb\x18\x08\x20\x01(\x07R\x0bsubtextA\
    rgb\x12@\n\tmediaData\x18\t\x20\x01(\x0b2\".proto.PaymentBackground.Medi\
    aDataR\tmediaData\x121\n\x04type\x18\n\x20\x01(\x0e2\x1d.proto.PaymentBa\
    ckground.TypeR\x04type\x1a\xbb\x01\n\tMediaData\x12\x1a\n\x08mediaKey\
    \x18\x01\x20\x01(\x0cR\x08mediaKey\x12,\n\x11mediaKeyTimestamp\x18\x02\
    \x20\x01(\x03R\x11mediaKeyTimestamp\x12\x1e\n\nfileSha256\x18\x03\x20\
    \x01(\x0cR\nfileSha256\x12$\n\rfileEncSha256\x18\x04\x20\x01(\x0cR\rfile\
    EncSha256\x12\x1e\n\ndirectPath\x18\x05\x20\x01(\tR\ndirectPath\"\x20\n\
    \x04Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07DEFAULT\x10\x01\"Y\n\
    \x05Money\x12\x14\n\x05value\x18\x01\x20\x01(\x03R\x05value\x12\x16\n\
    \x06offset\x18\x02\x20\x01(\rR\x06offset\x12\"\n\x0ccurrencyCode\x18\x03\
    \x20\x01(\tR\x0ccurrencyCode\"\xae\x20\n\x07Message\x12\"\n\x0cconversat\
    ion\x18\x01\x20\x01(\tR\x0cconversation\x12g\n\x1csenderKeyDistributionM\
    essage\x18\x02\x20\x01(\x0b2#.proto.SenderKeyDistributionMessageR\x1csen\
    derKeyDistributionMessage\x127\n\x0cimageMessage\x18\x03\x20\x01(\x0b2\
    \x13.proto.ImageMessageR\x0cimageMessage\x12=\n\x0econtactMessage\x18\
    \x04\x20\x01(\x0b2\x15.proto.ContactMessageR\x0econtactMessage\x12@\n\
    \x0flocationMessage\x18\x05\x20\x01(\x0b2\x16.proto.LocationMessageR\x0f\
    locationMessage\x12L\n\x13extendedTextMessage\x18\x06\x20\x01(\x0b2\x1a.\
    proto.ExtendedTextMessageR\x13extendedTextMessage\x12@\n\x0fdocumentMess\
    age\x18\x07\x20\x01(\x0b2\x16.proto.DocumentMessageR\x0fdocumentMessage\
    \x127\n\x0caudioMessage\x18\x08\x20\x01(\x0b2\x13.proto.AudioMessageR\
    \x0caudioMessage\x127\n\x0cvideoMessage\x18\t\x20\x01(\x0b2\x13.proto.Vi\
    deoMessageR\x0cvideoMessage\x12\x1f\n\x04call\x18\n\x20\x01(\x0b2\x0b.pr\
    oto.CallR\x04call\x12\x1f\n\x04chat\x18\x0b\x20\x01(\x0b2\x0b.proto.Chat\
    R\x04chat\x12@\n\x0fprotocolMessage\x18\x0c\x20\x01(\x0b2\x16.proto.Prot\
    ocolMessageR\x0fprotocolMessage\x12O\n\x14contactsArrayMessage\x18\r\x20\
    \x01(\x0b2\x1b.proto.ContactsArrayMessageR\x14contactsArrayMessage\x12X\
    \n\x17highlyStructuredMessage\x18\x0e\x20\x01(\x0b2\x1e.proto.HighlyStru\
    cturedMessageR\x17highlyStructuredMessage\x12\x83\x01\n*fastRatchetKeySe\
    nderKeyDistributionMessage\x18\x0f\x20\x01(\x0b2#.proto.SenderKeyDistrib\
    utionMessageR*fastRatchetKeySenderKeyDistributionMessage\x12I\n\x12sendP\
    aymentMessage\x18\x10\x20\x01(\x0b2\x19.proto.SendPaymentMessageR\x12sen\
    dPaymentMessage\x12L\n\x13liveLocationMessage\x18\x12\x20\x01(\x0b2\x1a.\
    proto.LiveLocationMessageR\x13liveLocationMessage\x12R\n\x15requestPayme\
    ntMessage\x18\x16\x20\x01(\x0b2\x1c.proto.RequestPaymentMessageR\x15requ\
    estPaymentMessage\x12g\n\x1cdeclinePaymentRequestMessage\x18\x17\x20\x01\
    (\x0b2#.proto.DeclinePaymentRequestMessageR\x1cdeclinePaymentRequestMess\
    age\x12d\n\x1bcancelPaymentRequestMessage\x18\x18\x20\x01(\x0b2\".proto.\
    CancelPaymentRequestMessageR\x1bcancelPaymentRequestMessage\x12@\n\x0fte\
    mplateMessage\x18\x19\x20\x01(\x0b2\x16.proto.TemplateMessageR\x0ftempla\
    teMessage\x12=\n\x0estickerMessage\x18\x1a\x20\x01(\x0b2\x15.proto.Stick\
    erMessageR\x0estickerMessage\x12I\n\x12groupInviteMessage\x18\x1c\x20\
    \x01(\x0b2\x19.proto.GroupInviteMessageR\x12groupInviteMessage\x12a\n\
    \x1atemplateButtonReplyMessage\x18\x1d\x20\x01(\x0b2!.proto.TemplateButt\
    onReplyMessageR\x1atemplateButtonReplyMessage\x12=\n\x0eproductMessage\
    \x18\x1e\x20\x01(\x0b2\x15.proto.ProductMessageR\x0eproductMessage\x12F\
    \n\x11deviceSentMessage\x18\x1f\x20\x01(\x0b2\x18.proto.DeviceSentMessag\
    eR\x11deviceSentMessage\x12I\n\x12messageContextInfo\x18#\x20\x01(\x0b2\
    \x19.proto.MessageContextInfoR\x12messageContextInfo\x124\n\x0blistMessa\
    ge\x18$\x20\x01(\x0b2\x12.proto.ListMessageR\x0blistMessage\x12C\n\x0fvi\
    ewOnceMessage\x18%\x20\x01(\x0b2\x19.proto.FutureProofMessageR\x0fviewOn\
    ceMessage\x127\n\x0corderMessage\x18&\x20\x01(\x0b2\x13.proto.OrderMessa\
    geR\x0corderMessage\x12L\n\x13listResponseMessage\x18'\x20\x01(\x0b2\x1a\
    .proto.ListResponseMessageR\x13listResponseMessage\x12E\n\x10ephemeralMe\
    ssage\x18(\x20\x01(\x0b2\x19.proto.FutureProofMessageR\x10ephemeralMessa\
    ge\x12=\n\x0einvoiceMessage\x18)\x20\x01(\x0b2\x15.proto.InvoiceMessageR\
    \x0einvoiceMessage\x12=\n\x0ebuttonsMessage\x18*\x20\x01(\x0b2\x15.proto\
    .ButtonsMessageR\x0ebuttonsMessage\x12U\n\x16buttonsResponseMessage\x18+\
    \x20\x01(\x0b2\x1d.proto.ButtonsResponseMessageR\x16buttonsResponseMessa\
    ge\x12O\n\x14paymentInviteMessage\x18,\x20\x01(\x0b2\x1b.proto.PaymentIn\
    viteMessageR\x14paymentInviteMessage\x12I\n\x12interactiveMessage\x18-\
    \x20\x01(\x0b2\x19.proto.InteractiveMessageR\x12interactiveMessage\x12@\
    \n\x0freactionMessage\x18.\x20\x01(\x0b2\x16.proto.ReactionMessageR\x0fr\
    eactionMessage\x12R\n\x15stickerSyncRmrMessage\x18/\x20\x01(\x0b2\x1c.pr\
    oto.StickerSyncRMRMessageR\x15stickerSyncRmrMessage\x12a\n\x1ainteractiv\
    eResponseMessage\x180\x20\x01(\x0b2!.proto.InteractiveResponseMessageR\
    \x1ainteractiveResponseMessage\x12L\n\x13pollCreationMessage\x181\x20\
    \x01(\x0b2\x1a.proto.PollCreationMessageR\x13pollCreationMessage\x12F\n\
    \x11pollUpdateMessage\x182\x20\x01(\x0b2\x18.proto.PollUpdateMessageR\
    \x11pollUpdateMessage\x12F\n\x11keepInChatMessage\x183\x20\x01(\x0b2\x18\
    .proto.KeepInChatMessageR\x11keepInChatMessage\x12Y\n\x1adocumentWithCap\
    tionMessage\x185\x20\x01(\x0b2\x19.proto.FutureProofMessageR\x1adocument\
    WithCaptionMessage\x12^\n\x19requestPhoneNumberMessage\x186\x20\x01(\x0b\
    2\x20.proto.RequestPhoneNumberMessageR\x19requestPhoneNumberMessage\x12G\
    \n\x11viewOnceMessageV2\x187\x20\x01(\x0b2\x19.proto.FutureProofMessageR\
    \x11viewOnceMessageV2\x12I\n\x12encReactionMessage\x188\x20\x01(\x0b2\
    \x19.proto.EncReactionMessageR\x12encReactionMessage\x12?\n\reditedMessa\
    ge\x18:\x20\x01(\x0b2\x19.proto.FutureProofMessageR\reditedMessage\x12Y\
    \n\x1aviewOnceMessageV2Extension\x18;\x20\x01(\x0b2\x19.proto.FutureProo\
    fMessageR\x1aviewOnceMessageV2Extension\x12P\n\x15pollCreationMessageV2\
    \x18<\x20\x01(\x0b2\x1a.proto.PollCreationMessageR\x15pollCreationMessag\
    eV2\x12g\n\x1cscheduledCallCreationMessage\x18=\x20\x01(\x0b2#.proto.Sch\
    eduledCallCreationMessageR\x1cscheduledCallCreationMessage\x12O\n\x15gro\
    upMentionedMessage\x18>\x20\x01(\x0b2\x19.proto.FutureProofMessageR\x15g\
    roupMentionedMessage\x121\n\npinMessage\x18?\x20\x01(\x0b2\x11.proto.Pin\
    MessageR\npinMessage\x12P\n\x15pollCreationMessageV3\x18@\x20\x01(\x0b2\
    \x1a.proto.PollCreationMessageR\x15pollCreationMessageV3\x12[\n\x18sched\
    uledCallEditMessage\x18A\x20\x01(\x0b2\x1f.proto.ScheduledCallEditMessag\
    eR\x18scheduledCallEditMessage\"\xe7\x01\n\x12MessageContextInfo\x12I\n\
    \x12deviceListMetadata\x18\x01\x20\x01(\x0b2\x19.proto.DeviceListMetadat\
    aR\x12deviceListMetadata\x12<\n\x19deviceListMetadataVersion\x18\x02\x20\
    \x01(\x05R\x19deviceListMetadataVersion\x12$\n\rmessageSecret\x18\x03\
    \x20\x01(\x0cR\rmessageSecret\x12\"\n\x0cpaddingBytes\x18\x04\x20\x01(\
    \x0cR\x0cpaddingBytes\"\xac\x07\n\x0cVideoMessage\x12\x10\n\x03url\x18\
    \x01\x20\x01(\tR\x03url\x12\x1a\n\x08mimetype\x18\x02\x20\x01(\tR\x08mim\
    etype\x12\x1e\n\nfileSha256\x18\x03\x20\x01(\x0cR\nfileSha256\x12\x1e\n\
    \nfileLength\x18\x04\x20\x01(\x04R\nfileLength\x12\x18\n\x07seconds\x18\
    \x05\x20\x01(\rR\x07seconds\x12\x1a\n\x08mediaKey\x18\x06\x20\x01(\x0cR\
    \x08mediaKey\x12\x18\n\x07caption\x18\x07\x20\x01(\tR\x07caption\x12\x20\
    \n\x0bgifPlayback\x18\x08\x20\x01(\x08R\x0bgifPlayback\x12\x16\n\x06heig\
    ht\x18\t\x20\x01(\rR\x06height\x12\x14\n\x05width\x18\n\x20\x01(\rR\x05w\
    idth\x12$\n\rfileEncSha256\x18\x0b\x20\x01(\x0cR\rfileEncSha256\x12T\n\
    \x16interactiveAnnotations\x18\x0c\x20\x03(\x0b2\x1c.proto.InteractiveAn\
    notationR\x16interactiveAnnotations\x12\x1e\n\ndirectPath\x18\r\x20\x01(\
    \tR\ndirectPath\x12,\n\x11mediaKeyTimestamp\x18\x0e\x20\x01(\x03R\x11med\
    iaKeyTimestamp\x12$\n\rjpegThumbnail\x18\x10\x20\x01(\x0cR\rjpegThumbnai\
    l\x124\n\x0bcontextInfo\x18\x11\x20\x01(\x0b2\x12.proto.ContextInfoR\x0b\
    contextInfo\x12*\n\x10streamingSidecar\x18\x12\x20\x01(\x0cR\x10streamin\
    gSidecar\x12G\n\x0egifAttribution\x18\x13\x20\x01(\x0e2\x1f.proto.VideoM\
    essage.AttributionR\x0egifAttribution\x12\x1a\n\x08viewOnce\x18\x14\x20\
    \x01(\x08R\x08viewOnce\x120\n\x13thumbnailDirectPath\x18\x15\x20\x01(\tR\
    \x13thumbnailDirectPath\x12(\n\x0fthumbnailSha256\x18\x16\x20\x01(\x0cR\
    \x0fthumbnailSha256\x12.\n\x12thumbnailEncSha256\x18\x17\x20\x01(\x0cR\
    \x12thumbnailEncSha256\x12\x1c\n\tstaticUrl\x18\x18\x20\x01(\tR\tstaticU\
    rl\"-\n\x0bAttribution\x12\x08\n\x04NONE\x10\0\x12\t\n\x05GIPHY\x10\x01\
    \x12\t\n\x05TENOR\x10\x02\"\xa2\x0c\n\x0fTemplateMessage\x124\n\x0bconte\
    xtInfo\x18\x03\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x12Z\
    \n\x10hydratedTemplate\x18\x04\x20\x01(\x0b2..proto.TemplateMessage.Hydr\
    atedFourRowTemplateR\x10hydratedTemplate\x12\x1e\n\ntemplateId\x18\t\x20\
    \x01(\tR\ntemplateId\x12R\n\x0ffourRowTemplate\x18\x01\x20\x01(\x0b2&.pr\
    oto.TemplateMessage.FourRowTemplateH\0R\x0ffourRowTemplate\x12j\n\x17hyd\
    ratedFourRowTemplate\x18\x02\x20\x01(\x0b2..proto.TemplateMessage.Hydrat\
    edFourRowTemplateH\0R\x17hydratedFourRowTemplate\x12[\n\x1ainteractiveMe\
    ssageTemplate\x18\x05\x20\x01(\x0b2\x19.proto.InteractiveMessageH\0R\x1a\
    interactiveMessageTemplate\x1a\x9b\x04\n\x17HydratedFourRowTemplate\x120\
    \n\x13hydratedContentText\x18\x06\x20\x01(\tR\x13hydratedContentText\x12\
    .\n\x12hydratedFooterText\x18\x07\x20\x01(\tR\x12hydratedFooterText\x12G\
    \n\x0fhydratedButtons\x18\x08\x20\x03(\x0b2\x1d.proto.HydratedTemplateBu\
    ttonR\x0fhydratedButtons\x12\x1e\n\ntemplateId\x18\t\x20\x01(\tR\ntempla\
    teId\x12B\n\x0fdocumentMessage\x18\x01\x20\x01(\x0b2\x16.proto.DocumentM\
    essageH\0R\x0fdocumentMessage\x12.\n\x11hydratedTitleText\x18\x02\x20\
    \x01(\tH\0R\x11hydratedTitleText\x129\n\x0cimageMessage\x18\x03\x20\x01(\
    \x0b2\x13.proto.ImageMessageH\0R\x0cimageMessage\x129\n\x0cvideoMessage\
    \x18\x04\x20\x01(\x0b2\x13.proto.VideoMessageH\0R\x0cvideoMessage\x12B\n\
    \x0flocationMessage\x18\x05\x20\x01(\x0b2\x16.proto.LocationMessageH\0R\
    \x0flocationMessageB\x07\n\x05title\x1a\x97\x04\n\x0fFourRowTemplate\x12\
    8\n\x07content\x18\x06\x20\x01(\x0b2\x1e.proto.HighlyStructuredMessageR\
    \x07content\x126\n\x06footer\x18\x07\x20\x01(\x0b2\x1e.proto.HighlyStruc\
    turedMessageR\x06footer\x12/\n\x07buttons\x18\x08\x20\x03(\x0b2\x15.prot\
    o.TemplateButtonR\x07buttons\x12B\n\x0fdocumentMessage\x18\x01\x20\x01(\
    \x0b2\x16.proto.DocumentMessageH\0R\x0fdocumentMessage\x12Z\n\x17highlyS\
    tructuredMessage\x18\x02\x20\x01(\x0b2\x1e.proto.HighlyStructuredMessage\
    H\0R\x17highlyStructuredMessage\x129\n\x0cimageMessage\x18\x03\x20\x01(\
    \x0b2\x13.proto.ImageMessageH\0R\x0cimageMessage\x129\n\x0cvideoMessage\
    \x18\x04\x20\x01(\x0b2\x13.proto.VideoMessageH\0R\x0cvideoMessage\x12B\n\
    \x0flocationMessage\x18\x05\x20\x01(\x0b2\x16.proto.LocationMessageH\0R\
    \x0flocationMessageB\x07\n\x05titleB\x08\n\x06format\"\xca\x01\n\x1aTemp\
    lateButtonReplyMessage\x12\x1e\n\nselectedId\x18\x01\x20\x01(\tR\nselect\
    edId\x120\n\x13selectedDisplayText\x18\x02\x20\x01(\tR\x13selectedDispla\
    yText\x124\n\x0bcontextInfo\x18\x03\x20\x01(\x0b2\x12.proto.ContextInfoR\
    \x0bcontextInfo\x12$\n\rselectedIndex\x18\x04\x20\x01(\rR\rselectedIndex\
    \"}\n\x15StickerSyncRMRMessage\x12\x1a\n\x08filehash\x18\x01\x20\x03(\tR\
    \x08filehash\x12\x1c\n\trmrSource\x18\x02\x20\x01(\tR\trmrSource\x12*\n\
    \x10requestTimestamp\x18\x03\x20\x01(\x03R\x10requestTimestamp\"\xd2\x04\
    \n\x0eStickerMessage\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x1e\
    \n\nfileSha256\x18\x02\x20\x01(\x0cR\nfileSha256\x12$\n\rfileEncSha256\
    \x18\x03\x20\x01(\x0cR\rfileEncSha256\x12\x1a\n\x08mediaKey\x18\x04\x20\
    \x01(\x0cR\x08mediaKey\x12\x1a\n\x08mimetype\x18\x05\x20\x01(\tR\x08mime\
    type\x12\x16\n\x06height\x18\x06\x20\x01(\rR\x06height\x12\x14\n\x05widt\
    h\x18\x07\x20\x01(\rR\x05width\x12\x1e\n\ndirectPath\x18\x08\x20\x01(\tR\
    \ndirectPath\x12\x1e\n\nfileLength\x18\t\x20\x01(\x04R\nfileLength\x12,\
    \n\x11mediaKeyTimestamp\x18\n\x20\x01(\x03R\x11mediaKeyTimestamp\x12*\n\
    \x10firstFrameLength\x18\x0b\x20\x01(\rR\x10firstFrameLength\x12,\n\x11f\
    irstFrameSidecar\x18\x0c\x20\x01(\x0cR\x11firstFrameSidecar\x12\x1e\n\ni\
    sAnimated\x18\r\x20\x01(\x08R\nisAnimated\x12\"\n\x0cpngThumbnail\x18\
    \x10\x20\x01(\x0cR\x0cpngThumbnail\x124\n\x0bcontextInfo\x18\x11\x20\x01\
    (\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x12$\n\rstickerSentTs\x18\
    \x12\x20\x01(\x03R\rstickerSentTs\x12\x1a\n\x08isAvatar\x18\x13\x20\x01(\
    \x08R\x08isAvatar\"\x8a\x01\n\x1cSenderKeyDistributionMessage\x12\x18\n\
    \x07groupId\x18\x01\x20\x01(\tR\x07groupId\x12P\n#axolotlSenderKeyDistri\
    butionMessage\x18\x02\x20\x01(\x0cR#axolotlSenderKeyDistributionMessage\
    \"\xc1\x01\n\x12SendPaymentMessage\x120\n\x0bnoteMessage\x18\x02\x20\x01\
    (\x0b2\x0e.proto.MessageR\x0bnoteMessage\x12?\n\x11requestMessageKey\x18\
    \x03\x20\x01(\x0b2\x11.proto.MessageKeyR\x11requestMessageKey\x128\n\nba\
    ckground\x18\x04\x20\x01(\x0b2\x18.proto.PaymentBackgroundR\nbackground\
    \"\xaa\x01\n\x18ScheduledCallEditMessage\x12#\n\x03key\x18\x01\x20\x01(\
    \x0b2\x11.proto.MessageKeyR\x03key\x12D\n\x08editType\x18\x02\x20\x01(\
    \x0e2(.proto.ScheduledCallEditMessage.EditTypeR\x08editType\"#\n\x08Edit\
    Type\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06CANCEL\x10\x01\"\xe1\x01\n\
    \x1cScheduledCallCreationMessage\x122\n\x14scheduledTimestampMs\x18\x01\
    \x20\x01(\x03R\x14scheduledTimestampMs\x12H\n\x08callType\x18\x02\x20\
    \x01(\x0e2,.proto.ScheduledCallCreationMessage.CallTypeR\x08callType\x12\
    \x14\n\x05title\x18\x03\x20\x01(\tR\x05title\"-\n\x08CallType\x12\x0b\n\
    \x07UNKNOWN\x10\0\x12\t\n\x05VOICE\x10\x01\x12\t\n\x05VIDEO\x10\x02\"Q\n\
    \x19RequestPhoneNumberMessage\x124\n\x0bcontextInfo\x18\x01\x20\x01(\x0b\
    2\x12.proto.ContextInfoR\x0bcontextInfo\"\xc7\x02\n\x15RequestPaymentMes\
    sage\x120\n\x0bnoteMessage\x18\x04\x20\x01(\x0b2\x0e.proto.MessageR\x0bn\
    oteMessage\x120\n\x13currencyCodeIso4217\x18\x01\x20\x01(\tR\x13currency\
    CodeIso4217\x12\x1e\n\namount1000\x18\x02\x20\x01(\x04R\namount1000\x12\
    \x20\n\x0brequestFrom\x18\x03\x20\x01(\tR\x0brequestFrom\x12(\n\x0fexpir\
    yTimestamp\x18\x05\x20\x01(\x03R\x0fexpiryTimestamp\x12$\n\x06amount\x18\
    \x06\x20\x01(\x0b2\x0c.proto.MoneyR\x06amount\x128\n\nbackground\x18\x07\
    \x20\x01(\x0b2\x18.proto.PaymentBackgroundR\nbackground\"\x9a\x01\n\x0fR\
    eactionMessage\x12#\n\x03key\x18\x01\x20\x01(\x0b2\x11.proto.MessageKeyR\
    \x03key\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\x12\x20\n\x0bgroup\
    ingKey\x18\x03\x20\x01(\tR\x0bgroupingKey\x12,\n\x11senderTimestampMs\
    \x18\x04\x20\x01(\x03R\x11senderTimestampMs\"\x9e\x0c\n\x0fProtocolMessa\
    ge\x12#\n\x03key\x18\x01\x20\x01(\x0b2\x11.proto.MessageKeyR\x03key\x12/\
    \n\x04type\x18\x02\x20\x01(\x0e2\x1b.proto.ProtocolMessage.TypeR\x04type\
    \x120\n\x13ephemeralExpiration\x18\x04\x20\x01(\rR\x13ephemeralExpiratio\
    n\x12<\n\x19ephemeralSettingTimestamp\x18\x05\x20\x01(\x03R\x19ephemeral\
    SettingTimestamp\x12X\n\x17historySyncNotification\x18\x06\x20\x01(\x0b2\
    \x1e.proto.HistorySyncNotificationR\x17historySyncNotification\x12O\n\
    \x14appStateSyncKeyShare\x18\x07\x20\x01(\x0b2\x1b.proto.AppStateSyncKey\
    ShareR\x14appStateSyncKeyShare\x12U\n\x16appStateSyncKeyRequest\x18\x08\
    \x20\x01(\x0b2\x1d.proto.AppStateSyncKeyRequestR\x16appStateSyncKeyReque\
    st\x12\x85\x01\n&initialSecurityNotificationSettingSync\x18\t\x20\x01(\
    \x0b2-.proto.InitialSecurityNotificationSettingSyncR&initialSecurityNoti\
    ficationSettingSync\x12y\n\"appStateFatalExceptionNotification\x18\n\x20\
    \x01(\x0b2).proto.AppStateFatalExceptionNotificationR\"appStateFatalExce\
    ptionNotification\x12C\n\x10disappearingMode\x18\x0b\x20\x01(\x0b2\x17.p\
    roto.DisappearingModeR\x10disappearingMode\x124\n\reditedMessage\x18\x0e\
    \x20\x01(\x0b2\x0e.proto.MessageR\reditedMessage\x12\x20\n\x0btimestampM\
    s\x18\x0f\x20\x01(\x03R\x0btimestampMs\x12p\n\x1fpeerDataOperationReques\
    tMessage\x18\x10\x20\x01(\x0b2&.proto.PeerDataOperationRequestMessageR\
    \x1fpeerDataOperationRequestMessage\x12\x88\x01\n'peerDataOperationReque\
    stResponseMessage\x18\x11\x20\x01(\x0b2..proto.PeerDataOperationRequestR\
    esponseMessageR'peerDataOperationRequestResponseMessage\"\xa5\x03\n\x04T\
    ype\x12\n\n\x06REVOKE\x10\0\x12\x15\n\x11EPHEMERAL_SETTING\x10\x03\x12\
    \x1b\n\x17EPHEMERAL_SYNC_RESPONSE\x10\x04\x12\x1d\n\x19HISTORY_SYNC_NOTI\
    FICATION\x10\x05\x12\x1c\n\x18APP_STATE_SYNC_KEY_SHARE\x10\x06\x12\x1e\n\
    \x1aAPP_STATE_SYNC_KEY_REQUEST\x10\x07\x12\x1f\n\x1bMSG_FANOUT_BACKFILL_\
    REQUEST\x10\x08\x12.\n*INITIAL_SECURITY_NOTIFICATION_SETTING_SYNC\x10\t\
    \x12*\n&APP_STATE_FATAL_EXCEPTION_NOTIFICATION\x10\n\x12\x16\n\x12SHARE_\
    PHONE_NUMBER\x10\x0b\x12\x10\n\x0cMESSAGE_EDIT\x10\x0e\x12'\n#PEER_DATA_\
    OPERATION_REQUEST_MESSAGE\x10\x10\x120\n,PEER_DATA_OPERATION_REQUEST_RES\
    PONSE_MESSAGE\x10\x11\"\xcc\x06\n\x0eProductMessage\x12?\n\x07product\
    \x18\x01\x20\x01(\x0b2%.proto.ProductMessage.ProductSnapshotR\x07product\
    \x12*\n\x10businessOwnerJid\x18\x02\x20\x01(\tR\x10businessOwnerJid\x12?\
    \n\x07catalog\x18\x04\x20\x01(\x0b2%.proto.ProductMessage.CatalogSnapsho\
    tR\x07catalog\x12\x12\n\x04body\x18\x05\x20\x01(\tR\x04body\x12\x16\n\
    \x06footer\x18\x06\x20\x01(\tR\x06footer\x124\n\x0bcontextInfo\x18\x11\
    \x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x1a\xa4\x03\n\x0fPr\
    oductSnapshot\x127\n\x0cproductImage\x18\x01\x20\x01(\x0b2\x13.proto.Ima\
    geMessageR\x0cproductImage\x12\x1c\n\tproductId\x18\x02\x20\x01(\tR\tpro\
    ductId\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x20\n\x0bdesc\
    ription\x18\x04\x20\x01(\tR\x0bdescription\x12\"\n\x0ccurrencyCode\x18\
    \x05\x20\x01(\tR\x0ccurrencyCode\x12(\n\x0fpriceAmount1000\x18\x06\x20\
    \x01(\x03R\x0fpriceAmount1000\x12\x1e\n\nretailerId\x18\x07\x20\x01(\tR\
    \nretailerId\x12\x10\n\x03url\x18\x08\x20\x01(\tR\x03url\x12,\n\x11produ\
    ctImageCount\x18\t\x20\x01(\rR\x11productImageCount\x12\"\n\x0cfirstImag\
    eId\x18\x0b\x20\x01(\tR\x0cfirstImageId\x120\n\x13salePriceAmount1000\
    \x18\x0c\x20\x01(\x03R\x13salePriceAmount1000\x1a\x82\x01\n\x0fCatalogSn\
    apshot\x127\n\x0ccatalogImage\x18\x01\x20\x01(\x0b2\x13.proto.ImageMessa\
    geR\x0ccatalogImage\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\
    \x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\";\n\x0fPollVot\
    eMessage\x12(\n\x0fselectedOptions\x18\x01\x20\x03(\x0cR\x0fselectedOpti\
    ons\"\xf3\x01\n\x11PollUpdateMessage\x12I\n\x16pollCreationMessageKey\
    \x18\x01\x20\x01(\x0b2\x11.proto.MessageKeyR\x16pollCreationMessageKey\
    \x12'\n\x04vote\x18\x02\x20\x01(\x0b2\x13.proto.PollEncValueR\x04vote\
    \x12<\n\x08metadata\x18\x03\x20\x01(\x0b2\x20.proto.PollUpdateMessageMet\
    adataR\x08metadata\x12,\n\x11senderTimestampMs\x18\x04\x20\x01(\x03R\x11\
    senderTimestampMs\"\x1b\n\x19PollUpdateMessageMetadata\"D\n\x0cPollEncVa\
    lue\x12\x1e\n\nencPayload\x18\x01\x20\x01(\x0cR\nencPayload\x12\x14\n\
    \x05encIv\x18\x02\x20\x01(\x0cR\x05encIv\"\x96\x02\n\x13PollCreationMess\
    age\x12\x16\n\x06encKey\x18\x01\x20\x01(\x0cR\x06encKey\x12\x12\n\x04nam\
    e\x18\x02\x20\x01(\tR\x04name\x12;\n\x07options\x18\x03\x20\x03(\x0b2!.p\
    roto.PollCreationMessage.OptionR\x07options\x126\n\x16selectableOptionsC\
    ount\x18\x04\x20\x01(\rR\x16selectableOptionsCount\x124\n\x0bcontextInfo\
    \x18\x05\x20\x01(\x0b2\x12.proto.ContextInfoR\x0bcontextInfo\x1a(\n\x06O\
    ption\x12\x1e\n\noptionName\x18\x01\x20\x01(\tR\noptionName\"\xfd\x01\n\
    \nPinMessage\x12#\n\x03key\x18\x01\x20\x01(\x0b2\x11.proto.MessageKeyR\
    \x03key\x12H\n\x0epinMessageType\x18\x02\x20\x01(\x0e2\x20.proto.PinMess\
    age.PinMessageTypeR\x0epinMessageType\x12,\n\x11senderTimestampMs\x18\
    \x03\x20\x01(\x03R\x11senderTimestampMs\"R\n\x0ePinMessageType\x12\x1c\n\
    \x18UNKNOWN_PIN_MESSAGE_TYPE\x10\0\x12\x0f\n\x0bPIN_FOR_ALL\x10\x01\x12\
    \x11\n\rUNPIN_FOR_ALL\x10\x02\"\xd7\x06\n'PeerDataOperationRequestRespon\
    seMessage\x12g\n\x1cpeerDataOperationRequestType\x18\x01\x20\x01(\x0e2#.\
    proto.PeerDataOperationRequestTypeR\x1cpeerDataOperationRequestType\x12\
    \x1a\n\x08stanzaId\x18\x02\x20\x01(\tR\x08stanzaId\x12\x80\x01\n\x17peer\
    DataOperationResult\x18\x03\x20\x03(\x0b2F.proto.PeerDataOperationReques\
    tResponseMessage.PeerDataOperationResultR\x17peerDataOperationResult\x1a\
    \xa3\x04\n\x17PeerDataOperationResult\x12V\n\x11mediaUploadResult\x18\
    \x01\x20\x01(\x0e2(.proto.MediaRetryNotification.ResultTypeR\x11mediaUpl\
    oadResult\x12=\n\x0estickerMessage\x18\x02\x20\x01(\x0b2\x15.proto.Stick\
    erMessageR\x0estickerMessage\x12\x8c\x01\n\x13linkPreviewResponse\x18\
    \x03\x20\x01(\x0b2Z.proto.PeerDataOperationRequestResponseMessage.PeerDa\
    taOperationResult.LinkPreviewResponseR\x13linkPreviewResponse\x1a\xe1\
    \x01\n\x13LinkPreviewResponse\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03ur\
    l\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\x20\n\x0bdescripti\
    on\x18\x03\x20\x01(\tR\x0bdescription\x12\x1c\n\tthumbData\x18\x04\x20\
    \x01(\x0cR\tthumbData\x12\"\n\x0ccanonicalUrl\x18\x05\x20\x01(\tR\x0ccan\
    onicalUrl\x12\x1c\n\tmatchText\x18\x06\x20\x01(\tR\tmatchText\x12\x20\n\
    \x0bpreviewType\x18\x07\x20\x01(\tR\x0bpreviewType\"L\n\x10EphemeralSett\
    ing\x12\x1a\n\x08duration\x18\x01\x20\x01(\x0fR\x08duration\x12\x1c\n\tt\
    imestamp\x18\x02\x20\x01(\x10R\ttimestamp\"I\n\x11WallpaperSettings\x12\
    \x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\x18\n\x07opacity\
    \x18\x02\x20\x01(\rR\x07opacity\"\xd5\x02\n\x0fStickerMetadata\x12\x10\n\
    \x03url\x18\x01\x20\x01(\tR\x03url\x12\x1e\n\nfileSha256\x18\x02\x20\x01\
    (\x0cR\nfileSha256\x12$\n\rfileEncSha256\x18\x03\x20\x01(\x0cR\rfileEncS\
    ha256\x12\x1a\n\x08mediaKey\x18\x04\x20\x01(\x0cR\x08mediaKey\x12\x1a\n\
    \x08mimetype\x18\x05\x20\x01(\tR\x08mimetype\x12\x16\n\x06height\x18\x06\
    \x20\x01(\rR\x06height\x12\x14\n\x05width\x18\x07\x20\x01(\rR\x05width\
    \x12\x1e\n\ndirectPath\x18\x08\x20\x01(\tR\ndirectPath\x12\x1e\n\nfileLe\
    ngth\x18\t\x20\x01(\x04R\nfileLength\x12\x16\n\x06weight\x18\n\x20\x01(\
    \x02R\x06weight\x12,\n\x11lastStickerSentTs\x18\x0b\x20\x01(\x03R\x11las\
    tStickerSentTs\"6\n\x08Pushname\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02i\
    d\x12\x1a\n\x08pushname\x18\x02\x20\x01(\tR\x08pushname\"r\n\x10PastPart\
    icipants\x12\x1a\n\x08groupJid\x18\x01\x20\x01(\tR\x08groupJid\x12B\n\
    \x10pastParticipants\x18\x02\x20\x03(\x0b2\x16.proto.PastParticipantR\
    \x10pastParticipants\"\xb1\x01\n\x0fPastParticipant\x12\x18\n\x07userJid\
    \x18\x01\x20\x01(\tR\x07userJid\x12D\n\x0bleaveReason\x18\x02\x20\x01(\
    \x0e2\".proto.PastParticipant.LeaveReasonR\x0bleaveReason\x12\x18\n\x07l\
    eaveTs\x18\x03\x20\x01(\x04R\x07leaveTs\"$\n\x0bLeaveReason\x12\x08\n\
    \x04LEFT\x10\0\x12\x0b\n\x07REMOVED\x10\x01\"\xe1\x05\n\x0bHistorySync\
    \x12>\n\x08syncType\x18\x01\x20\x02(\x0e2\".proto.HistorySync.HistorySyn\
    cTypeR\x08syncType\x129\n\rconversations\x18\x02\x20\x03(\x0b2\x13.proto\
    .ConversationR\rconversations\x12A\n\x10statusV3Messages\x18\x03\x20\x03\
    (\x0b2\x15.proto.WebMessageInfoR\x10statusV3Messages\x12\x1e\n\nchunkOrd\
    er\x18\x05\x20\x01(\rR\nchunkOrder\x12\x1a\n\x08progress\x18\x06\x20\x01\
    (\rR\x08progress\x12-\n\tpushnames\x18\x07\x20\x03(\x0b2\x0f.proto.Pushn\
    ameR\tpushnames\x12=\n\x0eglobalSettings\x18\x08\x20\x01(\x0b2\x15.proto\
    .GlobalSettingsR\x0eglobalSettings\x12.\n\x12threadIdUserSecret\x18\t\
    \x20\x01(\x0cR\x12threadIdUserSecret\x128\n\x17threadDsTimeframeOffset\
    \x18\n\x20\x01(\rR\x17threadDsTimeframeOffset\x12>\n\x0erecentStickers\
    \x18\x0b\x20\x03(\x0b2\x16.proto.StickerMetadataR\x0erecentStickers\x12C\
    \n\x10pastParticipants\x18\x0c\x20\x03(\x0b2\x17.proto.PastParticipantsR\
    \x10pastParticipants\"{\n\x0fHistorySyncType\x12\x15\n\x11INITIAL_BOOTST\
    RAP\x10\0\x12\x15\n\x11INITIAL_STATUS_V3\x10\x01\x12\x08\n\x04FULL\x10\
    \x02\x12\n\n\x06RECENT\x10\x03\x12\r\n\tPUSH_NAME\x10\x04\x12\x15\n\x11N\
    ON_BLOCKING_DATA\x10\x05\"a\n\x0eHistorySyncMsg\x12/\n\x07message\x18\
    \x01\x20\x01(\x0b2\x15.proto.WebMessageInfoR\x07message\x12\x1e\n\nmsgOr\
    derId\x18\x02\x20\x01(\x04R\nmsgOrderId\"\x8e\x01\n\x10GroupParticipant\
    \x12\x18\n\x07userJid\x18\x01\x20\x02(\tR\x07userJid\x120\n\x04rank\x18\
    \x02\x20\x01(\x0e2\x1c.proto.GroupParticipant.RankR\x04rank\".\n\x04Rank\
    \x12\x0b\n\x07REGULAR\x10\0\x12\t\n\x05ADMIN\x10\x01\x12\x0e\n\nSUPERADM\
    IN\x10\x02\"\xac\x06\n\x0eGlobalSettings\x12J\n\x13lightThemeWallpaper\
    \x18\x01\x20\x01(\x0b2\x18.proto.WallpaperSettingsR\x13lightThemeWallpap\
    er\x12@\n\x0fmediaVisibility\x18\x02\x20\x01(\x0e2\x16.proto.MediaVisibi\
    lityR\x0fmediaVisibility\x12H\n\x12darkThemeWallpaper\x18\x03\x20\x01(\
    \x0b2\x18.proto.WallpaperSettingsR\x12darkThemeWallpaper\x12G\n\x10autoD\
    ownloadWiFi\x18\x04\x20\x01(\x0b2\x1b.proto.AutoDownloadSettingsR\x10aut\
    oDownloadWiFi\x12O\n\x14autoDownloadCellular\x18\x05\x20\x01(\x0b2\x1b.p\
    roto.AutoDownloadSettingsR\x14autoDownloadCellular\x12M\n\x13autoDownloa\
    dRoaming\x18\x06\x20\x01(\x0b2\x1b.proto.AutoDownloadSettingsR\x13autoDo\
    wnloadRoaming\x12N\n\"showIndividualNotificationsPreview\x18\x07\x20\x01\
    (\x08R\"showIndividualNotificationsPreview\x12D\n\x1dshowGroupNotificati\
    onsPreview\x18\x08\x20\x01(\x08R\x1dshowGroupNotificationsPreview\x12:\n\
    \x18disappearingModeDuration\x18\t\x20\x01(\x05R\x18disappearingModeDura\
    tion\x12<\n\x19disappearingModeTimestamp\x18\n\x20\x01(\x03R\x19disappea\
    ringModeTimestamp\x12I\n\x12avatarUserSettings\x18\x0b\x20\x01(\x0b2\x19\
    .proto.AvatarUserSettingsR\x12avatarUserSettings\"\xb0\x0e\n\x0cConversa\
    tion\x12\x0e\n\x02id\x18\x01\x20\x02(\tR\x02id\x121\n\x08messages\x18\
    \x02\x20\x03(\x0b2\x15.proto.HistorySyncMsgR\x08messages\x12\x16\n\x06ne\
    wJid\x18\x03\x20\x01(\tR\x06newJid\x12\x16\n\x06oldJid\x18\x04\x20\x01(\
    \tR\x06oldJid\x12*\n\x10lastMsgTimestamp\x18\x05\x20\x01(\x04R\x10lastMs\
    gTimestamp\x12\x20\n\x0bunreadCount\x18\x06\x20\x01(\rR\x0bunreadCount\
    \x12\x1a\n\x08readOnly\x18\x07\x20\x01(\x08R\x08readOnly\x122\n\x14endOf\
    HistoryTransfer\x18\x08\x20\x01(\x08R\x14endOfHistoryTransfer\x120\n\x13\
    ephemeralExpiration\x18\t\x20\x01(\rR\x13ephemeralExpiration\x12<\n\x19e\
    phemeralSettingTimestamp\x18\n\x20\x01(\x03R\x19ephemeralSettingTimestam\
    p\x12h\n\x18endOfHistoryTransferType\x18\x0b\x20\x01(\x0e2,.proto.Conver\
    sation.EndOfHistoryTransferTypeR\x18endOfHistoryTransferType\x124\n\x15c\
    onversationTimestamp\x18\x0c\x20\x01(\x04R\x15conversationTimestamp\x12\
    \x12\n\x04name\x18\r\x20\x01(\tR\x04name\x12\x14\n\x05pHash\x18\x0e\x20\
    \x01(\tR\x05pHash\x12\x18\n\x07notSpam\x18\x0f\x20\x01(\x08R\x07notSpam\
    \x12\x1a\n\x08archived\x18\x10\x20\x01(\x08R\x08archived\x12C\n\x10disap\
    pearingMode\x18\x11\x20\x01(\x0b2\x17.proto.DisappearingModeR\x10disappe\
    aringMode\x12.\n\x12unreadMentionCount\x18\x12\x20\x01(\rR\x12unreadMent\
    ionCount\x12&\n\x0emarkedAsUnread\x18\x13\x20\x01(\x08R\x0emarkedAsUnrea\
    d\x129\n\x0bparticipant\x18\x14\x20\x03(\x0b2\x17.proto.GroupParticipant\
    R\x0bparticipant\x12\x18\n\x07tcToken\x18\x15\x20\x01(\x0cR\x07tcToken\
    \x12*\n\x10tcTokenTimestamp\x18\x16\x20\x01(\x04R\x10tcTokenTimestamp\
    \x12<\n\x19contactPrimaryIdentityKey\x18\x17\x20\x01(\x0cR\x19contactPri\
    maryIdentityKey\x12\x16\n\x06pinned\x18\x18\x20\x01(\rR\x06pinned\x12\
    \x20\n\x0bmuteEndTime\x18\x19\x20\x01(\x04R\x0bmuteEndTime\x126\n\twallp\
    aper\x18\x1a\x20\x01(\x0b2\x18.proto.WallpaperSettingsR\twallpaper\x12@\
    \n\x0fmediaVisibility\x18\x1b\x20\x01(\x0e2\x16.proto.MediaVisibilityR\
    \x0fmediaVisibility\x126\n\x16tcTokenSenderTimestamp\x18\x1c\x20\x01(\
    \x04R\x16tcTokenSenderTimestamp\x12\x1c\n\tsuspended\x18\x1d\x20\x01(\
    \x08R\tsuspended\x12\x1e\n\nterminated\x18\x1e\x20\x01(\x08R\nterminated\
    \x12\x1c\n\tcreatedAt\x18\x1f\x20\x01(\x04R\tcreatedAt\x12\x1c\n\tcreate\
    dBy\x18\x20\x20\x01(\tR\tcreatedBy\x12\x20\n\x0bdescription\x18!\x20\x01\
    (\tR\x0bdescription\x12\x18\n\x07support\x18\"\x20\x01(\x08R\x07support\
    \x12$\n\risParentGroup\x18#\x20\x01(\x08R\risParentGroup\x12,\n\x11isDef\
    aultSubgroup\x18$\x20\x01(\x08R\x11isDefaultSubgroup\x12$\n\rparentGroup\
    Id\x18%\x20\x01(\tR\rparentGroupId\x12\x20\n\x0bdisplayName\x18&\x20\x01\
    (\tR\x0bdisplayName\x12\x14\n\x05pnJid\x18'\x20\x01(\tR\x05pnJid\x12\x1e\
    \n\nshareOwnPn\x18(\x20\x01(\x08R\nshareOwnPn\x124\n\x15pnhDuplicateLidT\
    hread\x18)\x20\x01(\x08R\x15pnhDuplicateLidThread\x12\x16\n\x06lidJid\
    \x18*\x20\x01(\tR\x06lidJid\"\x80\x01\n\x18EndOfHistoryTransferType\x120\
    \n,COMPLETE_BUT_MORE_MESSAGES_REMAIN_ON_PRIMARY\x10\0\x122\n.COMPLETE_AN\
    D_NO_MORE_MESSAGE_REMAIN_ON_PRIMARY\x10\x01\"D\n\x12AvatarUserSettings\
    \x12\x12\n\x04fbid\x18\x01\x20\x01(\tR\x04fbid\x12\x1a\n\x08password\x18\
    \x02\x20\x01(\tR\x08password\"\xb8\x01\n\x14AutoDownloadSettings\x12&\n\
    \x0edownloadImages\x18\x01\x20\x01(\x08R\x0edownloadImages\x12$\n\rdownl\
    oadAudio\x18\x02\x20\x01(\x08R\rdownloadAudio\x12$\n\rdownloadVideo\x18\
    \x03\x20\x01(\x08R\rdownloadVideo\x12,\n\x11downloadDocuments\x18\x04\
    \x20\x01(\x08R\x11downloadDocuments\"|\n\x10MsgRowOpaqueData\x124\n\ncur\
    rentMsg\x18\x01\x20\x01(\x0b2\x14.proto.MsgOpaqueDataR\ncurrentMsg\x122\
    \n\tquotedMsg\x18\x02\x20\x01(\x0b2\x14.proto.MsgOpaqueDataR\tquotedMsg\
    \"\xbb\x08\n\rMsgOpaqueData\x12\x12\n\x04body\x18\x01\x20\x01(\tR\x04bod\
    y\x12\x18\n\x07caption\x18\x03\x20\x01(\tR\x07caption\x12\x10\n\x03lng\
    \x18\x05\x20\x01(\x01R\x03lng\x12\x16\n\x06isLive\x18\x06\x20\x01(\x08R\
    \x06isLive\x12\x10\n\x03lat\x18\x07\x20\x01(\x01R\x03lat\x12,\n\x11payme\
    ntAmount1000\x18\x08\x20\x01(\x05R\x11paymentAmount1000\x12.\n\x12paymen\
    tNoteMsgBody\x18\t\x20\x01(\tR\x12paymentNoteMsgBody\x12\"\n\x0ccanonica\
    lUrl\x18\n\x20\x01(\tR\x0ccanonicalUrl\x12\x20\n\x0bmatchedText\x18\x0b\
    \x20\x01(\tR\x0bmatchedText\x12\x14\n\x05title\x18\x0c\x20\x01(\tR\x05ti\
    tle\x12\x20\n\x0bdescription\x18\r\x20\x01(\tR\x0bdescription\x12,\n\x11\
    futureproofBuffer\x18\x0e\x20\x01(\x0cR\x11futureproofBuffer\x12\x1c\n\t\
    clientUrl\x18\x0f\x20\x01(\tR\tclientUrl\x12\x10\n\x03loc\x18\x10\x20\
    \x01(\tR\x03loc\x12\x1a\n\x08pollName\x18\x11\x20\x01(\tR\x08pollName\
    \x12A\n\x0bpollOptions\x18\x12\x20\x03(\x0b2\x1f.proto.MsgOpaqueData.Pol\
    lOptionR\x0bpollOptions\x12>\n\x1apollSelectableOptionsCount\x18\x14\x20\
    \x01(\rR\x1apollSelectableOptionsCount\x12$\n\rmessageSecret\x18\x15\x20\
    \x01(\x0cR\rmessageSecret\x12.\n\x12originalSelfAuthor\x183\x20\x01(\tR\
    \x12originalSelfAuthor\x12,\n\x11senderTimestampMs\x18\x16\x20\x01(\x03R\
    \x11senderTimestampMs\x120\n\x13pollUpdateParentKey\x18\x17\x20\x01(\tR\
    \x13pollUpdateParentKey\x125\n\x0bencPollVote\x18\x18\x20\x01(\x0b2\x13.\
    proto.PollEncValueR\x0bencPollVote\x124\n\x15isSentCagPollCreation\x18\
    \x1c\x20\x01(\x08R\x15isSentCagPollCreation\x12@\n\x1bencReactionTargetM\
    essageKey\x18\x19\x20\x01(\tR\x1bencReactionTargetMessageKey\x124\n\x15e\
    ncReactionEncPayload\x18\x1a\x20\x01(\x0cR\x15encReactionEncPayload\x12*\
    \n\x10encReactionEncIv\x18\x1b\x20\x01(\x0cR\x10encReactionEncIv\x1a\x20\
    \n\nPollOption\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"0\n\x12Ser\
    verErrorReceipt\x12\x1a\n\x08stanzaId\x18\x01\x20\x01(\tR\x08stanzaId\"\
    \xe9\x01\n\x16MediaRetryNotification\x12\x1a\n\x08stanzaId\x18\x01\x20\
    \x01(\tR\x08stanzaId\x12\x1e\n\ndirectPath\x18\x02\x20\x01(\tR\ndirectPa\
    th\x12@\n\x06result\x18\x03\x20\x01(\x0e2(.proto.MediaRetryNotification.\
    ResultTypeR\x06result\"Q\n\nResultType\x12\x11\n\rGENERAL_ERROR\x10\0\
    \x12\x0b\n\x07SUCCESS\x10\x01\x12\r\n\tNOT_FOUND\x10\x02\x12\x14\n\x10DE\
    CRYPTION_ERROR\x10\x03\"t\n\nMessageKey\x12\x1c\n\tremoteJid\x18\x01\x20\
    \x01(\tR\tremoteJid\x12\x16\n\x06fromMe\x18\x02\x20\x01(\x08R\x06fromMe\
    \x12\x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\x12\x20\n\x0bparticipant\x18\
    \x04\x20\x01(\tR\x0bparticipant\"(\n\x0cSyncdVersion\x12\x18\n\x07versio\
    n\x18\x01\x20\x01(\x04R\x07version\"\x20\n\nSyncdValue\x12\x12\n\x04blob\
    \x18\x01\x20\x01(\x0cR\x04blob\"\xa2\x01\n\rSyncdSnapshot\x12-\n\x07vers\
    ion\x18\x01\x20\x01(\x0b2\x13.proto.SyncdVersionR\x07version\x12,\n\x07r\
    ecords\x18\x02\x20\x03(\x0b2\x12.proto.SyncdRecordR\x07records\x12\x10\n\
    \x03mac\x18\x03\x20\x01(\x0cR\x03mac\x12\"\n\x05keyId\x18\x04\x20\x01(\
    \x0b2\x0c.proto.KeyIdR\x05keyId\"\x83\x01\n\x0bSyncdRecord\x12'\n\x05ind\
    ex\x18\x01\x20\x01(\x0b2\x11.proto.SyncdIndexR\x05index\x12'\n\x05value\
    \x18\x02\x20\x01(\x0b2\x11.proto.SyncdValueR\x05value\x12\"\n\x05keyId\
    \x18\x03\x20\x01(\x0b2\x0c.proto.KeyIdR\x05keyId\"\xec\x02\n\nSyncdPatch\
    \x12-\n\x07version\x18\x01\x20\x01(\x0b2\x13.proto.SyncdVersionR\x07vers\
    ion\x122\n\tmutations\x18\x02\x20\x03(\x0b2\x14.proto.SyncdMutationR\tmu\
    tations\x12J\n\x11externalMutations\x18\x03\x20\x01(\x0b2\x1c.proto.Exte\
    rnalBlobReferenceR\x11externalMutations\x12\x20\n\x0bsnapshotMac\x18\x04\
    \x20\x01(\x0cR\x0bsnapshotMac\x12\x1a\n\x08patchMac\x18\x05\x20\x01(\x0c\
    R\x08patchMac\x12\"\n\x05keyId\x18\x06\x20\x01(\x0b2\x0c.proto.KeyIdR\
    \x05keyId\x12+\n\x08exitCode\x18\x07\x20\x01(\x0b2\x0f.proto.ExitCodeR\
    \x08exitCode\x12\x20\n\x0bdeviceIndex\x18\x08\x20\x01(\rR\x0bdeviceIndex\
    \"D\n\x0eSyncdMutations\x122\n\tmutations\x18\x01\x20\x03(\x0b2\x14.prot\
    o.SyncdMutationR\tmutations\"\xa5\x01\n\rSyncdMutation\x12A\n\toperation\
    \x18\x01\x20\x01(\x0e2#.proto.SyncdMutation.SyncdOperationR\toperation\
    \x12*\n\x06record\x18\x02\x20\x01(\x0b2\x12.proto.SyncdRecordR\x06record\
    \"%\n\x0eSyncdOperation\x12\x07\n\x03SET\x10\0\x12\n\n\x06REMOVE\x10\x01\
    \"\x20\n\nSyncdIndex\x12\x12\n\x04blob\x18\x01\x20\x01(\x0cR\x04blob\"\
    \x17\n\x05KeyId\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\"\xd7\x01\n\
    \x15ExternalBlobReference\x12\x1a\n\x08mediaKey\x18\x01\x20\x01(\x0cR\
    \x08mediaKey\x12\x1e\n\ndirectPath\x18\x02\x20\x01(\tR\ndirectPath\x12\
    \x16\n\x06handle\x18\x03\x20\x01(\tR\x06handle\x12$\n\rfileSizeBytes\x18\
    \x04\x20\x01(\x04R\rfileSizeBytes\x12\x1e\n\nfileSha256\x18\x05\x20\x01(\
    \x0cR\nfileSha256\x12$\n\rfileEncSha256\x18\x06\x20\x01(\x0cR\rfileEncSh\
    a256\"2\n\x08ExitCode\x12\x12\n\x04code\x18\x01\x20\x01(\x04R\x04code\
    \x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"\xf9\x11\n\x0fSyncAction\
    Value\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\ttimestamp\x121\n\nstar\
    Action\x18\x02\x20\x01(\x0b2\x11.proto.StarActionR\nstarAction\x12:\n\rc\
    ontactAction\x18\x03\x20\x01(\x0b2\x14.proto.ContactActionR\rcontactActi\
    on\x121\n\nmuteAction\x18\x04\x20\x01(\x0b2\x11.proto.MuteActionR\nmuteA\
    ction\x12.\n\tpinAction\x18\x05\x20\x01(\x0b2\x10.proto.PinActionR\tpinA\
    ction\x12d\n\x1bsecurityNotificationSetting\x18\x06\x20\x01(\x0b2\".prot\
    o.SecurityNotificationSettingR\x1bsecurityNotificationSetting\x12@\n\x0f\
    pushNameSetting\x18\x07\x20\x01(\x0b2\x16.proto.PushNameSettingR\x0fpush\
    NameSetting\x12C\n\x10quickReplyAction\x18\x08\x20\x01(\x0b2\x17.proto.Q\
    uickReplyActionR\x10quickReplyAction\x12[\n\x18recentEmojiWeightsAction\
    \x18\x0b\x20\x01(\x0b2\x1f.proto.RecentEmojiWeightsActionR\x18recentEmoj\
    iWeightsAction\x12@\n\x0flabelEditAction\x18\x0e\x20\x01(\x0b2\x16.proto\
    .LabelEditActionR\x0flabelEditAction\x12U\n\x16labelAssociationAction\
    \x18\x0f\x20\x01(\x0b2\x1d.proto.LabelAssociationActionR\x16labelAssocia\
    tionAction\x12:\n\rlocaleSetting\x18\x10\x20\x01(\x0b2\x14.proto.LocaleS\
    ettingR\rlocaleSetting\x12F\n\x11archiveChatAction\x18\x11\x20\x01(\x0b2\
    \x18.proto.ArchiveChatActionR\x11archiveChatAction\x12[\n\x18deleteMessa\
    geForMeAction\x18\x12\x20\x01(\x0b2\x1f.proto.DeleteMessageForMeActionR\
    \x18deleteMessageForMeAction\x12:\n\rkeyExpiration\x18\x13\x20\x01(\x0b2\
    \x14.proto.KeyExpirationR\rkeyExpiration\x12O\n\x14markChatAsReadAction\
    \x18\x14\x20\x01(\x0b2\x1b.proto.MarkChatAsReadActionR\x14markChatAsRead\
    Action\x12@\n\x0fclearChatAction\x18\x15\x20\x01(\x0b2\x16.proto.ClearCh\
    atActionR\x0fclearChatAction\x12C\n\x10deleteChatAction\x18\x16\x20\x01(\
    \x0b2\x17.proto.DeleteChatActionR\x10deleteChatAction\x12R\n\x15unarchiv\
    eChatsSetting\x18\x17\x20\x01(\x0b2\x1c.proto.UnarchiveChatsSettingR\x15\
    unarchiveChatsSetting\x12=\n\x0eprimaryFeature\x18\x18\x20\x01(\x0b2\x15\
    .proto.PrimaryFeatureR\x0eprimaryFeature\x12^\n\x19androidUnsupportedAct\
    ions\x18\x1a\x20\x01(\x0b2\x20.proto.AndroidUnsupportedActionsR\x19andro\
    idUnsupportedActions\x124\n\x0bagentAction\x18\x1b\x20\x01(\x0b2\x12.pro\
    to.AgentActionR\x0bagentAction\x12I\n\x12subscriptionAction\x18\x1c\x20\
    \x01(\x0b2\x19.proto.SubscriptionActionR\x12subscriptionAction\x12O\n\
    \x14userStatusMuteAction\x18\x1d\x20\x01(\x0b2\x1b.proto.UserStatusMuteA\
    ctionR\x14userStatusMuteAction\x12C\n\x10timeFormatAction\x18\x1e\x20\
    \x01(\x0b2\x17.proto.TimeFormatActionR\x10timeFormatAction\x12.\n\tnuxAc\
    tion\x18\x1f\x20\x01(\x0b2\x10.proto.NuxActionR\tnuxAction\x12O\n\x14pri\
    maryVersionAction\x18\x20\x20\x01(\x0b2\x1b.proto.PrimaryVersionActionR\
    \x14primaryVersionAction\x12:\n\rstickerAction\x18!\x20\x01(\x0b2\x14.pr\
    oto.StickerActionR\rstickerAction\x12^\n\x19removeRecentStickerAction\
    \x18\"\x20\x01(\x0b2\x20.proto.RemoveRecentStickerActionR\x19removeRecen\
    tStickerAction\x12C\n\x0echatAssignment\x18#\x20\x01(\x0b2\x1b.proto.Cha\
    tAssignmentActionR\x0echatAssignment\x12g\n\x1achatAssignmentOpenedStatu\
    s\x18$\x20\x01(\x0b2'.proto.ChatAssignmentOpenedStatusActionR\x1achatAss\
    ignmentOpenedStatus\x12I\n\x12pnForLidChatAction\x18%\x20\x01(\x0b2\x19.\
    proto.PnForLidChatActionR\x12pnForLidChatAction\",\n\x14UserStatusMuteAc\
    tion\x12\x14\n\x05muted\x18\x01\x20\x01(\x08R\x05muted\"?\n\x15Unarchive\
    ChatsSetting\x12&\n\x0eunarchiveChats\x18\x01\x20\x01(\x08R\x0eunarchive\
    Chats\"X\n\x10TimeFormatAction\x12D\n\x1disTwentyFourHourFormatEnabled\
    \x18\x01\x20\x01(\x08R\x1disTwentyFourHourFormatEnabled\"V\n\x11SyncActi\
    onMessage\x12#\n\x03key\x18\x01\x20\x01(\x0b2\x11.proto.MessageKeyR\x03k\
    ey\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x03R\ttimestamp\"\xc2\x01\n\x16\
    SyncActionMessageRange\x122\n\x14lastMessageTimestamp\x18\x01\x20\x01(\
    \x03R\x14lastMessageTimestamp\x12>\n\x1alastSystemMessageTimestamp\x18\
    \x02\x20\x01(\x03R\x1alastSystemMessageTimestamp\x124\n\x08messages\x18\
    \x03\x20\x03(\x0b2\x18.proto.SyncActionMessageR\x08messages\"\x8a\x01\n\
    \x12SubscriptionAction\x12$\n\risDeactivated\x18\x01\x20\x01(\x08R\risDe\
    activated\x12&\n\x0eisAutoRenewing\x18\x02\x20\x01(\x08R\x0eisAutoRenewi\
    ng\x12&\n\x0eexpirationDate\x18\x03\x20\x01(\x03R\x0eexpirationDate\"\
    \xb1\x02\n\rStickerAction\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\
    \x12$\n\rfileEncSha256\x18\x02\x20\x01(\x0cR\rfileEncSha256\x12\x1a\n\
    \x08mediaKey\x18\x03\x20\x01(\x0cR\x08mediaKey\x12\x1a\n\x08mimetype\x18\
    \x04\x20\x01(\tR\x08mimetype\x12\x16\n\x06height\x18\x05\x20\x01(\rR\x06\
    height\x12\x14\n\x05width\x18\x06\x20\x01(\rR\x05width\x12\x1e\n\ndirect\
    Path\x18\x07\x20\x01(\tR\ndirectPath\x12\x1e\n\nfileLength\x18\x08\x20\
    \x01(\x04R\nfileLength\x12\x1e\n\nisFavorite\x18\t\x20\x01(\x08R\nisFavo\
    rite\x12\"\n\x0cdeviceIdHint\x18\n\x20\x01(\rR\x0cdeviceIdHint\"&\n\nSta\
    rAction\x12\x18\n\x07starred\x18\x01\x20\x01(\x08R\x07starred\"I\n\x1bSe\
    curityNotificationSetting\x12*\n\x10showNotification\x18\x01\x20\x01(\
    \x08R\x10showNotification\"I\n\x19RemoveRecentStickerAction\x12,\n\x11la\
    stStickerSentTs\x18\x01\x20\x01(\x03R\x11lastStickerSentTs\"N\n\x18Recen\
    tEmojiWeightsAction\x122\n\x07weights\x18\x01\x20\x03(\x0b2\x18.proto.Re\
    centEmojiWeightR\x07weights\"\x94\x01\n\x10QuickReplyAction\x12\x1a\n\
    \x08shortcut\x18\x01\x20\x01(\tR\x08shortcut\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\x12\x1a\n\x08keywords\x18\x03\x20\x03(\tR\
    \x08keywords\x12\x14\n\x05count\x18\x04\x20\x01(\x05R\x05count\x12\x18\n\
    \x07deleted\x18\x05\x20\x01(\x08R\x07deleted\"%\n\x0fPushNameSetting\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"0\n\x14PrimaryVersionAction\
    \x12\x18\n\x07version\x18\x01\x20\x01(\tR\x07version\"&\n\x0ePrimaryFeat\
    ure\x12\x14\n\x05flags\x18\x01\x20\x03(\tR\x05flags\"*\n\x12PnForLidChat\
    Action\x12\x14\n\x05pnJid\x18\x01\x20\x01(\tR\x05pnJid\"#\n\tPinAction\
    \x12\x16\n\x06pinned\x18\x01\x20\x01(\x08R\x06pinned\"/\n\tNuxAction\x12\
    \"\n\x0cacknowledged\x18\x01\x20\x01(\x08R\x0cacknowledged\"l\n\nMuteAct\
    ion\x12\x14\n\x05muted\x18\x01\x20\x01(\x08R\x05muted\x12*\n\x10muteEndT\
    imestamp\x18\x02\x20\x01(\x03R\x10muteEndTimestamp\x12\x1c\n\tautoMuted\
    \x18\x03\x20\x01(\x08R\tautoMuted\"m\n\x14MarkChatAsReadAction\x12\x12\n\
    \x04read\x18\x01\x20\x01(\x08R\x04read\x12A\n\x0cmessageRange\x18\x02\
    \x20\x01(\x0b2\x1d.proto.SyncActionMessageRangeR\x0cmessageRange\"'\n\rL\
    ocaleSetting\x12\x16\n\x06locale\x18\x01\x20\x01(\tR\x06locale\"y\n\x0fL\
    abelEditAction\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\
    \x05color\x18\x02\x20\x01(\x05R\x05color\x12\"\n\x0cpredefinedId\x18\x03\
    \x20\x01(\x05R\x0cpredefinedId\x12\x18\n\x07deleted\x18\x04\x20\x01(\x08\
    R\x07deleted\"2\n\x16LabelAssociationAction\x12\x18\n\x07labeled\x18\x01\
    \x20\x01(\x08R\x07labeled\"9\n\rKeyExpiration\x12(\n\x0fexpiredKeyEpoch\
    \x18\x01\x20\x01(\x05R\x0fexpiredKeyEpoch\"h\n\x18DeleteMessageForMeActi\
    on\x12\x20\n\x0bdeleteMedia\x18\x01\x20\x01(\x08R\x0bdeleteMedia\x12*\n\
    \x10messageTimestamp\x18\x02\x20\x01(\x03R\x10messageTimestamp\"U\n\x10D\
    eleteChatAction\x12A\n\x0cmessageRange\x18\x01\x20\x01(\x0b2\x1d.proto.S\
    yncActionMessageRangeR\x0cmessageRange\"a\n\rContactAction\x12\x1a\n\x08\
    fullName\x18\x01\x20\x01(\tR\x08fullName\x12\x1c\n\tfirstName\x18\x02\
    \x20\x01(\tR\tfirstName\x12\x16\n\x06lidJid\x18\x03\x20\x01(\tR\x06lidJi\
    d\"T\n\x0fClearChatAction\x12A\n\x0cmessageRange\x18\x01\x20\x01(\x0b2\
    \x1d.proto.SyncActionMessageRangeR\x0cmessageRange\"B\n\x20ChatAssignmen\
    tOpenedStatusAction\x12\x1e\n\nchatOpened\x18\x01\x20\x01(\x08R\nchatOpe\
    ned\"<\n\x14ChatAssignmentAction\x12$\n\rdeviceAgentID\x18\x01\x20\x01(\
    \tR\rdeviceAgentID\"r\n\x11ArchiveChatAction\x12\x1a\n\x08archived\x18\
    \x01\x20\x01(\x08R\x08archived\x12A\n\x0cmessageRange\x18\x02\x20\x01(\
    \x0b2\x1d.proto.SyncActionMessageRangeR\x0cmessageRange\"5\n\x19AndroidU\
    nsupportedActions\x12\x18\n\x07allowed\x18\x01\x20\x01(\x08R\x07allowed\
    \"[\n\x0bAgentAction\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x1a\n\x08deviceID\x18\x02\x20\x01(\x05R\x08deviceID\x12\x1c\n\tisDelete\
    d\x18\x03\x20\x01(\x08R\tisDeleted\"\x88\x01\n\x0eSyncActionData\x12\x14\
    \n\x05index\x18\x01\x20\x01(\x0cR\x05index\x12,\n\x05value\x18\x02\x20\
    \x01(\x0b2\x16.proto.SyncActionValueR\x05value\x12\x18\n\x07padding\x18\
    \x03\x20\x01(\x0cR\x07padding\x12\x18\n\x07version\x18\x04\x20\x01(\x05R\
    \x07version\"A\n\x11RecentEmojiWeight\x12\x14\n\x05emoji\x18\x01\x20\x01\
    (\tR\x05emoji\x12\x16\n\x06weight\x18\x02\x20\x01(\x02R\x06weight\"\xb7\
    \x02\n\x17VerifiedNameCertificate\x12\x18\n\x07details\x18\x01\x20\x01(\
    \x0cR\x07details\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\
    \x12(\n\x0fserverSignature\x18\x03\x20\x01(\x0cR\x0fserverSignature\x1a\
    \xb9\x01\n\x07Details\x12\x16\n\x06serial\x18\x01\x20\x01(\x04R\x06seria\
    l\x12\x16\n\x06issuer\x18\x02\x20\x01(\tR\x06issuer\x12\"\n\x0cverifiedN\
    ame\x18\x04\x20\x01(\tR\x0cverifiedName\x12<\n\x0elocalizedNames\x18\x08\
    \x20\x03(\x0b2\x14.proto.LocalizedNameR\x0elocalizedNames\x12\x1c\n\tiss\
    ueTime\x18\n\x20\x01(\x04R\tissueTime\"S\n\rLocalizedName\x12\x0e\n\x02l\
    g\x18\x01\x20\x01(\tR\x02lg\x12\x0e\n\x02lc\x18\x02\x20\x01(\tR\x02lc\
    \x12\"\n\x0cverifiedName\x18\x03\x20\x01(\tR\x0cverifiedName\"\xb9\x04\n\
    \x0fBizIdentityInfo\x12A\n\x06vlevel\x18\x01\x20\x01(\x0e2).proto.BizIde\
    ntityInfo.VerifiedLevelValueR\x06vlevel\x12<\n\tvnameCert\x18\x02\x20\
    \x01(\x0b2\x1e.proto.VerifiedNameCertificateR\tvnameCert\x12\x16\n\x06si\
    gned\x18\x03\x20\x01(\x08R\x06signed\x12\x18\n\x07revoked\x18\x04\x20\
    \x01(\x08R\x07revoked\x12H\n\x0bhostStorage\x18\x05\x20\x01(\x0e2&.proto\
    .BizIdentityInfo.HostStorageTypeR\x0bhostStorage\x12K\n\x0cactualActors\
    \x18\x06\x20\x01(\x0e2'.proto.BizIdentityInfo.ActualActorsTypeR\x0cactua\
    lActors\x12$\n\rprivacyModeTs\x18\x07\x20\x01(\x04R\rprivacyModeTs\x12(\
    \n\x0ffeatureControls\x18\x08\x20\x01(\x04R\x0ffeatureControls\"4\n\x12V\
    erifiedLevelValue\x12\x0b\n\x07UNKNOWN\x10\0\x12\x07\n\x03LOW\x10\x01\
    \x12\x08\n\x04HIGH\x10\x02\"/\n\x0fHostStorageType\x12\x0e\n\nON_PREMISE\
    \x10\0\x12\x0c\n\x08FACEBOOK\x10\x01\"%\n\x10ActualActorsType\x12\x08\n\
    \x04SELF\x10\0\x12\x07\n\x03BSP\x10\x01\"{\n\x11BizAccountPayload\x12<\n\
    \tvnameCert\x18\x01\x20\x01(\x0b2\x1e.proto.VerifiedNameCertificateR\tvn\
    ameCert\x12(\n\x0fbizAcctLinkInfo\x18\x02\x20\x01(\x0cR\x0fbizAcctLinkIn\
    fo\"\xfa\x02\n\x12BizAccountLinkInfo\x120\n\x13whatsappBizAcctFbid\x18\
    \x01\x20\x01(\x04R\x13whatsappBizAcctFbid\x12.\n\x12whatsappAcctNumber\
    \x18\x02\x20\x01(\tR\x12whatsappAcctNumber\x12\x1c\n\tissueTime\x18\x03\
    \x20\x01(\x04R\tissueTime\x12K\n\x0bhostStorage\x18\x04\x20\x01(\x0e2).p\
    roto.BizAccountLinkInfo.HostStorageTypeR\x0bhostStorage\x12G\n\x0baccoun\
    tType\x18\x05\x20\x01(\x0e2%.proto.BizAccountLinkInfo.AccountTypeR\x0bac\
    countType\"/\n\x0fHostStorageType\x12\x0e\n\nON_PREMISE\x10\0\x12\x0c\n\
    \x08FACEBOOK\x10\x01\"\x1d\n\x0bAccountType\x12\x0e\n\nENTERPRISE\x10\0\
    \"\xd2\x01\n\x10HandshakeMessage\x12=\n\x0bclientHello\x18\x02\x20\x01(\
    \x0b2\x1b.proto.HandshakeClientHelloR\x0bclientHello\x12=\n\x0bserverHel\
    lo\x18\x03\x20\x01(\x0b2\x1b.proto.HandshakeServerHelloR\x0bserverHello\
    \x12@\n\x0cclientFinish\x18\x04\x20\x01(\x0b2\x1c.proto.HandshakeClientF\
    inishR\x0cclientFinish\"f\n\x14HandshakeServerHello\x12\x1c\n\tephemeral\
    \x18\x01\x20\x01(\x0cR\tephemeral\x12\x16\n\x06static\x18\x02\x20\x01(\
    \x0cR\x06static\x12\x18\n\x07payload\x18\x03\x20\x01(\x0cR\x07payload\"f\
    \n\x14HandshakeClientHello\x12\x1c\n\tephemeral\x18\x01\x20\x01(\x0cR\te\
    phemeral\x12\x16\n\x06static\x18\x02\x20\x01(\x0cR\x06static\x12\x18\n\
    \x07payload\x18\x03\x20\x01(\x0cR\x07payload\"I\n\x15HandshakeClientFini\
    sh\x12\x16\n\x06static\x18\x01\x20\x01(\x0cR\x06static\x12\x18\n\x07payl\
    oad\x18\x02\x20\x01(\x0cR\x07payload\"\x97!\n\rClientPayload\x12\x1a\n\
    \x08username\x18\x01\x20\x01(\x04R\x08username\x12\x18\n\x07passive\x18\
    \x03\x20\x01(\x08R\x07passive\x12<\n\tuserAgent\x18\x05\x20\x01(\x0b2\
    \x1e.proto.ClientPayload.UserAgentR\tuserAgent\x126\n\x07webInfo\x18\x06\
    \x20\x01(\x0b2\x1c.proto.ClientPayload.WebInfoR\x07webInfo\x12\x1a\n\x08\
    pushName\x18\x07\x20\x01(\tR\x08pushName\x12\x1c\n\tsessionId\x18\t\x20\
    \x01(\x0fR\tsessionId\x12\"\n\x0cshortConnect\x18\n\x20\x01(\x08R\x0csho\
    rtConnect\x12B\n\x0bconnectType\x18\x0c\x20\x01(\x0e2\x20.proto.ClientPa\
    yload.ConnectTypeR\x0bconnectType\x12H\n\rconnectReason\x18\r\x20\x01(\
    \x0e2\".proto.ClientPayload.ConnectReasonR\rconnectReason\x12\x16\n\x06s\
    hards\x18\x0e\x20\x03(\x05R\x06shards\x12<\n\tdnsSource\x18\x0f\x20\x01(\
    \x0b2\x1e.proto.ClientPayload.DNSSourceR\tdnsSource\x120\n\x13connectAtt\
    emptCount\x18\x10\x20\x01(\rR\x13connectAttemptCount\x12\x16\n\x06device\
    \x18\x12\x20\x01(\rR\x06device\x12`\n\x11devicePairingData\x18\x13\x20\
    \x01(\x0b22.proto.ClientPayload.DevicePairingRegistrationDataR\x11device\
    PairingData\x126\n\x07product\x18\x14\x20\x01(\x0e2\x1c.proto.ClientPayl\
    oad.ProductR\x07product\x12\x14\n\x05fbCat\x18\x15\x20\x01(\x0cR\x05fbCa\
    t\x12\x20\n\x0bfbUserAgent\x18\x16\x20\x01(\x0cR\x0bfbUserAgent\x12\x0e\
    \n\x02oc\x18\x17\x20\x01(\x08R\x02oc\x12\x0e\n\x02lc\x18\x18\x20\x01(\
    \x05R\x02lc\x12N\n\x0fiosAppExtension\x18\x1e\x20\x01(\x0e2$.proto.Clien\
    tPayload.IOSAppExtensionR\x0fiosAppExtension\x12\x18\n\x07fbAppId\x18\
    \x1f\x20\x01(\x04R\x07fbAppId\x12\x1e\n\nfbDeviceId\x18\x20\x20\x01(\x0c\
    R\nfbDeviceId\x12\x12\n\x04pull\x18!\x20\x01(\x08R\x04pull\x12\"\n\x0cpa\
    ddingBytes\x18\"\x20\x01(\x0cR\x0cpaddingBytes\x12\x1c\n\tyearClass\x18$\
    \x20\x01(\x05R\tyearClass\x12\x1a\n\x08memClass\x18%\x20\x01(\x05R\x08me\
    mClass\x1a\xcc\x06\n\x07WebInfo\x12\x1a\n\x08refToken\x18\x01\x20\x01(\t\
    R\x08refToken\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\x12J\n\
    \x0bwebdPayload\x18\x03\x20\x01(\x0b2(.proto.ClientPayload.WebInfo.WebdP\
    ayloadR\x0bwebdPayload\x12S\n\x0ewebSubPlatform\x18\x04\x20\x01(\x0e2+.p\
    roto.ClientPayload.WebInfo.WebSubPlatformR\x0ewebSubPlatform\x1a\x91\x04\
    \n\x0bWebdPayload\x122\n\x14usesParticipantInKey\x18\x01\x20\x01(\x08R\
    \x14usesParticipantInKey\x128\n\x17supportsStarredMessages\x18\x02\x20\
    \x01(\x08R\x17supportsStarredMessages\x12:\n\x18supportsDocumentMessages\
    \x18\x03\x20\x01(\x08R\x18supportsDocumentMessages\x120\n\x13supportsUrl\
    Messages\x18\x04\x20\x01(\x08R\x13supportsUrlMessages\x12.\n\x12supports\
    MediaRetry\x18\x05\x20\x01(\x08R\x12supportsMediaRetry\x12*\n\x10support\
    sE2EImage\x18\x06\x20\x01(\x08R\x10supportsE2EImage\x12*\n\x10supportsE2\
    EVideo\x18\x07\x20\x01(\x08R\x10supportsE2EVideo\x12*\n\x10supportsE2EAu\
    dio\x18\x08\x20\x01(\x08R\x10supportsE2EAudio\x120\n\x13supportsE2EDocum\
    ent\x18\t\x20\x01(\x08R\x13supportsE2EDocument\x12$\n\rdocumentTypes\x18\
    \n\x20\x01(\tR\rdocumentTypes\x12\x1a\n\x08features\x18\x0b\x20\x01(\x0c\
    R\x08features\"V\n\x0eWebSubPlatform\x12\x0f\n\x0bWEB_BROWSER\x10\0\x12\
    \r\n\tAPP_STORE\x10\x01\x12\r\n\tWIN_STORE\x10\x02\x12\n\n\x06DARWIN\x10\
    \x03\x12\t\n\x05WIN32\x10\x04\x1a\x8c\n\n\tUserAgent\x12C\n\x08platform\
    \x18\x01\x20\x01(\x0e2'.proto.ClientPayload.UserAgent.PlatformR\x08platf\
    orm\x12I\n\nappVersion\x18\x02\x20\x01(\x0b2).proto.ClientPayload.UserAg\
    ent.AppVersionR\nappVersion\x12\x10\n\x03mcc\x18\x03\x20\x01(\tR\x03mcc\
    \x12\x10\n\x03mnc\x18\x04\x20\x01(\tR\x03mnc\x12\x1c\n\tosVersion\x18\
    \x05\x20\x01(\tR\tosVersion\x12\"\n\x0cmanufacturer\x18\x06\x20\x01(\tR\
    \x0cmanufacturer\x12\x16\n\x06device\x18\x07\x20\x01(\tR\x06device\x12$\
    \n\rosBuildNumber\x18\x08\x20\x01(\tR\rosBuildNumber\x12\x18\n\x07phoneI\
    d\x18\t\x20\x01(\tR\x07phoneId\x12U\n\x0ereleaseChannel\x18\n\x20\x01(\
    \x0e2-.proto.ClientPayload.UserAgent.ReleaseChannelR\x0ereleaseChannel\
    \x124\n\x15localeLanguageIso6391\x18\x0b\x20\x01(\tR\x15localeLanguageIs\
    o6391\x12@\n\x1blocaleCountryIso31661Alpha2\x18\x0c\x20\x01(\tR\x1blocal\
    eCountryIso31661Alpha2\x12\x20\n\x0bdeviceBoard\x18\r\x20\x01(\tR\x0bdev\
    iceBoard\x1a\x9a\x01\n\nAppVersion\x12\x18\n\x07primary\x18\x01\x20\x01(\
    \rR\x07primary\x12\x1c\n\tsecondary\x18\x02\x20\x01(\rR\tsecondary\x12\
    \x1a\n\x08tertiary\x18\x03\x20\x01(\rR\x08tertiary\x12\x1e\n\nquaternary\
    \x18\x04\x20\x01(\rR\nquaternary\x12\x18\n\x07quinary\x18\x05\x20\x01(\r\
    R\x07quinary\"=\n\x0eReleaseChannel\x12\x0b\n\x07RELEASE\x10\0\x12\x08\n\
    \x04BETA\x10\x01\x12\t\n\x05ALPHA\x10\x02\x12\t\n\x05DEBUG\x10\x03\"\xe3\
    \x03\n\x08Platform\x12\x0b\n\x07ANDROID\x10\0\x12\x07\n\x03IOS\x10\x01\
    \x12\x11\n\rWINDOWS_PHONE\x10\x02\x12\x0e\n\nBLACKBERRY\x10\x03\x12\x0f\
    \n\x0bBLACKBERRYX\x10\x04\x12\x07\n\x03S40\x10\x05\x12\x07\n\x03S60\x10\
    \x06\x12\x11\n\rPYTHON_CLIENT\x10\x07\x12\t\n\x05TIZEN\x10\x08\x12\x0e\n\
    \nENTERPRISE\x10\t\x12\x0f\n\x0bSMB_ANDROID\x10\n\x12\t\n\x05KAIOS\x10\
    \x0b\x12\x0b\n\x07SMB_IOS\x10\x0c\x12\x0b\n\x07WINDOWS\x10\r\x12\x07\n\
    \x03WEB\x10\x0e\x12\n\n\x06PORTAL\x10\x0f\x12\x11\n\rGREEN_ANDROID\x10\
    \x10\x12\x10\n\x0cGREEN_IPHONE\x10\x11\x12\x10\n\x0cBLUE_ANDROID\x10\x12\
    \x12\x0f\n\x0bBLUE_IPHONE\x10\x13\x12\x12\n\x0eFBLITE_ANDROID\x10\x14\
    \x12\x11\n\rMLITE_ANDROID\x10\x15\x12\x12\n\x0eIGLITE_ANDROID\x10\x16\
    \x12\x08\n\x04PAGE\x10\x17\x12\t\n\x05MACOS\x10\x18\x12\x0e\n\nOCULUS_MS\
    G\x10\x19\x12\x0f\n\x0bOCULUS_CALL\x10\x1a\x12\t\n\x05MILAN\x10\x1b\x12\
    \x08\n\x04CAPI\x10\x1c\x12\n\n\x06WEAROS\x10\x1d\x12\x0c\n\x08ARDEVICE\
    \x10\x1e\x12\x0c\n\x08VRDEVICE\x10\x1f\x12\x0c\n\x08BLUE_WEB\x10\x20\x1a\
    \xfd\x01\n\x1dDevicePairingRegistrationData\x12\x16\n\x06eRegid\x18\x01\
    \x20\x01(\x0cR\x06eRegid\x12\x1a\n\x08eKeytype\x18\x02\x20\x01(\x0cR\x08\
    eKeytype\x12\x16\n\x06eIdent\x18\x03\x20\x01(\x0cR\x06eIdent\x12\x18\n\
    \x07eSkeyId\x18\x04\x20\x01(\x0cR\x07eSkeyId\x12\x1a\n\x08eSkeyVal\x18\
    \x05\x20\x01(\x0cR\x08eSkeyVal\x12\x1a\n\x08eSkeySig\x18\x06\x20\x01(\
    \x0cR\x08eSkeySig\x12\x1c\n\tbuildHash\x18\x07\x20\x01(\x0cR\tbuildHash\
    \x12\x20\n\x0bdeviceProps\x18\x08\x20\x01(\x0cR\x0bdeviceProps\x1a\xd5\
    \x01\n\tDNSSource\x12P\n\tdnsMethod\x18\x0f\x20\x01(\x0e22.proto.ClientP\
    ayload.DNSSource.DNSResolutionMethodR\tdnsMethod\x12\x1c\n\tappCached\
    \x18\x10\x20\x01(\x08R\tappCached\"X\n\x13DNSResolutionMethod\x12\n\n\
    \x06SYSTEM\x10\0\x12\n\n\x06GOOGLE\x10\x01\x12\r\n\tHARDCODED\x10\x02\
    \x12\x0c\n\x08OVERRIDE\x10\x03\x12\x0c\n\x08FALLBACK\x10\x04\"&\n\x07Pro\
    duct\x12\x0c\n\x08WHATSAPP\x10\0\x12\r\n\tMESSENGER\x10\x01\"T\n\x0fIOSA\
    ppExtension\x12\x13\n\x0fSHARE_EXTENSION\x10\0\x12\x15\n\x11SERVICE_EXTE\
    NSION\x10\x01\x12\x15\n\x11INTENTS_EXTENSION\x10\x02\"\xb0\x02\n\x0bConn\
    ectType\x12\x14\n\x10CELLULAR_UNKNOWN\x10\0\x12\x10\n\x0cWIFI_UNKNOWN\
    \x10\x01\x12\x11\n\rCELLULAR_EDGE\x10d\x12\x11\n\rCELLULAR_IDEN\x10e\x12\
    \x11\n\rCELLULAR_UMTS\x10f\x12\x11\n\rCELLULAR_EVDO\x10g\x12\x11\n\rCELL\
    ULAR_GPRS\x10h\x12\x12\n\x0eCELLULAR_HSDPA\x10i\x12\x12\n\x0eCELLULAR_HS\
    UPA\x10j\x12\x11\n\rCELLULAR_HSPA\x10k\x12\x11\n\rCELLULAR_CDMA\x10l\x12\
    \x12\n\x0eCELLULAR_1XRTT\x10m\x12\x12\n\x0eCELLULAR_EHRPD\x10n\x12\x10\n\
    \x0cCELLULAR_LTE\x10o\x12\x12\n\x0eCELLULAR_HSPAP\x10p\"y\n\rConnectReas\
    on\x12\x08\n\x04PUSH\x10\0\x12\x12\n\x0eUSER_ACTIVATED\x10\x01\x12\r\n\t\
    SCHEDULED\x10\x02\x12\x13\n\x0fERROR_RECONNECT\x10\x03\x12\x12\n\x0eNETW\
    ORK_SWITCH\x10\x04\x12\x12\n\x0ePING_RECONNECT\x10\x05\"\xc5\x01\n\x14We\
    bNotificationsInfo\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x04R\ttimestamp\
    \x12\x20\n\x0bunreadChats\x18\x03\x20\x01(\rR\x0bunreadChats\x12.\n\x12n\
    otifyMessageCount\x18\x04\x20\x01(\rR\x12notifyMessageCount\x12=\n\x0eno\
    tifyMessages\x18\x05\x20\x03(\x0b2\x15.proto.WebMessageInfoR\x0enotifyMe\
    ssages\"\xba<\n\x0eWebMessageInfo\x12#\n\x03key\x18\x01\x20\x02(\x0b2\
    \x11.proto.MessageKeyR\x03key\x12(\n\x07message\x18\x02\x20\x01(\x0b2\
    \x0e.proto.MessageR\x07message\x12*\n\x10messageTimestamp\x18\x03\x20\
    \x01(\x04R\x10messageTimestamp\x124\n\x06status\x18\x04\x20\x01(\x0e2\
    \x1c.proto.WebMessageInfo.StatusR\x06status\x12\x20\n\x0bparticipant\x18\
    \x05\x20\x01(\tR\x0bparticipant\x120\n\x13messageC2STimestamp\x18\x06\
    \x20\x01(\x04R\x13messageC2STimestamp\x12\x16\n\x06ignore\x18\x10\x20\
    \x01(\x08R\x06ignore\x12\x18\n\x07starred\x18\x11\x20\x01(\x08R\x07starr\
    ed\x12\x1c\n\tbroadcast\x18\x12\x20\x01(\x08R\tbroadcast\x12\x1a\n\x08pu\
    shName\x18\x13\x20\x01(\tR\x08pushName\x124\n\x15mediaCiphertextSha256\
    \x18\x14\x20\x01(\x0cR\x15mediaCiphertextSha256\x12\x1c\n\tmulticast\x18\
    \x15\x20\x01(\x08R\tmulticast\x12\x18\n\x07urlText\x18\x16\x20\x01(\x08R\
    \x07urlText\x12\x1c\n\turlNumber\x18\x17\x20\x01(\x08R\turlNumber\x12H\n\
    \x0fmessageStubType\x18\x18\x20\x01(\x0e2\x1e.proto.WebMessageInfo.StubT\
    ypeR\x0fmessageStubType\x12\x1e\n\nclearMedia\x18\x19\x20\x01(\x08R\ncle\
    arMedia\x124\n\x15messageStubParameters\x18\x1a\x20\x03(\tR\x15messageSt\
    ubParameters\x12\x1a\n\x08duration\x18\x1b\x20\x01(\rR\x08duration\x12\
    \x16\n\x06labels\x18\x1c\x20\x03(\tR\x06labels\x124\n\x0bpaymentInfo\x18\
    \x1d\x20\x01(\x0b2\x12.proto.PaymentInfoR\x0bpaymentInfo\x12H\n\x11final\
    LiveLocation\x18\x1e\x20\x01(\x0b2\x1a.proto.LiveLocationMessageR\x11fin\
    alLiveLocation\x12@\n\x11quotedPaymentInfo\x18\x1f\x20\x01(\x0b2\x12.pro\
    to.PaymentInfoR\x11quotedPaymentInfo\x128\n\x17ephemeralStartTimestamp\
    \x18\x20\x20\x01(\x04R\x17ephemeralStartTimestamp\x12,\n\x11ephemeralDur\
    ation\x18!\x20\x01(\rR\x11ephemeralDuration\x12*\n\x10ephemeralOffToOn\
    \x18\"\x20\x01(\x08R\x10ephemeralOffToOn\x12.\n\x12ephemeralOutOfSync\
    \x18#\x20\x01(\x08R\x12ephemeralOutOfSync\x12R\n\x10bizPrivacyStatus\x18\
    $\x20\x01(\x0e2&.proto.WebMessageInfo.BizPrivacyStatusR\x10bizPrivacySta\
    tus\x12(\n\x0fverifiedBizName\x18%\x20\x01(\tR\x0fverifiedBizName\x12.\n\
    \tmediaData\x18&\x20\x01(\x0b2\x10.proto.MediaDataR\tmediaData\x124\n\
    \x0bphotoChange\x18'\x20\x01(\x0b2\x12.proto.PhotoChangeR\x0bphotoChange\
    \x124\n\x0buserReceipt\x18(\x20\x03(\x0b2\x12.proto.UserReceiptR\x0buser\
    Receipt\x12-\n\treactions\x18)\x20\x03(\x0b2\x0f.proto.ReactionR\treacti\
    ons\x12>\n\x11quotedStickerData\x18*\x20\x01(\x0b2\x10.proto.MediaDataR\
    \x11quotedStickerData\x12(\n\x0ffutureproofData\x18+\x20\x01(\x0cR\x0ffu\
    tureproofData\x12.\n\tstatusPsa\x18,\x20\x01(\x0b2\x10.proto.StatusPSAR\
    \tstatusPsa\x123\n\x0bpollUpdates\x18-\x20\x03(\x0b2\x11.proto.PollUpdat\
    eR\x0bpollUpdates\x12U\n\x16pollAdditionalMetadata\x18.\x20\x01(\x0b2\
    \x1d.proto.PollAdditionalMetadataR\x16pollAdditionalMetadata\x12\x18\n\
    \x07agentId\x18/\x20\x01(\tR\x07agentId\x120\n\x13statusAlreadyViewed\
    \x180\x20\x01(\x08R\x13statusAlreadyViewed\x12$\n\rmessageSecret\x181\
    \x20\x01(\x0cR\rmessageSecret\x121\n\nkeepInChat\x182\x20\x01(\x0b2\x11.\
    proto.KeepInChatR\nkeepInChat\x12H\n\x1foriginalSelfAuthorUserJidString\
    \x183\x20\x01(\tR\x1foriginalSelfAuthorUserJidString\x126\n\x16revokeMes\
    sageTimestamp\x184\x20\x01(\x04R\x16revokeMessageTimestamp\"\xa1+\n\x08S\
    tubType\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06REVOKE\x10\x01\x12\x0e\n\n\
    CIPHERTEXT\x10\x02\x12\x0f\n\x0bFUTUREPROOF\x10\x03\x12\x1b\n\x17NON_VER\
    IFIED_TRANSITION\x10\x04\x12\x19\n\x15UNVERIFIED_TRANSITION\x10\x05\x12\
    \x17\n\x13VERIFIED_TRANSITION\x10\x06\x12\x18\n\x14VERIFIED_LOW_UNKNOWN\
    \x10\x07\x12\x11\n\rVERIFIED_HIGH\x10\x08\x12\x1c\n\x18VERIFIED_INITIAL_\
    UNKNOWN\x10\t\x12\x18\n\x14VERIFIED_INITIAL_LOW\x10\n\x12\x19\n\x15VERIF\
    IED_INITIAL_HIGH\x10\x0b\x12#\n\x1fVERIFIED_TRANSITION_ANY_TO_NONE\x10\
    \x0c\x12#\n\x1fVERIFIED_TRANSITION_ANY_TO_HIGH\x10\r\x12#\n\x1fVERIFIED_\
    TRANSITION_HIGH_TO_LOW\x10\x0e\x12'\n#VERIFIED_TRANSITION_HIGH_TO_UNKNOW\
    N\x10\x0f\x12&\n\"VERIFIED_TRANSITION_UNKNOWN_TO_LOW\x10\x10\x12&\n\"VER\
    IFIED_TRANSITION_LOW_TO_UNKNOWN\x10\x11\x12#\n\x1fVERIFIED_TRANSITION_NO\
    NE_TO_LOW\x10\x12\x12'\n#VERIFIED_TRANSITION_NONE_TO_UNKNOWN\x10\x13\x12\
    \x10\n\x0cGROUP_CREATE\x10\x14\x12\x18\n\x14GROUP_CHANGE_SUBJECT\x10\x15\
    \x12\x15\n\x11GROUP_CHANGE_ICON\x10\x16\x12\x1c\n\x18GROUP_CHANGE_INVITE\
    _LINK\x10\x17\x12\x1c\n\x18GROUP_CHANGE_DESCRIPTION\x10\x18\x12\x19\n\
    \x15GROUP_CHANGE_RESTRICT\x10\x19\x12\x19\n\x15GROUP_CHANGE_ANNOUNCE\x10\
    \x1a\x12\x19\n\x15GROUP_PARTICIPANT_ADD\x10\x1b\x12\x1c\n\x18GROUP_PARTI\
    CIPANT_REMOVE\x10\x1c\x12\x1d\n\x19GROUP_PARTICIPANT_PROMOTE\x10\x1d\x12\
    \x1c\n\x18GROUP_PARTICIPANT_DEMOTE\x10\x1e\x12\x1c\n\x18GROUP_PARTICIPAN\
    T_INVITE\x10\x1f\x12\x1b\n\x17GROUP_PARTICIPANT_LEAVE\x10\x20\x12#\n\x1f\
    GROUP_PARTICIPANT_CHANGE_NUMBER\x10!\x12\x14\n\x10BROADCAST_CREATE\x10\"\
    \x12\x11\n\rBROADCAST_ADD\x10#\x12\x14\n\x10BROADCAST_REMOVE\x10$\x12\
    \x18\n\x14GENERIC_NOTIFICATION\x10%\x12\x18\n\x14E2E_IDENTITY_CHANGED\
    \x10&\x12\x11\n\rE2E_ENCRYPTED\x10'\x12\x15\n\x11CALL_MISSED_VOICE\x10(\
    \x12\x15\n\x11CALL_MISSED_VIDEO\x10)\x12\x1c\n\x18INDIVIDUAL_CHANGE_NUMB\
    ER\x10*\x12\x10\n\x0cGROUP_DELETE\x10+\x12&\n\"GROUP_ANNOUNCE_MODE_MESSA\
    GE_BOUNCE\x10,\x12\x1b\n\x17CALL_MISSED_GROUP_VOICE\x10-\x12\x1b\n\x17CA\
    LL_MISSED_GROUP_VIDEO\x10.\x12\x16\n\x12PAYMENT_CIPHERTEXT\x10/\x12\x17\
    \n\x13PAYMENT_FUTUREPROOF\x100\x12,\n(PAYMENT_TRANSACTION_STATUS_UPDATE_\
    FAILED\x101\x12.\n*PAYMENT_TRANSACTION_STATUS_UPDATE_REFUNDED\x102\x123\
    \n/PAYMENT_TRANSACTION_STATUS_UPDATE_REFUND_FAILED\x103\x125\n1PAYMENT_T\
    RANSACTION_STATUS_RECEIVER_PENDING_SETUP\x104\x12<\n8PAYMENT_TRANSACTION\
    _STATUS_RECEIVER_SUCCESS_AFTER_HICCUP\x105\x12)\n%PAYMENT_ACTION_ACCOUNT\
    _SETUP_REMINDER\x106\x12(\n$PAYMENT_ACTION_SEND_PAYMENT_REMINDER\x107\
    \x12*\n&PAYMENT_ACTION_SEND_PAYMENT_INVITATION\x108\x12#\n\x1fPAYMENT_AC\
    TION_REQUEST_DECLINED\x109\x12\"\n\x1ePAYMENT_ACTION_REQUEST_EXPIRED\x10\
    :\x12$\n\x20PAYMENT_ACTION_REQUEST_CANCELLED\x10;\x12)\n%BIZ_VERIFIED_TR\
    ANSITION_TOP_TO_BOTTOM\x10<\x12)\n%BIZ_VERIFIED_TRANSITION_BOTTOM_TO_TOP\
    \x10=\x12\x11\n\rBIZ_INTRO_TOP\x10>\x12\x14\n\x10BIZ_INTRO_BOTTOM\x10?\
    \x12\x13\n\x0fBIZ_NAME_CHANGE\x10@\x12\x1c\n\x18BIZ_MOVE_TO_CONSUMER_APP\
    \x10A\x12\x1e\n\x1aBIZ_TWO_TIER_MIGRATION_TOP\x10B\x12!\n\x1dBIZ_TWO_TIE\
    R_MIGRATION_BOTTOM\x10C\x12\r\n\tOVERSIZED\x10D\x12(\n$GROUP_CHANGE_NO_F\
    REQUENTLY_FORWARDED\x10E\x12\x1c\n\x18GROUP_V4_ADD_INVITE_SENT\x10F\x12&\
    \n\"GROUP_PARTICIPANT_ADD_REQUEST_JOIN\x10G\x12\x1c\n\x18CHANGE_EPHEMERA\
    L_SETTING\x10H\x12\x16\n\x12E2E_DEVICE_CHANGED\x10I\x12\x0f\n\x0bVIEWED_\
    ONCE\x10J\x12\x15\n\x11E2E_ENCRYPTED_NOW\x10K\x12\"\n\x1eBLUE_MSG_BSP_FB\
    _TO_BSP_PREMISE\x10L\x12\x1e\n\x1aBLUE_MSG_BSP_FB_TO_SELF_FB\x10M\x12#\n\
    \x1fBLUE_MSG_BSP_FB_TO_SELF_PREMISE\x10N\x12\x1e\n\x1aBLUE_MSG_BSP_FB_UN\
    VERIFIED\x10O\x127\n3BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_PREMISE_VERIFIED\
    \x10P\x12\x1c\n\x18BLUE_MSG_BSP_FB_VERIFIED\x10Q\x127\n3BLUE_MSG_BSP_FB_\
    VERIFIED_TO_SELF_PREMISE_UNVERIFIED\x10R\x12(\n$BLUE_MSG_BSP_PREMISE_TO_\
    SELF_PREMISE\x10S\x12#\n\x1fBLUE_MSG_BSP_PREMISE_UNVERIFIED\x10T\x12<\n8\
    BLUE_MSG_BSP_PREMISE_UNVERIFIED_TO_SELF_PREMISE_VERIFIED\x10U\x12!\n\x1d\
    BLUE_MSG_BSP_PREMISE_VERIFIED\x10V\x12<\n8BLUE_MSG_BSP_PREMISE_VERIFIED_\
    TO_SELF_PREMISE_UNVERIFIED\x10W\x12*\n&BLUE_MSG_CONSUMER_TO_BSP_FB_UNVER\
    IFIED\x10X\x12/\n+BLUE_MSG_CONSUMER_TO_BSP_PREMISE_UNVERIFIED\x10Y\x12+\
    \n'BLUE_MSG_CONSUMER_TO_SELF_FB_UNVERIFIED\x10Z\x120\n,BLUE_MSG_CONSUMER\
    _TO_SELF_PREMISE_UNVERIFIED\x10[\x12#\n\x1fBLUE_MSG_SELF_FB_TO_BSP_PREMI\
    SE\x10\\\x12$\n\x20BLUE_MSG_SELF_FB_TO_SELF_PREMISE\x10]\x12\x1f\n\x1bBL\
    UE_MSG_SELF_FB_UNVERIFIED\x10^\x128\n4BLUE_MSG_SELF_FB_UNVERIFIED_TO_SEL\
    F_PREMISE_VERIFIED\x10_\x12\x1d\n\x19BLUE_MSG_SELF_FB_VERIFIED\x10`\x128\
    \n4BLUE_MSG_SELF_FB_VERIFIED_TO_SELF_PREMISE_UNVERIFIED\x10a\x12(\n$BLUE\
    _MSG_SELF_PREMISE_TO_BSP_PREMISE\x10b\x12$\n\x20BLUE_MSG_SELF_PREMISE_UN\
    VERIFIED\x10c\x12\"\n\x1eBLUE_MSG_SELF_PREMISE_VERIFIED\x10d\x12\x16\n\
    \x12BLUE_MSG_TO_BSP_FB\x10e\x12\x18\n\x14BLUE_MSG_TO_CONSUMER\x10f\x12\
    \x17\n\x13BLUE_MSG_TO_SELF_FB\x10g\x12*\n&BLUE_MSG_UNVERIFIED_TO_BSP_FB_\
    VERIFIED\x10h\x12/\n+BLUE_MSG_UNVERIFIED_TO_BSP_PREMISE_VERIFIED\x10i\
    \x12+\n'BLUE_MSG_UNVERIFIED_TO_SELF_FB_VERIFIED\x10j\x12#\n\x1fBLUE_MSG_\
    UNVERIFIED_TO_VERIFIED\x10k\x12*\n&BLUE_MSG_VERIFIED_TO_BSP_FB_UNVERIFIE\
    D\x10l\x12/\n+BLUE_MSG_VERIFIED_TO_BSP_PREMISE_UNVERIFIED\x10m\x12+\n'BL\
    UE_MSG_VERIFIED_TO_SELF_FB_UNVERIFIED\x10n\x12#\n\x1fBLUE_MSG_VERIFIED_T\
    O_UNVERIFIED\x10o\x126\n2BLUE_MSG_BSP_FB_UNVERIFIED_TO_BSP_PREMISE_VERIF\
    IED\x10p\x122\n.BLUE_MSG_BSP_FB_UNVERIFIED_TO_SELF_FB_VERIFIED\x10q\x126\
    \n2BLUE_MSG_BSP_FB_VERIFIED_TO_BSP_PREMISE_UNVERIFIED\x10r\x122\n.BLUE_M\
    SG_BSP_FB_VERIFIED_TO_SELF_FB_UNVERIFIED\x10s\x127\n3BLUE_MSG_SELF_FB_UN\
    VERIFIED_TO_BSP_PREMISE_VERIFIED\x10t\x127\n3BLUE_MSG_SELF_FB_VERIFIED_T\
    O_BSP_PREMISE_UNVERIFIED\x10u\x12\x1c\n\x18E2E_IDENTITY_UNAVAILABLE\x10v\
    \x12\x12\n\x0eGROUP_CREATING\x10w\x12\x17\n\x13GROUP_CREATE_FAILED\x10x\
    \x12\x11\n\rGROUP_BOUNCED\x10y\x12\x11\n\rBLOCK_CONTACT\x10z\x12!\n\x1dE\
    PHEMERAL_SETTING_NOT_APPLIED\x10{\x12\x0f\n\x0bSYNC_FAILED\x10|\x12\x0b\
    \n\x07SYNCING\x10}\x12\x1c\n\x18BIZ_PRIVACY_MODE_INIT_FB\x10~\x12\x1d\n\
    \x19BIZ_PRIVACY_MODE_INIT_BSP\x10\x7f\x12\x1b\n\x16BIZ_PRIVACY_MODE_TO_F\
    B\x10\x80\x01\x12\x1c\n\x17BIZ_PRIVACY_MODE_TO_BSP\x10\x81\x01\x12\x16\n\
    \x11DISAPPEARING_MODE\x10\x82\x01\x12\x1c\n\x17E2E_DEVICE_FETCH_FAILED\
    \x10\x83\x01\x12\x11\n\x0cADMIN_REVOKE\x10\x84\x01\x12$\n\x1fGROUP_INVIT\
    E_LINK_GROWTH_LOCKED\x10\x85\x01\x12\x20\n\x1bCOMMUNITY_LINK_PARENT_GROU\
    P\x10\x86\x01\x12!\n\x1cCOMMUNITY_LINK_SIBLING_GROUP\x10\x87\x01\x12\x1d\
    \n\x18COMMUNITY_LINK_SUB_GROUP\x10\x88\x01\x12\"\n\x1dCOMMUNITY_UNLINK_P\
    ARENT_GROUP\x10\x89\x01\x12#\n\x1eCOMMUNITY_UNLINK_SIBLING_GROUP\x10\x8a\
    \x01\x12\x1f\n\x1aCOMMUNITY_UNLINK_SUB_GROUP\x10\x8b\x01\x12\x1d\n\x18GR\
    OUP_PARTICIPANT_ACCEPT\x10\x8c\x01\x12(\n#GROUP_PARTICIPANT_LINKED_GROUP\
    _JOIN\x10\x8d\x01\x12\x15\n\x10COMMUNITY_CREATE\x10\x8e\x01\x12\x1b\n\
    \x16EPHEMERAL_KEEP_IN_CHAT\x10\x8f\x01\x12+\n&GROUP_MEMBERSHIP_JOIN_APPR\
    OVAL_REQUEST\x10\x90\x01\x12(\n#GROUP_MEMBERSHIP_JOIN_APPROVAL_MODE\x10\
    \x91\x01\x12\"\n\x1dINTEGRITY_UNLINK_PARENT_GROUP\x10\x92\x01\x12\"\n\
    \x1dCOMMUNITY_PARTICIPANT_PROMOTE\x10\x93\x01\x12!\n\x1cCOMMUNITY_PARTIC\
    IPANT_DEMOTE\x10\x94\x01\x12#\n\x1eCOMMUNITY_PARENT_GROUP_DELETED\x10\
    \x95\x01\x124\n/COMMUNITY_LINK_PARENT_GROUP_MEMBERSHIP_APPROVAL\x10\x96\
    \x01\x124\n/GROUP_PARTICIPANT_JOINED_GROUP_AND_PARENT_GROUP\x10\x97\x01\
    \x12\x1a\n\x15MASKED_THREAD_CREATED\x10\x98\x01\x12\x1b\n\x16MASKED_THRE\
    AD_UNMASKED\x10\x99\x01\x12\x18\n\x13BIZ_CHAT_ASSIGNMENT\x10\x9a\x01\x12\
    \r\n\x08CHAT_PSA\x10\x9b\x01\x12\x1f\n\x1aCHAT_POLL_CREATION_MESSAGE\x10\
    \x9c\x01\x12\x1e\n\x19CAG_MASKED_THREAD_CREATED\x10\x9d\x01\x12+\n&COMMU\
    NITY_PARENT_GROUP_SUBJECT_CHANGED\x10\x9e\x01\x12\x18\n\x13CAG_INVITE_AU\
    TO_ADD\x10\x9f\x01\x12!\n\x1cBIZ_CHAT_ASSIGNMENT_UNASSIGN\x10\xa0\x01\
    \x12\x1b\n\x16CAG_INVITE_AUTO_JOINED\x10\xa1\x01\"X\n\x06Status\x12\t\n\
    \x05ERROR\x10\0\x12\x0b\n\x07PENDING\x10\x01\x12\x0e\n\nSERVER_ACK\x10\
    \x02\x12\x10\n\x0cDELIVERY_ACK\x10\x03\x12\x08\n\x04READ\x10\x04\x12\n\n\
    \x06PLAYED\x10\x05\"=\n\x10BizPrivacyStatus\x12\x08\n\x04E2EE\x10\0\x12\
    \x06\n\x02FB\x10\x02\x12\x07\n\x03BSP\x10\x01\x12\x0e\n\nBSP_AND_FB\x10\
    \x03\"\x8f\x19\n\x0bWebFeatures\x12=\n\rlabelsDisplay\x18\x01\x20\x01(\
    \x0e2\x17.proto.WebFeatures.FlagR\rlabelsDisplay\x12O\n\x16voipIndividua\
    lOutgoing\x18\x02\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x16voipIndiv\
    idualOutgoing\x123\n\x08groupsV3\x18\x03\x20\x01(\x0e2\x17.proto.WebFeat\
    ures.FlagR\x08groupsV3\x12?\n\x0egroupsV3Create\x18\x04\x20\x01(\x0e2\
    \x17.proto.WebFeatures.FlagR\x0egroupsV3Create\x12?\n\x0echangeNumberV2\
    \x18\x05\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x0echangeNumberV2\x12\
    O\n\x16queryStatusV3Thumbnail\x18\x06\x20\x01(\x0e2\x17.proto.WebFeature\
    s.FlagR\x16queryStatusV3Thumbnail\x12=\n\rliveLocations\x18\x07\x20\x01(\
    \x0e2\x17.proto.WebFeatures.FlagR\rliveLocations\x127\n\nqueryVname\x18\
    \x08\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\nqueryVname\x12O\n\x16voi\
    pIndividualIncoming\x18\t\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x16v\
    oipIndividualIncoming\x12E\n\x11quickRepliesQuery\x18\n\x20\x01(\x0e2\
    \x17.proto.WebFeatures.FlagR\x11quickRepliesQuery\x123\n\x08payments\x18\
    \x0b\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x08payments\x12C\n\x10sti\
    ckerPackQuery\x18\x0c\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x10stick\
    erPackQuery\x12G\n\x12liveLocationsFinal\x18\r\x20\x01(\x0e2\x17.proto.W\
    ebFeatures.FlagR\x12liveLocationsFinal\x127\n\nlabelsEdit\x18\x0e\x20\
    \x01(\x0e2\x17.proto.WebFeatures.FlagR\nlabelsEdit\x129\n\x0bmediaUpload\
    \x18\x0f\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x0bmediaUpload\x12Y\n\
    \x1bmediaUploadRichQuickReplies\x18\x12\x20\x01(\x0e2\x17.proto.WebFeatu\
    res.FlagR\x1bmediaUploadRichQuickReplies\x121\n\x07vnameV2\x18\x13\x20\
    \x01(\x0e2\x17.proto.WebFeatures.FlagR\x07vnameV2\x12C\n\x10videoPlaybac\
    kUrl\x18\x14\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x10videoPlaybackU\
    rl\x12=\n\rstatusRanking\x18\x15\x20\x01(\x0e2\x17.proto.WebFeatures.Fla\
    gR\rstatusRanking\x12I\n\x13voipIndividualVideo\x18\x16\x20\x01(\x0e2\
    \x17.proto.WebFeatures.FlagR\x13voipIndividualVideo\x12G\n\x12thirdParty\
    Stickers\x18\x17\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x12thirdParty\
    Stickers\x12W\n\x1afrequentlyForwardedSetting\x18\x18\x20\x01(\x0e2\x17.\
    proto.WebFeatures.FlagR\x1afrequentlyForwardedSetting\x12O\n\x16groupsV4\
    JoinPermission\x18\x19\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x16grou\
    psV4JoinPermission\x12?\n\x0erecentStickers\x18\x1a\x20\x01(\x0e2\x17.pr\
    oto.WebFeatures.FlagR\x0erecentStickers\x121\n\x07catalog\x18\x1b\x20\
    \x01(\x0e2\x17.proto.WebFeatures.FlagR\x07catalog\x12A\n\x0fstarredStick\
    ers\x18\x1c\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x0fstarredStickers\
    \x12=\n\rvoipGroupCall\x18\x1d\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\
    \rvoipGroupCall\x12A\n\x0ftemplateMessage\x18\x1e\x20\x01(\x0e2\x17.prot\
    o.WebFeatures.FlagR\x0ftemplateMessage\x12[\n\x1ctemplateMessageInteract\
    ivity\x18\x1f\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x1ctemplateMessa\
    geInteractivity\x12E\n\x11ephemeralMessages\x18\x20\x20\x01(\x0e2\x17.pr\
    oto.WebFeatures.FlagR\x11ephemeralMessages\x12I\n\x13e2ENotificationSync\
    \x18!\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x13e2ENotificationSync\
    \x12C\n\x10recentStickersV2\x18\"\x20\x01(\x0e2\x17.proto.WebFeatures.Fl\
    agR\x10recentStickersV2\x12C\n\x10recentStickersV3\x18$\x20\x01(\x0e2\
    \x17.proto.WebFeatures.FlagR\x10recentStickersV3\x127\n\nuserNotice\x18%\
    \x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\nuserNotice\x121\n\x07support\
    \x18'\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x07support\x12A\n\x0fgro\
    upUiiCleanup\x18(\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x0fgroupUiiC\
    leanup\x12Y\n\x1bgroupDogfoodingInternalOnly\x18)\x20\x01(\x0e2\x17.prot\
    o.WebFeatures.FlagR\x1bgroupDogfoodingInternalOnly\x12;\n\x0csettingsSyn\
    c\x18*\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x0csettingsSync\x125\n\
    \tarchiveV2\x18+\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\tarchiveV2\
    \x12W\n\x1aephemeralAllowGroupMembers\x18,\x20\x01(\x0e2\x17.proto.WebFe\
    atures.FlagR\x1aephemeralAllowGroupMembers\x12K\n\x14ephemeral24HDuratio\
    n\x18-\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x14ephemeral24HDuration\
    \x12?\n\x0emdForceUpgrade\x18.\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\
    \x0emdForceUpgrade\x12C\n\x10disappearingMode\x18/\x20\x01(\x0e2\x17.pro\
    to.WebFeatures.FlagR\x10disappearingMode\x12S\n\x18externalMdOptInAvaila\
    ble\x180\x20\x01(\x0e2\x17.proto.WebFeatures.FlagR\x18externalMdOptInAva\
    ilable\x12S\n\x18noDeleteMessageTimeLimit\x181\x20\x01(\x0e2\x17.proto.W\
    ebFeatures.FlagR\x18noDeleteMessageTimeLimit\"K\n\x04Flag\x12\x0f\n\x0bN\
    OT_STARTED\x10\0\x12\x11\n\rFORCE_UPGRADE\x10\x01\x12\x0f\n\x0bDEVELOPME\
    NT\x10\x02\x12\x0e\n\nPRODUCTION\x10\x03\"\xff\x01\n\x0bUserReceipt\x12\
    \x18\n\x07userJid\x18\x01\x20\x02(\tR\x07userJid\x12*\n\x10receiptTimest\
    amp\x18\x02\x20\x01(\x03R\x10receiptTimestamp\x12$\n\rreadTimestamp\x18\
    \x03\x20\x01(\x03R\rreadTimestamp\x12(\n\x0fplayedTimestamp\x18\x04\x20\
    \x01(\x03R\x0fplayedTimestamp\x12*\n\x10pendingDeviceJid\x18\x05\x20\x03\
    (\tR\x10pendingDeviceJid\x12.\n\x12deliveredDeviceJid\x18\x06\x20\x03(\t\
    R\x12deliveredDeviceJid\"m\n\tStatusPSA\x12\x1e\n\ncampaignId\x18,\x20\
    \x02(\x04R\ncampaignId\x12@\n\x1bcampaignExpirationTimestamp\x18-\x20\
    \x01(\x04R\x1bcampaignExpirationTimestamp\"\xab\x01\n\x08Reaction\x12#\n\
    \x03key\x18\x01\x20\x01(\x0b2\x11.proto.MessageKeyR\x03key\x12\x12\n\x04\
    text\x18\x02\x20\x01(\tR\x04text\x12\x20\n\x0bgroupingKey\x18\x03\x20\
    \x01(\tR\x0bgroupingKey\x12,\n\x11senderTimestampMs\x18\x04\x20\x01(\x03\
    R\x11senderTimestampMs\x12\x16\n\x06unread\x18\x05\x20\x01(\x08R\x06unre\
    ad\"\xf3\x01\n\nPollUpdate\x12E\n\x14pollUpdateMessageKey\x18\x01\x20\
    \x01(\x0b2\x11.proto.MessageKeyR\x14pollUpdateMessageKey\x12*\n\x04vote\
    \x18\x02\x20\x01(\x0b2\x16.proto.PollVoteMessageR\x04vote\x12,\n\x11send\
    erTimestampMs\x18\x03\x20\x01(\x03R\x11senderTimestampMs\x12,\n\x11serve\
    rTimestampMs\x18\x04\x20\x01(\x03R\x11serverTimestampMs\x12\x16\n\x06unr\
    ead\x18\x05\x20\x01(\x08R\x06unread\"B\n\x16PollAdditionalMetadata\x12(\
    \n\x0fpollInvalidated\x18\x01\x20\x01(\x08R\x0fpollInvalidated\"e\n\x0bP\
    hotoChange\x12\x1a\n\x08oldPhoto\x18\x01\x20\x01(\x0cR\x08oldPhoto\x12\
    \x1a\n\x08newPhoto\x18\x02\x20\x01(\x0cR\x08newPhoto\x12\x1e\n\nnewPhoto\
    Id\x18\x03\x20\x01(\rR\nnewPhotoId\"\x9a\x0c\n\x0bPaymentInfo\x12K\n\x12\
    currencyDeprecated\x18\x01\x20\x01(\x0e2\x1b.proto.PaymentInfo.CurrencyR\
    \x12currencyDeprecated\x12\x1e\n\namount1000\x18\x02\x20\x01(\x04R\namou\
    nt1000\x12\x20\n\x0breceiverJid\x18\x03\x20\x01(\tR\x0breceiverJid\x121\
    \n\x06status\x18\x04\x20\x01(\x0e2\x19.proto.PaymentInfo.StatusR\x06stat\
    us\x122\n\x14transactionTimestamp\x18\x05\x20\x01(\x04R\x14transactionTi\
    mestamp\x12?\n\x11requestMessageKey\x18\x06\x20\x01(\x0b2\x11.proto.Mess\
    ageKeyR\x11requestMessageKey\x12(\n\x0fexpiryTimestamp\x18\x07\x20\x01(\
    \x04R\x0fexpiryTimestamp\x12$\n\rfutureproofed\x18\x08\x20\x01(\x08R\rfu\
    tureproofed\x12\x1a\n\x08currency\x18\t\x20\x01(\tR\x08currency\x12:\n\t\
    txnStatus\x18\n\x20\x01(\x0e2\x1c.proto.PaymentInfo.TxnStatusR\ttxnStatu\
    s\x12,\n\x11useNoviFiatFormat\x18\x0b\x20\x01(\x08R\x11useNoviFiatFormat\
    \x122\n\rprimaryAmount\x18\x0c\x20\x01(\x0b2\x0c.proto.MoneyR\rprimaryAm\
    ount\x124\n\x0eexchangeAmount\x18\r\x20\x01(\x0b2\x0c.proto.MoneyR\x0eex\
    changeAmount\"\x99\x05\n\tTxnStatus\x12\x0b\n\x07UNKNOWN\x10\0\x12\x11\n\
    \rPENDING_SETUP\x10\x01\x12\x1a\n\x16PENDING_RECEIVER_SETUP\x10\x02\x12\
    \x08\n\x04INIT\x10\x03\x12\x0b\n\x07SUCCESS\x10\x04\x12\r\n\tCOMPLETED\
    \x10\x05\x12\n\n\x06FAILED\x10\x06\x12\x0f\n\x0bFAILED_RISK\x10\x07\x12\
    \x15\n\x11FAILED_PROCESSING\x10\x08\x12\x1e\n\x1aFAILED_RECEIVER_PROCESS\
    ING\x10\t\x12\r\n\tFAILED_DA\x10\n\x12\x13\n\x0fFAILED_DA_FINAL\x10\x0b\
    \x12\x10\n\x0cREFUNDED_TXN\x10\x0c\x12\x11\n\rREFUND_FAILED\x10\r\x12\
    \x1c\n\x18REFUND_FAILED_PROCESSING\x10\x0e\x12\x14\n\x10REFUND_FAILED_DA\
    \x10\x0f\x12\x0f\n\x0bEXPIRED_TXN\x10\x10\x12\x11\n\rAUTH_CANCELED\x10\
    \x11\x12!\n\x1dAUTH_CANCEL_FAILED_PROCESSING\x10\x12\x12\x16\n\x12AUTH_C\
    ANCEL_FAILED\x10\x13\x12\x10\n\x0cCOLLECT_INIT\x10\x14\x12\x13\n\x0fCOLL\
    ECT_SUCCESS\x10\x15\x12\x12\n\x0eCOLLECT_FAILED\x10\x16\x12\x17\n\x13COL\
    LECT_FAILED_RISK\x10\x17\x12\x14\n\x10COLLECT_REJECTED\x10\x18\x12\x13\n\
    \x0fCOLLECT_EXPIRED\x10\x19\x12\x14\n\x10COLLECT_CANCELED\x10\x1a\x12\
    \x16\n\x12COLLECT_CANCELLING\x10\x1b\x12\r\n\tIN_REVIEW\x10\x1c\x12\x14\
    \n\x10REVERSAL_SUCCESS\x10\x1d\x12\x14\n\x10REVERSAL_PENDING\x10\x1e\x12\
    \x12\n\x0eREFUND_PENDING\x10\x1f\"\xcc\x01\n\x06Status\x12\x12\n\x0eUNKN\
    OWN_STATUS\x10\0\x12\x0e\n\nPROCESSING\x10\x01\x12\x08\n\x04SENT\x10\x02\
    \x12\x12\n\x0eNEED_TO_ACCEPT\x10\x03\x12\x0c\n\x08COMPLETE\x10\x04\x12\
    \x16\n\x12COULD_NOT_COMPLETE\x10\x05\x12\x0c\n\x08REFUNDED\x10\x06\x12\
    \x0b\n\x07EXPIRED\x10\x07\x12\x0c\n\x08REJECTED\x10\x08\x12\r\n\tCANCELL\
    ED\x10\t\x12\x15\n\x11WAITING_FOR_PAYER\x10\n\x12\x0b\n\x07WAITING\x10\
    \x0b\")\n\x08Currency\x12\x14\n\x10UNKNOWN_CURRENCY\x10\0\x12\x07\n\x03I\
    NR\x10\x01\"\xb6\x01\n\x17NotificationMessageInfo\x12#\n\x03key\x18\x01\
    \x20\x01(\x0b2\x11.proto.MessageKeyR\x03key\x12(\n\x07message\x18\x02\
    \x20\x01(\x0b2\x0e.proto.MessageR\x07message\x12*\n\x10messageTimestamp\
    \x18\x03\x20\x01(\x04R\x10messageTimestamp\x12\x20\n\x0bparticipant\x18\
    \x04\x20\x01(\tR\x0bparticipant\")\n\tMediaData\x12\x1c\n\tlocalPath\x18\
    \x01\x20\x01(\tR\tlocalPath\"\x82\x02\n\nKeepInChat\x12+\n\x08keepType\
    \x18\x01\x20\x01(\x0e2\x0f.proto.KeepTypeR\x08keepType\x12(\n\x0fserverT\
    imestamp\x18\x02\x20\x01(\x03R\x0fserverTimestamp\x12#\n\x03key\x18\x03\
    \x20\x01(\x0b2\x11.proto.MessageKeyR\x03key\x12\x1c\n\tdeviceJid\x18\x04\
    \x20\x01(\tR\tdeviceJid\x12,\n\x11clientTimestampMs\x18\x05\x20\x01(\x03\
    R\x11clientTimestampMs\x12,\n\x11serverTimestampMs\x18\x06\x20\x01(\x03R\
    \x11serverTimestampMs\"\xcb\x01\n\x10NoiseCertificate\x12\x18\n\x07detai\
    ls\x18\x01\x20\x01(\x0cR\x07details\x12\x1c\n\tsignature\x18\x02\x20\x01\
    (\x0cR\tsignature\x1a\x7f\n\x07Details\x12\x16\n\x06serial\x18\x01\x20\
    \x01(\rR\x06serial\x12\x16\n\x06issuer\x18\x02\x20\x01(\tR\x06issuer\x12\
    \x18\n\x07expires\x18\x03\x20\x01(\x04R\x07expires\x12\x18\n\x07subject\
    \x18\x04\x20\x01(\tR\x07subject\x12\x10\n\x03key\x18\x05\x20\x01(\x0cR\
    \x03key\"\xea\x02\n\tCertChain\x125\n\x04leaf\x18\x01\x20\x01(\x0b2!.pro\
    to.CertChain.NoiseCertificateR\x04leaf\x12E\n\x0cintermediate\x18\x02\
    \x20\x01(\x0b2!.proto.CertChain.NoiseCertificateR\x0cintermediate\x1a\
    \xde\x01\n\x10NoiseCertificate\x12\x18\n\x07details\x18\x01\x20\x01(\x0c\
    R\x07details\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\x1a\
    \x91\x01\n\x07Details\x12\x16\n\x06serial\x18\x01\x20\x01(\rR\x06serial\
    \x12\"\n\x0cissuerSerial\x18\x02\x20\x01(\rR\x0cissuerSerial\x12\x10\n\
    \x03key\x18\x03\x20\x01(\x0cR\x03key\x12\x1c\n\tnotBefore\x18\x04\x20\
    \x01(\x04R\tnotBefore\x12\x1a\n\x08notAfter\x18\x05\x20\x01(\x04R\x08not\
    After*@\n\x08KeepType\x12\x0b\n\x07UNKNOWN\x10\0\x12\x10\n\x0cKEEP_FOR_A\
    LL\x10\x01\x12\x15\n\x11UNDO_KEEP_FOR_ALL\x10\x02*p\n\x1cPeerDataOperati\
    onRequestType\x12\x12\n\x0eUPLOAD_STICKER\x10\0\x12!\n\x1dSEND_RECENT_ST\
    ICKER_BOOTSTRAP\x10\x01\x12\x19\n\x15GENERATE_LINK_PREVIEW\x10\x02*/\n\
    \x0fMediaVisibility\x12\x0b\n\x07DEFAULT\x10\0\x12\x07\n\x03OFF\x10\x01\
    \x12\x06\n\x02ON\x10\x02J\xe3\xbb\x07\n\x07\x12\x05\0\0\x86\x13\x01\n\
    \x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x0e\n\n\n\
    \x02\x04\0\x12\x04\x03\0\x06\x01\n\n\n\x03\x04\0\x01\x12\x03\x03\x08\x1d\
    \n\x0b\n\x04\x04\0\x02\0\x12\x03\x04\x04\x1f\n\x0c\n\x05\x04\0\x02\0\x04\
    \x12\x03\x04\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x04\r\x12\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03\x04\x13\x1a\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x04\x1d\x1e\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x05\x04(\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x03\x05\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x05\
    \x12\x03\x05\r\x12\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x05\x13#\n\x0c\
    \n\x05\x04\0\x02\x01\x03\x12\x03\x05&'\n\n\n\x02\x04\x01\x12\x04\x08\0\r\
    \x01\n\n\n\x03\x04\x01\x01\x12\x03\x08\x08\x1f\n\x0b\n\x04\x04\x01\x02\0\
    \x12\x03\t\x04\x1f\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\t\x04\x0c\n\x0c\
    \n\x05\x04\x01\x02\0\x05\x12\x03\t\r\x12\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03\t\x13\x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\t\x1d\x1e\n\x0b\
    \n\x04\x04\x01\x02\x01\x12\x03\n\x04+\n\x0c\n\x05\x04\x01\x02\x01\x04\
    \x12\x03\n\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\n\r\x12\n\x0c\
    \n\x05\x04\x01\x02\x01\x01\x12\x03\n\x13&\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03\n)*\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x0b\x04(\n\x0c\n\
    \x05\x04\x01\x02\x02\x04\x12\x03\x0b\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\
    \x05\x12\x03\x0b\r\x12\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x0b\x13#\
    \n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x0b&'\n\x0b\n\x04\x04\x01\x02\
    \x03\x12\x03\x0c\x04'\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\x0c\x04\
    \x0c\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\x0c\r\x12\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03\x0c\x13\"\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\
    \x03\x0c%&\n\n\n\x02\x04\x02\x12\x04\x0f\0\x12\x01\n\n\n\x03\x04\x02\x01\
    \x12\x03\x0f\x08#\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x10\x04\x1f\n\x0c\n\
    \x05\x04\x02\x02\0\x04\x12\x03\x10\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x03\x10\r\x12\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x10\x13\x1a\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x10\x1d\x1e\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x03\x11\x04\x1c\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03\x11\x04\
    \x0c\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x11\r\x12\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03\x11\x13\x17\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\
    \x03\x11\x1a\x1b\n\n\n\x02\x04\x03\x12\x04\x14\0\x19\x01\n\n\n\x03\x04\
    \x03\x01\x12\x03\x14\x08\x17\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x15\x04\
    \x1e\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03\x15\x04\x0c\n\x0c\n\x05\x04\
    \x03\x02\0\x05\x12\x03\x15\r\x13\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\
    \x15\x14\x19\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x15\x1c\x1d\n\x0b\n\
    \x04\x04\x03\x02\x01\x12\x03\x16\x04\"\n\x0c\n\x05\x04\x03\x02\x01\x04\
    \x12\x03\x16\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03\x16\r\x13\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03\x16\x14\x1d\n\x0c\n\x05\x04\x03\
    \x02\x01\x03\x12\x03\x16\x20!\n\x0b\n\x04\x04\x03\x02\x02\x12\x03\x17\
    \x04%\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03\x17\x04\x0c\n\x0c\n\x05\
    \x04\x03\x02\x02\x05\x12\x03\x17\r\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\
    \x12\x03\x17\x14\x20\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03\x17#$\n\x0b\
    \n\x04\x04\x03\x02\x03\x12\x03\x18\x043\n\x0c\n\x05\x04\x03\x02\x03\x04\
    \x12\x03\x18\x04\x0c\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03\x18\r\x13\n\
    \x0c\n\x05\x04\x03\x02\x03\x01\x12\x03\x18\x14\x20\n\x0c\n\x05\x04\x03\
    \x02\x03\x03\x12\x03\x18#$\n\x0c\n\x05\x04\x03\x02\x03\x08\x12\x03\x18%2\
    \n\r\n\x06\x04\x03\x02\x03\x08\x02\x12\x03\x18&1\n\n\n\x02\x04\x04\x12\
    \x04\x1b\0\x1f\x01\n\n\n\x03\x04\x04\x01\x12\x03\x1b\x08\x19\n\x0b\n\x04\
    \x04\x04\x02\0\x12\x03\x1c\x04\x1e\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03\
    \x1c\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03\x1c\r\x13\n\x0c\n\x05\
    \x04\x04\x02\0\x01\x12\x03\x1c\x14\x19\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03\x1c\x1c\x1d\n\x0b\n\x04\x04\x04\x02\x01\x12\x03\x1d\x04\"\n\x0c\n\
    \x05\x04\x04\x02\x01\x04\x12\x03\x1d\x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\
    \x05\x12\x03\x1d\r\x13\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03\x1d\x14\
    \x1d\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03\x1d\x20!\n\x0b\n\x04\x04\
    \x04\x02\x02\x12\x03\x1e\x04!\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03\
    \x1e\x04\x0c\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03\x1e\r\x13\n\x0c\n\
    \x05\x04\x04\x02\x02\x01\x12\x03\x1e\x14\x1c\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x03\x1e\x1f\x20\n\n\n\x02\x04\x05\x12\x04!\0E\x01\n\n\n\x03\x04\
    \x05\x01\x12\x03!\x08\x13\n\x0c\n\x04\x04\x05\x04\0\x12\x04\"\x041\x05\n\
    \x0c\n\x05\x04\x05\x04\0\x01\x12\x03\"\t\x15\n\r\n\x06\x04\x05\x04\0\x02\
    \0\x12\x03#\x08\x14\n\x0e\n\x07\x04\x05\x04\0\x02\0\x01\x12\x03#\x08\x0f\
    \n\x0e\n\x07\x04\x05\x04\0\x02\0\x02\x12\x03#\x12\x13\n\r\n\x06\x04\x05\
    \x04\0\x02\x01\x12\x03$\x08\x13\n\x0e\n\x07\x04\x05\x04\0\x02\x01\x01\
    \x12\x03$\x08\x0e\n\x0e\n\x07\x04\x05\x04\0\x02\x01\x02\x12\x03$\x11\x12\
    \n\r\n\x06\x04\x05\x04\0\x02\x02\x12\x03%\x08\x14\n\x0e\n\x07\x04\x05\
    \x04\0\x02\x02\x01\x12\x03%\x08\x0f\n\x0e\n\x07\x04\x05\x04\0\x02\x02\
    \x02\x12\x03%\x12\x13\n\r\n\x06\x04\x05\x04\0\x02\x03\x12\x03&\x08\x0f\n\
    \x0e\n\x07\x04\x05\x04\0\x02\x03\x01\x12\x03&\x08\n\n\x0e\n\x07\x04\x05\
    \x04\0\x02\x03\x02\x12\x03&\r\x0e\n\r\n\x06\x04\x05\x04\0\x02\x04\x12\
    \x03'\x08\x12\n\x0e\n\x07\x04\x05\x04\0\x02\x04\x01\x12\x03'\x08\r\n\x0e\
    \n\x07\x04\x05\x04\0\x02\x04\x02\x12\x03'\x10\x11\n\r\n\x06\x04\x05\x04\
    \0\x02\x05\x12\x03(\x08\x13\n\x0e\n\x07\x04\x05\x04\0\x02\x05\x01\x12\
    \x03(\x08\x0e\n\x0e\n\x07\x04\x05\x04\0\x02\x05\x02\x12\x03(\x11\x12\n\r\
    \n\x06\x04\x05\x04\0\x02\x06\x12\x03)\x08\x11\n\x0e\n\x07\x04\x05\x04\0\
    \x02\x06\x01\x12\x03)\x08\x0c\n\x0e\n\x07\x04\x05\x04\0\x02\x06\x02\x12\
    \x03)\x0f\x10\n\r\n\x06\x04\x05\x04\0\x02\x07\x12\x03*\x08\x14\n\x0e\n\
    \x07\x04\x05\x04\0\x02\x07\x01\x12\x03*\x08\x0f\n\x0e\n\x07\x04\x05\x04\
    \0\x02\x07\x02\x12\x03*\x12\x13\n\r\n\x06\x04\x05\x04\0\x02\x08\x12\x03+\
    \x08\x11\n\x0e\n\x07\x04\x05\x04\0\x02\x08\x01\x12\x03+\x08\x0c\n\x0e\n\
    \x07\x04\x05\x04\0\x02\x08\x02\x12\x03+\x0f\x10\n\r\n\x06\x04\x05\x04\0\
    \x02\t\x12\x03,\x08\x1b\n\x0e\n\x07\x04\x05\x04\0\x02\t\x01\x12\x03,\x08\
    \x16\n\x0e\n\x07\x04\x05\x04\0\x02\t\x02\x12\x03,\x19\x1a\n\r\n\x06\x04\
    \x05\x04\0\x02\n\x12\x03-\x08\x13\n\x0e\n\x07\x04\x05\x04\0\x02\n\x01\
    \x12\x03-\x08\r\n\x0e\n\x07\x04\x05\x04\0\x02\n\x02\x12\x03-\x10\x12\n\r\
    \n\x06\x04\x05\x04\0\x02\x0b\x12\x03.\x08\x13\n\x0e\n\x07\x04\x05\x04\0\
    \x02\x0b\x01\x12\x03.\x08\r\n\x0e\n\x07\x04\x05\x04\0\x02\x0b\x02\x12\
    \x03.\x10\x12\n\r\n\x06\x04\x05\x04\0\x02\x0c\x12\x03/\x08\x16\n\x0e\n\
    \x07\x04\x05\x04\0\x02\x0c\x01\x12\x03/\x08\x10\n\x0e\n\x07\x04\x05\x04\
    \0\x02\x0c\x02\x12\x03/\x13\x15\n\r\n\x06\x04\x05\x04\0\x02\r\x12\x030\
    \x08\x14\n\x0e\n\x07\x04\x05\x04\0\x02\r\x01\x12\x030\x08\x0e\n\x0e\n\
    \x07\x04\x05\x04\0\x02\r\x02\x12\x030\x11\x13\n\x0c\n\x04\x04\x05\x03\0\
    \x12\x042\x046\x05\n\x0c\n\x05\x04\x05\x03\0\x01\x12\x032\x0c\x1d\n\r\n\
    \x06\x04\x05\x03\0\x02\0\x12\x033\x08.\n\x0e\n\x07\x04\x05\x03\0\x02\0\
    \x04\x12\x033\x08\x10\n\x0e\n\x07\x04\x05\x03\0\x02\0\x05\x12\x033\x11\
    \x17\n\x0e\n\x07\x04\x05\x03\0\x02\0\x01\x12\x033\x18)\n\x0e\n\x07\x04\
    \x05\x03\0\x02\0\x03\x12\x033,-\n\r\n\x06\x04\x05\x03\0\x02\x01\x12\x034\
    \x080\n\x0e\n\x07\x04\x05\x03\0\x02\x01\x04\x12\x034\x08\x10\n\x0e\n\x07\
    \x04\x05\x03\0\x02\x01\x05\x12\x034\x11\x17\n\x0e\n\x07\x04\x05\x03\0\
    \x02\x01\x01\x12\x034\x18+\n\x0e\n\x07\x04\x05\x03\0\x02\x01\x03\x12\x03\
    4./\n\r\n\x06\x04\x05\x03\0\x02\x02\x12\x035\x08+\n\x0e\n\x07\x04\x05\
    \x03\0\x02\x02\x04\x12\x035\x08\x10\n\x0e\n\x07\x04\x05\x03\0\x02\x02\
    \x05\x12\x035\x11\x17\n\x0e\n\x07\x04\x05\x03\0\x02\x02\x01\x12\x035\x18\
    &\n\x0e\n\x07\x04\x05\x03\0\x02\x02\x03\x12\x035)*\n\x0c\n\x04\x04\x05\
    \x03\x01\x12\x048\x04>\x05\n\x0c\n\x05\x04\x05\x03\x01\x01\x12\x038\x0c\
    \x16\n\r\n\x06\x04\x05\x03\x01\x02\0\x12\x039\x08$\n\x0e\n\x07\x04\x05\
    \x03\x01\x02\0\x04\x12\x039\x08\x10\n\x0e\n\x07\x04\x05\x03\x01\x02\0\
    \x05\x12\x039\x11\x17\n\x0e\n\x07\x04\x05\x03\x01\x02\0\x01\x12\x039\x18\
    \x1f\n\x0e\n\x07\x04\x05\x03\x01\x02\0\x03\x12\x039\"#\n\r\n\x06\x04\x05\
    \x03\x01\x02\x01\x12\x03:\x08&\n\x0e\n\x07\x04\x05\x03\x01\x02\x01\x04\
    \x12\x03:\x08\x10\n\x0e\n\x07\x04\x05\x03\x01\x02\x01\x05\x12\x03:\x11\
    \x17\n\x0e\n\x07\x04\x05\x03\x01\x02\x01\x01\x12\x03:\x18!\n\x0e\n\x07\
    \x04\x05\x03\x01\x02\x01\x03\x12\x03:$%\n\r\n\x06\x04\x05\x03\x01\x02\
    \x02\x12\x03;\x08%\n\x0e\n\x07\x04\x05\x03\x01\x02\x02\x04\x12\x03;\x08\
    \x10\n\x0e\n\x07\x04\x05\x03\x01\x02\x02\x05\x12\x03;\x11\x17\n\x0e\n\
    \x07\x04\x05\x03\x01\x02\x02\x01\x12\x03;\x18\x20\n\x0e\n\x07\x04\x05\
    \x03\x01\x02\x02\x03\x12\x03;#$\n\r\n\x06\x04\x05\x03\x01\x02\x03\x12\
    \x03<\x08'\n\x0e\n\x07\x04\x05\x03\x01\x02\x03\x04\x12\x03<\x08\x10\n\
    \x0e\n\x07\x04\x05\x03\x01\x02\x03\x05\x12\x03<\x11\x17\n\x0e\n\x07\x04\
    \x05\x03\x01\x02\x03\x01\x12\x03<\x18\"\n\x0e\n\x07\x04\x05\x03\x01\x02\
    \x03\x03\x12\x03<%&\n\r\n\x06\x04\x05\x03\x01\x02\x04\x12\x03=\x08$\n\
    \x0e\n\x07\x04\x05\x03\x01\x02\x04\x04\x12\x03=\x08\x10\n\x0e\n\x07\x04\
    \x05\x03\x01\x02\x04\x05\x12\x03=\x11\x17\n\x0e\n\x07\x04\x05\x03\x01\
    \x02\x04\x01\x12\x03=\x18\x1f\n\x0e\n\x07\x04\x05\x03\x01\x02\x04\x03\
    \x12\x03=\"#\n\x0b\n\x04\x04\x05\x02\0\x12\x03@\x04\x1b\n\x0c\n\x05\x04\
    \x05\x02\0\x04\x12\x03@\x04\x0c\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03@\r\
    \x13\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03@\x14\x16\n\x0c\n\x05\x04\x05\
    \x02\0\x03\x12\x03@\x19\x1a\n\x0b\n\x04\x04\x05\x02\x01\x12\x03A\x04$\n\
    \x0c\n\x05\x04\x05\x02\x01\x04\x12\x03A\x04\x0c\n\x0c\n\x05\x04\x05\x02\
    \x01\x06\x12\x03A\r\x17\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03A\x18\x1f\
    \n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03A\"#\n\x0b\n\x04\x04\x05\x02\x02\
    \x12\x03B\x04+\n\x0c\n\x05\x04\x05\x02\x02\x04\x12\x03B\x04\x0c\n\x0c\n\
    \x05\x04\x05\x02\x02\x06\x12\x03B\r\x19\n\x0c\n\x05\x04\x05\x02\x02\x01\
    \x12\x03B\x1a&\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03B)*\n\x0b\n\x04\
    \x04\x05\x02\x03\x12\x03C\x04&\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03C\
    \x04\x0c\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03C\r\x11\n\x0c\n\x05\x04\
    \x05\x02\x03\x01\x12\x03C\x12!\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03C$\
    %\n\x0b\n\x04\x04\x05\x02\x04\x12\x03D\x045\n\x0c\n\x05\x04\x05\x02\x04\
    \x04\x12\x03D\x04\x0c\n\x0c\n\x05\x04\x05\x02\x04\x06\x12\x03D\r\x1e\n\
    \x0c\n\x05\x04\x05\x02\x04\x01\x12\x03D\x1f0\n\x0c\n\x05\x04\x05\x02\x04\
    \x03\x12\x03D34\n\n\n\x02\x04\x06\x12\x04G\0S\x01\n\n\n\x03\x04\x06\x01\
    \x12\x03G\x08'\n\x0c\n\x04\x04\x06\x03\0\x12\x04H\x04J\x05\n\x0c\n\x05\
    \x04\x06\x03\0\x01\x12\x03H\x0c\x1d\n\r\n\x06\x04\x06\x03\0\x02\0\x12\
    \x03I\x08\x20\n\x0e\n\x07\x04\x06\x03\0\x02\0\x04\x12\x03I\x08\x10\n\x0e\
    \n\x07\x04\x06\x03\0\x02\0\x05\x12\x03I\x11\x17\n\x0e\n\x07\x04\x06\x03\
    \0\x02\0\x01\x12\x03I\x18\x1b\n\x0e\n\x07\x04\x06\x03\0\x02\0\x03\x12\
    \x03I\x1e\x1f\n\x0c\n\x04\x04\x06\x03\x01\x12\x04L\x04N\x05\n\x0c\n\x05\
    \x04\x06\x03\x01\x01\x12\x03L\x0c\"\n\r\n\x06\x04\x06\x03\x01\x02\0\x12\
    \x03M\x08'\n\x0e\n\x07\x04\x06\x03\x01\x02\0\x04\x12\x03M\x08\x10\n\x0e\
    \n\x07\x04\x06\x03\x01\x02\0\x05\x12\x03M\x11\x17\n\x0e\n\x07\x04\x06\
    \x03\x01\x02\0\x01\x12\x03M\x18\"\n\x0e\n\x07\x04\x06\x03\x01\x02\0\x03\
    \x12\x03M%&\n\x0b\n\x04\x04\x06\x02\0\x12\x03P\x04K\n\x0c\n\x05\x04\x06\
    \x02\0\x04\x12\x03P\x04\x0c\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03P\r)\n\
    \x0c\n\x05\x04\x06\x02\0\x01\x12\x03P*F\n\x0c\n\x05\x04\x06\x02\0\x03\
    \x12\x03PIJ\n\x0b\n\x04\x04\x06\x02\x01\x12\x03Q\x04?\n\x0c\n\x05\x04\
    \x06\x02\x01\x04\x12\x03Q\x04\x0c\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\
    \x03Q\r#\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03Q$:\n\x0c\n\x05\x04\x06\
    \x02\x01\x03\x12\x03Q=>\n\x0b\n\x04\x04\x06\x02\x02\x12\x03R\x045\n\x0c\
    \n\x05\x04\x06\x02\x02\x04\x12\x03R\x04\x0c\n\x0c\n\x05\x04\x06\x02\x02\
    \x06\x12\x03R\r\x1e\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03R\x1f0\n\x0c\
    \n\x05\x04\x06\x02\x02\x03\x12\x03R34\n\n\n\x02\x04\x07\x12\x04U\0^\x01\
    \n\n\n\x03\x04\x07\x01\x12\x03U\x08\x1c\n\x0c\n\x04\x04\x07\x04\0\x12\
    \x04V\x04[\x05\n\x0c\n\x05\x04\x07\x04\0\x01\x12\x03V\t\x14\n\r\n\x06\
    \x04\x07\x04\0\x02\0\x12\x03W\x08\x14\n\x0e\n\x07\x04\x07\x04\0\x02\0\
    \x01\x12\x03W\x08\x0f\n\x0e\n\x07\x04\x07\x04\0\x02\0\x02\x12\x03W\x12\
    \x13\n\r\n\x06\x04\x07\x04\0\x02\x01\x12\x03X\x08\x12\n\x0e\n\x07\x04\
    \x07\x04\0\x02\x01\x01\x12\x03X\x08\r\n\x0e\n\x07\x04\x07\x04\0\x02\x01\
    \x02\x12\x03X\x10\x11\n\r\n\x06\x04\x07\x04\0\x02\x02\x12\x03Y\x08\x11\n\
    \x0e\n\x07\x04\x07\x04\0\x02\x02\x01\x12\x03Y\x08\x0c\n\x0e\n\x07\x04\
    \x07\x04\0\x02\x02\x02\x12\x03Y\x0f\x10\n\r\n\x06\x04\x07\x04\0\x02\x03\
    \x12\x03Z\x08\x10\n\x0e\n\x07\x04\x07\x04\0\x02\x03\x01\x12\x03Z\x08\x0b\
    \n\x0e\n\x07\x04\x07\x04\0\x02\x03\x02\x12\x03Z\x0e\x0f\n\x0b\n\x04\x04\
    \x07\x02\0\x12\x03\\\x04)\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03\\\x04\
    \x0c\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03\\\r\x18\n\x0c\n\x05\x04\x07\
    \x02\0\x01\x12\x03\\\x19$\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03\\'(\n\
    \x0b\n\x04\x04\x07\x02\x01\x12\x03]\x04'\n\x0c\n\x05\x04\x07\x02\x01\x04\
    \x12\x03]\x04\x0c\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03]\r\x12\n\x0c\n\
    \x05\x04\x07\x02\x01\x01\x12\x03]\x13\"\n\x0c\n\x05\x04\x07\x02\x01\x03\
    \x12\x03]%&\n\n\n\x02\x04\x08\x12\x04`\0s\x01\n\n\n\x03\x04\x08\x01\x12\
    \x03`\x08\x14\n\x0c\n\x04\x04\x08\x04\0\x12\x04a\x04c\x05\n\x0c\n\x05\
    \x04\x08\x04\0\x01\x12\x03a\t\x15\n\r\n\x06\x04\x08\x04\0\x02\0\x12\x03b\
    \x08\x14\n\x0e\n\x07\x04\x08\x04\0\x02\0\x01\x12\x03b\x08\x0f\n\x0e\n\
    \x07\x04\x08\x04\0\x02\0\x02\x12\x03b\x12\x13\n\x0c\n\x04\x04\x08\x04\
    \x01\x12\x04d\x04f\x05\n\x0c\n\x05\x04\x08\x04\x01\x01\x12\x03d\t\x14\n\
    \r\n\x06\x04\x08\x04\x01\x02\0\x12\x03e\x08\x14\n\x0e\n\x07\x04\x08\x04\
    \x01\x02\0\x01\x12\x03e\x08\x0f\n\x0e\n\x07\x04\x08\x04\x01\x02\0\x02\
    \x12\x03e\x12\x13\n\x0b\n\x04\x04\x08\x02\0\x12\x03g\x04\x20\n\x0c\n\x05\
    \x04\x08\x02\0\x04\x12\x03g\x04\x0c\n\x0c\n\x05\x04\x08\x02\0\x05\x12\
    \x03g\r\x13\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03g\x14\x1b\n\x0c\n\x05\
    \x04\x08\x02\0\x03\x12\x03g\x1e\x1f\n\x0b\n\x04\x04\x08\x02\x01\x12\x03h\
    \x04!\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03h\x04\x0c\n\x0c\n\x05\x04\
    \x08\x02\x01\x05\x12\x03h\r\x12\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03h\
    \x13\x1c\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03h\x1f\x20\n\x0b\n\x04\
    \x04\x08\x02\x02\x12\x03i\x04!\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\x03i\
    \x04\x0c\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03i\r\x12\n\x0c\n\x05\x04\
    \x08\x02\x02\x01\x12\x03i\x13\x1c\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\
    \x03i\x1f\x20\n\x0b\n\x04\x04\x08\x02\x03\x12\x03j\x04$\n\x0c\n\x05\x04\
    \x08\x02\x03\x04\x12\x03j\x04\x0c\n\x0c\n\x05\x04\x08\x02\x03\x06\x12\
    \x03j\r\x18\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03j\x19\x1f\n\x0c\n\x05\
    \x04\x08\x02\x03\x03\x12\x03j\"#\n\x0b\n\x04\x04\x08\x02\x04\x12\x03k\
    \x04&\n\x0c\n\x05\x04\x08\x02\x04\x04\x12\x03k\x04\x0c\n\x0c\n\x05\x04\
    \x08\x02\x04\x06\x12\x03k\r\x19\n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03k\
    \x1a!\n\x0c\n\x05\x04\x08\x02\x04\x03\x12\x03k$%\n\x0b\n\x04\x04\x08\x02\
    \x05\x12\x03l\x04\x20\n\x0c\n\x05\x04\x08\x02\x05\x04\x12\x03l\x04\x0c\n\
    \x0c\n\x05\x04\x08\x02\x05\x05\x12\x03l\r\x13\n\x0c\n\x05\x04\x08\x02\
    \x05\x01\x12\x03l\x14\x1b\n\x0c\n\x05\x04\x08\x02\x05\x03\x12\x03l\x1e\
    \x1f\n\x0b\n\x04\x04\x08\x02\x06\x12\x03m\x04#\n\x0c\n\x05\x04\x08\x02\
    \x06\x04\x12\x03m\x04\x0c\n\x0c\n\x05\x04\x08\x02\x06\x05\x12\x03m\r\x13\
    \n\x0c\n\x05\x04\x08\x02\x06\x01\x12\x03m\x14\x1e\n\x0c\n\x05\x04\x08\
    \x02\x06\x03\x12\x03m!\"\n\x0b\n\x04\x04\x08\x02\x07\x12\x03n\x04\"\n\
    \x0c\n\x05\x04\x08\x02\x07\x04\x12\x03n\x04\x0c\n\x0c\n\x05\x04\x08\x02\
    \x07\x05\x12\x03n\r\x13\n\x0c\n\x05\x04\x08\x02\x07\x01\x12\x03n\x14\x1d\
    \n\x0c\n\x05\x04\x08\x02\x07\x03\x12\x03n\x20!\n\x0b\n\x04\x04\x08\x02\
    \x08\x12\x03o\x04\x1e\n\x0c\n\x05\x04\x08\x02\x08\x04\x12\x03o\x04\x0c\n\
    \x0c\n\x05\x04\x08\x02\x08\x05\x12\x03o\r\x13\n\x0c\n\x05\x04\x08\x02\
    \x08\x01\x12\x03o\x14\x19\n\x0c\n\x05\x04\x08\x02\x08\x03\x12\x03o\x1c\
    \x1d\n\x0b\n\x04\x04\x08\x02\t\x12\x03p\x04(\n\x0c\n\x05\x04\x08\x02\t\
    \x04\x12\x03p\x04\x0c\n\x0c\n\x05\x04\x08\x02\t\x05\x12\x03p\r\x12\n\x0c\
    \n\x05\x04\x08\x02\t\x01\x12\x03p\x13\"\n\x0c\n\x05\x04\x08\x02\t\x03\
    \x12\x03p%'\n\x0b\n\x04\x04\x08\x02\n\x12\x03q\x04+\n\x0c\n\x05\x04\x08\
    \x02\n\x04\x12\x03q\x04\x0c\n\x0c\n\x05\x04\x08\x02\n\x05\x12\x03q\r\x13\
    \n\x0c\n\x05\x04\x08\x02\n\x01\x12\x03q\x14%\n\x0c\n\x05\x04\x08\x02\n\
    \x03\x12\x03q(*\n\x0b\n\x04\x04\x08\x02\x0b\x12\x03r\x04*\n\x0c\n\x05\
    \x04\x08\x02\x0b\x04\x12\x03r\x04\x0c\n\x0c\n\x05\x04\x08\x02\x0b\x06\
    \x12\x03r\r\x18\n\x0c\n\x05\x04\x08\x02\x0b\x01\x12\x03r\x19$\n\x0c\n\
    \x05\x04\x08\x02\x0b\x03\x12\x03r')\n\x0b\n\x02\x04\t\x12\x05u\0\x82\x01\
    \x01\n\n\n\x03\x04\t\x01\x12\x03u\x08\x17\n\x0b\n\x04\x04\t\x02\0\x12\
    \x03v\x04(\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03v\x04\x0c\n\x0c\n\x05\x04\
    \t\x02\0\x05\x12\x03v\r\x13\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03v\x14#\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x03v&'\n\x0b\n\x04\x04\t\x02\x01\x12\x03w\
    \x04)\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03w\x04\x0c\n\x0c\n\x05\x04\t\
    \x02\x01\x05\x12\x03w\r\x13\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03w\x14$\
    \n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03w'(\n\x0b\n\x04\x04\t\x02\x02\x12\
    \x03x\x04\x1d\n\x0c\n\x05\x04\t\x02\x02\x04\x12\x03x\x04\x0c\n\x0c\n\x05\
    \x04\t\x02\x02\x05\x12\x03x\r\x13\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03x\
    \x14\x18\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03x\x1b\x1c\n\x0b\n\x04\x04\
    \t\x02\x03\x12\x03y\x04\x20\n\x0c\n\x05\x04\t\x02\x03\x04\x12\x03y\x04\
    \x0c\n\x0c\n\x05\x04\t\x02\x03\x05\x12\x03y\r\x13\n\x0c\n\x05\x04\t\x02\
    \x03\x01\x12\x03y\x14\x1b\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03y\x1e\x1f\
    \n\x0b\n\x04\x04\t\x02\x04\x12\x03z\x04\x1c\n\x0c\n\x05\x04\t\x02\x04\
    \x04\x12\x03z\x04\x0c\n\x0c\n\x05\x04\t\x02\x04\x05\x12\x03z\r\x13\n\x0c\
    \n\x05\x04\t\x02\x04\x01\x12\x03z\x14\x17\n\x0c\n\x05\x04\t\x02\x04\x03\
    \x12\x03z\x1a\x1b\n\x0b\n\x04\x04\t\x02\x05\x12\x03{\x04\x1d\n\x0c\n\x05\
    \x04\t\x02\x05\x04\x12\x03{\x04\x0c\n\x0c\n\x05\x04\t\x02\x05\x05\x12\
    \x03{\r\x11\n\x0c\n\x05\x04\t\x02\x05\x01\x12\x03{\x12\x18\n\x0c\n\x05\
    \x04\t\x02\x05\x03\x12\x03{\x1b\x1c\n\x0b\n\x04\x04\t\x02\x06\x12\x03|\
    \x04)\n\x0c\n\x05\x04\t\x02\x06\x04\x12\x03|\x04\x0c\n\x0c\n\x05\x04\t\
    \x02\x06\x05\x12\x03|\r\x13\n\x0c\n\x05\x04\t\x02\x06\x01\x12\x03|\x14$\
    \n\x0c\n\x05\x04\t\x02\x06\x03\x12\x03|'(\n\x0b\n\x04\x04\t\x02\x07\x12\
    \x03}\x04\"\n\x0c\n\x05\x04\t\x02\x07\x04\x12\x03}\x04\x0c\n\x0c\n\x05\
    \x04\t\x02\x07\x05\x12\x03}\r\x12\n\x0c\n\x05\x04\t\x02\x07\x01\x12\x03}\
    \x13\x1d\n\x0c\n\x05\x04\t\x02\x07\x03\x12\x03}\x20!\n\x0b\n\x04\x04\t\
    \x02\x08\x12\x03~\x04:\n\x0c\n\x05\x04\t\x02\x08\x04\x12\x03~\x04\x0c\n\
    \x0c\n\x05\x04\t\x02\x08\x05\x12\x03~\r\x13\n\x0c\n\x05\x04\t\x02\x08\
    \x01\x12\x03~\x145\n\x0c\n\x05\x04\t\x02\x08\x03\x12\x03~89\n\x0b\n\x04\
    \x04\t\x02\t\x12\x03\x7f\x04!\n\x0c\n\x05\x04\t\x02\t\x04\x12\x03\x7f\
    \x04\x0c\n\x0c\n\x05\x04\t\x02\t\x05\x12\x03\x7f\r\x13\n\x0c\n\x05\x04\t\
    \x02\t\x01\x12\x03\x7f\x14\x1b\n\x0c\n\x05\x04\t\x02\t\x03\x12\x03\x7f\
    \x1e\x20\n\x0c\n\x04\x04\t\x02\n\x12\x04\x80\x01\x04&\n\r\n\x05\x04\t\
    \x02\n\x04\x12\x04\x80\x01\x04\x0c\n\r\n\x05\x04\t\x02\n\x05\x12\x04\x80\
    \x01\r\x12\n\r\n\x05\x04\t\x02\n\x01\x12\x04\x80\x01\x13\x20\n\r\n\x05\
    \x04\t\x02\n\x03\x12\x04\x80\x01#%\n\x0c\n\x04\x04\t\x02\x0b\x12\x04\x81\
    \x01\x04*\n\r\n\x05\x04\t\x02\x0b\x04\x12\x04\x81\x01\x04\x0c\n\r\n\x05\
    \x04\t\x02\x0b\x06\x12\x04\x81\x01\r\x18\n\r\n\x05\x04\t\x02\x0b\x01\x12\
    \x04\x81\x01\x19$\n\r\n\x05\x04\t\x02\x0b\x03\x12\x04\x81\x01')\n\x0c\n\
    \x02\x04\n\x12\x06\x84\x01\0\x8f\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\
    \x84\x01\x08\x1b\n\x0c\n\x04\x04\n\x02\0\x12\x04\x85\x01\x04(\n\r\n\x05\
    \x04\n\x02\0\x04\x12\x04\x85\x01\x04\x0c\n\r\n\x05\x04\n\x02\0\x05\x12\
    \x04\x85\x01\r\x13\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x85\x01\x14#\n\r\n\
    \x05\x04\n\x02\0\x03\x12\x04\x85\x01&'\n\x0c\n\x04\x04\n\x02\x01\x12\x04\
    \x86\x01\x04)\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x86\x01\x04\x0c\n\r\n\
    \x05\x04\n\x02\x01\x05\x12\x04\x86\x01\r\x13\n\r\n\x05\x04\n\x02\x01\x01\
    \x12\x04\x86\x01\x14$\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x86\x01'(\n\
    \x0c\n\x04\x04\n\x02\x02\x12\x04\x87\x01\x04)\n\r\n\x05\x04\n\x02\x02\
    \x04\x12\x04\x87\x01\x04\x0c\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\x87\x01\
    \r\x13\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x87\x01\x14$\n\r\n\x05\x04\n\
    \x02\x02\x03\x12\x04\x87\x01'(\n\x0c\n\x04\x04\n\x02\x03\x12\x04\x88\x01\
    \x04\"\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\x88\x01\x04\x0c\n\r\n\x05\x04\
    \n\x02\x03\x05\x12\x04\x88\x01\r\x12\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\
    \x88\x01\x13\x1d\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\x88\x01\x20!\n\x0c\
    \n\x04\x04\n\x02\x04\x12\x04\x89\x01\x04:\n\r\n\x05\x04\n\x02\x04\x04\
    \x12\x04\x89\x01\x04\x0c\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\x89\x01\r\
    \x13\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\x89\x01\x145\n\r\n\x05\x04\n\
    \x02\x04\x03\x12\x04\x89\x0189\n\x0c\n\x04\x04\n\x02\x05\x12\x04\x8a\x01\
    \x04\x20\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\x8a\x01\x04\x0c\n\r\n\x05\
    \x04\n\x02\x05\x05\x12\x04\x8a\x01\r\x13\n\r\n\x05\x04\n\x02\x05\x01\x12\
    \x04\x8a\x01\x14\x1b\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\x8a\x01\x1e\x1f\
    \n\x0c\n\x04\x04\n\x02\x06\x12\x04\x8b\x01\x04&\n\r\n\x05\x04\n\x02\x06\
    \x04\x12\x04\x8b\x01\x04\x0c\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\x8b\x01\
    \r\x12\n\r\n\x05\x04\n\x02\x06\x01\x12\x04\x8b\x01\x13!\n\r\n\x05\x04\n\
    \x02\x06\x03\x12\x04\x8b\x01$%\n\x0c\n\x04\x04\n\x02\x07\x12\x04\x8c\x01\
    \x04#\n\r\n\x05\x04\n\x02\x07\x04\x12\x04\x8c\x01\x04\x0c\n\r\n\x05\x04\
    \n\x02\x07\x05\x12\x04\x8c\x01\r\x13\n\r\n\x05\x04\n\x02\x07\x01\x12\x04\
    \x8c\x01\x14\x1e\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\x8c\x01!\"\n\x0c\n\
    \x04\x04\n\x02\x08\x12\x04\x8d\x01\x04&\n\r\n\x05\x04\n\x02\x08\x04\x12\
    \x04\x8d\x01\x04\x0c\n\r\n\x05\x04\n\x02\x08\x05\x12\x04\x8d\x01\r\x12\n\
    \r\n\x05\x04\n\x02\x08\x01\x12\x04\x8d\x01\x13\x20\n\r\n\x05\x04\n\x02\
    \x08\x03\x12\x04\x8d\x01#%\n\x0c\n\x04\x04\n\x02\t\x12\x04\x8e\x01\x04*\
    \n\r\n\x05\x04\n\x02\t\x04\x12\x04\x8e\x01\x04\x0c\n\r\n\x05\x04\n\x02\t\
    \x06\x12\x04\x8e\x01\r\x18\n\r\n\x05\x04\n\x02\t\x01\x12\x04\x8e\x01\x19\
    $\n\r\n\x05\x04\n\x02\t\x03\x12\x04\x8e\x01')\n\x0c\n\x02\x04\x0b\x12\
    \x06\x91\x01\0\x9f\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x91\x01\x08\
    \x1b\n\x0e\n\x04\x04\x0b\x03\0\x12\x06\x92\x01\x04\x94\x01\x05\n\r\n\x05\
    \x04\x0b\x03\0\x01\x12\x04\x92\x01\x0c\x1d\n\x0e\n\x06\x04\x0b\x03\0\x02\
    \0\x12\x04\x93\x01\x08*\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x04\x12\x04\x93\
    \x01\x08\x10\n\x0f\n\x07\x04\x0b\x03\0\x02\0\x05\x12\x04\x93\x01\x11\x17\
    \n\x0f\n\x07\x04\x0b\x03\0\x02\0\x01\x12\x04\x93\x01\x18%\n\x0f\n\x07\
    \x04\x0b\x03\0\x02\0\x03\x12\x04\x93\x01()\n\x0e\n\x04\x04\x0b\x04\0\x12\
    \x06\x96\x01\x04\x99\x01\x05\n\r\n\x05\x04\x0b\x04\0\x01\x12\x04\x96\x01\
    \t\x11\n\x0e\n\x06\x04\x0b\x04\0\x02\0\x12\x04\x97\x01\x08\x14\n\x0f\n\
    \x07\x04\x0b\x04\0\x02\0\x01\x12\x04\x97\x01\x08\x0f\n\x0f\n\x07\x04\x0b\
    \x04\0\x02\0\x02\x12\x04\x97\x01\x12\x13\n\x0e\n\x06\x04\x0b\x04\0\x02\
    \x01\x12\x04\x98\x01\x08\x1a\n\x0f\n\x07\x04\x0b\x04\0\x02\x01\x01\x12\
    \x04\x98\x01\x08\x15\n\x0f\n\x07\x04\x0b\x04\0\x02\x01\x02\x12\x04\x98\
    \x01\x18\x19\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x9a\x01\x04\x1e\n\r\n\x05\
    \x04\x0b\x02\0\x04\x12\x04\x9a\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\0\x05\
    \x12\x04\x9a\x01\r\x13\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x9a\x01\x14\
    \x19\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\x9a\x01\x1c\x1d\n\x0c\n\x04\x04\
    \x0b\x02\x01\x12\x04\x9b\x01\x04#\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\
    \x9b\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\x9b\x01\r\x15\n\r\
    \n\x05\x04\x0b\x02\x01\x01\x12\x04\x9b\x01\x16\x1e\n\r\n\x05\x04\x0b\x02\
    \x01\x03\x12\x04\x9b\x01!\"\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\x9c\x01\
    \x045\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\x9c\x01\x04\x0c\n\r\n\x05\
    \x04\x0b\x02\x02\x06\x12\x04\x9c\x01\r\x1e\n\r\n\x05\x04\x0b\x02\x02\x01\
    \x12\x04\x9c\x01\x1f0\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x9c\x0134\n\
    \x0c\n\x04\x04\x0b\x02\x03\x12\x04\x9d\x01\x04)\n\r\n\x05\x04\x0b\x02\
    \x03\x04\x12\x04\x9d\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\x03\x06\x12\x04\
    \x9d\x01\r\x18\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\x9d\x01\x19$\n\r\n\
    \x05\x04\x0b\x02\x03\x03\x12\x04\x9d\x01'(\n\x0c\n\x04\x04\x0b\x02\x04\
    \x12\x04\x9e\x01\x04$\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\x9e\x01\x04\
    \x0c\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\x9e\x01\r\x13\n\r\n\x05\x04\
    \x0b\x02\x04\x01\x12\x04\x9e\x01\x14\x1f\n\r\n\x05\x04\x0b\x02\x04\x03\
    \x12\x04\x9e\x01\"#\n\x0c\n\x02\x04\x0c\x12\x06\xa1\x01\0\xce\x01\x01\n\
    \x0b\n\x03\x04\x0c\x01\x12\x04\xa1\x01\x08\x13\n\x0e\n\x04\x04\x0c\x03\0\
    \x12\x06\xa2\x01\x04\xa5\x01\x05\n\r\n\x05\x04\x0c\x03\0\x01\x12\x04\xa2\
    \x01\x0c\x13\n\x0e\n\x06\x04\x0c\x03\0\x02\0\x12\x04\xa3\x01\x08\"\n\x0f\
    \n\x07\x04\x0c\x03\0\x02\0\x04\x12\x04\xa3\x01\x08\x10\n\x0f\n\x07\x04\
    \x0c\x03\0\x02\0\x05\x12\x04\xa3\x01\x11\x17\n\x0f\n\x07\x04\x0c\x03\0\
    \x02\0\x01\x12\x04\xa3\x01\x18\x1d\n\x0f\n\x07\x04\x0c\x03\0\x02\0\x03\
    \x12\x04\xa3\x01\x20!\n\x0e\n\x06\x04\x0c\x03\0\x02\x01\x12\x04\xa4\x01\
    \x08\x1e\n\x0f\n\x07\x04\x0c\x03\0\x02\x01\x04\x12\x04\xa4\x01\x08\x10\n\
    \x0f\n\x07\x04\x0c\x03\0\x02\x01\x06\x12\x04\xa4\x01\x11\x14\n\x0f\n\x07\
    \x04\x0c\x03\0\x02\x01\x01\x12\x04\xa4\x01\x15\x19\n\x0f\n\x07\x04\x0c\
    \x03\0\x02\x01\x03\x12\x04\xa4\x01\x1c\x1d\n\x0e\n\x04\x04\x0c\x03\x01\
    \x12\x06\xa7\x01\x04\xab\x01\x05\n\r\n\x05\x04\x0c\x03\x01\x01\x12\x04\
    \xa7\x01\x0c\x0f\n\x0e\n\x06\x04\x0c\x03\x01\x02\0\x12\x04\xa8\x01\x08\"\
    \n\x0f\n\x07\x04\x0c\x03\x01\x02\0\x04\x12\x04\xa8\x01\x08\x10\n\x0f\n\
    \x07\x04\x0c\x03\x01\x02\0\x05\x12\x04\xa8\x01\x11\x17\n\x0f\n\x07\x04\
    \x0c\x03\x01\x02\0\x01\x12\x04\xa8\x01\x18\x1d\n\x0f\n\x07\x04\x0c\x03\
    \x01\x02\0\x03\x12\x04\xa8\x01\x20!\n\x0e\n\x06\x04\x0c\x03\x01\x02\x01\
    \x12\x04\xa9\x01\x08(\n\x0f\n\x07\x04\x0c\x03\x01\x02\x01\x04\x12\x04\
    \xa9\x01\x08\x10\n\x0f\n\x07\x04\x0c\x03\x01\x02\x01\x05\x12\x04\xa9\x01\
    \x11\x17\n\x0f\n\x07\x04\x0c\x03\x01\x02\x01\x01\x12\x04\xa9\x01\x18#\n\
    \x0f\n\x07\x04\x0c\x03\x01\x02\x01\x03\x12\x04\xa9\x01&'\n\x0e\n\x06\x04\
    \x0c\x03\x01\x02\x02\x12\x04\xaa\x01\x08\"\n\x0f\n\x07\x04\x0c\x03\x01\
    \x02\x02\x04\x12\x04\xaa\x01\x08\x10\n\x0f\n\x07\x04\x0c\x03\x01\x02\x02\
    \x05\x12\x04\xaa\x01\x11\x17\n\x0f\n\x07\x04\x0c\x03\x01\x02\x02\x01\x12\
    \x04\xaa\x01\x18\x1d\n\x0f\n\x07\x04\x0c\x03\x01\x02\x02\x03\x12\x04\xaa\
    \x01\x20!\n\x0e\n\x04\x04\x0c\x03\x02\x12\x06\xad\x01\x04\xaf\x01\x05\n\
    \r\n\x05\x04\x0c\x03\x02\x01\x12\x04\xad\x01\x0c\x13\n\x0e\n\x06\x04\x0c\
    \x03\x02\x02\0\x12\x04\xae\x01\x08&\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\
    \x04\x12\x04\xae\x01\x08\x10\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x05\x12\
    \x04\xae\x01\x11\x17\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x01\x12\x04\xae\
    \x01\x18!\n\x0f\n\x07\x04\x0c\x03\x02\x02\0\x03\x12\x04\xae\x01$%\n\x0e\
    \n\x04\x04\x0c\x03\x03\x12\x06\xb1\x01\x04\xb4\x01\x05\n\r\n\x05\x04\x0c\
    \x03\x03\x01\x12\x04\xb1\x01\x0c\x1a\n\x0e\n\x06\x04\x0c\x03\x03\x02\0\
    \x12\x04\xb2\x01\x08\"\n\x0f\n\x07\x04\x0c\x03\x03\x02\0\x04\x12\x04\xb2\
    \x01\x08\x10\n\x0f\n\x07\x04\x0c\x03\x03\x02\0\x05\x12\x04\xb2\x01\x11\
    \x17\n\x0f\n\x07\x04\x0c\x03\x03\x02\0\x01\x12\x04\xb2\x01\x18\x1d\n\x0f\
    \n\x07\x04\x0c\x03\x03\x02\0\x03\x12\x04\xb2\x01\x20!\n\x0e\n\x06\x04\
    \x0c\x03\x03\x02\x01\x12\x04\xb3\x01\x08&\n\x0f\n\x07\x04\x0c\x03\x03\
    \x02\x01\x04\x12\x04\xb3\x01\x08\x10\n\x0f\n\x07\x04\x0c\x03\x03\x02\x01\
    \x06\x12\x04\xb3\x01\x11\x18\n\x0f\n\x07\x04\x0c\x03\x03\x02\x01\x01\x12\
    \x04\xb3\x01\x19!\n\x0f\n\x07\x04\x0c\x03\x03\x02\x01\x03\x12\x04\xb3\
    \x01$%\n\x0e\n\x04\x04\x0c\x03\x04\x12\x06\xb6\x01\x04\xba\x01\x05\n\r\n\
    \x05\x04\x0c\x03\x04\x01\x12\x04\xb6\x01\x0c\x1b\n\x0e\n\x06\x04\x0c\x03\
    \x04\x02\0\x12\x04\xb7\x01\x084\n\x0f\n\x07\x04\x0c\x03\x04\x02\0\x04\
    \x12\x04\xb7\x01\x08\x10\n\x0f\n\x07\x04\x0c\x03\x04\x02\0\x06\x12\x04\
    \xb7\x01\x11\x1f\n\x0f\n\x07\x04\x0c\x03\x04\x02\0\x01\x12\x04\xb7\x01\
    \x20/\n\x0f\n\x07\x04\x0c\x03\x04\x02\0\x03\x12\x04\xb7\x0123\n\x0e\n\
    \x06\x04\x0c\x03\x04\x02\x01\x12\x04\xb8\x01\x088\n\x0f\n\x07\x04\x0c\
    \x03\x04\x02\x01\x04\x12\x04\xb8\x01\x08\x10\n\x0f\n\x07\x04\x0c\x03\x04\
    \x02\x01\x06\x12\x04\xb8\x01\x11'\n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\
    \x01\x12\x04\xb8\x01(3\n\x0f\n\x07\x04\x0c\x03\x04\x02\x01\x03\x12\x04\
    \xb8\x0167\n\x0e\n\x06\x04\x0c\x03\x04\x02\x02\x12\x04\xb9\x01\x08-\n\
    \x0f\n\x07\x04\x0c\x03\x04\x02\x02\x04\x12\x04\xb9\x01\x08\x10\n\x0f\n\
    \x07\x04\x0c\x03\x04\x02\x02\x05\x12\x04\xb9\x01\x11\x17\n\x0f\n\x07\x04\
    \x0c\x03\x04\x02\x02\x01\x12\x04\xb9\x01\x18(\n\x0f\n\x07\x04\x0c\x03\
    \x04\x02\x02\x03\x12\x04\xb9\x01+,\n\x0e\n\x04\x04\x0c\x03\x05\x12\x06\
    \xbc\x01\x04\xbf\x01\x05\n\r\n\x05\x04\x0c\x03\x05\x01\x12\x04\xbc\x01\
    \x0c\"\n\x0e\n\x06\x04\x0c\x03\x05\x02\0\x12\x04\xbd\x01\x08&\n\x0f\n\
    \x07\x04\x0c\x03\x05\x02\0\x04\x12\x04\xbd\x01\x08\x10\n\x0f\n\x07\x04\
    \x0c\x03\x05\x02\0\x05\x12\x04\xbd\x01\x11\x17\n\x0f\n\x07\x04\x0c\x03\
    \x05\x02\0\x01\x12\x04\xbd\x01\x18!\n\x0f\n\x07\x04\x0c\x03\x05\x02\0\
    \x03\x12\x04\xbd\x01$%\n\x0e\n\x06\x04\x0c\x03\x05\x02\x01\x12\x04\xbe\
    \x01\x08)\n\x0f\n\x07\x04\x0c\x03\x05\x02\x01\x04\x12\x04\xbe\x01\x08\
    \x10\n\x0f\n\x07\x04\x0c\x03\x05\x02\x01\x05\x12\x04\xbe\x01\x11\x16\n\
    \x0f\n\x07\x04\x0c\x03\x05\x02\x01\x01\x12\x04\xbe\x01\x17$\n\x0f\n\x07\
    \x04\x0c\x03\x05\x02\x01\x03\x12\x04\xbe\x01'(\n\x0e\n\x04\x04\x0c\x04\0\
    \x12\x06\xc1\x01\x04\xc5\x01\x05\n\r\n\x05\x04\x0c\x04\0\x01\x12\x04\xc1\
    \x01\t\x11\n\x0e\n\x06\x04\x0c\x04\0\x02\0\x12\x04\xc2\x01\x08\x14\n\x0f\
    \n\x07\x04\x0c\x04\0\x02\0\x01\x12\x04\xc2\x01\x08\x0f\n\x0f\n\x07\x04\
    \x0c\x04\0\x02\0\x02\x12\x04\xc2\x01\x12\x13\n\x0e\n\x06\x04\x0c\x04\0\
    \x02\x01\x12\x04\xc3\x01\x08\x1a\n\x0f\n\x07\x04\x0c\x04\0\x02\x01\x01\
    \x12\x04\xc3\x01\x08\x15\n\x0f\n\x07\x04\x0c\x04\0\x02\x01\x02\x12\x04\
    \xc3\x01\x18\x19\n\x0e\n\x06\x04\x0c\x04\0\x02\x02\x12\x04\xc4\x01\x08\
    \x19\n\x0f\n\x07\x04\x0c\x04\0\x02\x02\x01\x12\x04\xc4\x01\x08\x14\n\x0f\
    \n\x07\x04\x0c\x04\0\x02\x02\x02\x12\x04\xc4\x01\x17\x18\n\x0c\n\x04\x04\
    \x0c\x02\0\x12\x04\xc6\x01\x04\x1e\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\
    \xc6\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xc6\x01\r\x13\n\r\n\
    \x05\x04\x0c\x02\0\x01\x12\x04\xc6\x01\x14\x19\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\xc6\x01\x1c\x1d\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xc7\x01\
    \x04$\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xc7\x01\x04\x0c\n\r\n\x05\
    \x04\x0c\x02\x01\x05\x12\x04\xc7\x01\r\x13\n\r\n\x05\x04\x0c\x02\x01\x01\
    \x12\x04\xc7\x01\x14\x1f\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xc7\x01\"\
    #\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xc8\x01\x04#\n\r\n\x05\x04\x0c\x02\
    \x02\x04\x12\x04\xc8\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\
    \xc8\x01\r\x13\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xc8\x01\x14\x1e\n\r\
    \n\x05\x04\x0c\x02\x02\x03\x12\x04\xc8\x01!\"\n\x0c\n\x04\x04\x0c\x02\
    \x03\x12\x04\xc9\x01\x04#\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\xc9\x01\
    \x04\x0c\n\r\n\x05\x04\x0c\x02\x03\x06\x12\x04\xc9\x01\r\x15\n\r\n\x05\
    \x04\x0c\x02\x03\x01\x12\x04\xc9\x01\x16\x1e\n\r\n\x05\x04\x0c\x02\x03\
    \x03\x12\x04\xc9\x01!\"\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\xca\x01\x04\
    \"\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\xca\x01\x04\x0c\n\r\n\x05\x04\
    \x0c\x02\x04\x06\x12\x04\xca\x01\r\x14\n\r\n\x05\x04\x0c\x02\x04\x01\x12\
    \x04\xca\x01\x15\x1d\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xca\x01\x20!\
    \n\x0c\n\x04\x04\x0c\x02\x05\x12\x04\xcb\x01\x041\n\r\n\x05\x04\x0c\x02\
    \x05\x04\x12\x04\xcb\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\x05\x06\x12\x04\
    \xcb\x01\r\x1c\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xcb\x01\x1d,\n\r\n\
    \x05\x04\x0c\x02\x05\x03\x12\x04\xcb\x01/0\n\x0c\n\x04\x04\x0c\x02\x06\
    \x12\x04\xcc\x01\x04#\n\r\n\x05\x04\x0c\x02\x06\x04\x12\x04\xcc\x01\x04\
    \x0c\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xcc\x01\r\x13\n\r\n\x05\x04\
    \x0c\x02\x06\x01\x12\x04\xcc\x01\x14\x1e\n\r\n\x05\x04\x0c\x02\x06\x03\
    \x12\x04\xcc\x01!\"\n\x0c\n\x04\x04\x0c\x02\x07\x12\x04\xcd\x01\x04)\n\r\
    \n\x05\x04\x0c\x02\x07\x04\x12\x04\xcd\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\
    \x07\x06\x12\x04\xcd\x01\r\x18\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\xcd\
    \x01\x19$\n\r\n\x05\x04\x0c\x02\x07\x03\x12\x04\xcd\x01'(\n\x0c\n\x02\
    \x04\r\x12\x06\xd0\x01\0\xd4\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xd0\
    \x01\x08\x19\n\x0c\n\x04\x04\r\x02\0\x12\x04\xd1\x01\x04\x20\n\r\n\x05\
    \x04\r\x02\0\x04\x12\x04\xd1\x01\x04\x0c\n\r\n\x05\x04\r\x02\0\x06\x12\
    \x04\xd1\x01\r\x17\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xd1\x01\x18\x1b\n\r\
    \n\x05\x04\r\x02\0\x03\x12\x04\xd1\x01\x1e\x1f\n\x0c\n\x04\x04\r\x02\x01\
    \x12\x04\xd2\x01\x04#\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xd2\x01\x04\
    \x0c\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xd2\x01\r\x15\n\r\n\x05\x04\r\
    \x02\x01\x01\x12\x04\xd2\x01\x16\x1e\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\
    \xd2\x01!\"\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xd3\x01\x04#\n\r\n\x05\x04\
    \r\x02\x02\x04\x12\x04\xd3\x01\x04\x0c\n\r\n\x05\x04\r\x02\x02\x05\x12\
    \x04\xd3\x01\r\x12\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xd3\x01\x13\x1e\n\
    \r\n\x05\x04\r\x02\x02\x03\x12\x04\xd3\x01!\"\n\x0c\n\x02\x04\x0e\x12\
    \x06\xd6\x01\0\xe5\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xd6\x01\x08\
    \x16\n\x0e\n\x04\x04\x0e\x04\0\x12\x06\xd7\x01\x04\xda\x01\x05\n\r\n\x05\
    \x04\x0e\x04\0\x01\x12\x04\xd7\x01\t\x17\n\x0e\n\x06\x04\x0e\x04\0\x02\0\
    \x12\x04\xd8\x01\x08\x12\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\x04\xd8\
    \x01\x08\r\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x02\x12\x04\xd8\x01\x10\x11\n\
    \x0e\n\x06\x04\x0e\x04\0\x02\x01\x12\x04\xd9\x01\x08\x10\n\x0f\n\x07\x04\
    \x0e\x04\0\x02\x01\x01\x12\x04\xd9\x01\x08\x0b\n\x0f\n\x07\x04\x0e\x04\0\
    \x02\x01\x02\x12\x04\xd9\x01\x0e\x0f\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\
    \xdb\x01\x04\x1d\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xdb\x01\x04\x0c\n\r\
    \n\x05\x04\x0e\x02\0\x05\x12\x04\xdb\x01\r\x13\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\xdb\x01\x14\x18\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xdb\x01\
    \x1b\x1c\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xdc\x01\x04\x1e\n\r\n\x05\
    \x04\x0e\x02\x01\x04\x12\x04\xdc\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x01\
    \x05\x12\x04\xdc\x01\r\x13\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xdc\x01\
    \x14\x19\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xdc\x01\x1c\x1d\n\x0c\n\
    \x04\x04\x0e\x02\x02\x12\x04\xdd\x01\x04/\n\r\n\x05\x04\x0e\x02\x02\x04\
    \x12\x04\xdd\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\xdd\x01\r\
    \x1b\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xdd\x01\x1c*\n\r\n\x05\x04\
    \x0e\x02\x02\x03\x12\x04\xdd\x01-.\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\
    \xde\x01\x04+\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xde\x01\x04\x0c\n\r\
    \n\x05\x04\x0e\x02\x03\x05\x12\x04\xde\x01\r\x13\n\r\n\x05\x04\x0e\x02\
    \x03\x01\x12\x04\xde\x01\x14&\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xde\
    \x01)*\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xdf\x01\x04*\n\r\n\x05\x04\
    \x0e\x02\x04\x04\x12\x04\xdf\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x04\x05\
    \x12\x04\xdf\x01\r\x12\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xdf\x01\x13\
    %\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xdf\x01()\n\x0c\n\x04\x04\x0e\
    \x02\x05\x12\x04\xe0\x01\x043\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\xe0\
    \x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xe0\x01\r\x12\n\r\n\
    \x05\x04\x0e\x02\x05\x01\x12\x04\xe0\x01\x13.\n\r\n\x05\x04\x0e\x02\x05\
    \x03\x12\x04\xe0\x0112\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\xe1\x01\x04,\
    \n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\xe1\x01\x04\x0c\n\r\n\x05\x04\x0e\
    \x02\x06\x05\x12\x04\xe1\x01\r\x12\n\r\n\x05\x04\x0e\x02\x06\x01\x12\x04\
    \xe1\x01\x13'\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xe1\x01*+\n\x0c\n\
    \x04\x04\x0e\x02\x07\x12\x04\xe2\x01\x04/\n\r\n\x05\x04\x0e\x02\x07\x04\
    \x12\x04\xe2\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x07\x05\x12\x04\xe2\x01\r\
    \x12\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xe2\x01\x13*\n\r\n\x05\x04\
    \x0e\x02\x07\x03\x12\x04\xe2\x01-.\n\x0c\n\x04\x04\x0e\x02\x08\x12\x04\
    \xe3\x01\x04-\n\r\n\x05\x04\x0e\x02\x08\x04\x12\x04\xe3\x01\x04\x0c\n\r\
    \n\x05\x04\x0e\x02\x08\x05\x12\x04\xe3\x01\r\x13\n\r\n\x05\x04\x0e\x02\
    \x08\x01\x12\x04\xe3\x01\x14(\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\xe3\
    \x01+,\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\xe4\x01\x040\n\r\n\x05\x04\x0e\
    \x02\t\x04\x12\x04\xe4\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\t\x05\x12\x04\
    \xe4\x01\r\x12\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\xe4\x01\x13*\n\r\n\
    \x05\x04\x0e\x02\t\x03\x12\x04\xe4\x01-/\n\x0c\n\x02\x04\x0f\x12\x06\xe7\
    \x01\0\xf7\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xe7\x01\x08\"\n\x0e\n\
    \x04\x04\x0f\x03\0\x12\x06\xe8\x01\x04\xec\x01\x05\n\r\n\x05\x04\x0f\x03\
    \0\x01\x12\x04\xe8\x01\x0c%\n\x0e\n\x06\x04\x0f\x03\0\x02\0\x12\x04\xe9\
    \x01\x08!\n\x0f\n\x07\x04\x0f\x03\0\x02\0\x04\x12\x04\xe9\x01\x08\x10\n\
    \x0f\n\x07\x04\x0f\x03\0\x02\0\x05\x12\x04\xe9\x01\x11\x17\n\x0f\n\x07\
    \x04\x0f\x03\0\x02\0\x01\x12\x04\xe9\x01\x18\x1c\n\x0f\n\x07\x04\x0f\x03\
    \0\x02\0\x03\x12\x04\xe9\x01\x1f\x20\n\x0e\n\x06\x04\x0f\x03\0\x02\x01\
    \x12\x04\xea\x01\x08'\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x04\x12\x04\xea\
    \x01\x08\x10\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x05\x12\x04\xea\x01\x11\
    \x17\n\x0f\n\x07\x04\x0f\x03\0\x02\x01\x01\x12\x04\xea\x01\x18\"\n\x0f\n\
    \x07\x04\x0f\x03\0\x02\x01\x03\x12\x04\xea\x01%&\n\x0e\n\x06\x04\x0f\x03\
    \0\x02\x02\x12\x04\xeb\x01\x08#\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x04\
    \x12\x04\xeb\x01\x08\x10\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x05\x12\x04\
    \xeb\x01\x11\x16\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x01\x12\x04\xeb\x01\
    \x17\x1e\n\x0f\n\x07\x04\x0f\x03\0\x02\x02\x03\x12\x04\xeb\x01!\"\n\x0e\
    \n\x04\x04\x0f\x03\x01\x12\x06\xee\x01\x04\xf0\x01\x05\n\r\n\x05\x04\x0f\
    \x03\x01\x01\x12\x04\xee\x01\x0c\x10\n\x0e\n\x06\x04\x0f\x03\x01\x02\0\
    \x12\x04\xef\x01\x08!\n\x0f\n\x07\x04\x0f\x03\x01\x02\0\x04\x12\x04\xef\
    \x01\x08\x10\n\x0f\n\x07\x04\x0f\x03\x01\x02\0\x05\x12\x04\xef\x01\x11\
    \x17\n\x0f\n\x07\x04\x0f\x03\x01\x02\0\x01\x12\x04\xef\x01\x18\x1c\n\x0f\
    \n\x07\x04\x0f\x03\x01\x02\0\x03\x12\x04\xef\x01\x1f\x20\n\x0c\n\x04\x04\
    \x0f\x02\0\x12\x04\xf2\x01\x04\x1b\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\
    \xf2\x01\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\xf2\x01\r\x11\n\r\n\
    \x05\x04\x0f\x02\0\x01\x12\x04\xf2\x01\x12\x16\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xf2\x01\x19\x1a\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xf3\x01\
    \x04*\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xf3\x01\x04\x0c\n\r\n\x05\
    \x04\x0f\x02\x01\x06\x12\x04\xf3\x01\r\x18\n\r\n\x05\x04\x0f\x02\x01\x01\
    \x12\x04\xf3\x01\x19$\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xf3\x01')\n\
    \x0e\n\x04\x04\x0f\x08\0\x12\x06\xf4\x01\x04\xf6\x01\x05\n\r\n\x05\x04\
    \x0f\x08\0\x01\x12\x04\xf4\x01\n$\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\
    \xf5\x01\x08@\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\xf5\x01\x08!\n\r\n\
    \x05\x04\x0f\x02\x02\x01\x12\x04\xf5\x01\";\n\r\n\x05\x04\x0f\x02\x02\
    \x03\x12\x04\xf5\x01>?\n\x0c\n\x02\x04\x10\x12\x06\xf9\x01\0\xb4\x02\x01\
    \n\x0b\n\x03\x04\x10\x01\x12\x04\xf9\x01\x08\x1a\n\x0e\n\x04\x04\x10\x03\
    \0\x12\x06\xfa\x01\x04\x84\x02\x05\n\r\n\x05\x04\x10\x03\0\x01\x12\x04\
    \xfa\x01\x0c\x17\n\x10\n\x06\x04\x10\x03\0\x04\0\x12\x06\xfb\x01\x08\x80\
    \x02\t\n\x0f\n\x07\x04\x10\x03\0\x04\0\x01\x12\x04\xfb\x01\r\x14\n\x10\n\
    \x08\x04\x10\x03\0\x04\0\x02\0\x12\x04\xfc\x01\x0c\x20\n\x11\n\t\x04\x10\
    \x03\0\x04\0\x02\0\x01\x12\x04\xfc\x01\x0c\x1b\n\x11\n\t\x04\x10\x03\0\
    \x04\0\x02\0\x02\x12\x04\xfc\x01\x1e\x1f\n\x10\n\x08\x04\x10\x03\0\x04\0\
    \x02\x01\x12\x04\xfd\x01\x0c\x13\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x01\
    \x01\x12\x04\xfd\x01\x0c\x0e\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x01\x02\
    \x12\x04\xfd\x01\x11\x12\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x02\x12\x04\
    \xfe\x01\x0c\x13\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x02\x01\x12\x04\xfe\
    \x01\x0c\x0e\n\x11\n\t\x04\x10\x03\0\x04\0\x02\x02\x02\x12\x04\xfe\x01\
    \x11\x12\n\x10\n\x08\x04\x10\x03\0\x04\0\x02\x03\x12\x04\xff\x01\x0c\x13\
    \n\x11\n\t\x04\x10\x03\0\x04\0\x02\x03\x01\x12\x04\xff\x01\x0c\x0e\n\x11\
    \n\t\x04\x10\x03\0\x04\0\x02\x03\x02\x12\x04\xff\x01\x11\x12\n\x0e\n\x06\
    \x04\x10\x03\0\x02\0\x12\x04\x81\x02\x08\x1f\n\x0f\n\x07\x04\x10\x03\0\
    \x02\0\x04\x12\x04\x81\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\0\x02\0\x05\
    \x12\x04\x81\x02\x11\x17\n\x0f\n\x07\x04\x10\x03\0\x02\0\x01\x12\x04\x81\
    \x02\x18\x1a\n\x0f\n\x07\x04\x10\x03\0\x02\0\x03\x12\x04\x81\x02\x1d\x1e\
    \n\x0e\n\x06\x04\x10\x03\0\x02\x01\x12\x04\x82\x02\x08%\n\x0f\n\x07\x04\
    \x10\x03\0\x02\x01\x04\x12\x04\x82\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\0\
    \x02\x01\x06\x12\x04\x82\x02\x11\x18\n\x0f\n\x07\x04\x10\x03\0\x02\x01\
    \x01\x12\x04\x82\x02\x19\x20\n\x0f\n\x07\x04\x10\x03\0\x02\x01\x03\x12\
    \x04\x82\x02#$\n\x0e\n\x06\x04\x10\x03\0\x02\x02\x12\x04\x83\x02\x08*\n\
    \x0f\n\x07\x04\x10\x03\0\x02\x02\x04\x12\x04\x83\x02\x08\x10\n\x0f\n\x07\
    \x04\x10\x03\0\x02\x02\x05\x12\x04\x83\x02\x11\x16\n\x0f\n\x07\x04\x10\
    \x03\0\x02\x02\x01\x12\x04\x83\x02\x17%\n\x0f\n\x07\x04\x10\x03\0\x02\
    \x02\x03\x12\x04\x83\x02()\n\x0e\n\x04\x04\x10\x03\x01\x12\x06\x86\x02\
    \x04\x8f\x02\x05\n\r\n\x05\x04\x10\x03\x01\x01\x12\x04\x86\x02\x0c\x1d\n\
    \x10\n\x06\x04\x10\x03\x01\x03\0\x12\x06\x87\x02\x08\x8a\x02\t\n\x0f\n\
    \x07\x04\x10\x03\x01\x03\0\x01\x12\x04\x87\x02\x10\x20\n\x10\n\x08\x04\
    \x10\x03\x01\x03\0\x02\0\x12\x04\x88\x02\x0c%\n\x11\n\t\x04\x10\x03\x01\
    \x03\0\x02\0\x04\x12\x04\x88\x02\x0c\x14\n\x11\n\t\x04\x10\x03\x01\x03\0\
    \x02\0\x05\x12\x04\x88\x02\x15\x1b\n\x11\n\t\x04\x10\x03\x01\x03\0\x02\0\
    \x01\x12\x04\x88\x02\x1c\x20\n\x11\n\t\x04\x10\x03\x01\x03\0\x02\0\x03\
    \x12\x04\x88\x02#$\n\x10\n\x08\x04\x10\x03\x01\x03\0\x02\x01\x12\x04\x89\
    \x02\x0c1\n\x11\n\t\x04\x10\x03\x01\x03\0\x02\x01\x04\x12\x04\x89\x02\
    \x0c\x14\n\x11\n\t\x04\x10\x03\x01\x03\0\x02\x01\x05\x12\x04\x89\x02\x15\
    \x1b\n\x11\n\t\x04\x10\x03\x01\x03\0\x02\x01\x01\x12\x04\x89\x02\x1c,\n\
    \x11\n\t\x04\x10\x03\x01\x03\0\x02\x01\x03\x12\x04\x89\x02/0\n\x0e\n\x06\
    \x04\x10\x03\x01\x02\0\x12\x04\x8c\x02\x08.\n\x0f\n\x07\x04\x10\x03\x01\
    \x02\0\x04\x12\x04\x8c\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x06\
    \x12\x04\x8c\x02\x11!\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x01\x12\x04\x8c\
    \x02\")\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x03\x12\x04\x8c\x02,-\n\x0e\n\
    \x06\x04\x10\x03\x01\x02\x01\x12\x04\x8d\x02\x08.\n\x0f\n\x07\x04\x10\
    \x03\x01\x02\x01\x04\x12\x04\x8d\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\x01\
    \x02\x01\x05\x12\x04\x8d\x02\x11\x17\n\x0f\n\x07\x04\x10\x03\x01\x02\x01\
    \x01\x12\x04\x8d\x02\x18)\n\x0f\n\x07\x04\x10\x03\x01\x02\x01\x03\x12\
    \x04\x8d\x02,-\n\x0e\n\x06\x04\x10\x03\x01\x02\x02\x12\x04\x8e\x02\x08*\
    \n\x0f\n\x07\x04\x10\x03\x01\x02\x02\x04\x12\x04\x8e\x02\x08\x10\n\x0f\n\
    \x07\x04\x10\x03\x01\x02\x02\x05\x12\x04\x8e\x02\x11\x16\n\x0f\n\x07\x04\
    \x10\x03\x01\x02\x02\x01\x12\x04\x8e\x02\x17%\n\x0f\n\x07\x04\x10\x03\
    \x01\x02\x02\x03\x12\x04\x8e\x02()\n\x0e\n\x04\x04\x10\x03\x02\x12\x06\
    \x91\x02\x04\x9b\x02\x05\n\r\n\x05\x04\x10\x03\x02\x01\x12\x04\x91\x02\
    \x0c\x12\n\x0e\n\x06\x04\x10\x03\x02\x02\0\x12\x04\x92\x02\x08\"\n\x0f\n\
    \x07\x04\x10\x03\x02\x02\0\x04\x12\x04\x92\x02\x08\x10\n\x0f\n\x07\x04\
    \x10\x03\x02\x02\0\x05\x12\x04\x92\x02\x11\x17\n\x0f\n\x07\x04\x10\x03\
    \x02\x02\0\x01\x12\x04\x92\x02\x18\x1d\n\x0f\n\x07\x04\x10\x03\x02\x02\0\
    \x03\x12\x04\x92\x02\x20!\n\x0e\n\x06\x04\x10\x03\x02\x02\x01\x12\x04\
    \x93\x02\x08%\n\x0f\n\x07\x04\x10\x03\x02\x02\x01\x04\x12\x04\x93\x02\
    \x08\x10\n\x0f\n\x07\x04\x10\x03\x02\x02\x01\x05\x12\x04\x93\x02\x11\x17\
    \n\x0f\n\x07\x04\x10\x03\x02\x02\x01\x01\x12\x04\x93\x02\x18\x20\n\x0f\n\
    \x07\x04\x10\x03\x02\x02\x01\x03\x12\x04\x93\x02#$\n\x0e\n\x06\x04\x10\
    \x03\x02\x02\x02\x12\x04\x94\x02\x08-\n\x0f\n\x07\x04\x10\x03\x02\x02\
    \x02\x04\x12\x04\x94\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\x02\x02\x02\x05\
    \x12\x04\x94\x02\x11\x15\n\x0f\n\x07\x04\x10\x03\x02\x02\x02\x01\x12\x04\
    \x94\x02\x16(\n\x0f\n\x07\x04\x10\x03\x02\x02\x02\x03\x12\x04\x94\x02+,\
    \n\x10\n\x06\x04\x10\x03\x02\x08\0\x12\x06\x95\x02\x08\x9a\x02\t\n\x0f\n\
    \x07\x04\x10\x03\x02\x08\0\x01\x12\x04\x95\x02\x0e\x13\n\x0e\n\x06\x04\
    \x10\x03\x02\x02\x03\x12\x04\x96\x02\x0c0\n\x0f\n\x07\x04\x10\x03\x02\
    \x02\x03\x06\x12\x04\x96\x02\x0c\x1b\n\x0f\n\x07\x04\x10\x03\x02\x02\x03\
    \x01\x12\x04\x96\x02\x1c+\n\x0f\n\x07\x04\x10\x03\x02\x02\x03\x03\x12\
    \x04\x96\x02./\n\x0e\n\x06\x04\x10\x03\x02\x02\x04\x12\x04\x97\x02\x0c*\
    \n\x0f\n\x07\x04\x10\x03\x02\x02\x04\x06\x12\x04\x97\x02\x0c\x18\n\x0f\n\
    \x07\x04\x10\x03\x02\x02\x04\x01\x12\x04\x97\x02\x19%\n\x0f\n\x07\x04\
    \x10\x03\x02\x02\x04\x03\x12\x04\x97\x02()\n\x0e\n\x06\x04\x10\x03\x02\
    \x02\x05\x12\x04\x98\x02\x0c$\n\x0f\n\x07\x04\x10\x03\x02\x02\x05\x05\
    \x12\x04\x98\x02\x0c\x11\n\x0f\n\x07\x04\x10\x03\x02\x02\x05\x01\x12\x04\
    \x98\x02\x12\x1f\n\x0f\n\x07\x04\x10\x03\x02\x02\x05\x03\x12\x04\x98\x02\
    \"#\n\x0e\n\x06\x04\x10\x03\x02\x02\x06\x12\x04\x99\x02\x0c*\n\x0f\n\x07\
    \x04\x10\x03\x02\x02\x06\x06\x12\x04\x99\x02\x0c\x18\n\x0f\n\x07\x04\x10\
    \x03\x02\x02\x06\x01\x12\x04\x99\x02\x19%\n\x0f\n\x07\x04\x10\x03\x02\
    \x02\x06\x03\x12\x04\x99\x02()\n\x0e\n\x04\x04\x10\x03\x03\x12\x06\x9d\
    \x02\x04\x9f\x02\x05\n\r\n\x05\x04\x10\x03\x03\x01\x12\x04\x9d\x02\x0c\
    \x12\n\x0e\n\x06\x04\x10\x03\x03\x02\0\x12\x04\x9e\x02\x08!\n\x0f\n\x07\
    \x04\x10\x03\x03\x02\0\x04\x12\x04\x9e\x02\x08\x10\n\x0f\n\x07\x04\x10\
    \x03\x03\x02\0\x05\x12\x04\x9e\x02\x11\x17\n\x0f\n\x07\x04\x10\x03\x03\
    \x02\0\x01\x12\x04\x9e\x02\x18\x1c\n\x0f\n\x07\x04\x10\x03\x03\x02\0\x03\
    \x12\x04\x9e\x02\x1f\x20\n\x0e\n\x04\x04\x10\x03\x04\x12\x06\xa1\x02\x04\
    \xa5\x02\x05\n\r\n\x05\x04\x10\x03\x04\x01\x12\x04\xa1\x02\x0c\x1d\n\x0e\
    \n\x06\x04\x10\x03\x04\x02\0\x12\x04\xa2\x02\x08#\n\x0f\n\x07\x04\x10\
    \x03\x04\x02\0\x04\x12\x04\xa2\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\x04\
    \x02\0\x05\x12\x04\xa2\x02\x11\x17\n\x0f\n\x07\x04\x10\x03\x04\x02\0\x01\
    \x12\x04\xa2\x02\x18\x1e\n\x0f\n\x07\x04\x10\x03\x04\x02\0\x03\x12\x04\
    \xa2\x02!\"\n\x0e\n\x06\x04\x10\x03\x04\x02\x01\x12\x04\xa3\x02\x08\x1f\
    \n\x0f\n\x07\x04\x10\x03\x04\x02\x01\x04\x12\x04\xa3\x02\x08\x10\n\x0f\n\
    \x07\x04\x10\x03\x04\x02\x01\x05\x12\x04\xa3\x02\x11\x17\n\x0f\n\x07\x04\
    \x10\x03\x04\x02\x01\x01\x12\x04\xa3\x02\x18\x1a\n\x0f\n\x07\x04\x10\x03\
    \x04\x02\x01\x03\x12\x04\xa3\x02\x1d\x1e\n\x0e\n\x06\x04\x10\x03\x04\x02\
    \x02\x12\x04\xa4\x02\x08*\n\x0f\n\x07\x04\x10\x03\x04\x02\x02\x04\x12\
    \x04\xa4\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\x04\x02\x02\x05\x12\x04\xa4\
    \x02\x11\x16\n\x0f\n\x07\x04\x10\x03\x04\x02\x02\x01\x12\x04\xa4\x02\x17\
    %\n\x0f\n\x07\x04\x10\x03\x04\x02\x02\x03\x12\x04\xa4\x02()\n\x0e\n\x04\
    \x04\x10\x03\x05\x12\x06\xa7\x02\x04\xa9\x02\x05\n\r\n\x05\x04\x10\x03\
    \x05\x01\x12\x04\xa7\x02\x0c\x10\n\x0e\n\x06\x04\x10\x03\x05\x02\0\x12\
    \x04\xa8\x02\x08!\n\x0f\n\x07\x04\x10\x03\x05\x02\0\x04\x12\x04\xa8\x02\
    \x08\x10\n\x0f\n\x07\x04\x10\x03\x05\x02\0\x05\x12\x04\xa8\x02\x11\x17\n\
    \x0f\n\x07\x04\x10\x03\x05\x02\0\x01\x12\x04\xa8\x02\x18\x1c\n\x0f\n\x07\
    \x04\x10\x03\x05\x02\0\x03\x12\x04\xa8\x02\x1f\x20\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\xab\x02\x04\x1f\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xab\
    \x02\x04\x0c\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xab\x02\r\x13\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xab\x02\x14\x1a\n\r\n\x05\x04\x10\x02\0\x03\
    \x12\x04\xab\x02\x1d\x1e\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xac\x02\x04\
    \x1b\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xac\x02\x04\x0c\n\r\n\x05\x04\
    \x10\x02\x01\x06\x12\x04\xac\x02\r\x11\n\r\n\x05\x04\x10\x02\x01\x01\x12\
    \x04\xac\x02\x12\x16\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xac\x02\x19\
    \x1a\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xad\x02\x04\x1f\n\r\n\x05\x04\
    \x10\x02\x02\x04\x12\x04\xad\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x02\x06\
    \x12\x04\xad\x02\r\x13\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xad\x02\x14\
    \x1a\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xad\x02\x1d\x1e\n\x0c\n\x04\
    \x04\x10\x02\x03\x12\x04\xae\x02\x04*\n\r\n\x05\x04\x10\x02\x03\x04\x12\
    \x04\xae\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x03\x06\x12\x04\xae\x02\r\x18\
    \n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xae\x02\x19$\n\r\n\x05\x04\x10\
    \x02\x03\x03\x12\x04\xae\x02')\n\x0e\n\x04\x04\x10\x08\0\x12\x06\xaf\x02\
    \x04\xb3\x02\x05\n\r\n\x05\x04\x10\x08\0\x01\x12\x04\xaf\x02\n\x1c\n\x0c\
    \n\x04\x04\x10\x02\x04\x12\x04\xb0\x02\x08.\n\r\n\x05\x04\x10\x02\x04\
    \x06\x12\x04\xb0\x02\x08\x13\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\xb0\
    \x02\x14)\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xb0\x02,-\n\x0c\n\x04\
    \x04\x10\x02\x05\x12\x04\xb1\x02\x080\n\r\n\x05\x04\x10\x02\x05\x06\x12\
    \x04\xb1\x02\x08\x19\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xb1\x02\x1a+\
    \n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xb1\x02./\n\x0c\n\x04\x04\x10\x02\
    \x06\x12\x04\xb2\x02\x080\n\r\n\x05\x04\x10\x02\x06\x06\x12\x04\xb2\x02\
    \x08\x19\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xb2\x02\x1a+\n\r\n\x05\
    \x04\x10\x02\x06\x03\x12\x04\xb2\x02./\n\x0c\n\x02\x04\x11\x12\x06\xb6\
    \x02\0\xb8\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb6\x02\x08.\n\x0c\n\
    \x04\x04\x11\x02\0\x12\x04\xb7\x02\x042\n\r\n\x05\x04\x11\x02\0\x04\x12\
    \x04\xb7\x02\x04\x0c\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xb7\x02\r\x11\n\
    \r\n\x05\x04\x11\x02\0\x01\x12\x04\xb7\x02\x12-\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\xb7\x0201\n\x0c\n\x02\x04\x12\x12\x06\xba\x02\0\xd5\x02\x01\
    \n\x0b\n\x03\x04\x12\x01\x12\x04\xba\x02\x08\x14\n\x0c\n\x04\x04\x12\x02\
    \0\x12\x04\xbb\x02\x04\x1c\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xbb\x02\
    \x04\x0c\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xbb\x02\r\x13\n\r\n\x05\x04\
    \x12\x02\0\x01\x12\x04\xbb\x02\x14\x17\n\r\n\x05\x04\x12\x02\0\x03\x12\
    \x04\xbb\x02\x1a\x1b\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xbc\x02\x04!\n\
    \r\n\x05\x04\x12\x02\x01\x04\x12\x04\xbc\x02\x04\x0c\n\r\n\x05\x04\x12\
    \x02\x01\x05\x12\x04\xbc\x02\r\x13\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\
    \xbc\x02\x14\x1c\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xbc\x02\x1f\x20\n\
    \x0c\n\x04\x04\x12\x02\x02\x12\x04\xbd\x02\x04\x20\n\r\n\x05\x04\x12\x02\
    \x02\x04\x12\x04\xbd\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\
    \xbd\x02\r\x13\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xbd\x02\x14\x1b\n\r\
    \n\x05\x04\x12\x02\x02\x03\x12\x04\xbd\x02\x1e\x1f\n\x0c\n\x04\x04\x12\
    \x02\x03\x12\x04\xbe\x02\x04\"\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xbe\
    \x02\x04\x0c\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xbe\x02\r\x12\n\r\n\
    \x05\x04\x12\x02\x03\x01\x12\x04\xbe\x02\x13\x1d\n\r\n\x05\x04\x12\x02\
    \x03\x03\x12\x04\xbe\x02\x20!\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\xbf\
    \x02\x04#\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xbf\x02\x04\x0c\n\r\n\
    \x05\x04\x12\x02\x04\x05\x12\x04\xbf\x02\r\x13\n\r\n\x05\x04\x12\x02\x04\
    \x01\x12\x04\xbf\x02\x14\x1e\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xbf\
    \x02!\"\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\xc0\x02\x04\x1f\n\r\n\x05\
    \x04\x12\x02\x05\x04\x12\x04\xc0\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x05\
    \x05\x12\x04\xc0\x02\r\x13\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\xc0\x02\
    \x14\x1a\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\xc0\x02\x1d\x1e\n\x0c\n\
    \x04\x04\x12\x02\x06\x12\x04\xc1\x02\x04\x1e\n\r\n\x05\x04\x12\x02\x06\
    \x04\x12\x04\xc1\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x06\x05\x12\x04\xc1\
    \x02\r\x13\n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\xc1\x02\x14\x19\n\r\n\
    \x05\x04\x12\x02\x06\x03\x12\x04\xc1\x02\x1c\x1d\n\x0c\n\x04\x04\x12\x02\
    \x07\x12\x04\xc2\x02\x04\x20\n\r\n\x05\x04\x12\x02\x07\x04\x12\x04\xc2\
    \x02\x04\x0c\n\r\n\x05\x04\x12\x02\x07\x05\x12\x04\xc2\x02\r\x12\n\r\n\
    \x05\x04\x12\x02\x07\x01\x12\x04\xc2\x02\x13\x1b\n\r\n\x05\x04\x12\x02\
    \x07\x03\x12\x04\xc2\x02\x1e\x1f\n\x0c\n\x04\x04\x12\x02\x08\x12\x04\xc3\
    \x02\x04%\n\r\n\x05\x04\x12\x02\x08\x04\x12\x04\xc3\x02\x04\x0c\n\r\n\
    \x05\x04\x12\x02\x08\x05\x12\x04\xc3\x02\r\x12\n\r\n\x05\x04\x12\x02\x08\
    \x01\x12\x04\xc3\x02\x13\x20\n\r\n\x05\x04\x12\x02\x08\x03\x12\x04\xc3\
    \x02#$\n\x0c\n\x04\x04\x12\x02\t\x12\x04\xc4\x02\x04?\n\r\n\x05\x04\x12\
    \x02\t\x04\x12\x04\xc4\x02\x04\x0c\n\r\n\x05\x04\x12\x02\t\x06\x12\x04\
    \xc4\x02\r\"\n\r\n\x05\x04\x12\x02\t\x01\x12\x04\xc4\x02#9\n\r\n\x05\x04\
    \x12\x02\t\x03\x12\x04\xc4\x02<>\n\x0c\n\x04\x04\x12\x02\n\x12\x04\xc5\
    \x02\x04$\n\r\n\x05\x04\x12\x02\n\x04\x12\x04\xc5\x02\x04\x0c\n\r\n\x05\
    \x04\x12\x02\n\x05\x12\x04\xc5\x02\r\x13\n\r\n\x05\x04\x12\x02\n\x01\x12\
    \x04\xc5\x02\x14\x1e\n\r\n\x05\x04\x12\x02\n\x03\x12\x04\xc5\x02!#\n\x0c\
    \n\x04\x04\x12\x02\x0b\x12\x04\xc6\x02\x04*\n\r\n\x05\x04\x12\x02\x0b\
    \x04\x12\x04\xc6\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x0b\x05\x12\x04\xc6\
    \x02\r\x12\n\r\n\x05\x04\x12\x02\x0b\x01\x12\x04\xc6\x02\x13$\n\r\n\x05\
    \x04\x12\x02\x0b\x03\x12\x04\xc6\x02')\n\x0c\n\x04\x04\x12\x02\x0c\x12\
    \x04\xc7\x02\x04&\n\r\n\x05\x04\x12\x02\x0c\x04\x12\x04\xc7\x02\x04\x0c\
    \n\r\n\x05\x04\x12\x02\x0c\x05\x12\x04\xc7\x02\r\x12\n\r\n\x05\x04\x12\
    \x02\x0c\x01\x12\x04\xc7\x02\x13\x20\n\r\n\x05\x04\x12\x02\x0c\x03\x12\
    \x04\xc7\x02#%\n\x0c\n\x04\x04\x12\x02\r\x12\x04\xc8\x02\x04*\n\r\n\x05\
    \x04\x12\x02\r\x04\x12\x04\xc8\x02\x04\x0c\n\r\n\x05\x04\x12\x02\r\x06\
    \x12\x04\xc8\x02\r\x18\n\r\n\x05\x04\x12\x02\r\x01\x12\x04\xc8\x02\x19$\
    \n\r\n\x05\x04\x12\x02\r\x03\x12\x04\xc8\x02')\n\x0c\n\x04\x04\x12\x02\
    \x0e\x12\x04\xc9\x02\x04)\n\r\n\x05\x04\x12\x02\x0e\x04\x12\x04\xc9\x02\
    \x04\x0c\n\r\n\x05\x04\x12\x02\x0e\x05\x12\x04\xc9\x02\r\x12\n\r\n\x05\
    \x04\x12\x02\x0e\x01\x12\x04\xc9\x02\x13#\n\r\n\x05\x04\x12\x02\x0e\x03\
    \x12\x04\xc9\x02&(\n\x0c\n\x04\x04\x12\x02\x0f\x12\x04\xca\x02\x04)\n\r\
    \n\x05\x04\x12\x02\x0f\x04\x12\x04\xca\x02\x04\x0c\n\r\n\x05\x04\x12\x02\
    \x0f\x05\x12\x04\xca\x02\r\x13\n\r\n\x05\x04\x12\x02\x0f\x01\x12\x04\xca\
    \x02\x14#\n\r\n\x05\x04\x12\x02\x0f\x03\x12\x04\xca\x02&(\n\x0c\n\x04\
    \x04\x12\x02\x10\x12\x04\xcb\x02\x04+\n\r\n\x05\x04\x12\x02\x10\x04\x12\
    \x04\xcb\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x10\x05\x12\x04\xcb\x02\r\x13\
    \n\r\n\x05\x04\x12\x02\x10\x01\x12\x04\xcb\x02\x14%\n\r\n\x05\x04\x12\
    \x02\x10\x03\x12\x04\xcb\x02(*\n\x0c\n\x04\x04\x12\x02\x11\x12\x04\xcc\
    \x02\x04%\n\r\n\x05\x04\x12\x02\x11\x04\x12\x04\xcc\x02\x04\x0c\n\r\n\
    \x05\x04\x12\x02\x11\x05\x12\x04\xcc\x02\r\x12\n\r\n\x05\x04\x12\x02\x11\
    \x01\x12\x04\xcc\x02\x13\x1f\n\r\n\x05\x04\x12\x02\x11\x03\x12\x04\xcc\
    \x02\"$\n\x0c\n\x04\x04\x12\x02\x12\x12\x04\xcd\x02\x04%\n\r\n\x05\x04\
    \x12\x02\x12\x04\x12\x04\xcd\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x12\x05\
    \x12\x04\xcd\x02\r\x13\n\r\n\x05\x04\x12\x02\x12\x01\x12\x04\xcd\x02\x14\
    \x1f\n\r\n\x05\x04\x12\x02\x12\x03\x12\x04\xcd\x02\"$\n\x0c\n\x04\x04\
    \x12\x02\x13\x12\x04\xce\x02\x04-\n\r\n\x05\x04\x12\x02\x13\x04\x12\x04\
    \xce\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x13\x05\x12\x04\xce\x02\r\x12\n\r\
    \n\x05\x04\x12\x02\x13\x01\x12\x04\xce\x02\x13'\n\r\n\x05\x04\x12\x02\
    \x13\x03\x12\x04\xce\x02*,\n\x0c\n\x04\x04\x12\x02\x14\x12\x04\xcf\x02\
    \x040\n\r\n\x05\x04\x12\x02\x14\x04\x12\x04\xcf\x02\x04\x0c\n\r\n\x05\
    \x04\x12\x02\x14\x05\x12\x04\xcf\x02\r\x12\n\r\n\x05\x04\x12\x02\x14\x01\
    \x12\x04\xcf\x02\x13*\n\r\n\x05\x04\x12\x02\x14\x03\x12\x04\xcf\x02-/\n\
    \x0c\n\x04\x04\x12\x02\x15\x12\x04\xd0\x02\x04\x20\n\r\n\x05\x04\x12\x02\
    \x15\x04\x12\x04\xd0\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x15\x05\x12\x04\
    \xd0\x02\r\x11\n\r\n\x05\x04\x12\x02\x15\x01\x12\x04\xd0\x02\x12\x1a\n\r\
    \n\x05\x04\x12\x02\x15\x03\x12\x04\xd0\x02\x1d\x1f\n\x0c\n\x04\x04\x12\
    \x02\x16\x12\x04\xd1\x02\x04-\n\r\n\x05\x04\x12\x02\x16\x04\x12\x04\xd1\
    \x02\x04\x0c\n\r\n\x05\x04\x12\x02\x16\x05\x12\x04\xd1\x02\r\x13\n\r\n\
    \x05\x04\x12\x02\x16\x01\x12\x04\xd1\x02\x14'\n\r\n\x05\x04\x12\x02\x16\
    \x03\x12\x04\xd1\x02*,\n\x0c\n\x04\x04\x12\x02\x17\x12\x04\xd2\x02\x04(\
    \n\r\n\x05\x04\x12\x02\x17\x04\x12\x04\xd2\x02\x04\x0c\n\r\n\x05\x04\x12\
    \x02\x17\x05\x12\x04\xd2\x02\r\x12\n\r\n\x05\x04\x12\x02\x17\x01\x12\x04\
    \xd2\x02\x13\"\n\r\n\x05\x04\x12\x02\x17\x03\x12\x04\xd2\x02%'\n\x0c\n\
    \x04\x04\x12\x02\x18\x12\x04\xd3\x02\x04+\n\r\n\x05\x04\x12\x02\x18\x04\
    \x12\x04\xd3\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x18\x05\x12\x04\xd3\x02\r\
    \x12\n\r\n\x05\x04\x12\x02\x18\x01\x12\x04\xd3\x02\x13%\n\r\n\x05\x04\
    \x12\x02\x18\x03\x12\x04\xd3\x02(*\n\x0c\n\x04\x04\x12\x02\x19\x12\x04\
    \xd4\x02\x04#\n\r\n\x05\x04\x12\x02\x19\x04\x12\x04\xd4\x02\x04\x0c\n\r\
    \n\x05\x04\x12\x02\x19\x05\x12\x04\xd4\x02\r\x13\n\r\n\x05\x04\x12\x02\
    \x19\x01\x12\x04\xd4\x02\x14\x1d\n\r\n\x05\x04\x12\x02\x19\x03\x12\x04\
    \xd4\x02\x20\"\n\x0c\n\x02\x04\x13\x12\x06\xd7\x02\0\xea\x02\x01\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xd7\x02\x08\x1f\n\x0e\n\x04\x04\x13\x04\0\x12\
    \x06\xd8\x02\x04\xdf\x02\x05\n\r\n\x05\x04\x13\x04\0\x01\x12\x04\xd8\x02\
    \t\x18\n\x0e\n\x06\x04\x13\x04\0\x02\0\x12\x04\xd9\x02\x08\x1e\n\x0f\n\
    \x07\x04\x13\x04\0\x02\0\x01\x12\x04\xd9\x02\x08\x19\n\x0f\n\x07\x04\x13\
    \x04\0\x02\0\x02\x12\x04\xd9\x02\x1c\x1d\n\x0e\n\x06\x04\x13\x04\0\x02\
    \x01\x12\x04\xda\x02\x08\x1e\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x01\x12\
    \x04\xda\x02\x08\x19\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x02\x12\x04\xda\
    \x02\x1c\x1d\n\x0e\n\x06\x04\x13\x04\0\x02\x02\x12\x04\xdb\x02\x08\x11\n\
    \x0f\n\x07\x04\x13\x04\0\x02\x02\x01\x12\x04\xdb\x02\x08\x0c\n\x0f\n\x07\
    \x04\x13\x04\0\x02\x02\x02\x12\x04\xdb\x02\x0f\x10\n\x0e\n\x06\x04\x13\
    \x04\0\x02\x03\x12\x04\xdc\x02\x08\x13\n\x0f\n\x07\x04\x13\x04\0\x02\x03\
    \x01\x12\x04\xdc\x02\x08\x0e\n\x0f\n\x07\x04\x13\x04\0\x02\x03\x02\x12\
    \x04\xdc\x02\x11\x12\n\x0e\n\x06\x04\x13\x04\0\x02\x04\x12\x04\xdd\x02\
    \x08\x16\n\x0f\n\x07\x04\x13\x04\0\x02\x04\x01\x12\x04\xdd\x02\x08\x11\n\
    \x0f\n\x07\x04\x13\x04\0\x02\x04\x02\x12\x04\xdd\x02\x14\x15\n\x0e\n\x06\
    \x04\x13\x04\0\x02\x05\x12\x04\xde\x02\x08\x1e\n\x0f\n\x07\x04\x13\x04\0\
    \x02\x05\x01\x12\x04\xde\x02\x08\x19\n\x0f\n\x07\x04\x13\x04\0\x02\x05\
    \x02\x12\x04\xde\x02\x1c\x1d\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xe0\x02\
    \x04\"\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xe0\x02\x04\x0c\n\r\n\x05\x04\
    \x13\x02\0\x05\x12\x04\xe0\x02\r\x12\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \xe0\x02\x13\x1d\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xe0\x02\x20!\n\x0c\
    \n\x04\x04\x13\x02\x01\x12\x04\xe1\x02\x04#\n\r\n\x05\x04\x13\x02\x01\
    \x04\x12\x04\xe1\x02\x04\x0c\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xe1\
    \x02\r\x13\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xe1\x02\x14\x1e\n\r\n\
    \x05\x04\x13\x02\x01\x03\x12\x04\xe1\x02!\"\n\x0c\n\x04\x04\x13\x02\x02\
    \x12\x04\xe2\x02\x04\x20\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\xe2\x02\
    \x04\x0c\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xe2\x02\r\x12\n\r\n\x05\
    \x04\x13\x02\x02\x01\x12\x04\xe2\x02\x13\x1b\n\r\n\x05\x04\x13\x02\x02\
    \x03\x12\x04\xe2\x02\x1e\x1f\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\xe3\x02\
    \x04%\n\r\n\x05\x04\x13\x02\x03\x04\x12\x04\xe3\x02\x04\x0c\n\r\n\x05\
    \x04\x13\x02\x03\x05\x12\x04\xe3\x02\r\x12\n\r\n\x05\x04\x13\x02\x03\x01\
    \x12\x04\xe3\x02\x13\x20\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xe3\x02#$\
    \n\x0c\n\x04\x04\x13\x02\x04\x12\x04\xe4\x02\x04#\n\r\n\x05\x04\x13\x02\
    \x04\x04\x12\x04\xe4\x02\x04\x0c\n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\
    \xe4\x02\r\x13\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xe4\x02\x14\x1e\n\r\
    \n\x05\x04\x13\x02\x04\x03\x12\x04\xe4\x02!\"\n\x0c\n\x04\x04\x13\x02\
    \x05\x12\x04\xe5\x02\x04*\n\r\n\x05\x04\x13\x02\x05\x04\x12\x04\xe5\x02\
    \x04\x0c\n\r\n\x05\x04\x13\x02\x05\x06\x12\x04\xe5\x02\r\x1c\n\r\n\x05\
    \x04\x13\x02\x05\x01\x12\x04\xe5\x02\x1d%\n\r\n\x05\x04\x13\x02\x05\x03\
    \x12\x04\xe5\x02()\n\x0c\n\x04\x04\x13\x02\x06\x12\x04\xe6\x02\x04#\n\r\
    \n\x05\x04\x13\x02\x06\x04\x12\x04\xe6\x02\x04\x0c\n\r\n\x05\x04\x13\x02\
    \x06\x05\x12\x04\xe6\x02\r\x13\n\r\n\x05\x04\x13\x02\x06\x01\x12\x04\xe6\
    \x02\x14\x1e\n\r\n\x05\x04\x13\x02\x06\x03\x12\x04\xe6\x02!\"\n\x0c\n\
    \x04\x04\x13\x02\x07\x12\x04\xe7\x02\x04*\n\r\n\x05\x04\x13\x02\x07\x04\
    \x12\x04\xe7\x02\x04\x0c\n\r\n\x05\x04\x13\x02\x07\x05\x12\x04\xe7\x02\r\
    \x13\n\r\n\x05\x04\x13\x02\x07\x01\x12\x04\xe7\x02\x14%\n\r\n\x05\x04\
    \x13\x02\x07\x03\x12\x04\xe7\x02()\n\x0c\n\x04\x04\x13\x02\x08\x12\x04\
    \xe8\x02\x04!\n\r\n\x05\x04\x13\x02\x08\x04\x12\x04\xe8\x02\x04\x0c\n\r\
    \n\x05\x04\x13\x02\x08\x05\x12\x04\xe8\x02\r\x13\n\r\n\x05\x04\x13\x02\
    \x08\x01\x12\x04\xe8\x02\x14\x1c\n\r\n\x05\x04\x13\x02\x08\x03\x12\x04\
    \xe8\x02\x1f\x20\n\x0c\n\x04\x04\x13\x02\t\x12\x04\xe9\x02\x045\n\r\n\
    \x05\x04\x13\x02\t\x04\x12\x04\xe9\x02\x04\x0c\n\r\n\x05\x04\x13\x02\t\
    \x05\x12\x04\xe9\x02\r\x12\n\r\n\x05\x04\x13\x02\t\x01\x12\x04\xe9\x02\
    \x13/\n\r\n\x05\x04\x13\x02\t\x03\x12\x04\xe9\x0224\n\x0c\n\x02\x04\x14\
    \x12\x06\xec\x02\0\xa5\x03\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xec\x02\
    \x08\x1f\n\x0e\n\x04\x04\x14\x03\0\x12\x06\xed\x02\x04\x9a\x03\x05\n\r\n\
    \x05\x04\x14\x03\0\x01\x12\x04\xed\x02\x0c#\n\x10\n\x06\x04\x14\x03\0\
    \x03\0\x12\x06\xee\x02\x08\x8e\x03\t\n\x0f\n\x07\x04\x14\x03\0\x03\0\x01\
    \x12\x04\xee\x02\x10\x1b\n\x12\n\x08\x04\x14\x03\0\x03\0\x03\0\x12\x06\
    \xef\x02\x0c\xf1\x02\r\n\x11\n\t\x04\x14\x03\0\x03\0\x03\0\x01\x12\x04\
    \xef\x02\x14(\n\x12\n\n\x04\x14\x03\0\x03\0\x03\0\x02\0\x12\x04\xf0\x02\
    \x10-\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\0\x02\0\x04\x12\x04\xf0\x02\
    \x10\x18\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\0\x02\0\x05\x12\x04\xf0\x02\
    \x19\x1e\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\0\x02\0\x01\x12\x04\xf0\x02\
    \x1f(\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\0\x02\0\x03\x12\x04\xf0\x02+,\
    \n\x12\n\x08\x04\x14\x03\0\x03\0\x03\x01\x12\x06\xf3\x02\x0c\x88\x03\r\n\
    \x11\n\t\x04\x14\x03\0\x03\0\x03\x01\x01\x12\x04\xf3\x02\x14(\n\x14\n\n\
    \x04\x14\x03\0\x03\0\x03\x01\x04\0\x12\x06\xf4\x02\x10\xfc\x02\x11\n\x13\
    \n\x0b\x04\x14\x03\0\x03\0\x03\x01\x04\0\x01\x12\x04\xf4\x02\x15\"\n\x14\
    \n\x0c\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\0\x12\x04\xf5\x02\x14\x1f\n\
    \x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\0\x01\x12\x04\xf5\x02\x14\
    \x1a\n\x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\0\x02\x12\x04\xf5\
    \x02\x1d\x1e\n\x14\n\x0c\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\x01\x12\
    \x04\xf6\x02\x14\x20\n\x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\x01\
    \x01\x12\x04\xf6\x02\x14\x1b\n\x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\0\
    \x02\x01\x02\x12\x04\xf6\x02\x1e\x1f\n\x14\n\x0c\x04\x14\x03\0\x03\0\x03\
    \x01\x04\0\x02\x02\x12\x04\xf7\x02\x14\"\n\x15\n\r\x04\x14\x03\0\x03\0\
    \x03\x01\x04\0\x02\x02\x01\x12\x04\xf7\x02\x14\x1d\n\x15\n\r\x04\x14\x03\
    \0\x03\0\x03\x01\x04\0\x02\x02\x02\x12\x04\xf7\x02\x20!\n\x14\n\x0c\x04\
    \x14\x03\0\x03\0\x03\x01\x04\0\x02\x03\x12\x04\xf8\x02\x14!\n\x15\n\r\
    \x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\x03\x01\x12\x04\xf8\x02\x14\x1c\n\
    \x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\x03\x02\x12\x04\xf8\x02\
    \x1f\x20\n\x14\n\x0c\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\x04\x12\x04\
    \xf9\x02\x14\x1f\n\x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\x04\x01\
    \x12\x04\xf9\x02\x14\x1a\n\x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\
    \x04\x02\x12\x04\xf9\x02\x1d\x1e\n\x14\n\x0c\x04\x14\x03\0\x03\0\x03\x01\
    \x04\0\x02\x05\x12\x04\xfa\x02\x14!\n\x15\n\r\x04\x14\x03\0\x03\0\x03\
    \x01\x04\0\x02\x05\x01\x12\x04\xfa\x02\x14\x1c\n\x15\n\r\x04\x14\x03\0\
    \x03\0\x03\x01\x04\0\x02\x05\x02\x12\x04\xfa\x02\x1f\x20\n\x14\n\x0c\x04\
    \x14\x03\0\x03\0\x03\x01\x04\0\x02\x06\x12\x04\xfb\x02\x14\x1f\n\x15\n\r\
    \x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\x06\x01\x12\x04\xfb\x02\x14\x1a\n\
    \x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\0\x02\x06\x02\x12\x04\xfb\x02\
    \x1d\x1e\n\x14\n\n\x04\x14\x03\0\x03\0\x03\x01\x04\x01\x12\x06\xfd\x02\
    \x10\x80\x03\x11\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x04\x01\x01\x12\
    \x04\xfd\x02\x15!\n\x14\n\x0c\x04\x14\x03\0\x03\0\x03\x01\x04\x01\x02\0\
    \x12\x04\xfe\x02\x14\"\n\x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\x01\x02\
    \0\x01\x12\x04\xfe\x02\x14\x1d\n\x15\n\r\x04\x14\x03\0\x03\0\x03\x01\x04\
    \x01\x02\0\x02\x12\x04\xfe\x02\x20!\n\x14\n\x0c\x04\x14\x03\0\x03\0\x03\
    \x01\x04\x01\x02\x01\x12\x04\xff\x02\x14$\n\x15\n\r\x04\x14\x03\0\x03\0\
    \x03\x01\x04\x01\x02\x01\x01\x12\x04\xff\x02\x14\x1f\n\x15\n\r\x04\x14\
    \x03\0\x03\0\x03\x01\x04\x01\x02\x01\x02\x12\x04\xff\x02\"#\n\x12\n\n\
    \x04\x14\x03\0\x03\0\x03\x01\x02\0\x12\x04\x81\x03\x105\n\x13\n\x0b\x04\
    \x14\x03\0\x03\0\x03\x01\x02\0\x04\x12\x04\x81\x03\x10\x18\n\x13\n\x0b\
    \x04\x14\x03\0\x03\0\x03\x01\x02\0\x06\x12\x04\x81\x03\x19&\n\x13\n\x0b\
    \x04\x14\x03\0\x03\0\x03\x01\x02\0\x01\x12\x04\x81\x03'0\n\x13\n\x0b\x04\
    \x14\x03\0\x03\0\x03\x01\x02\0\x03\x12\x04\x81\x0334\n\x12\n\n\x04\x14\
    \x03\0\x03\0\x03\x01\x02\x01\x12\x04\x82\x03\x10)\n\x13\n\x0b\x04\x14\
    \x03\0\x03\0\x03\x01\x02\x01\x04\x12\x04\x82\x03\x10\x18\n\x13\n\x0b\x04\
    \x14\x03\0\x03\0\x03\x01\x02\x01\x05\x12\x04\x82\x03\x19\x1f\n\x13\n\x0b\
    \x04\x14\x03\0\x03\0\x03\x01\x02\x01\x01\x12\x04\x82\x03\x20$\n\x13\n\
    \x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x01\x03\x12\x04\x82\x03'(\n\x12\n\n\
    \x04\x14\x03\0\x03\0\x03\x01\x02\x02\x12\x04\x83\x03\x10*\n\x13\n\x0b\
    \x04\x14\x03\0\x03\0\x03\x01\x02\x02\x04\x12\x04\x83\x03\x10\x18\n\x13\n\
    \x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x02\x05\x12\x04\x83\x03\x19\x1f\n\
    \x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x02\x01\x12\x04\x83\x03\x20%\
    \n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x02\x03\x12\x04\x83\x03()\n\
    \x12\n\n\x04\x14\x03\0\x03\0\x03\x01\x02\x03\x12\x04\x84\x03\x10/\n\x13\
    \n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x03\x04\x12\x04\x84\x03\x10\x18\n\
    \x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x03\x05\x12\x04\x84\x03\x19\
    \x1f\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x03\x01\x12\x04\x84\x03\
    \x20*\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x03\x03\x12\x04\x84\
    \x03-.\n\x12\n\n\x04\x14\x03\0\x03\0\x03\x01\x02\x04\x12\x04\x85\x03\x10\
    )\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x04\x04\x12\x04\x85\x03\
    \x10\x18\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x04\x05\x12\x04\x85\
    \x03\x19\x1f\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x04\x01\x12\x04\
    \x85\x03\x20$\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x04\x03\x12\
    \x04\x85\x03'(\n\x12\n\n\x04\x14\x03\0\x03\0\x03\x01\x02\x05\x12\x04\x86\
    \x03\x10+\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x05\x04\x12\x04\
    \x86\x03\x10\x18\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x05\x05\x12\
    \x04\x86\x03\x19\x1f\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x05\x01\
    \x12\x04\x86\x03\x20&\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x05\
    \x03\x12\x04\x86\x03)*\n\x12\n\n\x04\x14\x03\0\x03\0\x03\x01\x02\x06\x12\
    \x04\x87\x03\x103\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x06\x04\
    \x12\x04\x87\x03\x10\x18\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\x06\
    \x06\x12\x04\x87\x03\x19%\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\
    \x06\x01\x12\x04\x87\x03&.\n\x13\n\x0b\x04\x14\x03\0\x03\0\x03\x01\x02\
    \x06\x03\x12\x04\x87\x0312\n\x12\n\x08\x04\x14\x03\0\x03\0\x08\0\x12\x06\
    \x8a\x03\x0c\x8d\x03\r\n\x11\n\t\x04\x14\x03\0\x03\0\x08\0\x01\x12\x04\
    \x8a\x03\x12\x1f\n\x10\n\x08\x04\x14\x03\0\x03\0\x02\0\x12\x04\x8b\x03\
    \x103\n\x11\n\t\x04\x14\x03\0\x03\0\x02\0\x06\x12\x04\x8b\x03\x10$\n\x11\
    \n\t\x04\x14\x03\0\x03\0\x02\0\x01\x12\x04\x8b\x03%.\n\x11\n\t\x04\x14\
    \x03\0\x03\0\x02\0\x03\x12\x04\x8b\x0312\n\x10\n\x08\x04\x14\x03\0\x03\0\
    \x02\x01\x12\x04\x8c\x03\x103\n\x11\n\t\x04\x14\x03\0\x03\0\x02\x01\x06\
    \x12\x04\x8c\x03\x10$\n\x11\n\t\x04\x14\x03\0\x03\0\x02\x01\x01\x12\x04\
    \x8c\x03%.\n\x11\n\t\x04\x14\x03\0\x03\0\x02\x01\x03\x12\x04\x8c\x0312\n\
    \x10\n\x06\x04\x14\x03\0\x03\x01\x12\x06\x90\x03\x08\x93\x03\t\n\x0f\n\
    \x07\x04\x14\x03\0\x03\x01\x01\x12\x04\x90\x03\x10\x1b\n\x10\n\x08\x04\
    \x14\x03\0\x03\x01\x02\0\x12\x04\x91\x03\x0c-\n\x11\n\t\x04\x14\x03\0\
    \x03\x01\x02\0\x04\x12\x04\x91\x03\x0c\x14\n\x11\n\t\x04\x14\x03\0\x03\
    \x01\x02\0\x05\x12\x04\x91\x03\x15\x1b\n\x11\n\t\x04\x14\x03\0\x03\x01\
    \x02\0\x01\x12\x04\x91\x03\x1c(\n\x11\n\t\x04\x14\x03\0\x03\x01\x02\0\
    \x03\x12\x04\x91\x03+,\n\x10\n\x08\x04\x14\x03\0\x03\x01\x02\x01\x12\x04\
    \x92\x03\x0c*\n\x11\n\t\x04\x14\x03\0\x03\x01\x02\x01\x04\x12\x04\x92\
    \x03\x0c\x14\n\x11\n\t\x04\x14\x03\0\x03\x01\x02\x01\x05\x12\x04\x92\x03\
    \x15\x1a\n\x11\n\t\x04\x14\x03\0\x03\x01\x02\x01\x01\x12\x04\x92\x03\x1b\
    %\n\x11\n\t\x04\x14\x03\0\x03\x01\x02\x01\x03\x12\x04\x92\x03()\n\x0e\n\
    \x06\x04\x14\x03\0\x02\0\x12\x04\x95\x03\x08$\n\x0f\n\x07\x04\x14\x03\0\
    \x02\0\x04\x12\x04\x95\x03\x08\x10\n\x0f\n\x07\x04\x14\x03\0\x02\0\x05\
    \x12\x04\x95\x03\x11\x17\n\x0f\n\x07\x04\x14\x03\0\x02\0\x01\x12\x04\x95\
    \x03\x18\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\0\x03\x12\x04\x95\x03\"#\n\
    \x10\n\x06\x04\x14\x03\0\x08\0\x12\x06\x96\x03\x08\x99\x03\t\n\x0f\n\x07\
    \x04\x14\x03\0\x08\0\x01\x12\x04\x96\x03\x0e\x18\n\x0e\n\x06\x04\x14\x03\
    \0\x02\x01\x12\x04\x97\x03\x0c%\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x06\
    \x12\x04\x97\x03\x0c\x17\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x01\x12\x04\
    \x97\x03\x18\x20\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x03\x12\x04\x97\x03#$\
    \n\x0e\n\x06\x04\x14\x03\0\x02\x02\x12\x04\x98\x03\x0c%\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x02\x06\x12\x04\x98\x03\x0c\x17\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x02\x01\x12\x04\x98\x03\x18\x20\n\x0f\n\x07\x04\x14\x03\0\x02\x02\
    \x03\x12\x04\x98\x03#$\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x9c\x03\x04\"\n\
    \r\n\x05\x04\x14\x02\0\x04\x12\x04\x9c\x03\x04\x0c\n\r\n\x05\x04\x14\x02\
    \0\x05\x12\x04\x9c\x03\r\x13\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x9c\x03\
    \x14\x1d\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x9c\x03\x20!\n\x0c\n\x04\
    \x04\x14\x02\x01\x12\x04\x9d\x03\x04$\n\r\n\x05\x04\x14\x02\x01\x04\x12\
    \x04\x9d\x03\x04\x0c\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\x9d\x03\r\x13\
    \n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x9d\x03\x14\x1f\n\r\n\x05\x04\x14\
    \x02\x01\x03\x12\x04\x9d\x03\"#\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\x9e\
    \x03\x04\x1f\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\x9e\x03\x04\x0c\n\r\n\
    \x05\x04\x14\x02\x02\x05\x12\x04\x9e\x03\r\x13\n\r\n\x05\x04\x14\x02\x02\
    \x01\x12\x04\x9e\x03\x14\x1a\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x9e\
    \x03\x1d\x1e\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\x9f\x03\x04#\n\r\n\x05\
    \x04\x14\x02\x03\x04\x12\x04\x9f\x03\x04\x0c\n\r\n\x05\x04\x14\x02\x03\
    \x05\x12\x04\x9f\x03\r\x13\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\x9f\x03\
    \x14\x1e\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\x9f\x03!\"\n\x0c\n\x04\
    \x04\x14\x02\x04\x12\x04\xa0\x03\x04#\n\r\n\x05\x04\x14\x02\x04\x04\x12\
    \x04\xa0\x03\x04\x0c\n\r\n\x05\x04\x14\x02\x04\x05\x12\x04\xa0\x03\r\x13\
    \n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\xa0\x03\x14\x1e\n\r\n\x05\x04\x14\
    \x02\x04\x03\x12\x04\xa0\x03!\"\n\x0c\n\x04\x04\x14\x02\x05\x12\x04\xa1\
    \x03\x04;\n\r\n\x05\x04\x14\x02\x05\x04\x12\x04\xa1\x03\x04\x0c\n\r\n\
    \x05\x04\x14\x02\x05\x06\x12\x04\xa1\x03\r$\n\r\n\x05\x04\x14\x02\x05\
    \x01\x12\x04\xa1\x03%6\n\r\n\x05\x04\x14\x02\x05\x03\x12\x04\xa1\x039:\n\
    \x0c\n\x04\x04\x14\x02\x06\x12\x04\xa2\x03\x04(\n\r\n\x05\x04\x14\x02\
    \x06\x04\x12\x04\xa2\x03\x04\x0c\n\r\n\x05\x04\x14\x02\x06\x05\x12\x04\
    \xa2\x03\r\x13\n\r\n\x05\x04\x14\x02\x06\x01\x12\x04\xa2\x03\x14#\n\r\n\
    \x05\x04\x14\x02\x06\x03\x12\x04\xa2\x03&'\n\x0c\n\x04\x04\x14\x02\x07\
    \x12\x04\xa3\x03\x04(\n\r\n\x05\x04\x14\x02\x07\x04\x12\x04\xa3\x03\x04\
    \x0c\n\r\n\x05\x04\x14\x02\x07\x05\x12\x04\xa3\x03\r\x13\n\r\n\x05\x04\
    \x14\x02\x07\x01\x12\x04\xa3\x03\x14#\n\r\n\x05\x04\x14\x02\x07\x03\x12\
    \x04\xa3\x03&'\n\x0c\n\x04\x04\x14\x02\x08\x12\x04\xa4\x03\x04-\n\r\n\
    \x05\x04\x14\x02\x08\x04\x12\x04\xa4\x03\x04\x0c\n\r\n\x05\x04\x14\x02\
    \x08\x06\x12\x04\xa4\x03\r\x1c\n\r\n\x05\x04\x14\x02\x08\x01\x12\x04\xa4\
    \x03\x1d(\n\r\n\x05\x04\x14\x02\x08\x03\x12\x04\xa4\x03+,\n\x0c\n\x02\
    \x04\x15\x12\x06\xa7\x03\0\xb4\x03\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\
    \xa7\x03\x08\x1a\n\x0e\n\x04\x04\x15\x04\0\x12\x06\xa8\x03\x04\xab\x03\
    \x05\n\r\n\x05\x04\x15\x04\0\x01\x12\x04\xa8\x03\t\x12\n\x0e\n\x06\x04\
    \x15\x04\0\x02\0\x12\x04\xa9\x03\x08\x14\n\x0f\n\x07\x04\x15\x04\0\x02\0\
    \x01\x12\x04\xa9\x03\x08\x0f\n\x0f\n\x07\x04\x15\x04\0\x02\0\x02\x12\x04\
    \xa9\x03\x12\x13\n\x0e\n\x06\x04\x15\x04\0\x02\x01\x12\x04\xaa\x03\x08\
    \x13\n\x0f\n\x07\x04\x15\x04\0\x02\x01\x01\x12\x04\xaa\x03\x08\x0e\n\x0f\
    \n\x07\x04\x15\x04\0\x02\x01\x02\x12\x04\xaa\x03\x11\x12\n\x0c\n\x04\x04\
    \x15\x02\0\x12\x04\xac\x03\x04!\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xac\
    \x03\x04\x0c\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xac\x03\r\x13\n\r\n\x05\
    \x04\x15\x02\0\x01\x12\x04\xac\x03\x14\x1c\n\r\n\x05\x04\x15\x02\0\x03\
    \x12\x04\xac\x03\x1f\x20\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xad\x03\x04\
    #\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xad\x03\x04\x0c\n\r\n\x05\x04\
    \x15\x02\x01\x05\x12\x04\xad\x03\r\x13\n\r\n\x05\x04\x15\x02\x01\x01\x12\
    \x04\xad\x03\x14\x1e\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xad\x03!\"\n\
    \x0c\n\x04\x04\x15\x02\x02\x12\x04\xae\x03\x04(\n\r\n\x05\x04\x15\x02\
    \x02\x04\x12\x04\xae\x03\x04\x0c\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\
    \xae\x03\r\x12\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xae\x03\x13#\n\r\n\
    \x05\x04\x15\x02\x02\x03\x12\x04\xae\x03&'\n\x0c\n\x04\x04\x15\x02\x03\
    \x12\x04\xaf\x03\x04\"\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xaf\x03\x04\
    \x0c\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xaf\x03\r\x13\n\r\n\x05\x04\
    \x15\x02\x03\x01\x12\x04\xaf\x03\x14\x1d\n\r\n\x05\x04\x15\x02\x03\x03\
    \x12\x04\xaf\x03\x20!\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\xb0\x03\x04%\n\
    \r\n\x05\x04\x15\x02\x04\x04\x12\x04\xb0\x03\x04\x0c\n\r\n\x05\x04\x15\
    \x02\x04\x05\x12\x04\xb0\x03\r\x12\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\
    \xb0\x03\x13\x20\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xb0\x03#$\n\x0c\n\
    \x04\x04\x15\x02\x05\x12\x04\xb1\x03\x04\x20\n\r\n\x05\x04\x15\x02\x05\
    \x04\x12\x04\xb1\x03\x04\x0c\n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\xb1\
    \x03\r\x13\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\xb1\x03\x14\x1b\n\r\n\
    \x05\x04\x15\x02\x05\x03\x12\x04\xb1\x03\x1e\x1f\n\x0c\n\x04\x04\x15\x02\
    \x06\x12\x04\xb2\x03\x04)\n\r\n\x05\x04\x15\x02\x06\x04\x12\x04\xb2\x03\
    \x04\x0c\n\r\n\x05\x04\x15\x02\x06\x06\x12\x04\xb2\x03\r\x18\n\r\n\x05\
    \x04\x15\x02\x06\x01\x12\x04\xb2\x03\x19$\n\r\n\x05\x04\x15\x02\x06\x03\
    \x12\x04\xb2\x03'(\n\x0c\n\x04\x04\x15\x02\x07\x12\x04\xb3\x03\x04%\n\r\
    \n\x05\x04\x15\x02\x07\x04\x12\x04\xb3\x03\x04\x0c\n\r\n\x05\x04\x15\x02\
    \x07\x06\x12\x04\xb3\x03\r\x16\n\r\n\x05\x04\x15\x02\x07\x01\x12\x04\xb3\
    \x03\x17\x20\n\r\n\x05\x04\x15\x02\x07\x03\x12\x04\xb3\x03#$\n\x0c\n\x02\
    \x04\x16\x12\x06\xb6\x03\0\xb8\x03\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\
    \xb6\x03\x08\x1a\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xb7\x03\x04!\n\r\n\
    \x05\x04\x16\x02\0\x04\x12\x04\xb7\x03\x04\x0c\n\r\n\x05\x04\x16\x02\0\
    \x06\x12\x04\xb7\x03\r\x14\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xb7\x03\
    \x15\x1c\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xb7\x03\x1f\x20\n\x0c\n\x02\
    \x04\x17\x12\x06\xba\x03\0\xea\x03\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\
    \xba\x03\x08\x1b\n\x0e\n\x04\x04\x17\x04\0\x12\x06\xbb\x03\x04\xbe\x03\
    \x05\n\r\n\x05\x04\x17\x04\0\x01\x12\x04\xbb\x03\t\x14\n\x0e\n\x06\x04\
    \x17\x04\0\x02\0\x12\x04\xbc\x03\x08\x11\n\x0f\n\x07\x04\x17\x04\0\x02\0\
    \x01\x12\x04\xbc\x03\x08\x0c\n\x0f\n\x07\x04\x17\x04\0\x02\0\x02\x12\x04\
    \xbc\x03\x0f\x10\n\x0e\n\x06\x04\x17\x04\0\x02\x01\x12\x04\xbd\x03\x08\
    \x12\n\x0f\n\x07\x04\x17\x04\0\x02\x01\x01\x12\x04\xbd\x03\x08\r\n\x0f\n\
    \x07\x04\x17\x04\0\x02\x01\x02\x12\x04\xbd\x03\x10\x11\n\x0e\n\x04\x04\
    \x17\x04\x01\x12\x06\xbf\x03\x04\xc4\x03\x05\n\r\n\x05\x04\x17\x04\x01\
    \x01\x12\x04\xbf\x03\t\x1c\n\x0e\n\x06\x04\x17\x04\x01\x02\0\x12\x04\xc0\
    \x03\x08\x14\n\x0f\n\x07\x04\x17\x04\x01\x02\0\x01\x12\x04\xc0\x03\x08\
    \x0f\n\x0f\n\x07\x04\x17\x04\x01\x02\0\x02\x12\x04\xc0\x03\x12\x13\n\x0e\
    \n\x06\x04\x17\x04\x01\x02\x01\x12\x04\xc1\x03\x08\x13\n\x0f\n\x07\x04\
    \x17\x04\x01\x02\x01\x01\x12\x04\xc1\x03\x08\x0e\n\x0f\n\x07\x04\x17\x04\
    \x01\x02\x01\x02\x12\x04\xc1\x03\x11\x12\n\x0e\n\x06\x04\x17\x04\x01\x02\
    \x02\x12\x04\xc2\x03\x08\x10\n\x0f\n\x07\x04\x17\x04\x01\x02\x02\x01\x12\
    \x04\xc2\x03\x08\x0b\n\x0f\n\x07\x04\x17\x04\x01\x02\x02\x02\x12\x04\xc2\
    \x03\x0e\x0f\n\x0e\n\x06\x04\x17\x04\x01\x02\x03\x12\x04\xc3\x03\x08\x18\
    \n\x0f\n\x07\x04\x17\x04\x01\x02\x03\x01\x12\x04\xc3\x03\x08\x13\n\x0f\n\
    \x07\x04\x17\x04\x01\x02\x03\x02\x12\x04\xc3\x03\x16\x17\n\x0e\n\x04\x04\
    \x17\x04\x02\x12\x06\xc5\x03\x04\xd1\x03\x05\n\r\n\x05\x04\x17\x04\x02\
    \x01\x12\x04\xc5\x03\t\x11\n\x0e\n\x06\x04\x17\x04\x02\x02\0\x12\x04\xc6\
    \x03\x08\x17\n\x0f\n\x07\x04\x17\x04\x02\x02\0\x01\x12\x04\xc6\x03\x08\
    \x12\n\x0f\n\x07\x04\x17\x04\x02\x02\0\x02\x12\x04\xc6\x03\x15\x16\n\x0e\
    \n\x06\x04\x17\x04\x02\x02\x01\x12\x04\xc7\x03\x08\x12\n\x0f\n\x07\x04\
    \x17\x04\x02\x02\x01\x01\x12\x04\xc7\x03\x08\r\n\x0f\n\x07\x04\x17\x04\
    \x02\x02\x01\x02\x12\x04\xc7\x03\x10\x11\n\x0e\n\x06\x04\x17\x04\x02\x02\
    \x02\x12\x04\xc8\x03\x08\x1c\n\x0f\n\x07\x04\x17\x04\x02\x02\x02\x01\x12\
    \x04\xc8\x03\x08\x17\n\x0f\n\x07\x04\x17\x04\x02\x02\x02\x02\x12\x04\xc8\
    \x03\x1a\x1b\n\x0e\n\x06\x04\x17\x04\x02\x02\x03\x12\x04\xc9\x03\x08\x1a\
    \n\x0f\n\x07\x04\x17\x04\x02\x02\x03\x01\x12\x04\xc9\x03\x08\x15\n\x0f\n\
    \x07\x04\x17\x04\x02\x02\x03\x02\x12\x04\xc9\x03\x18\x19\n\x0e\n\x06\x04\
    \x17\x04\x02\x02\x04\x12\x04\xca\x03\x08\x1e\n\x0f\n\x07\x04\x17\x04\x02\
    \x02\x04\x01\x12\x04\xca\x03\x08\x19\n\x0f\n\x07\x04\x17\x04\x02\x02\x04\
    \x02\x12\x04\xca\x03\x1c\x1d\n\x0e\n\x06\x04\x17\x04\x02\x02\x05\x12\x04\
    \xcb\x03\x08\x19\n\x0f\n\x07\x04\x17\x04\x02\x02\x05\x01\x12\x04\xcb\x03\
    \x08\x14\n\x0f\n\x07\x04\x17\x04\x02\x02\x05\x02\x12\x04\xcb\x03\x17\x18\
    \n\x0e\n\x06\x04\x17\x04\x02\x02\x06\x12\x04\xcc\x03\x08\x1b\n\x0f\n\x07\
    \x04\x17\x04\x02\x02\x06\x01\x12\x04\xcc\x03\x08\x16\n\x0f\n\x07\x04\x17\
    \x04\x02\x02\x06\x02\x12\x04\xcc\x03\x19\x1a\n\x0e\n\x06\x04\x17\x04\x02\
    \x02\x07\x12\x04\xcd\x03\x08\"\n\x0f\n\x07\x04\x17\x04\x02\x02\x07\x01\
    \x12\x04\xcd\x03\x08\x1d\n\x0f\n\x07\x04\x17\x04\x02\x02\x07\x02\x12\x04\
    \xcd\x03\x20!\n\x0e\n\x06\x04\x17\x04\x02\x02\x08\x12\x04\xce\x03\x08\
    \x1e\n\x0f\n\x07\x04\x17\x04\x02\x02\x08\x01\x12\x04\xce\x03\x08\x19\n\
    \x0f\n\x07\x04\x17\x04\x02\x02\x08\x02\x12\x04\xce\x03\x1c\x1d\n\x0e\n\
    \x06\x04\x17\x04\x02\x02\t\x12\x04\xcf\x03\x08\x1b\n\x0f\n\x07\x04\x17\
    \x04\x02\x02\t\x01\x12\x04\xcf\x03\x08\x16\n\x0f\n\x07\x04\x17\x04\x02\
    \x02\t\x02\x12\x04\xcf\x03\x19\x1a\n\x0e\n\x06\x04\x17\x04\x02\x02\n\x12\
    \x04\xd0\x03\x08\x1f\n\x0f\n\x07\x04\x17\x04\x02\x02\n\x01\x12\x04\xd0\
    \x03\x08\x19\n\x0f\n\x07\x04\x17\x04\x02\x02\n\x02\x12\x04\xd0\x03\x1c\
    \x1e\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xd2\x03\x04\x1d\n\r\n\x05\x04\x17\
    \x02\0\x04\x12\x04\xd2\x03\x04\x0c\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\
    \xd2\x03\r\x13\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xd2\x03\x14\x18\n\r\n\
    \x05\x04\x17\x02\0\x03\x12\x04\xd2\x03\x1b\x1c\n\x0c\n\x04\x04\x17\x02\
    \x01\x12\x04\xd3\x03\x04$\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xd3\x03\
    \x04\x0c\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xd3\x03\r\x13\n\r\n\x05\
    \x04\x17\x02\x01\x01\x12\x04\xd3\x03\x14\x1f\n\r\n\x05\x04\x17\x02\x01\
    \x03\x12\x04\xd3\x03\"#\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xd4\x03\x04%\
    \n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xd4\x03\x04\x0c\n\r\n\x05\x04\x17\
    \x02\x02\x05\x12\x04\xd4\x03\r\x13\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\
    \xd4\x03\x14\x20\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xd4\x03#$\n\x0c\n\
    \x04\x04\x17\x02\x03\x12\x04\xd5\x03\x04$\n\r\n\x05\x04\x17\x02\x03\x04\
    \x12\x04\xd5\x03\x04\x0c\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xd5\x03\r\
    \x13\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xd5\x03\x14\x1f\n\r\n\x05\x04\
    \x17\x02\x03\x03\x12\x04\xd5\x03\"#\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\
    \xd6\x03\x04\x1e\n\r\n\x05\x04\x17\x02\x04\x04\x12\x04\xd6\x03\x04\x0c\n\
    \r\n\x05\x04\x17\x02\x04\x05\x12\x04\xd6\x03\r\x13\n\r\n\x05\x04\x17\x02\
    \x04\x01\x12\x04\xd6\x03\x14\x19\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\
    \xd6\x03\x1c\x1d\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xd7\x03\x04\"\n\r\n\
    \x05\x04\x17\x02\x05\x04\x12\x04\xd7\x03\x04\x0c\n\r\n\x05\x04\x17\x02\
    \x05\x05\x12\x04\xd7\x03\r\x14\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\xd7\
    \x03\x15\x1d\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\xd7\x03\x20!\n\x0c\n\
    \x04\x04\x17\x02\x06\x12\x04\xd8\x03\x04(\n\r\n\x05\x04\x17\x02\x06\x04\
    \x12\x04\xd8\x03\x04\x0c\n\r\n\x05\x04\x17\x02\x06\x05\x12\x04\xd8\x03\r\
    \x14\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\xd8\x03\x15#\n\r\n\x05\x04\
    \x17\x02\x06\x03\x12\x04\xd8\x03&'\n\x0c\n\x04\x04\x17\x02\x07\x12\x04\
    \xd9\x03\x04\x1f\n\r\n\x05\x04\x17\x02\x07\x04\x12\x04\xd9\x03\x04\x0c\n\
    \r\n\x05\x04\x17\x02\x07\x06\x12\x04\xd9\x03\r\x15\n\r\n\x05\x04\x17\x02\
    \x07\x01\x12\x04\xd9\x03\x16\x1a\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\
    \xd9\x03\x1d\x1e\n\x0c\n\x04\x04\x17\x02\x08\x12\x04\xda\x03\x04*\n\r\n\
    \x05\x04\x17\x02\x08\x04\x12\x04\xda\x03\x04\x0c\n\r\n\x05\x04\x17\x02\
    \x08\x06\x12\x04\xda\x03\r\x18\n\r\n\x05\x04\x17\x02\x08\x01\x12\x04\xda\
    \x03\x19$\n\r\n\x05\x04\x17\x02\x08\x03\x12\x04\xda\x03')\n\x0c\n\x04\
    \x04\x17\x02\t\x12\x04\xdb\x03\x04&\n\r\n\x05\x04\x17\x02\t\x04\x12\x04\
    \xdb\x03\x04\x0c\n\r\n\x05\x04\x17\x02\t\x05\x12\x04\xdb\x03\r\x12\n\r\n\
    \x05\x04\x17\x02\t\x01\x12\x04\xdb\x03\x13\x20\n\r\n\x05\x04\x17\x02\t\
    \x03\x12\x04\xdb\x03#%\n\x0c\n\x04\x04\x17\x02\n\x12\x04\xdc\x03\x04*\n\
    \r\n\x05\x04\x17\x02\n\x04\x12\x04\xdc\x03\x04\x0c\n\r\n\x05\x04\x17\x02\
    \n\x06\x12\x04\xdc\x03\r\x18\n\r\n\x05\x04\x17\x02\n\x01\x12\x04\xdc\x03\
    \x19$\n\r\n\x05\x04\x17\x02\n\x03\x12\x04\xdc\x03')\n\x0c\n\x04\x04\x17\
    \x02\x0b\x12\x04\xdd\x03\x04'\n\r\n\x05\x04\x17\x02\x0b\x04\x12\x04\xdd\
    \x03\x04\x0c\n\r\n\x05\x04\x17\x02\x0b\x05\x12\x04\xdd\x03\r\x11\n\r\n\
    \x05\x04\x17\x02\x0b\x01\x12\x04\xdd\x03\x12!\n\r\n\x05\x04\x17\x02\x0b\
    \x03\x12\x04\xdd\x03$&\n\x0c\n\x04\x04\x17\x02\x0c\x12\x04\xde\x03\x04-\
    \n\r\n\x05\x04\x17\x02\x0c\x04\x12\x04\xde\x03\x04\x0c\n\r\n\x05\x04\x17\
    \x02\x0c\x05\x12\x04\xde\x03\r\x13\n\r\n\x05\x04\x17\x02\x0c\x01\x12\x04\
    \xde\x03\x14'\n\r\n\x05\x04\x17\x02\x0c\x03\x12\x04\xde\x03*,\n\x0c\n\
    \x04\x04\x17\x02\r\x12\x04\xdf\x03\x04(\n\r\n\x05\x04\x17\x02\r\x04\x12\
    \x04\xdf\x03\x04\x0c\n\r\n\x05\x04\x17\x02\r\x05\x12\x04\xdf\x03\r\x12\n\
    \r\n\x05\x04\x17\x02\r\x01\x12\x04\xdf\x03\x13\"\n\r\n\x05\x04\x17\x02\r\
    \x03\x12\x04\xdf\x03%'\n\x0c\n\x04\x04\x17\x02\x0e\x12\x04\xe0\x03\x04+\
    \n\r\n\x05\x04\x17\x02\x0e\x04\x12\x04\xe0\x03\x04\x0c\n\r\n\x05\x04\x17\
    \x02\x0e\x05\x12\x04\xe0\x03\r\x12\n\r\n\x05\x04\x17\x02\x0e\x01\x12\x04\
    \xe0\x03\x13%\n\r\n\x05\x04\x17\x02\x0e\x03\x12\x04\xe0\x03(*\n\x0c\n\
    \x04\x04\x17\x02\x0f\x12\x04\xe1\x03\x04!\n\r\n\x05\x04\x17\x02\x0f\x04\
    \x12\x04\xe1\x03\x04\x0c\n\r\n\x05\x04\x17\x02\x0f\x05\x12\x04\xe1\x03\r\
    \x12\n\r\n\x05\x04\x17\x02\x0f\x01\x12\x04\xe1\x03\x13\x1b\n\r\n\x05\x04\
    \x17\x02\x0f\x03\x12\x04\xe1\x03\x1e\x20\n\x0c\n\x04\x04\x17\x02\x10\x12\
    \x04\xe2\x03\x04*\n\r\n\x05\x04\x17\x02\x10\x04\x12\x04\xe2\x03\x04\x0c\
    \n\r\n\x05\x04\x17\x02\x10\x05\x12\x04\xe2\x03\r\x12\n\r\n\x05\x04\x17\
    \x02\x10\x01\x12\x04\xe2\x03\x13$\n\r\n\x05\x04\x17\x02\x10\x03\x12\x04\
    \xe2\x03')\n\x0c\n\x04\x04\x17\x02\x11\x12\x04\xe3\x03\x04)\n\r\n\x05\
    \x04\x17\x02\x11\x04\x12\x04\xe3\x03\x04\x0c\n\r\n\x05\x04\x17\x02\x11\
    \x05\x12\x04\xe3\x03\r\x13\n\r\n\x05\x04\x17\x02\x11\x01\x12\x04\xe3\x03\
    \x14#\n\r\n\x05\x04\x17\x02\x11\x03\x12\x04\xe3\x03&(\n\x0c\n\x04\x04\
    \x17\x02\x12\x12\x04\xe4\x03\x04(\n\r\n\x05\x04\x17\x02\x12\x04\x12\x04\
    \xe4\x03\x04\x0c\n\r\n\x05\x04\x17\x02\x12\x05\x12\x04\xe4\x03\r\x13\n\r\
    \n\x05\x04\x17\x02\x12\x01\x12\x04\xe4\x03\x14\"\n\r\n\x05\x04\x17\x02\
    \x12\x03\x12\x04\xe4\x03%'\n\x0c\n\x04\x04\x17\x02\x13\x12\x04\xe5\x03\
    \x04:\n\r\n\x05\x04\x17\x02\x13\x04\x12\x04\xe5\x03\x04\x0c\n\r\n\x05\
    \x04\x17\x02\x13\x06\x12\x04\xe5\x03\r\x20\n\r\n\x05\x04\x17\x02\x13\x01\
    \x12\x04\xe5\x03!4\n\r\n\x05\x04\x17\x02\x13\x03\x12\x04\xe5\x0379\n\x0c\
    \n\x04\x04\x17\x02\x14\x12\x04\xe6\x03\x048\n\r\n\x05\x04\x17\x02\x14\
    \x04\x12\x04\xe6\x03\x04\x0c\n\r\n\x05\x04\x17\x02\x14\x05\x12\x04\xe6\
    \x03\r\x13\n\r\n\x05\x04\x17\x02\x14\x01\x12\x04\xe6\x03\x142\n\r\n\x05\
    \x04\x17\x02\x14\x03\x12\x04\xe6\x0357\n\x0c\n\x04\x04\x17\x02\x15\x12\
    \x04\xe7\x03\x049\n\r\n\x05\x04\x17\x02\x15\x04\x12\x04\xe7\x03\x04\x0c\
    \n\r\n\x05\x04\x17\x02\x15\x05\x12\x04\xe7\x03\r\x12\n\r\n\x05\x04\x17\
    \x02\x15\x01\x12\x04\xe7\x03\x133\n\r\n\x05\x04\x17\x02\x15\x03\x12\x04\
    \xe7\x0368\n\x0c\n\x04\x04\x17\x02\x16\x12\x04\xe8\x03\x04<\n\r\n\x05\
    \x04\x17\x02\x16\x04\x12\x04\xe8\x03\x04\x0c\n\r\n\x05\x04\x17\x02\x16\
    \x06\x12\x04\xe8\x03\r\x20\n\r\n\x05\x04\x17\x02\x16\x01\x12\x04\xe8\x03\
    !6\n\r\n\x05\x04\x17\x02\x16\x03\x12\x04\xe8\x039;\n\x0c\n\x04\x04\x17\
    \x02\x17\x12\x04\xe9\x03\x04\x20\n\r\n\x05\x04\x17\x02\x17\x04\x12\x04\
    \xe9\x03\x04\x0c\n\r\n\x05\x04\x17\x02\x17\x05\x12\x04\xe9\x03\r\x11\n\r\
    \n\x05\x04\x17\x02\x17\x01\x12\x04\xe9\x03\x12\x1a\n\r\n\x05\x04\x17\x02\
    \x17\x03\x12\x04\xe9\x03\x1d\x1f\n\x0c\n\x02\x04\x18\x12\x06\xec\x03\0\
    \xf0\x03\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\xec\x03\x08\x1a\n\x0c\n\x04\
    \x04\x18\x02\0\x12\x04\xed\x03\x04-\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\
    \xed\x03\x04\x0c\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xed\x03\r\x17\n\r\n\
    \x05\x04\x18\x02\0\x01\x12\x04\xed\x03\x18(\n\r\n\x05\x04\x18\x02\0\x03\
    \x12\x04\xed\x03+,\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xee\x03\x04\"\n\r\
    \n\x05\x04\x18\x02\x01\x04\x12\x04\xee\x03\x04\x0c\n\r\n\x05\x04\x18\x02\
    \x01\x05\x12\x04\xee\x03\r\x12\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xee\
    \x03\x13\x1d\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xee\x03\x20!\n\x0c\n\
    \x04\x04\x18\x02\x02\x12\x04\xef\x03\x04\x1d\n\r\n\x05\x04\x18\x02\x02\
    \x04\x12\x04\xef\x03\x04\x0c\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xef\
    \x03\r\x12\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xef\x03\x13\x18\n\r\n\
    \x05\x04\x18\x02\x02\x03\x12\x04\xef\x03\x1b\x1c\n\x0c\n\x02\x04\x19\x12\
    \x06\xf2\x03\0\x87\x04\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xf2\x03\x08\
    \x17\n\x0c\n\x04\x04\x19\x02\0\x12\x04\xf3\x03\x04\x1c\n\r\n\x05\x04\x19\
    \x02\0\x04\x12\x04\xf3\x03\x04\x0c\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\
    \xf3\x03\r\x13\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xf3\x03\x14\x17\n\r\n\
    \x05\x04\x19\x02\0\x03\x12\x04\xf3\x03\x1a\x1b\n\x0c\n\x04\x04\x19\x02\
    \x01\x12\x04\xf4\x03\x04!\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xf4\x03\
    \x04\x0c\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xf4\x03\r\x13\n\r\n\x05\
    \x04\x19\x02\x01\x01\x12\x04\xf4\x03\x14\x1c\n\r\n\x05\x04\x19\x02\x01\
    \x03\x12\x04\xf4\x03\x1f\x20\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xf5\x03\
    \x04\x1e\n\r\n\x05\x04\x19\x02\x02\x04\x12\x04\xf5\x03\x04\x0c\n\r\n\x05\
    \x04\x19\x02\x02\x05\x12\x04\xf5\x03\r\x13\n\r\n\x05\x04\x19\x02\x02\x01\
    \x12\x04\xf5\x03\x14\x19\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xf5\x03\
    \x1c\x1d\n\x0c\n\x04\x04\x19\x02\x03\x12\x04\xf6\x03\x04\"\n\r\n\x05\x04\
    \x19\x02\x03\x04\x12\x04\xf6\x03\x04\x0c\n\r\n\x05\x04\x19\x02\x03\x05\
    \x12\x04\xf6\x03\r\x12\n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xf6\x03\x13\
    \x1d\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xf6\x03\x20!\n\x0c\n\x04\x04\
    \x19\x02\x04\x12\x04\xf7\x03\x04#\n\r\n\x05\x04\x19\x02\x04\x04\x12\x04\
    \xf7\x03\x04\x0c\n\r\n\x05\x04\x19\x02\x04\x05\x12\x04\xf7\x03\r\x13\n\r\
    \n\x05\x04\x19\x02\x04\x01\x12\x04\xf7\x03\x14\x1e\n\r\n\x05\x04\x19\x02\
    \x04\x03\x12\x04\xf7\x03!\"\n\x0c\n\x04\x04\x19\x02\x05\x12\x04\xf8\x03\
    \x04\"\n\r\n\x05\x04\x19\x02\x05\x04\x12\x04\xf8\x03\x04\x0c\n\r\n\x05\
    \x04\x19\x02\x05\x05\x12\x04\xf8\x03\r\x13\n\r\n\x05\x04\x19\x02\x05\x01\
    \x12\x04\xf8\x03\x14\x1d\n\r\n\x05\x04\x19\x02\x05\x03\x12\x04\xf8\x03\
    \x20!\n\x0c\n\x04\x04\x19\x02\x06\x12\x04\xf9\x03\x04\x20\n\r\n\x05\x04\
    \x19\x02\x06\x04\x12\x04\xf9\x03\x04\x0c\n\r\n\x05\x04\x19\x02\x06\x05\
    \x12\x04\xf9\x03\r\x12\n\r\n\x05\x04\x19\x02\x06\x01\x12\x04\xf9\x03\x13\
    \x1b\n\r\n\x05\x04\x19\x02\x06\x03\x12\x04\xf9\x03\x1e\x1f\n\x0c\n\x04\
    \x04\x19\x02\x07\x12\x04\xfa\x03\x04!\n\r\n\x05\x04\x19\x02\x07\x04\x12\
    \x04\xfa\x03\x04\x0c\n\r\n\x05\x04\x19\x02\x07\x05\x12\x04\xfa\x03\r\x13\
    \n\r\n\x05\x04\x19\x02\x07\x01\x12\x04\xfa\x03\x14\x1c\n\r\n\x05\x04\x19\
    \x02\x07\x03\x12\x04\xfa\x03\x1f\x20\n\x0c\n\x04\x04\x19\x02\x08\x12\x04\
    \xfb\x03\x04%\n\r\n\x05\x04\x19\x02\x08\x04\x12\x04\xfb\x03\x04\x0c\n\r\
    \n\x05\x04\x19\x02\x08\x05\x12\x04\xfb\x03\r\x12\n\r\n\x05\x04\x19\x02\
    \x08\x01\x12\x04\xfb\x03\x13\x20\n\r\n\x05\x04\x19\x02\x08\x03\x12\x04\
    \xfb\x03#$\n\x0c\n\x04\x04\x19\x02\t\x12\x04\xfc\x03\x04$\n\r\n\x05\x04\
    \x19\x02\t\x04\x12\x04\xfc\x03\x04\x0c\n\r\n\x05\x04\x19\x02\t\x05\x12\
    \x04\xfc\x03\r\x13\n\r\n\x05\x04\x19\x02\t\x01\x12\x04\xfc\x03\x14\x1e\n\
    \r\n\x05\x04\x19\x02\t\x03\x12\x04\xfc\x03!#\n\x0c\n\x04\x04\x19\x02\n\
    \x12\x04\xfd\x03\x04*\n\r\n\x05\x04\x19\x02\n\x04\x12\x04\xfd\x03\x04\
    \x0c\n\r\n\x05\x04\x19\x02\n\x05\x12\x04\xfd\x03\r\x12\n\r\n\x05\x04\x19\
    \x02\n\x01\x12\x04\xfd\x03\x13$\n\r\n\x05\x04\x19\x02\n\x03\x12\x04\xfd\
    \x03')\n\x0c\n\x04\x04\x19\x02\x0b\x12\x04\xfe\x03\x04$\n\r\n\x05\x04\
    \x19\x02\x0b\x04\x12\x04\xfe\x03\x04\x0c\n\r\n\x05\x04\x19\x02\x0b\x05\
    \x12\x04\xfe\x03\r\x11\n\r\n\x05\x04\x19\x02\x0b\x01\x12\x04\xfe\x03\x12\
    \x1e\n\r\n\x05\x04\x19\x02\x0b\x03\x12\x04\xfe\x03!#\n\x0c\n\x04\x04\x19\
    \x02\x0c\x12\x04\xff\x03\x04-\n\r\n\x05\x04\x19\x02\x0c\x04\x12\x04\xff\
    \x03\x04\x0c\n\r\n\x05\x04\x19\x02\x0c\x05\x12\x04\xff\x03\r\x13\n\r\n\
    \x05\x04\x19\x02\x0c\x01\x12\x04\xff\x03\x14'\n\r\n\x05\x04\x19\x02\x0c\
    \x03\x12\x04\xff\x03*,\n\x0c\n\x04\x04\x19\x02\r\x12\x04\x80\x04\x04(\n\
    \r\n\x05\x04\x19\x02\r\x04\x12\x04\x80\x04\x04\x0c\n\r\n\x05\x04\x19\x02\
    \r\x05\x12\x04\x80\x04\r\x12\n\r\n\x05\x04\x19\x02\r\x01\x12\x04\x80\x04\
    \x13\"\n\r\n\x05\x04\x19\x02\r\x03\x12\x04\x80\x04%'\n\x0c\n\x04\x04\x19\
    \x02\x0e\x12\x04\x81\x04\x04+\n\r\n\x05\x04\x19\x02\x0e\x04\x12\x04\x81\
    \x04\x04\x0c\n\r\n\x05\x04\x19\x02\x0e\x05\x12\x04\x81\x04\r\x12\n\r\n\
    \x05\x04\x19\x02\x0e\x01\x12\x04\x81\x04\x13%\n\r\n\x05\x04\x19\x02\x0e\
    \x03\x12\x04\x81\x04(*\n\x0c\n\x04\x04\x19\x02\x0f\x12\x04\x82\x04\x04&\
    \n\r\n\x05\x04\x19\x02\x0f\x04\x12\x04\x82\x04\x04\x0c\n\r\n\x05\x04\x19\
    \x02\x0f\x05\x12\x04\x82\x04\r\x12\n\r\n\x05\x04\x19\x02\x0f\x01\x12\x04\
    \x82\x04\x13\x20\n\r\n\x05\x04\x19\x02\x0f\x03\x12\x04\x82\x04#%\n\x0c\n\
    \x04\x04\x19\x02\x10\x12\x04\x83\x04\x04*\n\r\n\x05\x04\x19\x02\x10\x04\
    \x12\x04\x83\x04\x04\x0c\n\r\n\x05\x04\x19\x02\x10\x06\x12\x04\x83\x04\r\
    \x18\n\r\n\x05\x04\x19\x02\x10\x01\x12\x04\x83\x04\x19$\n\r\n\x05\x04\
    \x19\x02\x10\x03\x12\x04\x83\x04')\n\x0c\n\x04\x04\x19\x02\x11\x12\x04\
    \x84\x04\x04)\n\r\n\x05\x04\x19\x02\x11\x04\x12\x04\x84\x04\x04\x0c\n\r\
    \n\x05\x04\x19\x02\x11\x05\x12\x04\x84\x04\r\x13\n\r\n\x05\x04\x19\x02\
    \x11\x01\x12\x04\x84\x04\x14#\n\r\n\x05\x04\x19\x02\x11\x03\x12\x04\x84\
    \x04&(\n\x0c\n\x04\x04\x19\x02\x12\x12\x04\x85\x04\x04(\n\r\n\x05\x04\
    \x19\x02\x12\x04\x12\x04\x85\x04\x04\x0c\n\r\n\x05\x04\x19\x02\x12\x05\
    \x12\x04\x85\x04\r\x13\n\r\n\x05\x04\x19\x02\x12\x01\x12\x04\x85\x04\x14\
    \"\n\r\n\x05\x04\x19\x02\x12\x03\x12\x04\x85\x04%'\n\x0c\n\x04\x04\x19\
    \x02\x13\x12\x04\x86\x04\x04!\n\r\n\x05\x04\x19\x02\x13\x04\x12\x04\x86\
    \x04\x04\x0c\n\r\n\x05\x04\x19\x02\x13\x05\x12\x04\x86\x04\r\x13\n\r\n\
    \x05\x04\x19\x02\x13\x01\x12\x04\x86\x04\x14\x1b\n\r\n\x05\x04\x19\x02\
    \x13\x03\x12\x04\x86\x04\x1e\x20\n\x0c\n\x02\x04\x1a\x12\x06\x89\x04\0\
    \x8d\x04\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\x89\x04\x08\x19\n\x0c\n\x04\
    \x04\x1a\x02\0\x12\x04\x8a\x04\x04'\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\
    \x8a\x04\x04\x0c\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\x8a\x04\r\x13\n\r\n\
    \x05\x04\x1a\x02\0\x01\x12\x04\x8a\x04\x14\"\n\r\n\x05\x04\x1a\x02\0\x03\
    \x12\x04\x8a\x04%&\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\x8b\x04\x04!\n\r\
    \n\x05\x04\x1a\x02\x01\x04\x12\x04\x8b\x04\x04\x0c\n\r\n\x05\x04\x1a\x02\
    \x01\x06\x12\x04\x8b\x04\r\x14\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\x8b\
    \x04\x15\x1c\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\x8b\x04\x1f\x20\n\x0c\
    \n\x04\x04\x1a\x02\x02\x12\x04\x8c\x04\x04\x1e\n\r\n\x05\x04\x1a\x02\x02\
    \x04\x12\x04\x8c\x04\x04\x0c\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\x8c\
    \x04\r\x13\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\x8c\x04\x14\x19\n\r\n\
    \x05\x04\x1a\x02\x02\x03\x12\x04\x8c\x04\x1c\x1d\n\x0c\n\x02\x04\x1b\x12\
    \x06\x8f\x04\0\x91\x04\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\x8f\x04\x08$\
    \n\x0c\n\x04\x04\x1b\x02\0\x12\x04\x90\x04\x04\x20\n\r\n\x05\x04\x1b\x02\
    \0\x04\x12\x04\x90\x04\x04\x0c\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\x90\
    \x04\r\x17\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x90\x04\x18\x1b\n\r\n\x05\
    \x04\x1b\x02\0\x03\x12\x04\x90\x04\x1e\x1f\n\x0c\n\x02\x04\x1c\x12\x06\
    \x93\x04\0\x97\x04\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x93\x04\x08\x1c\n\
    \x0c\n\x04\x04\x1c\x02\0\x12\x04\x94\x04\x04$\n\r\n\x05\x04\x1c\x02\0\
    \x04\x12\x04\x94\x04\x04\x0c\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\x94\x04\
    \r\x13\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\x94\x04\x14\x1f\n\r\n\x05\x04\
    \x1c\x02\0\x03\x12\x04\x94\x04\"#\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\
    \x95\x04\x04)\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\x95\x04\x04\x0c\n\r\
    \n\x05\x04\x1c\x02\x01\x06\x12\x04\x95\x04\r\x1b\n\r\n\x05\x04\x1c\x02\
    \x01\x01\x12\x04\x95\x04\x1c$\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\x95\
    \x04'(\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\x96\x04\x04*\n\r\n\x05\x04\
    \x1c\x02\x02\x04\x12\x04\x96\x04\x04\x0c\n\r\n\x05\x04\x1c\x02\x02\x06\
    \x12\x04\x96\x04\r\x18\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\x96\x04\x19\
    $\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\x96\x04')\n\x0c\n\x02\x04\x1d\
    \x12\x06\x99\x04\0\x9d\x04\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\x99\x04\
    \x08\x16\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\x9a\x04\x04$\n\r\n\x05\x04\
    \x1d\x02\0\x04\x12\x04\x9a\x04\x04\x0c\n\r\n\x05\x04\x1d\x02\0\x05\x12\
    \x04\x9a\x04\r\x13\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x9a\x04\x14\x1f\n\
    \r\n\x05\x04\x1d\x02\0\x03\x12\x04\x9a\x04\"#\n\x0c\n\x04\x04\x1d\x02\
    \x01\x12\x04\x9b\x04\x04\x1f\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\x9b\
    \x04\x04\x0c\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\x9b\x04\r\x13\n\r\n\
    \x05\x04\x1d\x02\x01\x01\x12\x04\x9b\x04\x14\x19\n\r\n\x05\x04\x1d\x02\
    \x01\x03\x12\x04\x9b\x04\x1c\x1e\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\x9c\
    \x04\x04*\n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\x9c\x04\x04\x0c\n\r\n\
    \x05\x04\x1d\x02\x02\x06\x12\x04\x9c\x04\r\x18\n\r\n\x05\x04\x1d\x02\x02\
    \x01\x12\x04\x9c\x04\x19$\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\x9c\x04'\
    )\n\x0c\n\x02\x04\x1e\x12\x06\x9f\x04\0\xa2\x04\x01\n\x0b\n\x03\x04\x1e\
    \x01\x12\x04\x9f\x04\x08\x0c\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xa0\x04\
    \x04$\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xa0\x04\x04\x0c\n\r\n\x05\x04\
    \x1e\x02\0\x05\x12\x04\xa0\x04\r\x13\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\
    \xa0\x04\x14\x1f\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xa0\x04\"#\n\x0c\n\
    \x04\x04\x1e\x02\x01\x12\x04\xa1\x04\x04\x1b\n\r\n\x05\x04\x1e\x02\x01\
    \x04\x12\x04\xa1\x04\x04\x0c\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\xa1\
    \x04\r\x13\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xa1\x04\x14\x16\n\r\n\
    \x05\x04\x1e\x02\x01\x03\x12\x04\xa1\x04\x19\x1a\n\x0c\n\x02\x04\x1f\x12\
    \x06\xa4\x04\0\xa6\x04\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xa4\x04\x08#\
    \n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xa5\x04\x04\x20\n\r\n\x05\x04\x1f\x02\
    \0\x04\x12\x04\xa5\x04\x04\x0c\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\xa5\
    \x04\r\x17\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xa5\x04\x18\x1b\n\r\n\x05\
    \x04\x1f\x02\0\x03\x12\x04\xa5\x04\x1e\x1f\n\x0c\n\x02\x04\x20\x12\x06\
    \xa8\x04\0\xad\x04\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xa8\x04\x08\x0c\n\
    \x0c\n\x04\x04\x20\x02\0\x12\x04\xa9\x04\x04\x1f\n\r\n\x05\x04\x20\x02\0\
    \x04\x12\x04\xa9\x04\x04\x0c\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xa9\x04\
    \r\x12\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xa9\x04\x13\x1a\n\r\n\x05\x04\
    \x20\x02\0\x03\x12\x04\xa9\x04\x1d\x1e\n\x0c\n\x04\x04\x20\x02\x01\x12\
    \x04\xaa\x04\x04)\n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\xaa\x04\x04\x0c\
    \n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xaa\x04\r\x13\n\r\n\x05\x04\x20\
    \x02\x01\x01\x12\x04\xaa\x04\x14$\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\
    \xaa\x04'(\n\x0c\n\x04\x04\x20\x02\x02\x12\x04\xab\x04\x04&\n\r\n\x05\
    \x04\x20\x02\x02\x04\x12\x04\xab\x04\x04\x0c\n\r\n\x05\x04\x20\x02\x02\
    \x05\x12\x04\xab\x04\r\x12\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xab\x04\
    \x13!\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xab\x04$%\n\x0c\n\x04\x04\
    \x20\x02\x03\x12\x04\xac\x04\x04/\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\
    \xac\x04\x04\x0c\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\xac\x04\r\x13\n\r\
    \n\x05\x04\x20\x02\x03\x01\x12\x04\xac\x04\x14*\n\r\n\x05\x04\x20\x02\
    \x03\x03\x12\x04\xac\x04-.\n\x0c\n\x02\x04!\x12\x06\xaf\x04\0\xba\x04\
    \x01\n\x0b\n\x03\x04!\x01\x12\x04\xaf\x04\x08\x1e\n\x0e\n\x04\x04!\x04\0\
    \x12\x06\xb0\x04\x04\xb3\x04\x05\n\r\n\x05\x04!\x04\0\x01\x12\x04\xb0\
    \x04\t\r\n\x0e\n\x06\x04!\x04\0\x02\0\x12\x04\xb1\x04\x08\x14\n\x0f\n\
    \x07\x04!\x04\0\x02\0\x01\x12\x04\xb1\x04\x08\x0f\n\x0f\n\x07\x04!\x04\0\
    \x02\0\x02\x12\x04\xb1\x04\x12\x13\n\x0e\n\x06\x04!\x04\0\x02\x01\x12\
    \x04\xb2\x04\x08\x19\n\x0f\n\x07\x04!\x04\0\x02\x01\x01\x12\x04\xb2\x04\
    \x08\x14\n\x0f\n\x07\x04!\x04\0\x02\x01\x02\x12\x04\xb2\x04\x17\x18\n\
    \x0c\n\x04\x04!\x02\0\x12\x04\xb4\x04\x04)\n\r\n\x05\x04!\x02\0\x04\x12\
    \x04\xb4\x04\x04\x0c\n\r\n\x05\x04!\x02\0\x05\x12\x04\xb4\x04\r\x13\n\r\
    \n\x05\x04!\x02\0\x01\x12\x04\xb4\x04\x14$\n\r\n\x05\x04!\x02\0\x03\x12\
    \x04\xb4\x04'(\n\x0c\n\x04\x04!\x02\x01\x12\x04\xb5\x04\x04)\n\r\n\x05\
    \x04!\x02\x01\x04\x12\x04\xb5\x04\x04\x0c\n\r\n\x05\x04!\x02\x01\x06\x12\
    \x04\xb5\x04\r\x18\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xb5\x04\x19$\n\r\n\
    \x05\x04!\x02\x01\x03\x12\x04\xb5\x04'(\n\x0c\n\x04\x04!\x02\x02\x12\x04\
    \xb6\x04\x04\x1b\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xb6\x04\x04\x0c\n\r\
    \n\x05\x04!\x02\x02\x06\x12\x04\xb6\x04\r\x11\n\r\n\x05\x04!\x02\x02\x01\
    \x12\x04\xb6\x04\x12\x16\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xb6\x04\x19\
    \x1a\n\x0e\n\x04\x04!\x08\0\x12\x06\xb7\x04\x04\xb9\x04\x05\n\r\n\x05\
    \x04!\x08\0\x01\x12\x04\xb7\x04\n\x12\n\x0c\n\x04\x04!\x02\x03\x12\x04\
    \xb8\x04\x08'\n\r\n\x05\x04!\x02\x03\x05\x12\x04\xb8\x04\x08\x0e\n\r\n\
    \x05\x04!\x02\x03\x01\x12\x04\xb8\x04\x0f\"\n\r\n\x05\x04!\x02\x03\x03\
    \x12\x04\xb8\x04%&\n\x0c\n\x02\x04\"\x12\x06\xbc\x04\0\xe7\x04\x01\n\x0b\
    \n\x03\x04\"\x01\x12\x04\xbc\x04\x08\x16\n\x0e\n\x04\x04\"\x04\0\x12\x06\
    \xbd\x04\x04\xc5\x04\x05\n\r\n\x05\x04\"\x04\0\x01\x12\x04\xbd\x04\t\x13\
    \n\x0e\n\x06\x04\"\x04\0\x02\0\x12\x04\xbe\x04\x08\x14\n\x0f\n\x07\x04\"\
    \x04\0\x02\0\x01\x12\x04\xbe\x04\x08\x0f\n\x0f\n\x07\x04\"\x04\0\x02\0\
    \x02\x12\x04\xbe\x04\x12\x13\n\x0e\n\x06\x04\"\x04\0\x02\x01\x12\x04\xbf\
    \x04\x08\x12\n\x0f\n\x07\x04\"\x04\0\x02\x01\x01\x12\x04\xbf\x04\x08\r\n\
    \x0f\n\x07\x04\"\x04\0\x02\x01\x02\x12\x04\xbf\x04\x10\x11\n\x0e\n\x06\
    \x04\"\x04\0\x02\x02\x12\x04\xc0\x04\x08\x11\n\x0f\n\x07\x04\"\x04\0\x02\
    \x02\x01\x12\x04\xc0\x04\x08\x0c\n\x0f\n\x07\x04\"\x04\0\x02\x02\x02\x12\
    \x04\xc0\x04\x0f\x10\n\x0e\n\x06\x04\"\x04\0\x02\x03\x12\x04\xc1\x04\x08\
    \x15\n\x0f\n\x07\x04\"\x04\0\x02\x03\x01\x12\x04\xc1\x04\x08\x10\n\x0f\n\
    \x07\x04\"\x04\0\x02\x03\x02\x12\x04\xc1\x04\x13\x14\n\x0e\n\x06\x04\"\
    \x04\0\x02\x04\x12\x04\xc2\x04\x08\x12\n\x0f\n\x07\x04\"\x04\0\x02\x04\
    \x01\x12\x04\xc2\x04\x08\r\n\x0f\n\x07\x04\"\x04\0\x02\x04\x02\x12\x04\
    \xc2\x04\x10\x11\n\x0e\n\x06\x04\"\x04\0\x02\x05\x12\x04\xc3\x04\x08\x12\
    \n\x0f\n\x07\x04\"\x04\0\x02\x05\x01\x12\x04\xc3\x04\x08\r\n\x0f\n\x07\
    \x04\"\x04\0\x02\x05\x02\x12\x04\xc3\x04\x10\x11\n\x0e\n\x06\x04\"\x04\0\
    \x02\x06\x12\x04\xc4\x04\x08\x15\n\x0f\n\x07\x04\"\x04\0\x02\x06\x01\x12\
    \x04\xc4\x04\x08\x10\n\x0f\n\x07\x04\"\x04\0\x02\x06\x02\x12\x04\xc4\x04\
    \x13\x14\n\x0e\n\x04\x04\"\x03\0\x12\x06\xc6\x04\x04\xd9\x04\x05\n\r\n\
    \x05\x04\"\x03\0\x01\x12\x04\xc6\x04\x0c\x12\n\x10\n\x06\x04\"\x03\0\x04\
    \0\x12\x06\xc7\x04\x08\xcb\x04\t\n\x0f\n\x07\x04\"\x03\0\x04\0\x01\x12\
    \x04\xc7\x04\r\x11\n\x10\n\x08\x04\"\x03\0\x04\0\x02\0\x12\x04\xc8\x04\
    \x0c\x18\n\x11\n\t\x04\"\x03\0\x04\0\x02\0\x01\x12\x04\xc8\x04\x0c\x13\n\
    \x11\n\t\x04\"\x03\0\x04\0\x02\0\x02\x12\x04\xc8\x04\x16\x17\n\x10\n\x08\
    \x04\"\x03\0\x04\0\x02\x01\x12\x04\xc9\x04\x0c\x19\n\x11\n\t\x04\"\x03\0\
    \x04\0\x02\x01\x01\x12\x04\xc9\x04\x0c\x14\n\x11\n\t\x04\"\x03\0\x04\0\
    \x02\x01\x02\x12\x04\xc9\x04\x17\x18\n\x10\n\x08\x04\"\x03\0\x04\0\x02\
    \x02\x12\x04\xca\x04\x0c\x1c\n\x11\n\t\x04\"\x03\0\x04\0\x02\x02\x01\x12\
    \x04\xca\x04\x0c\x17\n\x11\n\t\x04\"\x03\0\x04\0\x02\x02\x02\x12\x04\xca\
    \x04\x1a\x1b\n\x10\n\x06\x04\"\x03\0\x03\0\x12\x06\xcc\x04\x08\xcf\x04\t\
    \n\x0f\n\x07\x04\"\x03\0\x03\0\x01\x12\x04\xcc\x04\x10\x1e\n\x10\n\x08\
    \x04\"\x03\0\x03\0\x02\0\x12\x04\xcd\x04\x0c%\n\x11\n\t\x04\"\x03\0\x03\
    \0\x02\0\x04\x12\x04\xcd\x04\x0c\x14\n\x11\n\t\x04\"\x03\0\x03\0\x02\0\
    \x05\x12\x04\xcd\x04\x15\x1b\n\x11\n\t\x04\"\x03\0\x03\0\x02\0\x01\x12\
    \x04\xcd\x04\x1c\x20\n\x11\n\t\x04\"\x03\0\x03\0\x02\0\x03\x12\x04\xcd\
    \x04#$\n\x10\n\x08\x04\"\x03\0\x03\0\x02\x01\x12\x04\xce\x04\x0c+\n\x11\
    \n\t\x04\"\x03\0\x03\0\x02\x01\x04\x12\x04\xce\x04\x0c\x14\n\x11\n\t\x04\
    \"\x03\0\x03\0\x02\x01\x05\x12\x04\xce\x04\x15\x1b\n\x11\n\t\x04\"\x03\0\
    \x03\0\x02\x01\x01\x12\x04\xce\x04\x1c&\n\x11\n\t\x04\"\x03\0\x03\0\x02\
    \x01\x03\x12\x04\xce\x04)*\n\x10\n\x06\x04\"\x03\0\x03\x01\x12\x06\xd1\
    \x04\x08\xd3\x04\t\n\x0f\n\x07\x04\"\x03\0\x03\x01\x01\x12\x04\xd1\x04\
    \x10\x1a\n\x10\n\x08\x04\"\x03\0\x03\x01\x02\0\x12\x04\xd2\x04\x0c,\n\
    \x11\n\t\x04\"\x03\0\x03\x01\x02\0\x04\x12\x04\xd2\x04\x0c\x14\n\x11\n\t\
    \x04\"\x03\0\x03\x01\x02\0\x05\x12\x04\xd2\x04\x15\x1b\n\x11\n\t\x04\"\
    \x03\0\x03\x01\x02\0\x01\x12\x04\xd2\x04\x1c'\n\x11\n\t\x04\"\x03\0\x03\
    \x01\x02\0\x03\x12\x04\xd2\x04*+\n\x0e\n\x06\x04\"\x03\0\x02\0\x12\x04\
    \xd5\x04\x08%\n\x0f\n\x07\x04\"\x03\0\x02\0\x04\x12\x04\xd5\x04\x08\x10\
    \n\x0f\n\x07\x04\"\x03\0\x02\0\x05\x12\x04\xd5\x04\x11\x17\n\x0f\n\x07\
    \x04\"\x03\0\x02\0\x01\x12\x04\xd5\x04\x18\x20\n\x0f\n\x07\x04\"\x03\0\
    \x02\0\x03\x12\x04\xd5\x04#$\n\x0e\n\x06\x04\"\x03\0\x02\x01\x12\x04\xd6\
    \x04\x08+\n\x0f\n\x07\x04\"\x03\0\x02\x01\x04\x12\x04\xd6\x04\x08\x10\n\
    \x0f\n\x07\x04\"\x03\0\x02\x01\x06\x12\x04\xd6\x04\x11\x1b\n\x0f\n\x07\
    \x04\"\x03\0\x02\x01\x01\x12\x04\xd6\x04\x1c&\n\x0f\n\x07\x04\"\x03\0\
    \x02\x01\x03\x12\x04\xd6\x04)*\n\x0e\n\x06\x04\"\x03\0\x02\x02\x12\x04\
    \xd7\x04\x08\x1f\n\x0f\n\x07\x04\"\x03\0\x02\x02\x04\x12\x04\xd7\x04\x08\
    \x10\n\x0f\n\x07\x04\"\x03\0\x02\x02\x06\x12\x04\xd7\x04\x11\x15\n\x0f\n\
    \x07\x04\"\x03\0\x02\x02\x01\x12\x04\xd7\x04\x16\x1a\n\x0f\n\x07\x04\"\
    \x03\0\x02\x02\x03\x12\x04\xd7\x04\x1d\x1e\n\x0e\n\x06\x04\"\x03\0\x02\
    \x03\x12\x04\xd8\x04\x083\n\x0f\n\x07\x04\"\x03\0\x02\x03\x04\x12\x04\
    \xd8\x04\x08\x10\n\x0f\n\x07\x04\"\x03\0\x02\x03\x06\x12\x04\xd8\x04\x11\
    \x1f\n\x0f\n\x07\x04\"\x03\0\x02\x03\x01\x12\x04\xd8\x04\x20.\n\x0f\n\
    \x07\x04\"\x03\0\x02\x03\x03\x12\x04\xd8\x0412\n\x0c\n\x04\x04\"\x02\0\
    \x12\x04\xdb\x04\x04$\n\r\n\x05\x04\"\x02\0\x04\x12\x04\xdb\x04\x04\x0c\
    \n\r\n\x05\x04\"\x02\0\x05\x12\x04\xdb\x04\r\x13\n\r\n\x05\x04\"\x02\0\
    \x01\x12\x04\xdb\x04\x14\x1f\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xdb\x04\"\
    #\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xdc\x04\x04#\n\r\n\x05\x04\"\x02\x01\
    \x04\x12\x04\xdc\x04\x04\x0c\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xdc\x04\
    \r\x13\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xdc\x04\x14\x1e\n\r\n\x05\x04\
    \"\x02\x01\x03\x12\x04\xdc\x04!\"\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xdd\
    \x04\x04)\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\xdd\x04\x04\x0c\n\r\n\x05\
    \x04\"\x02\x02\x06\x12\x04\xdd\x04\r\x18\n\r\n\x05\x04\"\x02\x02\x01\x12\
    \x04\xdd\x04\x19$\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xdd\x04'(\n\x0c\n\
    \x04\x04\"\x02\x03\x12\x04\xde\x04\x04\x20\n\r\n\x05\x04\"\x02\x03\x04\
    \x12\x04\xde\x04\x04\x0c\n\r\n\x05\x04\"\x02\x03\x06\x12\x04\xde\x04\r\
    \x13\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xde\x04\x14\x1b\n\r\n\x05\x04\"\
    \x02\x03\x03\x12\x04\xde\x04\x1e\x1f\n\x0c\n\x04\x04\"\x02\x04\x12\x04\
    \xdf\x04\x04(\n\r\n\x05\x04\"\x02\x04\x04\x12\x04\xdf\x04\x04\x0c\n\r\n\
    \x05\x04\"\x02\x04\x06\x12\x04\xdf\x04\r\x17\n\r\n\x05\x04\"\x02\x04\x01\
    \x12\x04\xdf\x04\x18\"\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\xdf\x04%'\n\
    \x0e\n\x04\x04\"\x08\0\x12\x06\xe0\x04\x04\xe6\x04\x05\n\r\n\x05\x04\"\
    \x08\0\x01\x12\x04\xe0\x04\n\x10\n\x0c\n\x04\x04\"\x02\x05\x12\x04\xe1\
    \x04\x08\x18\n\r\n\x05\x04\"\x02\x05\x05\x12\x04\xe1\x04\x08\x0e\n\r\n\
    \x05\x04\"\x02\x05\x01\x12\x04\xe1\x04\x0f\x13\n\r\n\x05\x04\"\x02\x05\
    \x03\x12\x04\xe1\x04\x16\x17\n\x0c\n\x04\x04\"\x02\x06\x12\x04\xe2\x04\
    \x08,\n\r\n\x05\x04\"\x02\x06\x06\x12\x04\xe2\x04\x08\x17\n\r\n\x05\x04\
    \"\x02\x06\x01\x12\x04\xe2\x04\x18'\n\r\n\x05\x04\"\x02\x06\x03\x12\x04\
    \xe2\x04*+\n\x0c\n\x04\x04\"\x02\x07\x12\x04\xe3\x04\x08&\n\r\n\x05\x04\
    \"\x02\x07\x06\x12\x04\xe3\x04\x08\x14\n\r\n\x05\x04\"\x02\x07\x01\x12\
    \x04\xe3\x04\x15!\n\r\n\x05\x04\"\x02\x07\x03\x12\x04\xe3\x04$%\n\x0c\n\
    \x04\x04\"\x02\x08\x12\x04\xe4\x04\x08&\n\r\n\x05\x04\"\x02\x08\x06\x12\
    \x04\xe4\x04\x08\x14\n\r\n\x05\x04\"\x02\x08\x01\x12\x04\xe4\x04\x15!\n\
    \r\n\x05\x04\"\x02\x08\x03\x12\x04\xe4\x04$%\n\x0c\n\x04\x04\"\x02\t\x12\
    \x04\xe5\x04\x08,\n\r\n\x05\x04\"\x02\t\x06\x12\x04\xe5\x04\x08\x17\n\r\
    \n\x05\x04\"\x02\t\x01\x12\x04\xe5\x04\x18'\n\r\n\x05\x04\"\x02\t\x03\
    \x12\x04\xe5\x04*+\n\x0c\n\x02\x04#\x12\x06\xe9\x04\0\xf8\x04\x01\n\x0b\
    \n\x03\x04#\x01\x12\x04\xe9\x04\x08\x14\n\x0c\n\x04\x04#\x02\0\x12\x04\
    \xea\x04\x04\x1c\n\r\n\x05\x04#\x02\0\x04\x12\x04\xea\x04\x04\x0c\n\r\n\
    \x05\x04#\x02\0\x05\x12\x04\xea\x04\r\x13\n\r\n\x05\x04#\x02\0\x01\x12\
    \x04\xea\x04\x14\x17\n\r\n\x05\x04#\x02\0\x03\x12\x04\xea\x04\x1a\x1b\n\
    \x0c\n\x04\x04#\x02\x01\x12\x04\xeb\x04\x04!\n\r\n\x05\x04#\x02\x01\x04\
    \x12\x04\xeb\x04\x04\x0c\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xeb\x04\r\
    \x13\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xeb\x04\x14\x1c\n\r\n\x05\x04#\
    \x02\x01\x03\x12\x04\xeb\x04\x1f\x20\n\x0c\n\x04\x04#\x02\x02\x12\x04\
    \xec\x04\x04\"\n\r\n\x05\x04#\x02\x02\x04\x12\x04\xec\x04\x04\x0c\n\r\n\
    \x05\x04#\x02\x02\x05\x12\x04\xec\x04\r\x12\n\r\n\x05\x04#\x02\x02\x01\
    \x12\x04\xec\x04\x13\x1d\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xec\x04\x20!\
    \n\x0c\n\x04\x04#\x02\x03\x12\x04\xed\x04\x04#\n\r\n\x05\x04#\x02\x03\
    \x04\x12\x04\xed\x04\x04\x0c\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xed\x04\
    \r\x13\n\r\n\x05\x04#\x02\x03\x01\x12\x04\xed\x04\x14\x1e\n\r\n\x05\x04#\
    \x02\x03\x03\x12\x04\xed\x04!\"\n\x0c\n\x04\x04#\x02\x04\x12\x04\xee\x04\
    \x04\x20\n\r\n\x05\x04#\x02\x04\x04\x12\x04\xee\x04\x04\x0c\n\r\n\x05\
    \x04#\x02\x04\x05\x12\x04\xee\x04\r\x13\n\r\n\x05\x04#\x02\x04\x01\x12\
    \x04\xee\x04\x14\x1b\n\r\n\x05\x04#\x02\x04\x03\x12\x04\xee\x04\x1e\x1f\
    \n\x0c\n\x04\x04#\x02\x05\x12\x04\xef\x04\x04\x1a\n\r\n\x05\x04#\x02\x05\
    \x04\x12\x04\xef\x04\x04\x0c\n\r\n\x05\x04#\x02\x05\x05\x12\x04\xef\x04\
    \r\x11\n\r\n\x05\x04#\x02\x05\x01\x12\x04\xef\x04\x12\x15\n\r\n\x05\x04#\
    \x02\x05\x03\x12\x04\xef\x04\x18\x19\n\x0c\n\x04\x04#\x02\x06\x12\x04\
    \xf0\x04\x04\x20\n\r\n\x05\x04#\x02\x06\x04\x12\x04\xf0\x04\x04\x0c\n\r\
    \n\x05\x04#\x02\x06\x05\x12\x04\xf0\x04\r\x12\n\r\n\x05\x04#\x02\x06\x01\
    \x12\x04\xf0\x04\x13\x1b\n\r\n\x05\x04#\x02\x06\x03\x12\x04\xf0\x04\x1e\
    \x1f\n\x0c\n\x04\x04#\x02\x07\x12\x04\xf1\x04\x04%\n\r\n\x05\x04#\x02\
    \x07\x04\x12\x04\xf1\x04\x04\x0c\n\r\n\x05\x04#\x02\x07\x05\x12\x04\xf1\
    \x04\r\x12\n\r\n\x05\x04#\x02\x07\x01\x12\x04\xf1\x04\x13\x20\n\r\n\x05\
    \x04#\x02\x07\x03\x12\x04\xf1\x04#$\n\x0c\n\x04\x04#\x02\x08\x12\x04\xf2\
    \x04\x04#\n\r\n\x05\x04#\x02\x08\x04\x12\x04\xf2\x04\x04\x0c\n\r\n\x05\
    \x04#\x02\x08\x05\x12\x04\xf2\x04\r\x13\n\r\n\x05\x04#\x02\x08\x01\x12\
    \x04\xf2\x04\x14\x1e\n\r\n\x05\x04#\x02\x08\x03\x12\x04\xf2\x04!\"\n\x0c\
    \n\x04\x04#\x02\t\x12\x04\xf3\x04\x04*\n\r\n\x05\x04#\x02\t\x04\x12\x04\
    \xf3\x04\x04\x0c\n\r\n\x05\x04#\x02\t\x05\x12\x04\xf3\x04\r\x12\n\r\n\
    \x05\x04#\x02\t\x01\x12\x04\xf3\x04\x13$\n\r\n\x05\x04#\x02\t\x03\x12\
    \x04\xf3\x04')\n\x0c\n\x04\x04#\x02\n\x12\x04\xf4\x04\x04*\n\r\n\x05\x04\
    #\x02\n\x04\x12\x04\xf4\x04\x04\x0c\n\r\n\x05\x04#\x02\n\x06\x12\x04\xf4\
    \x04\r\x18\n\r\n\x05\x04#\x02\n\x01\x12\x04\xf4\x04\x19$\n\r\n\x05\x04#\
    \x02\n\x03\x12\x04\xf4\x04')\n\x0c\n\x04\x04#\x02\x0b\x12\x04\xf5\x04\
    \x04)\n\r\n\x05\x04#\x02\x0b\x04\x12\x04\xf5\x04\x04\x0c\n\r\n\x05\x04#\
    \x02\x0b\x05\x12\x04\xf5\x04\r\x12\n\r\n\x05\x04#\x02\x0b\x01\x12\x04\
    \xf5\x04\x13#\n\r\n\x05\x04#\x02\x0b\x03\x12\x04\xf5\x04&(\n\x0c\n\x04\
    \x04#\x02\x0c\x12\x04\xf6\x04\x04!\n\r\n\x05\x04#\x02\x0c\x04\x12\x04\
    \xf6\x04\x04\x0c\n\r\n\x05\x04#\x02\x0c\x05\x12\x04\xf6\x04\r\x12\n\r\n\
    \x05\x04#\x02\x0c\x01\x12\x04\xf6\x04\x13\x1b\n\r\n\x05\x04#\x02\x0c\x03\
    \x12\x04\xf6\x04\x1e\x20\n\x0c\n\x04\x04#\x02\r\x12\x04\xf7\x04\x04)\n\r\
    \n\x05\x04#\x02\r\x04\x12\x04\xf7\x04\x04\x0c\n\r\n\x05\x04#\x02\r\x05\
    \x12\x04\xf7\x04\r\x14\n\r\n\x05\x04#\x02\r\x01\x12\x04\xf7\x04\x15#\n\r\
    \n\x05\x04#\x02\r\x03\x12\x04\xf7\x04&(\n\x0c\n\x02\x04$\x12\x06\xfa\x04\
    \0\xfd\x04\x01\n\x0b\n\x03\x04$\x01\x12\x04\xfa\x04\x08\x17\n\x0c\n\x04\
    \x04$\x02\0\x12\x04\xfb\x04\x04)\n\r\n\x05\x04$\x02\0\x04\x12\x04\xfb\
    \x04\x04\x0c\n\r\n\x05\x04$\x02\0\x06\x12\x04\xfb\x04\r\x1e\n\r\n\x05\
    \x04$\x02\0\x01\x12\x04\xfb\x04\x1f$\n\r\n\x05\x04$\x02\0\x03\x12\x04\
    \xfb\x04'(\n\x0c\n\x04\x04$\x02\x01\x12\x04\xfc\x04\x04-\n\r\n\x05\x04$\
    \x02\x01\x04\x12\x04\xfc\x04\x04\x0c\n\r\n\x05\x04$\x02\x01\x06\x12\x04\
    \xfc\x04\r\x20\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xfc\x04!(\n\r\n\x05\
    \x04$\x02\x01\x03\x12\x04\xfc\x04+,\n\x0c\n\x02\x04%\x12\x06\xff\x04\0\
    \x81\x05\x01\n\x0b\n\x03\x04%\x01\x12\x04\xff\x04\x08\x1c\n\x0c\n\x04\
    \x04%\x02\0\x12\x04\x80\x05\x04&\n\r\n\x05\x04%\x02\0\x04\x12\x04\x80\
    \x05\x04\x0c\n\r\n\x05\x04%\x02\0\x06\x12\x04\x80\x05\r\x1c\n\r\n\x05\
    \x04%\x02\0\x01\x12\x04\x80\x05\x1d!\n\r\n\x05\x04%\x02\0\x03\x12\x04\
    \x80\x05$%\n\x0c\n\x02\x04&\x12\x06\x83\x05\0\x85\x05\x01\n\x0b\n\x03\
    \x04&\x01\x12\x04\x83\x05\x08\x1e\n\x0c\n\x04\x04&\x02\0\x12\x04\x84\x05\
    \x04*\n\r\n\x05\x04&\x02\0\x04\x12\x04\x84\x05\x04\x0c\n\r\n\x05\x04&\
    \x02\0\x06\x12\x04\x84\x05\r\x1e\n\r\n\x05\x04&\x02\0\x01\x12\x04\x84\
    \x05\x1f%\n\r\n\x05\x04&\x02\0\x03\x12\x04\x84\x05()\n\x0c\n\x02\x04'\
    \x12\x06\x87\x05\0\x89\x05\x01\n\x0b\n\x03\x04'\x01\x12\x04\x87\x05\x08\
    \x19\n\x0c\n\x04\x04'\x02\0\x12\x04\x88\x05\x04\x1d\n\r\n\x05\x04'\x02\0\
    \x04\x12\x04\x88\x05\x04\x0c\n\r\n\x05\x04'\x02\0\x05\x12\x04\x88\x05\r\
    \x12\n\r\n\x05\x04'\x02\0\x01\x12\x04\x88\x05\x13\x18\n\r\n\x05\x04'\x02\
    \0\x03\x12\x04\x88\x05\x1b\x1c\n\x0c\n\x02\x04(\x12\x06\x8b\x05\0\x8f\
    \x05\x01\n\x0b\n\x03\x04(\x01\x12\x04\x8b\x05\x08\"\n\x0c\n\x04\x04(\x02\
    \0\x12\x04\x8c\x05\x04\x1e\n\r\n\x05\x04(\x02\0\x04\x12\x04\x8c\x05\x04\
    \x0c\n\r\n\x05\x04(\x02\0\x05\x12\x04\x8c\x05\r\x13\n\r\n\x05\x04(\x02\0\
    \x01\x12\x04\x8c\x05\x14\x19\n\r\n\x05\x04(\x02\0\x03\x12\x04\x8c\x05\
    \x1c\x1d\n\x0c\n\x04\x04(\x02\x01\x12\x04\x8d\x05\x04%\n\r\n\x05\x04(\
    \x02\x01\x04\x12\x04\x8d\x05\x04\x0c\n\r\n\x05\x04(\x02\x01\x05\x12\x04\
    \x8d\x05\r\x13\n\r\n\x05\x04(\x02\x01\x01\x12\x04\x8d\x05\x14\x20\n\r\n\
    \x05\x04(\x02\x01\x03\x12\x04\x8d\x05#$\n\x0c\n\x04\x04(\x02\x02\x12\x04\
    \x8e\x05\x044\n\r\n\x05\x04(\x02\x02\x04\x12\x04\x8e\x05\x04\x0c\n\r\n\
    \x05\x04(\x02\x02\x05\x12\x04\x8e\x05\r\x13\n\r\n\x05\x04(\x02\x02\x01\
    \x12\x04\x8e\x05\x14!\n\r\n\x05\x04(\x02\x02\x03\x12\x04\x8e\x05$%\n\r\n\
    \x05\x04(\x02\x02\x08\x12\x04\x8e\x05&3\n\x0e\n\x06\x04(\x02\x02\x08\x02\
    \x12\x04\x8e\x05'2\n\x0c\n\x02\x04)\x12\x06\x91\x05\0\x95\x05\x01\n\x0b\
    \n\x03\x04)\x01\x12\x04\x91\x05\x08\x1b\n\x0c\n\x04\x04)\x02\0\x12\x04\
    \x92\x05\x04\x1f\n\r\n\x05\x04)\x02\0\x04\x12\x04\x92\x05\x04\x0c\n\r\n\
    \x05\x04)\x02\0\x05\x12\x04\x92\x05\r\x12\n\r\n\x05\x04)\x02\0\x01\x12\
    \x04\x92\x05\x13\x1a\n\r\n\x05\x04)\x02\0\x03\x12\x04\x92\x05\x1d\x1e\n\
    \x0c\n\x04\x04)\x02\x01\x12\x04\x93\x05\x048\n\r\n\x05\x04)\x02\x01\x04\
    \x12\x04\x93\x05\x04\x0c\n\r\n\x05\x04)\x02\x01\x06\x12\x04\x93\x05\r'\n\
    \r\n\x05\x04)\x02\x01\x01\x12\x04\x93\x05(3\n\r\n\x05\x04)\x02\x01\x03\
    \x12\x04\x93\x0567\n\x0c\n\x04\x04)\x02\x02\x12\x04\x94\x05\x04!\n\r\n\
    \x05\x04)\x02\x02\x04\x12\x04\x94\x05\x04\x0c\n\r\n\x05\x04)\x02\x02\x05\
    \x12\x04\x94\x05\r\x12\n\r\n\x05\x04)\x02\x02\x01\x12\x04\x94\x05\x13\
    \x1c\n\r\n\x05\x04)\x02\x02\x03\x12\x04\x94\x05\x1f\x20\n\x0c\n\x02\x04*\
    \x12\x06\x97\x05\0\x9a\x05\x01\n\x0b\n\x03\x04*\x01\x12\x04\x97\x05\x08*\
    \n\x0c\n\x04\x04*\x02\0\x12\x04\x98\x05\x04(\n\r\n\x05\x04*\x02\0\x04\
    \x12\x04\x98\x05\x04\x0c\n\r\n\x05\x04*\x02\0\x05\x12\x04\x98\x05\r\x13\
    \n\r\n\x05\x04*\x02\0\x01\x12\x04\x98\x05\x14#\n\r\n\x05\x04*\x02\0\x03\
    \x12\x04\x98\x05&'\n\x0c\n\x04\x04*\x02\x01\x12\x04\x99\x05\x04!\n\r\n\
    \x05\x04*\x02\x01\x04\x12\x04\x99\x05\x04\x0c\n\r\n\x05\x04*\x02\x01\x05\
    \x12\x04\x99\x05\r\x12\n\r\n\x05\x04*\x02\x01\x01\x12\x04\x99\x05\x13\
    \x1c\n\r\n\x05\x04*\x02\x01\x03\x12\x04\x99\x05\x1f\x20\n\x0c\n\x02\x04+\
    \x12\x06\x9c\x05\0\xa0\x05\x01\n\x0b\n\x03\x04+\x01\x12\x04\x9c\x05\x08\
    \x10\n\x0c\n\x04\x04+\x02\0\x12\x04\x9d\x05\x04(\n\r\n\x05\x04+\x02\0\
    \x04\x12\x04\x9d\x05\x04\x0c\n\r\n\x05\x04+\x02\0\x05\x12\x04\x9d\x05\r\
    \x13\n\r\n\x05\x04+\x02\0\x01\x12\x04\x9d\x05\x14#\n\r\n\x05\x04+\x02\0\
    \x03\x12\x04\x9d\x05&'\n\x0c\n\x04\x04+\x02\x01\x12\x04\x9e\x05\x04)\n\r\
    \n\x05\x04+\x02\x01\x04\x12\x04\x9e\x05\x04\x0c\n\r\n\x05\x04+\x02\x01\
    \x05\x12\x04\x9e\x05\r\x13\n\r\n\x05\x04+\x02\x01\x01\x12\x04\x9e\x05\
    \x14$\n\r\n\x05\x04+\x02\x01\x03\x12\x04\x9e\x05'(\n\x0c\n\x04\x04+\x02\
    \x02\x12\x04\x9f\x05\x04\x1d\n\r\n\x05\x04+\x02\x02\x04\x12\x04\x9f\x05\
    \x04\x0c\n\r\n\x05\x04+\x02\x02\x05\x12\x04\x9f\x05\r\x13\n\r\n\x05\x04+\
    \x02\x02\x01\x12\x04\x9f\x05\x14\x18\n\r\n\x05\x04+\x02\x02\x03\x12\x04\
    \x9f\x05\x1b\x1c\n\x0c\n\x02\x05\0\x12\x06\xa2\x05\0\xa6\x05\x01\n\x0b\n\
    \x03\x05\0\x01\x12\x04\xa2\x05\x05\r\n\x0c\n\x04\x05\0\x02\0\x12\x04\xa3\
    \x05\x04\x10\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xa3\x05\x04\x0b\n\r\n\x05\
    \x05\0\x02\0\x02\x12\x04\xa3\x05\x0e\x0f\n\x0c\n\x04\x05\0\x02\x01\x12\
    \x04\xa4\x05\x04\x15\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xa4\x05\x04\x10\
    \n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xa4\x05\x13\x14\n\x0c\n\x04\x05\0\
    \x02\x02\x12\x04\xa5\x05\x04\x1a\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xa5\
    \x05\x04\x15\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xa5\x05\x18\x19\n\x0c\n\
    \x02\x04,\x12\x06\xa7\x05\0\xac\x05\x01\n\x0b\n\x03\x04,\x01\x12\x04\xa7\
    \x05\x08\x1d\n\x0c\n\x04\x04,\x02\0\x12\x04\xa8\x05\x04'\n\r\n\x05\x04,\
    \x02\0\x04\x12\x04\xa8\x05\x04\x0c\n\r\n\x05\x04,\x02\0\x06\x12\x04\xa8\
    \x05\r\x12\n\r\n\x05\x04,\x02\0\x01\x12\x04\xa8\x05\x13\"\n\r\n\x05\x04,\
    \x02\0\x03\x12\x04\xa8\x05%&\n\x0e\n\x04\x04,\x08\0\x12\x06\xa9\x05\x04\
    \xab\x05\x05\n\r\n\x05\x04,\x08\0\x01\x12\x04\xa9\x05\n\x10\n\x0c\n\x04\
    \x04,\x02\x01\x12\x04\xaa\x05\x08\x1e\n\r\n\x05\x04,\x02\x01\x06\x12\x04\
    \xaa\x05\x08\x10\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xaa\x05\x11\x19\n\r\
    \n\x05\x04,\x02\x01\x03\x12\x04\xaa\x05\x1c\x1d\n\x0c\n\x02\x04-\x12\x06\
    \xae\x05\0\xc4\x05\x01\n\x0b\n\x03\x04-\x01\x12\x04\xae\x05\x08\x1e\n\
    \x0e\n\x04\x04-\x03\0\x12\x06\xaf\x05\x04\xb2\x05\x05\n\r\n\x05\x04-\x03\
    \0\x01\x12\x04\xaf\x05\x0c\x1d\n\x0e\n\x06\x04-\x03\0\x02\0\x12\x04\xb0\
    \x05\x08(\n\x0f\n\x07\x04-\x03\0\x02\0\x04\x12\x04\xb0\x05\x08\x10\n\x0f\
    \n\x07\x04-\x03\0\x02\0\x05\x12\x04\xb0\x05\x11\x17\n\x0f\n\x07\x04-\x03\
    \0\x02\0\x01\x12\x04\xb0\x05\x18#\n\x0f\n\x07\x04-\x03\0\x02\0\x03\x12\
    \x04\xb0\x05&'\n\x0e\n\x06\x04-\x03\0\x02\x01\x12\x04\xb1\x05\x08\x20\n\
    \x0f\n\x07\x04-\x03\0\x02\x01\x04\x12\x04\xb1\x05\x08\x10\n\x0f\n\x07\
    \x04-\x03\0\x02\x01\x05\x12\x04\xb1\x05\x11\x17\n\x0f\n\x07\x04-\x03\0\
    \x02\x01\x01\x12\x04\xb1\x05\x18\x1b\n\x0f\n\x07\x04-\x03\0\x02\x01\x03\
    \x12\x04\xb1\x05\x1e\x1f\n\x0e\n\x04\x04-\x03\x01\x12\x06\xb4\x05\x04\
    \xb7\x05\x05\n\r\n\x05\x04-\x03\x01\x01\x12\x04\xb4\x05\x0c$\n\x0e\n\x06\
    \x04-\x03\x01\x02\0\x12\x04\xb5\x05\x08(\n\x0f\n\x07\x04-\x03\x01\x02\0\
    \x04\x12\x04\xb5\x05\x08\x10\n\x0f\n\x07\x04-\x03\x01\x02\0\x05\x12\x04\
    \xb5\x05\x11\x17\n\x0f\n\x07\x04-\x03\x01\x02\0\x01\x12\x04\xb5\x05\x18#\
    \n\x0f\n\x07\x04-\x03\x01\x02\0\x03\x12\x04\xb5\x05&'\n\x0e\n\x06\x04-\
    \x03\x01\x02\x01\x12\x04\xb6\x05\x08\x1f\n\x0f\n\x07\x04-\x03\x01\x02\
    \x01\x04\x12\x04\xb6\x05\x08\x10\n\x0f\n\x07\x04-\x03\x01\x02\x01\x05\
    \x12\x04\xb6\x05\x11\x17\n\x0f\n\x07\x04-\x03\x01\x02\x01\x01\x12\x04\
    \xb6\x05\x18\x1a\n\x0f\n\x07\x04-\x03\x01\x02\x01\x03\x12\x04\xb6\x05\
    \x1d\x1e\n\x0e\n\x04\x04-\x03\x02\x12\x06\xb9\x05\x04\xbc\x05\x05\n\r\n\
    \x05\x04-\x03\x02\x01\x12\x04\xb9\x05\x0c\x1e\n\x0e\n\x06\x04-\x03\x02\
    \x02\0\x12\x04\xba\x05\x08(\n\x0f\n\x07\x04-\x03\x02\x02\0\x04\x12\x04\
    \xba\x05\x08\x10\n\x0f\n\x07\x04-\x03\x02\x02\0\x05\x12\x04\xba\x05\x11\
    \x17\n\x0f\n\x07\x04-\x03\x02\x02\0\x01\x12\x04\xba\x05\x18#\n\x0f\n\x07\
    \x04-\x03\x02\x02\0\x03\x12\x04\xba\x05&'\n\x0e\n\x06\x04-\x03\x02\x02\
    \x01\x12\x04\xbb\x05\x08(\n\x0f\n\x07\x04-\x03\x02\x02\x01\x04\x12\x04\
    \xbb\x05\x08\x10\n\x0f\n\x07\x04-\x03\x02\x02\x01\x05\x12\x04\xbb\x05\
    \x11\x17\n\x0f\n\x07\x04-\x03\x02\x02\x01\x01\x12\x04\xbb\x05\x18#\n\x0f\
    \n\x07\x04-\x03\x02\x02\x01\x03\x12\x04\xbb\x05&'\n\x0c\n\x04\x04-\x02\0\
    \x12\x04\xbe\x05\x04\x1e\n\r\n\x05\x04-\x02\0\x04\x12\x04\xbe\x05\x04\
    \x0c\n\r\n\x05\x04-\x02\0\x05\x12\x04\xbe\x05\r\x13\n\r\n\x05\x04-\x02\0\
    \x01\x12\x04\xbe\x05\x14\x19\n\r\n\x05\x04-\x02\0\x03\x12\x04\xbe\x05\
    \x1c\x1d\n\x0e\n\x04\x04-\x08\0\x12\x06\xbf\x05\x04\xc3\x05\x05\n\r\n\
    \x05\x04-\x08\0\x01\x12\x04\xbf\x05\n\x18\n\x0c\n\x04\x04-\x02\x01\x12\
    \x04\xc0\x05\x086\n\r\n\x05\x04-\x02\x01\x06\x12\x04\xc0\x05\x08\x20\n\r\
    \n\x05\x04-\x02\x01\x01\x12\x04\xc0\x05!1\n\r\n\x05\x04-\x02\x01\x03\x12\
    \x04\xc0\x0545\n\x0c\n\x04\x04-\x02\x02\x12\x04\xc1\x05\x08(\n\r\n\x05\
    \x04-\x02\x02\x06\x12\x04\xc1\x05\x08\x19\n\r\n\x05\x04-\x02\x02\x01\x12\
    \x04\xc1\x05\x1a#\n\r\n\x05\x04-\x02\x02\x03\x12\x04\xc1\x05&'\n\x0c\n\
    \x04\x04-\x02\x03\x12\x04\xc2\x05\x08*\n\r\n\x05\x04-\x02\x03\x06\x12\
    \x04\xc2\x05\x08\x1a\n\r\n\x05\x04-\x02\x03\x01\x12\x04\xc2\x05\x1b%\n\r\
    \n\x05\x04-\x02\x03\x03\x12\x04\xc2\x05()\n\x0c\n\x02\x04.\x12\x06\xc6\
    \x05\0\xc9\x05\x01\n\x0b\n\x03\x04.\x01\x12\x04\xc6\x05\x08\x14\n\x0c\n\
    \x04\x04.\x02\0\x12\x04\xc7\x05\x04!\n\r\n\x05\x04.\x02\0\x04\x12\x04\
    \xc7\x05\x04\x0c\n\r\n\x05\x04.\x02\0\x05\x12\x04\xc7\x05\r\x13\n\r\n\
    \x05\x04.\x02\0\x01\x12\x04\xc7\x05\x14\x1c\n\r\n\x05\x04.\x02\0\x03\x12\
    \x04\xc7\x05\x1f\x20\n\x0c\n\x04\x04.\x02\x01\x12\x04\xc8\x05\x04%\n\r\n\
    \x05\x04.\x02\x01\x04\x12\x04\xc8\x05\x04\x0c\n\r\n\x05\x04.\x02\x01\x05\
    \x12\x04\xc8\x05\r\x13\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xc8\x05\x14\
    \x20\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xc8\x05#$\n\x0c\n\x02\x04/\x12\
    \x06\xcb\x05\0\xd2\x05\x01\n\x0b\n\x03\x04/\x01\x12\x04\xcb\x05\x08\x18\
    \n\x0e\n\x04\x04/\x04\0\x12\x06\xcc\x05\x04\xd0\x05\x05\n\r\n\x05\x04/\
    \x04\0\x01\x12\x04\xcc\x05\t\x12\n\x0e\n\x06\x04/\x04\0\x02\0\x12\x04\
    \xcd\x05\x08\x1c\n\x0f\n\x07\x04/\x04\0\x02\0\x01\x12\x04\xcd\x05\x08\
    \x17\n\x0f\n\x07\x04/\x04\0\x02\0\x02\x12\x04\xcd\x05\x1a\x1b\n\x0e\n\
    \x06\x04/\x04\0\x02\x01\x12\x04\xce\x05\x08\x1c\n\x0f\n\x07\x04/\x04\0\
    \x02\x01\x01\x12\x04\xce\x05\x08\x17\n\x0f\n\x07\x04/\x04\0\x02\x01\x02\
    \x12\x04\xce\x05\x1a\x1b\n\x0e\n\x06\x04/\x04\0\x02\x02\x12\x04\xcf\x05\
    \x08\x1f\n\x0f\n\x07\x04/\x04\0\x02\x02\x01\x12\x04\xcf\x05\x08\x1a\n\
    \x0f\n\x07\x04/\x04\0\x02\x02\x02\x12\x04\xcf\x05\x1d\x1e\n\x0c\n\x04\
    \x04/\x02\0\x12\x04\xd1\x05\x04%\n\r\n\x05\x04/\x02\0\x04\x12\x04\xd1\
    \x05\x04\x0c\n\r\n\x05\x04/\x02\0\x06\x12\x04\xd1\x05\r\x16\n\r\n\x05\
    \x04/\x02\0\x01\x12\x04\xd1\x05\x17\x20\n\r\n\x05\x04/\x02\0\x03\x12\x04\
    \xd1\x05#$\n\x0c\n\x02\x040\x12\x06\xd4\x05\0\xdb\x05\x01\n\x0b\n\x03\
    \x040\x01\x12\x04\xd4\x05\x08\x1a\n\x0c\n\x04\x040\x02\0\x12\x04\xd5\x05\
    \x04%\n\r\n\x05\x040\x02\0\x04\x12\x04\xd5\x05\x04\x0c\n\r\n\x05\x040\
    \x02\0\x05\x12\x04\xd5\x05\r\x12\n\r\n\x05\x040\x02\0\x01\x12\x04\xd5\
    \x05\x13\x20\n\r\n\x05\x040\x02\0\x03\x12\x04\xd5\x05#$\n\x0c\n\x04\x040\
    \x02\x01\x12\x04\xd6\x05\x04(\n\r\n\x05\x040\x02\x01\x04\x12\x04\xd6\x05\
    \x04\x0c\n\r\n\x05\x040\x02\x01\x05\x12\x04\xd6\x05\r\x13\n\r\n\x05\x040\
    \x02\x01\x01\x12\x04\xd6\x05\x14#\n\r\n\x05\x040\x02\x01\x03\x12\x04\xd6\
    \x05&'\n\x0c\n\x04\x040\x02\x02\x12\x04\xd7\x05\x047\n\r\n\x05\x040\x02\
    \x02\x04\x12\x04\xd7\x05\x04\x0c\n\r\n\x05\x040\x02\x02\x05\x12\x04\xd7\
    \x05\r\x13\n\r\n\x05\x040\x02\x02\x01\x12\x04\xd7\x05\x14$\n\r\n\x05\x04\
    0\x02\x02\x03\x12\x04\xd7\x05'(\n\r\n\x05\x040\x02\x02\x08\x12\x04\xd7\
    \x05)6\n\x0e\n\x06\x040\x02\x02\x08\x02\x12\x04\xd7\x05*5\n\x0c\n\x04\
    \x040\x02\x03\x12\x04\xd8\x05\x04(\n\r\n\x05\x040\x02\x03\x04\x12\x04\
    \xd8\x05\x04\x0c\n\r\n\x05\x040\x02\x03\x05\x12\x04\xd8\x05\r\x12\n\r\n\
    \x05\x040\x02\x03\x01\x12\x04\xd8\x05\x13#\n\r\n\x05\x040\x02\x03\x03\
    \x12\x04\xd8\x05&'\n\x0c\n\x04\x040\x02\x04\x12\x04\xd9\x05\x04+\n\r\n\
    \x05\x040\x02\x04\x04\x12\x04\xd9\x05\x04\x0c\n\r\n\x05\x040\x02\x04\x05\
    \x12\x04\xd9\x05\r\x13\n\r\n\x05\x040\x02\x04\x01\x12\x04\xd9\x05\x14&\n\
    \r\n\x05\x040\x02\x04\x03\x12\x04\xd9\x05)*\n\x0c\n\x04\x040\x02\x05\x12\
    \x04\xda\x05\x04;\n\r\n\x05\x040\x02\x05\x04\x12\x04\xda\x05\x04\x0c\n\r\
    \n\x05\x040\x02\x05\x05\x12\x04\xda\x05\r\x13\n\r\n\x05\x040\x02\x05\x01\
    \x12\x04\xda\x05\x14'\n\r\n\x05\x040\x02\x05\x03\x12\x04\xda\x05*,\n\r\n\
    \x05\x040\x02\x05\x08\x12\x04\xda\x05-:\n\x0e\n\x06\x040\x02\x05\x08\x02\
    \x12\x04\xda\x05.9\n\x0c\n\x02\x041\x12\x06\xdd\x05\0\xa0\x06\x01\n\x0b\
    \n\x03\x041\x01\x12\x04\xdd\x05\x08\x13\n\x0e\n\x04\x041\x03\0\x12\x06\
    \xde\x05\x04\xe1\x05\x05\n\r\n\x05\x041\x03\0\x01\x12\x04\xde\x05\x0c\
    \x13\n\x0e\n\x06\x041\x03\0\x02\0\x12\x04\xdf\x05\x08&\n\x0f\n\x07\x041\
    \x03\0\x02\0\x04\x12\x04\xdf\x05\x08\x10\n\x0f\n\x07\x041\x03\0\x02\0\
    \x05\x12\x04\xdf\x05\x11\x17\n\x0f\n\x07\x041\x03\0\x02\0\x01\x12\x04\
    \xdf\x05\x18!\n\x0f\n\x07\x041\x03\0\x02\0\x03\x12\x04\xdf\x05$%\n\x0e\n\
    \x06\x041\x03\0\x02\x01\x12\x04\xe0\x05\x08(\n\x0f\n\x07\x041\x03\0\x02\
    \x01\x04\x12\x04\xe0\x05\x08\x10\n\x0f\n\x07\x041\x03\0\x02\x01\x05\x12\
    \x04\xe0\x05\x11\x17\n\x0f\n\x07\x041\x03\0\x02\x01\x01\x12\x04\xe0\x05\
    \x18#\n\x0f\n\x07\x041\x03\0\x02\x01\x03\x12\x04\xe0\x05&'\n\x0e\n\x04\
    \x041\x03\x01\x12\x06\xe3\x05\x04\xf6\x05\x05\n\r\n\x05\x041\x03\x01\x01\
    \x12\x04\xe3\x05\x0c\x1f\n\x10\n\x06\x041\x03\x01\x04\0\x12\x06\xe4\x05\
    \x08\xe8\x05\t\n\x0f\n\x07\x041\x03\x01\x04\0\x01\x12\x04\xe4\x05\r\x16\
    \n\x10\n\x08\x041\x03\x01\x04\0\x02\0\x12\x04\xe5\x05\x0c\x15\n\x11\n\t\
    \x041\x03\x01\x04\0\x02\0\x01\x12\x04\xe5\x05\x0c\x10\n\x11\n\t\x041\x03\
    \x01\x04\0\x02\0\x02\x12\x04\xe5\x05\x13\x14\n\x10\n\x08\x041\x03\x01\
    \x04\0\x02\x01\x12\x04\xe6\x05\x0c\x16\n\x11\n\t\x041\x03\x01\x04\0\x02\
    \x01\x01\x12\x04\xe6\x05\x0c\x11\n\x11\n\t\x041\x03\x01\x04\0\x02\x01\
    \x02\x12\x04\xe6\x05\x14\x15\n\x10\n\x08\x041\x03\x01\x04\0\x02\x02\x12\
    \x04\xe7\x05\x0c\x16\n\x11\n\t\x041\x03\x01\x04\0\x02\x02\x01\x12\x04\
    \xe7\x05\x0c\x11\n\x11\n\t\x041\x03\x01\x04\0\x02\x02\x02\x12\x04\xe7\
    \x05\x14\x15\n\x0e\n\x06\x041\x03\x01\x02\0\x12\x04\xe9\x05\x08\"\n\x0f\
    \n\x07\x041\x03\x01\x02\0\x04\x12\x04\xe9\x05\x08\x10\n\x0f\n\x07\x041\
    \x03\x01\x02\0\x05\x12\x04\xe9\x05\x11\x17\n\x0f\n\x07\x041\x03\x01\x02\
    \0\x01\x12\x04\xe9\x05\x18\x1d\n\x0f\n\x07\x041\x03\x01\x02\0\x03\x12\
    \x04\xe9\x05\x20!\n\x0e\n\x06\x041\x03\x01\x02\x01\x12\x04\xea\x05\x08!\
    \n\x0f\n\x07\x041\x03\x01\x02\x01\x04\x12\x04\xea\x05\x08\x10\n\x0f\n\
    \x07\x041\x03\x01\x02\x01\x05\x12\x04\xea\x05\x11\x17\n\x0f\n\x07\x041\
    \x03\x01\x02\x01\x01\x12\x04\xea\x05\x18\x1c\n\x0f\n\x07\x041\x03\x01\
    \x02\x01\x03\x12\x04\xea\x05\x1f\x20\n\x0e\n\x06\x041\x03\x01\x02\x02\
    \x12\x04\xeb\x05\x08)\n\x0f\n\x07\x041\x03\x01\x02\x02\x04\x12\x04\xeb\
    \x05\x08\x10\n\x0f\n\x07\x041\x03\x01\x02\x02\x06\x12\x04\xeb\x05\x11\
    \x1a\n\x0f\n\x07\x041\x03\x01\x02\x02\x01\x12\x04\xeb\x05\x1b$\n\x0f\n\
    \x07\x041\x03\x01\x02\x02\x03\x12\x04\xeb\x05'(\n\x0e\n\x06\x041\x03\x01\
    \x02\x03\x12\x04\xec\x05\x08)\n\x0f\n\x07\x041\x03\x01\x02\x03\x04\x12\
    \x04\xec\x05\x08\x10\n\x0f\n\x07\x041\x03\x01\x02\x03\x05\x12\x04\xec\
    \x05\x11\x17\n\x0f\n\x07\x041\x03\x01\x02\x03\x01\x12\x04\xec\x05\x18$\n\
    \x0f\n\x07\x041\x03\x01\x02\x03\x03\x12\x04\xec\x05'(\n\x0e\n\x06\x041\
    \x03\x01\x02\x04\x12\x04\xed\x05\x08%\n\x0f\n\x07\x041\x03\x01\x02\x04\
    \x04\x12\x04\xed\x05\x08\x10\n\x0f\n\x07\x041\x03\x01\x02\x04\x05\x12\
    \x04\xed\x05\x11\x17\n\x0f\n\x07\x041\x03\x01\x02\x04\x01\x12\x04\xed\
    \x05\x18\x20\n\x0f\n\x07\x041\x03\x01\x02\x04\x03\x12\x04\xed\x05#$\n\
    \x0e\n\x06\x041\x03\x01\x02\x05\x12\x04\xee\x05\x08%\n\x0f\n\x07\x041\
    \x03\x01\x02\x05\x04\x12\x04\xee\x05\x08\x10\n\x0f\n\x07\x041\x03\x01\
    \x02\x05\x05\x12\x04\xee\x05\x11\x16\n\x0f\n\x07\x041\x03\x01\x02\x05\
    \x01\x12\x04\xee\x05\x17\x20\n\x0f\n\x07\x041\x03\x01\x02\x05\x03\x12\
    \x04\xee\x05#$\n\x0e\n\x06\x041\x03\x01\x02\x06\x12\x04\xef\x05\x08'\n\
    \x0f\n\x07\x041\x03\x01\x02\x06\x04\x12\x04\xef\x05\x08\x10\n\x0f\n\x07\
    \x041\x03\x01\x02\x06\x05\x12\x04\xef\x05\x11\x17\n\x0f\n\x07\x041\x03\
    \x01\x02\x06\x01\x12\x04\xef\x05\x18\"\n\x0f\n\x07\x041\x03\x01\x02\x06\
    \x03\x12\x04\xef\x05%&\n\x0e\n\x06\x041\x03\x01\x02\x07\x12\x04\xf0\x05\
    \x08%\n\x0f\n\x07\x041\x03\x01\x02\x07\x04\x12\x04\xf0\x05\x08\x10\n\x0f\
    \n\x07\x041\x03\x01\x02\x07\x05\x12\x04\xf0\x05\x11\x17\n\x0f\n\x07\x041\
    \x03\x01\x02\x07\x01\x12\x04\xf0\x05\x18\x20\n\x0f\n\x07\x041\x03\x01\
    \x02\x07\x03\x12\x04\xf0\x05#$\n\x0e\n\x06\x041\x03\x01\x02\x08\x12\x04\
    \xf1\x05\x08&\n\x0f\n\x07\x041\x03\x01\x02\x08\x04\x12\x04\xf1\x05\x08\
    \x10\n\x0f\n\x07\x041\x03\x01\x02\x08\x05\x12\x04\xf1\x05\x11\x17\n\x0f\
    \n\x07\x041\x03\x01\x02\x08\x01\x12\x04\xf1\x05\x18!\n\x0f\n\x07\x041\
    \x03\x01\x02\x08\x03\x12\x04\xf1\x05$%\n\x0e\n\x06\x041\x03\x01\x02\t\
    \x12\x04\xf2\x05\x08-\n\x0f\n\x07\x041\x03\x01\x02\t\x04\x12\x04\xf2\x05\
    \x08\x10\n\x0f\n\x07\x041\x03\x01\x02\t\x05\x12\x04\xf2\x05\x11\x15\n\
    \x0f\n\x07\x041\x03\x01\x02\t\x01\x12\x04\xf2\x05\x16'\n\x0f\n\x07\x041\
    \x03\x01\x02\t\x03\x12\x04\xf2\x05*,\n\x0e\n\x06\x041\x03\x01\x02\n\x12\
    \x04\xf3\x05\x081\n\x0f\n\x07\x041\x03\x01\x02\n\x04\x12\x04\xf3\x05\x08\
    \x10\n\x0f\n\x07\x041\x03\x01\x02\n\x05\x12\x04\xf3\x05\x11\x15\n\x0f\n\
    \x07\x041\x03\x01\x02\n\x01\x12\x04\xf3\x05\x16+\n\x0f\n\x07\x041\x03\
    \x01\x02\n\x03\x12\x04\xf3\x05.0\n\x0e\n\x06\x041\x03\x01\x02\x0b\x12\
    \x04\xf4\x05\x08-\n\x0f\n\x07\x041\x03\x01\x02\x0b\x04\x12\x04\xf4\x05\
    \x08\x10\n\x0f\n\x07\x041\x03\x01\x02\x0b\x05\x12\x04\xf4\x05\x11\x15\n\
    \x0f\n\x07\x041\x03\x01\x02\x0b\x01\x12\x04\xf4\x05\x16'\n\x0f\n\x07\x04\
    1\x03\x01\x02\x0b\x03\x12\x04\xf4\x05*,\n\x0e\n\x06\x041\x03\x01\x02\x0c\
    \x12\x04\xf5\x05\x08&\n\x0f\n\x07\x041\x03\x01\x02\x0c\x04\x12\x04\xf5\
    \x05\x08\x10\n\x0f\n\x07\x041\x03\x01\x02\x0c\x05\x12\x04\xf5\x05\x11\
    \x17\n\x0f\n\x07\x041\x03\x01\x02\x0c\x01\x12\x04\xf5\x05\x18\x20\n\x0f\
    \n\x07\x041\x03\x01\x02\x0c\x03\x12\x04\xf5\x05#%\n\x0e\n\x04\x041\x03\
    \x02\x12\x06\xf8\x05\x04\x82\x06\x05\n\r\n\x05\x041\x03\x02\x01\x12\x04\
    \xf8\x05\x0c\x17\n\x10\n\x06\x041\x03\x02\x04\0\x12\x06\xf9\x05\x08\xfd\
    \x05\t\n\x0f\n\x07\x041\x03\x02\x04\0\x01\x12\x04\xf9\x05\r\x16\n\x10\n\
    \x08\x041\x03\x02\x04\0\x02\0\x12\x04\xfa\x05\x0c\x15\n\x11\n\t\x041\x03\
    \x02\x04\0\x02\0\x01\x12\x04\xfa\x05\x0c\x10\n\x11\n\t\x041\x03\x02\x04\
    \0\x02\0\x02\x12\x04\xfa\x05\x13\x14\n\x10\n\x08\x041\x03\x02\x04\0\x02\
    \x01\x12\x04\xfb\x05\x0c\x16\n\x11\n\t\x041\x03\x02\x04\0\x02\x01\x01\
    \x12\x04\xfb\x05\x0c\x11\n\x11\n\t\x041\x03\x02\x04\0\x02\x01\x02\x12\
    \x04\xfb\x05\x14\x15\n\x10\n\x08\x041\x03\x02\x04\0\x02\x02\x12\x04\xfc\
    \x05\x0c\x16\n\x11\n\t\x041\x03\x02\x04\0\x02\x02\x01\x12\x04\xfc\x05\
    \x0c\x11\n\x11\n\t\x041\x03\x02\x04\0\x02\x02\x02\x12\x04\xfc\x05\x14\
    \x15\n\x0e\n\x06\x041\x03\x02\x02\0\x12\x04\xfe\x05\x08+\n\x0f\n\x07\x04\
    1\x03\x02\x02\0\x04\x12\x04\xfe\x05\x08\x10\n\x0f\n\x07\x041\x03\x02\x02\
    \0\x05\x12\x04\xfe\x05\x11\x17\n\x0f\n\x07\x041\x03\x02\x02\0\x01\x12\
    \x04\xfe\x05\x18&\n\x0f\n\x07\x041\x03\x02\x02\0\x03\x12\x04\xfe\x05)*\n\
    \x0e\n\x06\x041\x03\x02\x02\x01\x12\x04\xff\x05\x08)\n\x0f\n\x07\x041\
    \x03\x02\x02\x01\x04\x12\x04\xff\x05\x08\x10\n\x0f\n\x07\x041\x03\x02\
    \x02\x01\x06\x12\x04\xff\x05\x11\x1a\n\x0f\n\x07\x041\x03\x02\x02\x01\
    \x01\x12\x04\xff\x05\x1b$\n\x0f\n\x07\x041\x03\x02\x02\x01\x03\x12\x04\
    \xff\x05'(\n\x0e\n\x06\x041\x03\x02\x02\x02\x12\x04\x80\x06\x08*\n\x0f\n\
    \x07\x041\x03\x02\x02\x02\x04\x12\x04\x80\x06\x08\x10\n\x0f\n\x07\x041\
    \x03\x02\x02\x02\x05\x12\x04\x80\x06\x11\x16\n\x0f\n\x07\x041\x03\x02\
    \x02\x02\x01\x12\x04\x80\x06\x17$\n\x0f\n\x07\x041\x03\x02\x02\x02\x03\
    \x12\x04\x80\x06')\n\x0e\n\x06\x041\x03\x02\x02\x03\x12\x04\x81\x06\x08%\
    \n\x0f\n\x07\x041\x03\x02\x02\x03\x04\x12\x04\x81\x06\x08\x10\n\x0f\n\
    \x07\x041\x03\x02\x02\x03\x05\x12\x04\x81\x06\x11\x17\n\x0f\n\x07\x041\
    \x03\x02\x02\x03\x01\x12\x04\x81\x06\x18\x1f\n\x0f\n\x07\x041\x03\x02\
    \x02\x03\x03\x12\x04\x81\x06\"$\n\x0c\n\x04\x041\x02\0\x12\x04\x84\x06\
    \x04!\n\r\n\x05\x041\x02\0\x04\x12\x04\x84\x06\x04\x0c\n\r\n\x05\x041\
    \x02\0\x05\x12\x04\x84\x06\r\x13\n\r\n\x05\x041\x02\0\x01\x12\x04\x84\
    \x06\x14\x1c\n\r\n\x05\x041\x02\0\x03\x12\x04\x84\x06\x1f\x20\n\x0c\n\
    \x04\x041\x02\x01\x12\x04\x85\x06\x04$\n\r\n\x05\x041\x02\x01\x04\x12\
    \x04\x85\x06\x04\x0c\n\r\n\x05\x041\x02\x01\x05\x12\x04\x85\x06\r\x13\n\
    \r\n\x05\x041\x02\x01\x01\x12\x04\x85\x06\x14\x1f\n\r\n\x05\x041\x02\x01\
    \x03\x12\x04\x85\x06\"#\n\x0c\n\x04\x041\x02\x02\x12\x04\x86\x06\x04'\n\
    \r\n\x05\x041\x02\x02\x04\x12\x04\x86\x06\x04\x0c\n\r\n\x05\x041\x02\x02\
    \x06\x12\x04\x86\x06\r\x14\n\r\n\x05\x041\x02\x02\x01\x12\x04\x86\x06\
    \x15\"\n\r\n\x05\x041\x02\x02\x03\x12\x04\x86\x06%&\n\x0c\n\x04\x041\x02\
    \x03\x12\x04\x87\x06\x04\"\n\r\n\x05\x041\x02\x03\x04\x12\x04\x87\x06\
    \x04\x0c\n\r\n\x05\x041\x02\x03\x05\x12\x04\x87\x06\r\x13\n\r\n\x05\x041\
    \x02\x03\x01\x12\x04\x87\x06\x14\x1d\n\r\n\x05\x041\x02\x03\x03\x12\x04\
    \x87\x06\x20!\n\x0c\n\x04\x041\x02\x04\x12\x04\x88\x06\x04&\n\r\n\x05\
    \x041\x02\x04\x04\x12\x04\x88\x06\x04\x0c\n\r\n\x05\x041\x02\x04\x05\x12\
    \x04\x88\x06\r\x13\n\r\n\x05\x041\x02\x04\x01\x12\x04\x88\x06\x14\x20\n\
    \r\n\x05\x041\x02\x04\x03\x12\x04\x88\x06#%\n\x0c\n\x04\x041\x02\x05\x12\
    \x04\x89\x06\x04*\n\r\n\x05\x041\x02\x05\x04\x12\x04\x89\x06\x04\x0c\n\r\
    \n\x05\x041\x02\x05\x05\x12\x04\x89\x06\r\x13\n\r\n\x05\x041\x02\x05\x01\
    \x12\x04\x89\x06\x14$\n\r\n\x05\x041\x02\x05\x03\x12\x04\x89\x06')\n\x0c\
    \n\x04\x041\x02\x06\x12\x04\x8a\x06\x04'\n\r\n\x05\x041\x02\x06\x04\x12\
    \x04\x8a\x06\x04\x0c\n\r\n\x05\x041\x02\x06\x05\x12\x04\x8a\x06\r\x12\n\
    \r\n\x05\x041\x02\x06\x01\x12\x04\x8a\x06\x13!\n\r\n\x05\x041\x02\x06\
    \x03\x12\x04\x8a\x06$&\n\x0c\n\x04\x041\x02\x07\x12\x04\x8b\x06\x040\n\r\
    \n\x05\x041\x02\x07\x04\x12\x04\x8b\x06\x04\x0c\n\r\n\x05\x041\x02\x07\
    \x05\x12\x04\x8b\x06\r\x13\n\r\n\x05\x041\x02\x07\x01\x12\x04\x8b\x06\
    \x14*\n\r\n\x05\x041\x02\x07\x03\x12\x04\x8b\x06-/\n\x0c\n\x04\x041\x02\
    \x08\x12\x04\x8c\x06\x04)\n\r\n\x05\x041\x02\x08\x04\x12\x04\x8c\x06\x04\
    \x0c\n\r\n\x05\x041\x02\x08\x05\x12\x04\x8c\x06\r\x13\n\r\n\x05\x041\x02\
    \x08\x01\x12\x04\x8c\x06\x14#\n\r\n\x05\x041\x02\x08\x03\x12\x04\x8c\x06\
    &(\n\x0c\n\x04\x041\x02\t\x12\x04\x8d\x06\x04#\n\r\n\x05\x041\x02\t\x04\
    \x12\x04\x8d\x06\x04\x0c\n\r\n\x05\x041\x02\t\x05\x12\x04\x8d\x06\r\x11\
    \n\r\n\x05\x041\x02\t\x01\x12\x04\x8d\x06\x12\x1d\n\r\n\x05\x041\x02\t\
    \x03\x12\x04\x8d\x06\x20\"\n\x0c\n\x04\x041\x02\n\x12\x04\x8e\x06\x04'\n\
    \r\n\x05\x041\x02\n\x04\x12\x04\x8e\x06\x04\x0c\n\r\n\x05\x041\x02\n\x06\
    \x12\x04\x8e\x06\r\x18\n\r\n\x05\x041\x02\n\x01\x12\x04\x8e\x06\x19!\n\r\
    \n\x05\x041\x02\n\x03\x12\x04\x8e\x06$&\n\x0c\n\x04\x041\x02\x0b\x12\x04\
    \x8f\x06\x04,\n\r\n\x05\x041\x02\x0b\x04\x12\x04\x8f\x06\x04\x0c\n\r\n\
    \x05\x041\x02\x0b\x06\x12\x04\x8f\x06\r\x17\n\r\n\x05\x041\x02\x0b\x01\
    \x12\x04\x8f\x06\x18&\n\r\n\x05\x041\x02\x0b\x03\x12\x04\x8f\x06)+\n\x0c\
    \n\x04\x041\x02\x0c\x12\x04\x90\x06\x04$\n\r\n\x05\x041\x02\x0c\x04\x12\
    \x04\x90\x06\x04\x0c\n\r\n\x05\x041\x02\x0c\x05\x12\x04\x90\x06\r\x13\n\
    \r\n\x05\x041\x02\x0c\x01\x12\x04\x90\x06\x14\x1e\n\r\n\x05\x041\x02\x0c\
    \x03\x12\x04\x90\x06!#\n\x0c\n\x04\x041\x02\r\x12\x04\x91\x06\x042\n\r\n\
    \x05\x041\x02\r\x04\x12\x04\x91\x06\x04\x0c\n\r\n\x05\x041\x02\r\x05\x12\
    \x04\x91\x06\r\x12\n\r\n\x05\x041\x02\r\x01\x12\x04\x91\x06\x13,\n\r\n\
    \x05\x041\x02\r\x03\x12\x04\x91\x06/1\n\x0c\n\x04\x041\x02\x0e\x12\x04\
    \x92\x06\x04.\n\r\n\x05\x041\x02\x0e\x04\x12\x04\x92\x06\x04\x0c\n\r\n\
    \x05\x041\x02\x0e\x05\x12\x04\x92\x06\r\x12\n\r\n\x05\x041\x02\x0e\x01\
    \x12\x04\x92\x06\x13(\n\r\n\x05\x041\x02\x0e\x03\x12\x04\x92\x06+-\n\x0c\
    \n\x04\x041\x02\x0f\x12\x04\x93\x06\x046\n\r\n\x05\x041\x02\x0f\x04\x12\
    \x04\x93\x06\x04\x0c\n\r\n\x05\x041\x02\x0f\x06\x12\x04\x93\x06\r\x20\n\
    \r\n\x05\x041\x02\x0f\x01\x12\x04\x93\x06!0\n\r\n\x05\x041\x02\x0f\x03\
    \x12\x04\x93\x0635\n\x0c\n\x04\x041\x02\x10\x12\x04\x94\x06\x044\n\r\n\
    \x05\x041\x02\x10\x04\x12\x04\x94\x06\x04\x0c\n\r\n\x05\x041\x02\x10\x05\
    \x12\x04\x94\x06\r\x13\n\r\n\x05\x041\x02\x10\x01\x12\x04\x94\x06\x14.\n\
    \r\n\x05\x041\x02\x10\x03\x12\x04\x94\x0613\n\x0c\n\x04\x041\x02\x11\x12\
    \x04\x95\x06\x041\n\r\n\x05\x041\x02\x11\x04\x12\x04\x95\x06\x04\x0c\n\r\
    \n\x05\x041\x02\x11\x05\x12\x04\x95\x06\r\x13\n\r\n\x05\x041\x02\x11\x01\
    \x12\x04\x95\x06\x14+\n\r\n\x05\x041\x02\x11\x03\x12\x04\x95\x06.0\n\x0c\
    \n\x04\x041\x02\x12\x12\x04\x96\x06\x04:\n\r\n\x05\x041\x02\x12\x04\x12\
    \x04\x96\x06\x04\x0c\n\r\n\x05\x041\x02\x12\x05\x12\x04\x96\x06\r\x13\n\
    \r\n\x05\x041\x02\x12\x01\x12\x04\x96\x06\x144\n\r\n\x05\x041\x02\x12\
    \x03\x12\x04\x96\x0679\n\x0c\n\x04\x041\x02\x13\x12\x04\x97\x06\x044\n\r\
    \n\x05\x041\x02\x13\x04\x12\x04\x97\x06\x04\x0c\n\r\n\x05\x041\x02\x13\
    \x06\x12\x04\x97\x06\r\x1d\n\r\n\x05\x041\x02\x13\x01\x12\x04\x97\x06\
    \x1e.\n\r\n\x05\x041\x02\x13\x03\x12\x04\x97\x0613\n\x0c\n\x04\x041\x02\
    \x14\x12\x04\x98\x06\x04(\n\r\n\x05\x041\x02\x14\x04\x12\x04\x98\x06\x04\
    \x0c\n\r\n\x05\x041\x02\x14\x06\x12\x04\x98\x06\r\x17\n\r\n\x05\x041\x02\
    \x14\x01\x12\x04\x98\x06\x18\"\n\r\n\x05\x041\x02\x14\x03\x12\x04\x98\
    \x06%'\n\x0c\n\x04\x041\x02\x15\x12\x04\x99\x06\x04&\n\r\n\x05\x041\x02\
    \x15\x04\x12\x04\x99\x06\x04\x0c\n\r\n\x05\x041\x02\x15\x05\x12\x04\x99\
    \x06\r\x13\n\r\n\x05\x041\x02\x15\x01\x12\x04\x99\x06\x14\x20\n\r\n\x05\
    \x041\x02\x15\x03\x12\x04\x99\x06#%\n\x0c\n\x04\x041\x02\x16\x12\x04\x9a\
    \x06\x04(\n\r\n\x05\x041\x02\x16\x04\x12\x04\x9a\x06\x04\x0c\n\r\n\x05\
    \x041\x02\x16\x05\x12\x04\x9a\x06\r\x13\n\r\n\x05\x041\x02\x16\x01\x12\
    \x04\x9a\x06\x14\"\n\r\n\x05\x041\x02\x16\x03\x12\x04\x9a\x06%'\n\x0c\n\
    \x04\x041\x02\x17\x12\x04\x9b\x06\x04)\n\r\n\x05\x041\x02\x17\x04\x12\
    \x04\x9b\x06\x04\x0c\n\r\n\x05\x041\x02\x17\x05\x12\x04\x9b\x06\r\x13\n\
    \r\n\x05\x041\x02\x17\x01\x12\x04\x9b\x06\x14#\n\r\n\x05\x041\x02\x17\
    \x03\x12\x04\x9b\x06&(\n\x0c\n\x04\x041\x02\x18\x12\x04\x9c\x06\x04+\n\r\
    \n\x05\x041\x02\x18\x04\x12\x04\x9c\x06\x04\x0c\n\r\n\x05\x041\x02\x18\
    \x05\x12\x04\x9c\x06\r\x13\n\r\n\x05\x041\x02\x18\x01\x12\x04\x9c\x06\
    \x14%\n\r\n\x05\x041\x02\x18\x03\x12\x04\x9c\x06(*\n\x0c\n\x04\x041\x02\
    \x19\x12\x04\x9d\x06\x04!\n\r\n\x05\x041\x02\x19\x04\x12\x04\x9d\x06\x04\
    \x0c\n\r\n\x05\x041\x02\x19\x05\x12\x04\x9d\x06\r\x11\n\r\n\x05\x041\x02\
    \x19\x01\x12\x04\x9d\x06\x12\x1b\n\r\n\x05\x041\x02\x19\x03\x12\x04\x9d\
    \x06\x1e\x20\n\x0c\n\x04\x041\x02\x1a\x12\x04\x9e\x06\x04-\n\r\n\x05\x04\
    1\x02\x1a\x04\x12\x04\x9e\x06\x04\x0c\n\r\n\x05\x041\x02\x1a\x06\x12\x04\
    \x9e\x06\r\x19\n\r\n\x05\x041\x02\x1a\x01\x12\x04\x9e\x06\x1a'\n\r\n\x05\
    \x041\x02\x1a\x03\x12\x04\x9e\x06*,\n\x0c\n\x04\x041\x02\x1b\x12\x04\x9f\
    \x06\x04\x1e\n\r\n\x05\x041\x02\x1b\x04\x12\x04\x9f\x06\x04\x0c\n\r\n\
    \x05\x041\x02\x1b\x06\x12\x04\x9f\x06\r\x14\n\r\n\x05\x041\x02\x1b\x01\
    \x12\x04\x9f\x06\x15\x18\n\r\n\x05\x041\x02\x1b\x03\x12\x04\x9f\x06\x1b\
    \x1d\n\x0c\n\x02\x042\x12\x06\xa2\x06\0\xa5\x06\x01\n\x0b\n\x03\x042\x01\
    \x12\x04\xa2\x06\x08\x12\n\x0c\n\x04\x042\x02\0\x12\x04\xa3\x06\x04\x1c\
    \n\r\n\x05\x042\x02\0\x04\x12\x04\xa3\x06\x04\x0c\n\r\n\x05\x042\x02\0\
    \x05\x12\x04\xa3\x06\r\x13\n\r\n\x05\x042\x02\0\x01\x12\x04\xa3\x06\x14\
    \x17\n\r\n\x05\x042\x02\0\x03\x12\x04\xa3\x06\x1a\x1b\n\x0c\n\x04\x042\
    \x02\x01\x12\x04\xa4\x06\x04$\n\r\n\x05\x042\x02\x01\x04\x12\x04\xa4\x06\
    \x04\x0c\n\r\n\x05\x042\x02\x01\x05\x12\x04\xa4\x06\r\x13\n\r\n\x05\x042\
    \x02\x01\x01\x12\x04\xa4\x06\x14\x1f\n\r\n\x05\x042\x02\x01\x03\x12\x04\
    \xa4\x06\"#\n\x0c\n\x02\x043\x12\x06\xa7\x06\0\xbd\x06\x01\n\x0b\n\x03\
    \x043\x01\x12\x04\xa7\x06\x08\x16\n\x0e\n\x04\x043\x03\0\x12\x06\xa8\x06\
    \x04\xab\x06\x05\n\r\n\x05\x043\x03\0\x01\x12\x04\xa8\x06\x0c\x15\n\x0e\
    \n\x06\x043\x03\0\x02\0\x12\x04\xa9\x06\x089\n\x0f\n\x07\x043\x03\0\x02\
    \0\x04\x12\x04\xa9\x06\x08\x10\n\x0f\n\x07\x043\x03\0\x02\0\x06\x12\x04\
    \xa9\x06\x11(\n\x0f\n\x07\x043\x03\0\x02\0\x01\x12\x04\xa9\x06)4\n\x0f\n\
    \x07\x043\x03\0\x02\0\x03\x12\x04\xa9\x0678\n\x0e\n\x06\x043\x03\0\x02\
    \x01\x12\x04\xaa\x06\x081\n\x0f\n\x07\x043\x03\0\x02\x01\x04\x12\x04\xaa\
    \x06\x08\x10\n\x0f\n\x07\x043\x03\0\x02\x01\x06\x12\x04\xaa\x06\x11(\n\
    \x0f\n\x07\x043\x03\0\x02\x01\x01\x12\x04\xaa\x06),\n\x0f\n\x07\x043\x03\
    \0\x02\x01\x03\x12\x04\xaa\x06/0\n\x0e\n\x04\x043\x03\x01\x12\x06\xad\
    \x06\x04\xb0\x06\x05\n\r\n\x05\x043\x03\x01\x01\x12\x04\xad\x06\x0c\x1c\
    \n\x0e\n\x06\x043\x03\x01\x02\0\x12\x04\xae\x06\x089\n\x0f\n\x07\x043\
    \x03\x01\x02\0\x04\x12\x04\xae\x06\x08\x10\n\x0f\n\x07\x043\x03\x01\x02\
    \0\x06\x12\x04\xae\x06\x11(\n\x0f\n\x07\x043\x03\x01\x02\0\x01\x12\x04\
    \xae\x06)4\n\x0f\n\x07\x043\x03\x01\x02\0\x03\x12\x04\xae\x0678\n\x0e\n\
    \x06\x043\x03\x01\x02\x01\x12\x04\xaf\x06\x08\x1f\n\x0f\n\x07\x043\x03\
    \x01\x02\x01\x04\x12\x04\xaf\x06\x08\x10\n\x0f\n\x07\x043\x03\x01\x02\
    \x01\x05\x12\x04\xaf\x06\x11\x17\n\x0f\n\x07\x043\x03\x01\x02\x01\x01\
    \x12\x04\xaf\x06\x18\x1a\n\x0f\n\x07\x043\x03\x01\x02\x01\x03\x12\x04\
    \xaf\x06\x1d\x1e\n\x0e\n\x04\x043\x03\x02\x12\x06\xb2\x06\x04\xb5\x06\
    \x05\n\r\n\x05\x043\x03\x02\x01\x12\x04\xb2\x06\x0c\x16\n\x0e\n\x06\x043\
    \x03\x02\x02\0\x12\x04\xb3\x06\x089\n\x0f\n\x07\x043\x03\x02\x02\0\x04\
    \x12\x04\xb3\x06\x08\x10\n\x0f\n\x07\x043\x03\x02\x02\0\x06\x12\x04\xb3\
    \x06\x11(\n\x0f\n\x07\x043\x03\x02\x02\0\x01\x12\x04\xb3\x06)4\n\x0f\n\
    \x07\x043\x03\x02\x02\0\x03\x12\x04\xb3\x0678\n\x0e\n\x06\x043\x03\x02\
    \x02\x01\x12\x04\xb4\x06\x089\n\x0f\n\x07\x043\x03\x02\x02\x01\x04\x12\
    \x04\xb4\x06\x08\x10\n\x0f\n\x07\x043\x03\x02\x02\x01\x06\x12\x04\xb4\
    \x06\x11(\n\x0f\n\x07\x043\x03\x02\x02\x01\x01\x12\x04\xb4\x06)4\n\x0f\n\
    \x07\x043\x03\x02\x02\x01\x03\x12\x04\xb4\x0678\n\x0c\n\x04\x043\x02\0\
    \x12\x04\xb7\x06\x04\x1e\n\r\n\x05\x043\x02\0\x04\x12\x04\xb7\x06\x04\
    \x0c\n\r\n\x05\x043\x02\0\x05\x12\x04\xb7\x06\r\x13\n\r\n\x05\x043\x02\0\
    \x01\x12\x04\xb7\x06\x14\x19\n\r\n\x05\x043\x02\0\x03\x12\x04\xb7\x06\
    \x1c\x1d\n\x0e\n\x04\x043\x08\0\x12\x06\xb8\x06\x04\xbc\x06\x05\n\r\n\
    \x05\x043\x08\0\x01\x12\x04\xb8\x06\n\x10\n\x0c\n\x04\x043\x02\x01\x12\
    \x04\xb9\x06\x08.\n\r\n\x05\x043\x02\x01\x06\x12\x04\xb9\x06\x08\x18\n\r\
    \n\x05\x043\x02\x01\x01\x12\x04\xb9\x06\x19)\n\r\n\x05\x043\x02\x01\x03\
    \x12\x04\xb9\x06,-\n\x0c\n\x04\x043\x02\x02\x12\x04\xba\x06\x08\x20\n\r\
    \n\x05\x043\x02\x02\x06\x12\x04\xba\x06\x08\x11\n\r\n\x05\x043\x02\x02\
    \x01\x12\x04\xba\x06\x12\x1b\n\r\n\x05\x043\x02\x02\x03\x12\x04\xba\x06\
    \x1e\x1f\n\x0c\n\x04\x043\x02\x03\x12\x04\xbb\x06\x08\"\n\r\n\x05\x043\
    \x02\x03\x06\x12\x04\xbb\x06\x08\x12\n\r\n\x05\x043\x02\x03\x01\x12\x04\
    \xbb\x06\x13\x1d\n\r\n\x05\x043\x02\x03\x03\x12\x04\xbb\x06\x20!\n\x0c\n\
    \x02\x044\x12\x06\xbf\x06\0\xc4\x06\x01\n\x0b\n\x03\x044\x01\x12\x04\xbf\
    \x06\x08\r\n\x0c\n\x04\x044\x02\0\x12\x04\xc0\x06\x04#\n\r\n\x05\x044\
    \x02\0\x04\x12\x04\xc0\x06\x04\x0c\n\r\n\x05\x044\x02\0\x05\x12\x04\xc0\
    \x06\r\x12\n\r\n\x05\x044\x02\0\x01\x12\x04\xc0\x06\x13\x1e\n\r\n\x05\
    \x044\x02\0\x03\x12\x04\xc0\x06!\"\n\x0c\n\x04\x044\x02\x01\x12\x04\xc1\
    \x06\x04#\n\r\n\x05\x044\x02\x01\x04\x12\x04\xc1\x06\x04\x0c\n\r\n\x05\
    \x044\x02\x01\x05\x12\x04\xc1\x06\r\x12\n\r\n\x05\x044\x02\x01\x01\x12\
    \x04\xc1\x06\x13\x1e\n\r\n\x05\x044\x02\x01\x03\x12\x04\xc1\x06!\"\n\x0c\
    \n\x04\x044\x02\x02\x12\x04\xc2\x06\x04\x1a\n\r\n\x05\x044\x02\x02\x04\
    \x12\x04\xc2\x06\x04\x0c\n\r\n\x05\x044\x02\x02\x05\x12\x04\xc2\x06\r\
    \x13\n\r\n\x05\x044\x02\x02\x01\x12\x04\xc2\x06\x14\x15\n\r\n\x05\x044\
    \x02\x02\x03\x12\x04\xc2\x06\x18\x19\n\x0c\n\x04\x044\x02\x03\x12\x04\
    \xc3\x06\x04\x1a\n\r\n\x05\x044\x02\x03\x04\x12\x04\xc3\x06\x04\x0c\n\r\
    \n\x05\x044\x02\x03\x05\x12\x04\xc3\x06\r\x13\n\r\n\x05\x044\x02\x03\x01\
    \x12\x04\xc3\x06\x14\x15\n\r\n\x05\x044\x02\x03\x03\x12\x04\xc3\x06\x18\
    \x19\n\x0c\n\x02\x045\x12\x06\xc6\x06\0\xdd\x06\x01\n\x0b\n\x03\x045\x01\
    \x12\x04\xc6\x06\x08\x19\n\x0e\n\x04\x045\x04\0\x12\x06\xc7\x06\x04\xca\
    \x06\x05\n\r\n\x05\x045\x04\0\x01\x12\x04\xc7\x06\t\r\n\x0e\n\x06\x045\
    \x04\0\x02\0\x12\x04\xc8\x06\x08\x14\n\x0f\n\x07\x045\x04\0\x02\0\x01\
    \x12\x04\xc8\x06\x08\x0f\n\x0f\n\x07\x045\x04\0\x02\0\x02\x12\x04\xc8\
    \x06\x12\x13\n\x0e\n\x06\x045\x04\0\x02\x01\x12\x04\xc9\x06\x08\x14\n\
    \x0f\n\x07\x045\x04\0\x02\x01\x01\x12\x04\xc9\x06\x08\x0f\n\x0f\n\x07\
    \x045\x04\0\x02\x01\x02\x12\x04\xc9\x06\x12\x13\n\x0e\n\x04\x045\x03\0\
    \x12\x06\xcb\x06\x04\xd1\x06\x05\n\r\n\x05\x045\x03\0\x01\x12\x04\xcb\
    \x06\x0c\x15\n\x0e\n\x06\x045\x03\0\x02\0\x12\x04\xcc\x06\x08$\n\x0f\n\
    \x07\x045\x03\0\x02\0\x04\x12\x04\xcc\x06\x08\x10\n\x0f\n\x07\x045\x03\0\
    \x02\0\x05\x12\x04\xcc\x06\x11\x16\n\x0f\n\x07\x045\x03\0\x02\0\x01\x12\
    \x04\xcc\x06\x17\x1f\n\x0f\n\x07\x045\x03\0\x02\0\x03\x12\x04\xcc\x06\"#\
    \n\x0e\n\x06\x045\x03\0\x02\x01\x12\x04\xcd\x06\x08-\n\x0f\n\x07\x045\
    \x03\0\x02\x01\x04\x12\x04\xcd\x06\x08\x10\n\x0f\n\x07\x045\x03\0\x02\
    \x01\x05\x12\x04\xcd\x06\x11\x16\n\x0f\n\x07\x045\x03\0\x02\x01\x01\x12\
    \x04\xcd\x06\x17(\n\x0f\n\x07\x045\x03\0\x02\x01\x03\x12\x04\xcd\x06+,\n\
    \x0e\n\x06\x045\x03\0\x02\x02\x12\x04\xce\x06\x08&\n\x0f\n\x07\x045\x03\
    \0\x02\x02\x04\x12\x04\xce\x06\x08\x10\n\x0f\n\x07\x045\x03\0\x02\x02\
    \x05\x12\x04\xce\x06\x11\x16\n\x0f\n\x07\x045\x03\0\x02\x02\x01\x12\x04\
    \xce\x06\x17!\n\x0f\n\x07\x045\x03\0\x02\x02\x03\x12\x04\xce\x06$%\n\x0e\
    \n\x06\x045\x03\0\x02\x03\x12\x04\xcf\x06\x08)\n\x0f\n\x07\x045\x03\0\
    \x02\x03\x04\x12\x04\xcf\x06\x08\x10\n\x0f\n\x07\x045\x03\0\x02\x03\x05\
    \x12\x04\xcf\x06\x11\x16\n\x0f\n\x07\x045\x03\0\x02\x03\x01\x12\x04\xcf\
    \x06\x17$\n\x0f\n\x07\x045\x03\0\x02\x03\x03\x12\x04\xcf\x06'(\n\x0e\n\
    \x06\x045\x03\0\x02\x04\x12\x04\xd0\x06\x08'\n\x0f\n\x07\x045\x03\0\x02\
    \x04\x04\x12\x04\xd0\x06\x08\x10\n\x0f\n\x07\x045\x03\0\x02\x04\x05\x12\
    \x04\xd0\x06\x11\x17\n\x0f\n\x07\x045\x03\0\x02\x04\x01\x12\x04\xd0\x06\
    \x18\"\n\x0f\n\x07\x045\x03\0\x02\x04\x03\x12\x04\xd0\x06%&\n\x0c\n\x04\
    \x045\x02\0\x12\x04\xd3\x06\x04\x1b\n\r\n\x05\x045\x02\0\x04\x12\x04\xd3\
    \x06\x04\x0c\n\r\n\x05\x045\x02\0\x05\x12\x04\xd3\x06\r\x13\n\r\n\x05\
    \x045\x02\0\x01\x12\x04\xd3\x06\x14\x16\n\r\n\x05\x045\x02\0\x03\x12\x04\
    \xd3\x06\x19\x1a\n\x0c\n\x04\x045\x02\x01\x12\x04\xd4\x06\x04#\n\r\n\x05\
    \x045\x02\x01\x04\x12\x04\xd4\x06\x04\x0c\n\r\n\x05\x045\x02\x01\x05\x12\
    \x04\xd4\x06\r\x13\n\r\n\x05\x045\x02\x01\x01\x12\x04\xd4\x06\x14\x1e\n\
    \r\n\x05\x045\x02\x01\x03\x12\x04\xd4\x06!\"\n\x0c\n\x04\x045\x02\x02\
    \x12\x04\xd5\x06\x04\x1e\n\r\n\x05\x045\x02\x02\x04\x12\x04\xd5\x06\x04\
    \x0c\n\r\n\x05\x045\x02\x02\x05\x12\x04\xd5\x06\r\x13\n\r\n\x05\x045\x02\
    \x02\x01\x12\x04\xd5\x06\x14\x19\n\r\n\x05\x045\x02\x02\x03\x12\x04\xd5\
    \x06\x1c\x1d\n\x0c\n\x04\x045\x02\x03\x12\x04\xd6\x06\x04\x1f\n\r\n\x05\
    \x045\x02\x03\x04\x12\x04\xd6\x06\x04\x0c\n\r\n\x05\x045\x02\x03\x05\x12\
    \x04\xd6\x06\r\x13\n\r\n\x05\x045\x02\x03\x01\x12\x04\xd6\x06\x14\x1a\n\
    \r\n\x05\x045\x02\x03\x03\x12\x04\xd6\x06\x1d\x1e\n\x0c\n\x04\x045\x02\
    \x04\x12\x04\xd7\x06\x04!\n\r\n\x05\x045\x02\x04\x04\x12\x04\xd7\x06\x04\
    \x0c\n\r\n\x05\x045\x02\x04\x05\x12\x04\xd7\x06\r\x13\n\r\n\x05\x045\x02\
    \x04\x01\x12\x04\xd7\x06\x14\x1c\n\r\n\x05\x045\x02\x04\x03\x12\x04\xd7\
    \x06\x1f\x20\n\x0c\n\x04\x045\x02\x05\x12\x04\xd8\x06\x04)\n\r\n\x05\x04\
    5\x02\x05\x04\x12\x04\xd8\x06\x04\x0c\n\r\n\x05\x045\x02\x05\x05\x12\x04\
    \xd8\x06\r\x14\n\r\n\x05\x045\x02\x05\x01\x12\x04\xd8\x06\x15$\n\r\n\x05\
    \x045\x02\x05\x03\x12\x04\xd8\x06'(\n\x0c\n\x04\x045\x02\x06\x12\x04\xd9\
    \x06\x04\"\n\r\n\x05\x045\x02\x06\x04\x12\x04\xd9\x06\x04\x0c\n\r\n\x05\
    \x045\x02\x06\x05\x12\x04\xd9\x06\r\x14\n\r\n\x05\x045\x02\x06\x01\x12\
    \x04\xd9\x06\x15\x1d\n\r\n\x05\x045\x02\x06\x03\x12\x04\xd9\x06\x20!\n\
    \x0c\n\x04\x045\x02\x07\x12\x04\xda\x06\x04%\n\r\n\x05\x045\x02\x07\x04\
    \x12\x04\xda\x06\x04\x0c\n\r\n\x05\x045\x02\x07\x05\x12\x04\xda\x06\r\
    \x14\n\r\n\x05\x045\x02\x07\x01\x12\x04\xda\x06\x15\x20\n\r\n\x05\x045\
    \x02\x07\x03\x12\x04\xda\x06#$\n\x0c\n\x04\x045\x02\x08\x12\x04\xdb\x06\
    \x04%\n\r\n\x05\x045\x02\x08\x04\x12\x04\xdb\x06\x04\x0c\n\r\n\x05\x045\
    \x02\x08\x06\x12\x04\xdb\x06\r\x16\n\r\n\x05\x045\x02\x08\x01\x12\x04\
    \xdb\x06\x17\x20\n\r\n\x05\x045\x02\x08\x03\x12\x04\xdb\x06#$\n\x0c\n\
    \x04\x045\x02\t\x12\x04\xdc\x06\x04\x1c\n\r\n\x05\x045\x02\t\x04\x12\x04\
    \xdc\x06\x04\x0c\n\r\n\x05\x045\x02\t\x06\x12\x04\xdc\x06\r\x11\n\r\n\
    \x05\x045\x02\t\x01\x12\x04\xdc\x06\x12\x16\n\r\n\x05\x045\x02\t\x03\x12\
    \x04\xdc\x06\x19\x1b\n\x0c\n\x02\x046\x12\x06\xdf\x06\0\xe3\x06\x01\n\
    \x0b\n\x03\x046\x01\x12\x04\xdf\x06\x08\r\n\x0c\n\x04\x046\x02\0\x12\x04\
    \xe0\x06\x04\x1d\n\r\n\x05\x046\x02\0\x04\x12\x04\xe0\x06\x04\x0c\n\r\n\
    \x05\x046\x02\0\x05\x12\x04\xe0\x06\r\x12\n\r\n\x05\x046\x02\0\x01\x12\
    \x04\xe0\x06\x13\x18\n\r\n\x05\x046\x02\0\x03\x12\x04\xe0\x06\x1b\x1c\n\
    \x0c\n\x04\x046\x02\x01\x12\x04\xe1\x06\x04\x1f\n\r\n\x05\x046\x02\x01\
    \x04\x12\x04\xe1\x06\x04\x0c\n\r\n\x05\x046\x02\x01\x05\x12\x04\xe1\x06\
    \r\x13\n\r\n\x05\x046\x02\x01\x01\x12\x04\xe1\x06\x14\x1a\n\r\n\x05\x046\
    \x02\x01\x03\x12\x04\xe1\x06\x1d\x1e\n\x0c\n\x04\x046\x02\x02\x12\x04\
    \xe2\x06\x04%\n\r\n\x05\x046\x02\x02\x04\x12\x04\xe2\x06\x04\x0c\n\r\n\
    \x05\x046\x02\x02\x05\x12\x04\xe2\x06\r\x13\n\r\n\x05\x046\x02\x02\x01\
    \x12\x04\xe2\x06\x14\x20\n\r\n\x05\x046\x02\x02\x03\x12\x04\xe2\x06#$\n\
    \x0c\n\x02\x047\x12\x06\xe5\x06\0\x9d\x07\x01\n\x0b\n\x03\x047\x01\x12\
    \x04\xe5\x06\x08\x0f\n\x0c\n\x04\x047\x02\0\x12\x04\xe6\x06\x04%\n\r\n\
    \x05\x047\x02\0\x04\x12\x04\xe6\x06\x04\x0c\n\r\n\x05\x047\x02\0\x05\x12\
    \x04\xe6\x06\r\x13\n\r\n\x05\x047\x02\0\x01\x12\x04\xe6\x06\x14\x20\n\r\
    \n\x05\x047\x02\0\x03\x12\x04\xe6\x06#$\n\x0c\n\x04\x047\x02\x01\x12\x04\
    \xe7\x06\x04K\n\r\n\x05\x047\x02\x01\x04\x12\x04\xe7\x06\x04\x0c\n\r\n\
    \x05\x047\x02\x01\x06\x12\x04\xe7\x06\r)\n\r\n\x05\x047\x02\x01\x01\x12\
    \x04\xe7\x06*F\n\r\n\x05\x047\x02\x01\x03\x12\x04\xe7\x06IJ\n\x0c\n\x04\
    \x047\x02\x02\x12\x04\xe8\x06\x04+\n\r\n\x05\x047\x02\x02\x04\x12\x04\
    \xe8\x06\x04\x0c\n\r\n\x05\x047\x02\x02\x06\x12\x04\xe8\x06\r\x19\n\r\n\
    \x05\x047\x02\x02\x01\x12\x04\xe8\x06\x1a&\n\r\n\x05\x047\x02\x02\x03\
    \x12\x04\xe8\x06)*\n\x0c\n\x04\x047\x02\x03\x12\x04\xe9\x06\x04/\n\r\n\
    \x05\x047\x02\x03\x04\x12\x04\xe9\x06\x04\x0c\n\r\n\x05\x047\x02\x03\x06\
    \x12\x04\xe9\x06\r\x1b\n\r\n\x05\x047\x02\x03\x01\x12\x04\xe9\x06\x1c*\n\
    \r\n\x05\x047\x02\x03\x03\x12\x04\xe9\x06-.\n\x0c\n\x04\x047\x02\x04\x12\
    \x04\xea\x06\x041\n\r\n\x05\x047\x02\x04\x04\x12\x04\xea\x06\x04\x0c\n\r\
    \n\x05\x047\x02\x04\x06\x12\x04\xea\x06\r\x1c\n\r\n\x05\x047\x02\x04\x01\
    \x12\x04\xea\x06\x1d,\n\r\n\x05\x047\x02\x04\x03\x12\x04\xea\x06/0\n\x0c\
    \n\x04\x047\x02\x05\x12\x04\xeb\x06\x049\n\r\n\x05\x047\x02\x05\x04\x12\
    \x04\xeb\x06\x04\x0c\n\r\n\x05\x047\x02\x05\x06\x12\x04\xeb\x06\r\x20\n\
    \r\n\x05\x047\x02\x05\x01\x12\x04\xeb\x06!4\n\r\n\x05\x047\x02\x05\x03\
    \x12\x04\xeb\x0678\n\x0c\n\x04\x047\x02\x06\x12\x04\xec\x06\x041\n\r\n\
    \x05\x047\x02\x06\x04\x12\x04\xec\x06\x04\x0c\n\r\n\x05\x047\x02\x06\x06\
    \x12\x04\xec\x06\r\x1c\n\r\n\x05\x047\x02\x06\x01\x12\x04\xec\x06\x1d,\n\
    \r\n\x05\x047\x02\x06\x03\x12\x04\xec\x06/0\n\x0c\n\x04\x047\x02\x07\x12\
    \x04\xed\x06\x04+\n\r\n\x05\x047\x02\x07\x04\x12\x04\xed\x06\x04\x0c\n\r\
    \n\x05\x047\x02\x07\x06\x12\x04\xed\x06\r\x19\n\r\n\x05\x047\x02\x07\x01\
    \x12\x04\xed\x06\x1a&\n\r\n\x05\x047\x02\x07\x03\x12\x04\xed\x06)*\n\x0c\
    \n\x04\x047\x02\x08\x12\x04\xee\x06\x04+\n\r\n\x05\x047\x02\x08\x04\x12\
    \x04\xee\x06\x04\x0c\n\r\n\x05\x047\x02\x08\x06\x12\x04\xee\x06\r\x19\n\
    \r\n\x05\x047\x02\x08\x01\x12\x04\xee\x06\x1a&\n\r\n\x05\x047\x02\x08\
    \x03\x12\x04\xee\x06)*\n\x0c\n\x04\x047\x02\t\x12\x04\xef\x06\x04\x1c\n\
    \r\n\x05\x047\x02\t\x04\x12\x04\xef\x06\x04\x0c\n\r\n\x05\x047\x02\t\x06\
    \x12\x04\xef\x06\r\x11\n\r\n\x05\x047\x02\t\x01\x12\x04\xef\x06\x12\x16\
    \n\r\n\x05\x047\x02\t\x03\x12\x04\xef\x06\x19\x1b\n\x0c\n\x04\x047\x02\n\
    \x12\x04\xf0\x06\x04\x1c\n\r\n\x05\x047\x02\n\x04\x12\x04\xf0\x06\x04\
    \x0c\n\r\n\x05\x047\x02\n\x06\x12\x04\xf0\x06\r\x11\n\r\n\x05\x047\x02\n\
    \x01\x12\x04\xf0\x06\x12\x16\n\r\n\x05\x047\x02\n\x03\x12\x04\xf0\x06\
    \x19\x1b\n\x0c\n\x04\x047\x02\x0b\x12\x04\xf1\x06\x042\n\r\n\x05\x047\
    \x02\x0b\x04\x12\x04\xf1\x06\x04\x0c\n\r\n\x05\x047\x02\x0b\x06\x12\x04\
    \xf1\x06\r\x1c\n\r\n\x05\x047\x02\x0b\x01\x12\x04\xf1\x06\x1d,\n\r\n\x05\
    \x047\x02\x0b\x03\x12\x04\xf1\x06/1\n\x0c\n\x04\x047\x02\x0c\x12\x04\xf2\
    \x06\x04<\n\r\n\x05\x047\x02\x0c\x04\x12\x04\xf2\x06\x04\x0c\n\r\n\x05\
    \x047\x02\x0c\x06\x12\x04\xf2\x06\r!\n\r\n\x05\x047\x02\x0c\x01\x12\x04\
    \xf2\x06\"6\n\r\n\x05\x047\x02\x0c\x03\x12\x04\xf2\x069;\n\x0c\n\x04\x04\
    7\x02\r\x12\x04\xf3\x06\x04B\n\r\n\x05\x047\x02\r\x04\x12\x04\xf3\x06\
    \x04\x0c\n\r\n\x05\x047\x02\r\x06\x12\x04\xf3\x06\r$\n\r\n\x05\x047\x02\
    \r\x01\x12\x04\xf3\x06%<\n\r\n\x05\x047\x02\r\x03\x12\x04\xf3\x06?A\n\
    \x0c\n\x04\x047\x02\x0e\x12\x04\xf4\x06\x04Z\n\r\n\x05\x047\x02\x0e\x04\
    \x12\x04\xf4\x06\x04\x0c\n\r\n\x05\x047\x02\x0e\x06\x12\x04\xf4\x06\r)\n\
    \r\n\x05\x047\x02\x0e\x01\x12\x04\xf4\x06*T\n\r\n\x05\x047\x02\x0e\x03\
    \x12\x04\xf4\x06WY\n\x0c\n\x04\x047\x02\x0f\x12\x04\xf5\x06\x048\n\r\n\
    \x05\x047\x02\x0f\x04\x12\x04\xf5\x06\x04\x0c\n\r\n\x05\x047\x02\x0f\x06\
    \x12\x04\xf5\x06\r\x1f\n\r\n\x05\x047\x02\x0f\x01\x12\x04\xf5\x06\x202\n\
    \r\n\x05\x047\x02\x0f\x03\x12\x04\xf5\x0657\n\x0c\n\x04\x047\x02\x10\x12\
    \x04\xf6\x06\x04:\n\r\n\x05\x047\x02\x10\x04\x12\x04\xf6\x06\x04\x0c\n\r\
    \n\x05\x047\x02\x10\x06\x12\x04\xf6\x06\r\x20\n\r\n\x05\x047\x02\x10\x01\
    \x12\x04\xf6\x06!4\n\r\n\x05\x047\x02\x10\x03\x12\x04\xf6\x0679\n\x0c\n\
    \x04\x047\x02\x11\x12\x04\xf7\x06\x04>\n\r\n\x05\x047\x02\x11\x04\x12\
    \x04\xf7\x06\x04\x0c\n\r\n\x05\x047\x02\x11\x06\x12\x04\xf7\x06\r\"\n\r\
    \n\x05\x047\x02\x11\x01\x12\x04\xf7\x06#8\n\r\n\x05\x047\x02\x11\x03\x12\
    \x04\xf7\x06;=\n\x0c\n\x04\x047\x02\x12\x12\x04\xf8\x06\x04L\n\r\n\x05\
    \x047\x02\x12\x04\x12\x04\xf8\x06\x04\x0c\n\r\n\x05\x047\x02\x12\x06\x12\
    \x04\xf8\x06\r)\n\r\n\x05\x047\x02\x12\x01\x12\x04\xf8\x06*F\n\r\n\x05\
    \x047\x02\x12\x03\x12\x04\xf8\x06IK\n\x0c\n\x04\x047\x02\x13\x12\x04\xf9\
    \x06\x04J\n\r\n\x05\x047\x02\x13\x04\x12\x04\xf9\x06\x04\x0c\n\r\n\x05\
    \x047\x02\x13\x06\x12\x04\xf9\x06\r(\n\r\n\x05\x047\x02\x13\x01\x12\x04\
    \xf9\x06)D\n\r\n\x05\x047\x02\x13\x03\x12\x04\xf9\x06GI\n\x0c\n\x04\x047\
    \x02\x14\x12\x04\xfa\x06\x042\n\r\n\x05\x047\x02\x14\x04\x12\x04\xfa\x06\
    \x04\x0c\n\r\n\x05\x047\x02\x14\x06\x12\x04\xfa\x06\r\x1c\n\r\n\x05\x047\
    \x02\x14\x01\x12\x04\xfa\x06\x1d,\n\r\n\x05\x047\x02\x14\x03\x12\x04\xfa\
    \x06/1\n\x0c\n\x04\x047\x02\x15\x12\x04\xfb\x06\x040\n\r\n\x05\x047\x02\
    \x15\x04\x12\x04\xfb\x06\x04\x0c\n\r\n\x05\x047\x02\x15\x06\x12\x04\xfb\
    \x06\r\x1b\n\r\n\x05\x047\x02\x15\x01\x12\x04\xfb\x06\x1c*\n\r\n\x05\x04\
    7\x02\x15\x03\x12\x04\xfb\x06-/\n\x0c\n\x04\x047\x02\x16\x12\x04\xfc\x06\
    \x048\n\r\n\x05\x047\x02\x16\x04\x12\x04\xfc\x06\x04\x0c\n\r\n\x05\x047\
    \x02\x16\x06\x12\x04\xfc\x06\r\x1f\n\r\n\x05\x047\x02\x16\x01\x12\x04\
    \xfc\x06\x202\n\r\n\x05\x047\x02\x16\x03\x12\x04\xfc\x0657\n\x0c\n\x04\
    \x047\x02\x17\x12\x04\xfd\x06\x04H\n\r\n\x05\x047\x02\x17\x04\x12\x04\
    \xfd\x06\x04\x0c\n\r\n\x05\x047\x02\x17\x06\x12\x04\xfd\x06\r'\n\r\n\x05\
    \x047\x02\x17\x01\x12\x04\xfd\x06(B\n\r\n\x05\x047\x02\x17\x03\x12\x04\
    \xfd\x06EG\n\x0c\n\x04\x047\x02\x18\x12\x04\xfe\x06\x040\n\r\n\x05\x047\
    \x02\x18\x04\x12\x04\xfe\x06\x04\x0c\n\r\n\x05\x047\x02\x18\x06\x12\x04\
    \xfe\x06\r\x1b\n\r\n\x05\x047\x02\x18\x01\x12\x04\xfe\x06\x1c*\n\r\n\x05\
    \x047\x02\x18\x03\x12\x04\xfe\x06-/\n\x0c\n\x04\x047\x02\x19\x12\x04\xff\
    \x06\x046\n\r\n\x05\x047\x02\x19\x04\x12\x04\xff\x06\x04\x0c\n\r\n\x05\
    \x047\x02\x19\x06\x12\x04\xff\x06\r\x1e\n\r\n\x05\x047\x02\x19\x01\x12\
    \x04\xff\x06\x1f0\n\r\n\x05\x047\x02\x19\x03\x12\x04\xff\x0635\n\x0c\n\
    \x04\x047\x02\x1a\x12\x04\x80\x07\x048\n\r\n\x05\x047\x02\x1a\x04\x12\
    \x04\x80\x07\x04\x0c\n\r\n\x05\x047\x02\x1a\x06\x12\x04\x80\x07\r\x1f\n\
    \r\n\x05\x047\x02\x1a\x01\x12\x04\x80\x07\x202\n\r\n\x05\x047\x02\x1a\
    \x03\x12\x04\x80\x0757\n\x0c\n\x04\x047\x02\x1b\x12\x04\x81\x07\x04*\n\r\
    \n\x05\x047\x02\x1b\x04\x12\x04\x81\x07\x04\x0c\n\r\n\x05\x047\x02\x1b\
    \x06\x12\x04\x81\x07\r\x18\n\r\n\x05\x047\x02\x1b\x01\x12\x04\x81\x07\
    \x19$\n\r\n\x05\x047\x02\x1b\x03\x12\x04\x81\x07')\n\x0c\n\x04\x047\x02\
    \x1c\x12\x04\x82\x07\x045\n\r\n\x05\x047\x02\x1c\x04\x12\x04\x82\x07\x04\
    \x0c\n\r\n\x05\x047\x02\x1c\x06\x12\x04\x82\x07\r\x1f\n\r\n\x05\x047\x02\
    \x1c\x01\x12\x04\x82\x07\x20/\n\r\n\x05\x047\x02\x1c\x03\x12\x04\x82\x07\
    24\n\x0c\n\x04\x047\x02\x1d\x12\x04\x83\x07\x04,\n\r\n\x05\x047\x02\x1d\
    \x04\x12\x04\x83\x07\x04\x0c\n\r\n\x05\x047\x02\x1d\x06\x12\x04\x83\x07\
    \r\x19\n\r\n\x05\x047\x02\x1d\x01\x12\x04\x83\x07\x1a&\n\r\n\x05\x047\
    \x02\x1d\x03\x12\x04\x83\x07)+\n\x0c\n\x04\x047\x02\x1e\x12\x04\x84\x07\
    \x04:\n\r\n\x05\x047\x02\x1e\x04\x12\x04\x84\x07\x04\x0c\n\r\n\x05\x047\
    \x02\x1e\x06\x12\x04\x84\x07\r\x20\n\r\n\x05\x047\x02\x1e\x01\x12\x04\
    \x84\x07!4\n\r\n\x05\x047\x02\x1e\x03\x12\x04\x84\x0779\n\x0c\n\x04\x047\
    \x02\x1f\x12\x04\x85\x07\x046\n\r\n\x05\x047\x02\x1f\x04\x12\x04\x85\x07\
    \x04\x0c\n\r\n\x05\x047\x02\x1f\x06\x12\x04\x85\x07\r\x1f\n\r\n\x05\x047\
    \x02\x1f\x01\x12\x04\x85\x07\x200\n\r\n\x05\x047\x02\x1f\x03\x12\x04\x85\
    \x0735\n\x0c\n\x04\x047\x02\x20\x12\x04\x86\x07\x040\n\r\n\x05\x047\x02\
    \x20\x04\x12\x04\x86\x07\x04\x0c\n\r\n\x05\x047\x02\x20\x06\x12\x04\x86\
    \x07\r\x1b\n\r\n\x05\x047\x02\x20\x01\x12\x04\x86\x07\x1c*\n\r\n\x05\x04\
    7\x02\x20\x03\x12\x04\x86\x07-/\n\x0c\n\x04\x047\x02!\x12\x04\x87\x07\
    \x040\n\r\n\x05\x047\x02!\x04\x12\x04\x87\x07\x04\x0c\n\r\n\x05\x047\x02\
    !\x06\x12\x04\x87\x07\r\x1b\n\r\n\x05\x047\x02!\x01\x12\x04\x87\x07\x1c*\
    \n\r\n\x05\x047\x02!\x03\x12\x04\x87\x07-/\n\x0c\n\x04\x047\x02\"\x12\
    \x04\x88\x07\x04@\n\r\n\x05\x047\x02\"\x04\x12\x04\x88\x07\x04\x0c\n\r\n\
    \x05\x047\x02\"\x06\x12\x04\x88\x07\r#\n\r\n\x05\x047\x02\"\x01\x12\x04\
    \x88\x07$:\n\r\n\x05\x047\x02\"\x03\x12\x04\x88\x07=?\n\x0c\n\x04\x047\
    \x02#\x12\x04\x89\x07\x04<\n\r\n\x05\x047\x02#\x04\x12\x04\x89\x07\x04\
    \x0c\n\r\n\x05\x047\x02#\x06\x12\x04\x89\x07\r!\n\r\n\x05\x047\x02#\x01\
    \x12\x04\x89\x07\"6\n\r\n\x05\x047\x02#\x03\x12\x04\x89\x079;\n\x0c\n\
    \x04\x047\x02$\x12\x04\x8a\x07\x048\n\r\n\x05\x047\x02$\x04\x12\x04\x8a\
    \x07\x04\x0c\n\r\n\x05\x047\x02$\x06\x12\x04\x8a\x07\r\x1f\n\r\n\x05\x04\
    7\x02$\x01\x12\x04\x8a\x07\x202\n\r\n\x05\x047\x02$\x03\x12\x04\x8a\x075\
    7\n\x0c\n\x04\x047\x02%\x12\x04\x8b\x07\x042\n\r\n\x05\x047\x02%\x04\x12\
    \x04\x8b\x07\x04\x0c\n\r\n\x05\x047\x02%\x06\x12\x04\x8b\x07\r\x1c\n\r\n\
    \x05\x047\x02%\x01\x12\x04\x8b\x07\x1d,\n\r\n\x05\x047\x02%\x03\x12\x04\
    \x8b\x07/1\n\x0c\n\x04\x047\x02&\x12\x04\x8c\x07\x04>\n\r\n\x05\x047\x02\
    &\x04\x12\x04\x8c\x07\x04\x0c\n\r\n\x05\x047\x02&\x06\x12\x04\x8c\x07\r\
    \"\n\r\n\x05\x047\x02&\x01\x12\x04\x8c\x07#8\n\r\n\x05\x047\x02&\x03\x12\
    \x04\x8c\x07;=\n\x0c\n\x04\x047\x02'\x12\x04\x8d\x07\x04H\n\r\n\x05\x047\
    \x02'\x04\x12\x04\x8d\x07\x04\x0c\n\r\n\x05\x047\x02'\x06\x12\x04\x8d\
    \x07\r'\n\r\n\x05\x047\x02'\x01\x12\x04\x8d\x07(B\n\r\n\x05\x047\x02'\
    \x03\x12\x04\x8d\x07EG\n\x0c\n\x04\x047\x02(\x12\x04\x8e\x07\x04:\n\r\n\
    \x05\x047\x02(\x04\x12\x04\x8e\x07\x04\x0c\n\r\n\x05\x047\x02(\x06\x12\
    \x04\x8e\x07\r\x20\n\r\n\x05\x047\x02(\x01\x12\x04\x8e\x07!4\n\r\n\x05\
    \x047\x02(\x03\x12\x04\x8e\x0779\n\x0c\n\x04\x047\x02)\x12\x04\x8f\x07\
    \x046\n\r\n\x05\x047\x02)\x04\x12\x04\x8f\x07\x04\x0c\n\r\n\x05\x047\x02\
    )\x06\x12\x04\x8f\x07\r\x1e\n\r\n\x05\x047\x02)\x01\x12\x04\x8f\x07\x1f0\
    \n\r\n\x05\x047\x02)\x03\x12\x04\x8f\x0735\n\x0c\n\x04\x047\x02*\x12\x04\
    \x90\x07\x046\n\r\n\x05\x047\x02*\x04\x12\x04\x90\x07\x04\x0c\n\r\n\x05\
    \x047\x02*\x06\x12\x04\x90\x07\r\x1e\n\r\n\x05\x047\x02*\x01\x12\x04\x90\
    \x07\x1f0\n\r\n\x05\x047\x02*\x03\x12\x04\x90\x0735\n\x0c\n\x04\x047\x02\
    +\x12\x04\x91\x07\x04@\n\r\n\x05\x047\x02+\x04\x12\x04\x91\x07\x04\x0c\n\
    \r\n\x05\x047\x02+\x06\x12\x04\x91\x07\r\x1f\n\r\n\x05\x047\x02+\x01\x12\
    \x04\x91\x07\x20:\n\r\n\x05\x047\x02+\x03\x12\x04\x91\x07=?\n\x0c\n\x04\
    \x047\x02,\x12\x04\x92\x07\x04F\n\r\n\x05\x047\x02,\x04\x12\x04\x92\x07\
    \x04\x0c\n\r\n\x05\x047\x02,\x06\x12\x04\x92\x07\r&\n\r\n\x05\x047\x02,\
    \x01\x12\x04\x92\x07'@\n\r\n\x05\x047\x02,\x03\x12\x04\x92\x07CE\n\x0c\n\
    \x04\x047\x02-\x12\x04\x93\x07\x047\n\r\n\x05\x047\x02-\x04\x12\x04\x93\
    \x07\x04\x0c\n\r\n\x05\x047\x02-\x06\x12\x04\x93\x07\r\x1f\n\r\n\x05\x04\
    7\x02-\x01\x12\x04\x93\x07\x201\n\r\n\x05\x047\x02-\x03\x12\x04\x93\x074\
    6\n\x0c\n\x04\x047\x02.\x12\x04\x94\x07\x048\n\r\n\x05\x047\x02.\x04\x12\
    \x04\x94\x07\x04\x0c\n\r\n\x05\x047\x02.\x06\x12\x04\x94\x07\r\x1f\n\r\n\
    \x05\x047\x02.\x01\x12\x04\x94\x07\x202\n\r\n\x05\x047\x02.\x03\x12\x04\
    \x94\x0757\n\x0c\n\x04\x047\x02/\x12\x04\x95\x07\x043\n\r\n\x05\x047\x02\
    /\x04\x12\x04\x95\x07\x04\x0c\n\r\n\x05\x047\x02/\x06\x12\x04\x95\x07\r\
    \x1f\n\r\n\x05\x047\x02/\x01\x12\x04\x95\x07\x20-\n\r\n\x05\x047\x02/\
    \x03\x12\x04\x95\x0702\n\x0c\n\x04\x047\x020\x12\x04\x96\x07\x04@\n\r\n\
    \x05\x047\x020\x04\x12\x04\x96\x07\x04\x0c\n\r\n\x05\x047\x020\x06\x12\
    \x04\x96\x07\r\x1f\n\r\n\x05\x047\x020\x01\x12\x04\x96\x07\x20:\n\r\n\
    \x05\x047\x020\x03\x12\x04\x96\x07=?\n\x0c\n\x04\x047\x021\x12\x04\x97\
    \x07\x04<\n\r\n\x05\x047\x021\x04\x12\x04\x97\x07\x04\x0c\n\r\n\x05\x047\
    \x021\x06\x12\x04\x97\x07\r\x20\n\r\n\x05\x047\x021\x01\x12\x04\x97\x07!\
    6\n\r\n\x05\x047\x021\x03\x12\x04\x97\x079;\n\x0c\n\x04\x047\x022\x12\
    \x04\x98\x07\x04L\n\r\n\x05\x047\x022\x04\x12\x04\x98\x07\x04\x0c\n\r\n\
    \x05\x047\x022\x06\x12\x04\x98\x07\r)\n\r\n\x05\x047\x022\x01\x12\x04\
    \x98\x07*F\n\r\n\x05\x047\x022\x03\x12\x04\x98\x07IK\n\x0c\n\x04\x047\
    \x023\x12\x04\x99\x07\x04;\n\r\n\x05\x047\x023\x04\x12\x04\x99\x07\x04\
    \x0c\n\r\n\x05\x047\x023\x06\x12\x04\x99\x07\r\x1f\n\r\n\x05\x047\x023\
    \x01\x12\x04\x99\x07\x205\n\r\n\x05\x047\x023\x03\x12\x04\x99\x078:\n\
    \x0c\n\x04\x047\x024\x12\x04\x9a\x07\x04(\n\r\n\x05\x047\x024\x04\x12\
    \x04\x9a\x07\x04\x0c\n\r\n\x05\x047\x024\x06\x12\x04\x9a\x07\r\x17\n\r\n\
    \x05\x047\x024\x01\x12\x04\x9a\x07\x18\"\n\r\n\x05\x047\x024\x03\x12\x04\
    \x9a\x07%'\n\x0c\n\x04\x047\x025\x12\x04\x9b\x07\x04<\n\r\n\x05\x047\x02\
    5\x04\x12\x04\x9b\x07\x04\x0c\n\r\n\x05\x047\x025\x06\x12\x04\x9b\x07\r\
    \x20\n\r\n\x05\x047\x025\x01\x12\x04\x9b\x07!6\n\r\n\x05\x047\x025\x03\
    \x12\x04\x9b\x079;\n\x0c\n\x04\x047\x026\x12\x04\x9c\x07\x04D\n\r\n\x05\
    \x047\x026\x04\x12\x04\x9c\x07\x04\x0c\n\r\n\x05\x047\x026\x06\x12\x04\
    \x9c\x07\r%\n\r\n\x05\x047\x026\x01\x12\x04\x9c\x07&>\n\r\n\x05\x047\x02\
    6\x03\x12\x04\x9c\x07AC\n\x0c\n\x02\x048\x12\x06\x9f\x07\0\xa4\x07\x01\n\
    \x0b\n\x03\x048\x01\x12\x04\x9f\x07\x08\x1a\n\x0c\n\x04\x048\x02\0\x12\
    \x04\xa0\x07\x047\n\r\n\x05\x048\x02\0\x04\x12\x04\xa0\x07\x04\x0c\n\r\n\
    \x05\x048\x02\0\x06\x12\x04\xa0\x07\r\x1f\n\r\n\x05\x048\x02\0\x01\x12\
    \x04\xa0\x07\x202\n\r\n\x05\x048\x02\0\x03\x12\x04\xa0\x0756\n\x0c\n\x04\
    \x048\x02\x01\x12\x04\xa1\x07\x041\n\r\n\x05\x048\x02\x01\x04\x12\x04\
    \xa1\x07\x04\x0c\n\r\n\x05\x048\x02\x01\x05\x12\x04\xa1\x07\r\x12\n\r\n\
    \x05\x048\x02\x01\x01\x12\x04\xa1\x07\x13,\n\r\n\x05\x048\x02\x01\x03\
    \x12\x04\xa1\x07/0\n\x0c\n\x04\x048\x02\x02\x12\x04\xa2\x07\x04%\n\r\n\
    \x05\x048\x02\x02\x04\x12\x04\xa2\x07\x04\x0c\n\r\n\x05\x048\x02\x02\x05\
    \x12\x04\xa2\x07\r\x12\n\r\n\x05\x048\x02\x02\x01\x12\x04\xa2\x07\x13\
    \x20\n\r\n\x05\x048\x02\x02\x03\x12\x04\xa2\x07#$\n\x0c\n\x04\x048\x02\
    \x03\x12\x04\xa3\x07\x04$\n\r\n\x05\x048\x02\x03\x04\x12\x04\xa3\x07\x04\
    \x0c\n\r\n\x05\x048\x02\x03\x05\x12\x04\xa3\x07\r\x12\n\r\n\x05\x048\x02\
    \x03\x01\x12\x04\xa3\x07\x13\x1f\n\r\n\x05\x048\x02\x03\x03\x12\x04\xa3\
    \x07\"#\n\x0c\n\x02\x049\x12\x06\xa6\x07\0\xc3\x07\x01\n\x0b\n\x03\x049\
    \x01\x12\x04\xa6\x07\x08\x14\n\x0e\n\x04\x049\x04\0\x12\x06\xa7\x07\x04\
    \xab\x07\x05\n\r\n\x05\x049\x04\0\x01\x12\x04\xa7\x07\t\x14\n\x0e\n\x06\
    \x049\x04\0\x02\0\x12\x04\xa8\x07\x08\x11\n\x0f\n\x07\x049\x04\0\x02\0\
    \x01\x12\x04\xa8\x07\x08\x0c\n\x0f\n\x07\x049\x04\0\x02\0\x02\x12\x04\
    \xa8\x07\x0f\x10\n\x0e\n\x06\x049\x04\0\x02\x01\x12\x04\xa9\x07\x08\x12\
    \n\x0f\n\x07\x049\x04\0\x02\x01\x01\x12\x04\xa9\x07\x08\r\n\x0f\n\x07\
    \x049\x04\0\x02\x01\x02\x12\x04\xa9\x07\x10\x11\n\x0e\n\x06\x049\x04\0\
    \x02\x02\x12\x04\xaa\x07\x08\x12\n\x0f\n\x07\x049\x04\0\x02\x02\x01\x12\
    \x04\xaa\x07\x08\r\n\x0f\n\x07\x049\x04\0\x02\x02\x02\x12\x04\xaa\x07\
    \x10\x11\n\x0c\n\x04\x049\x02\0\x12\x04\xac\x07\x04\x1c\n\r\n\x05\x049\
    \x02\0\x04\x12\x04\xac\x07\x04\x0c\n\r\n\x05\x049\x02\0\x05\x12\x04\xac\
    \x07\r\x13\n\r\n\x05\x049\x02\0\x01\x12\x04\xac\x07\x14\x17\n\r\n\x05\
    \x049\x02\0\x03\x12\x04\xac\x07\x1a\x1b\n\x0c\n\x04\x049\x02\x01\x12\x04\
    \xad\x07\x04!\n\r\n\x05\x049\x02\x01\x04\x12\x04\xad\x07\x04\x0c\n\r\n\
    \x05\x049\x02\x01\x05\x12\x04\xad\x07\r\x13\n\r\n\x05\x049\x02\x01\x01\
    \x12\x04\xad\x07\x14\x1c\n\r\n\x05\x049\x02\x01\x03\x12\x04\xad\x07\x1f\
    \x20\n\x0c\n\x04\x049\x02\x02\x12\x04\xae\x07\x04\"\n\r\n\x05\x049\x02\
    \x02\x04\x12\x04\xae\x07\x04\x0c\n\r\n\x05\x049\x02\x02\x05\x12\x04\xae\
    \x07\r\x12\n\r\n\x05\x049\x02\x02\x01\x12\x04\xae\x07\x13\x1d\n\r\n\x05\
    \x049\x02\x02\x03\x12\x04\xae\x07\x20!\n\x0c\n\x04\x049\x02\x03\x12\x04\
    \xaf\x07\x04#\n\r\n\x05\x049\x02\x03\x04\x12\x04\xaf\x07\x04\x0c\n\r\n\
    \x05\x049\x02\x03\x05\x12\x04\xaf\x07\r\x13\n\r\n\x05\x049\x02\x03\x01\
    \x12\x04\xaf\x07\x14\x1e\n\r\n\x05\x049\x02\x03\x03\x12\x04\xaf\x07!\"\n\
    \x0c\n\x04\x049\x02\x04\x12\x04\xb0\x07\x04\x20\n\r\n\x05\x049\x02\x04\
    \x04\x12\x04\xb0\x07\x04\x0c\n\r\n\x05\x049\x02\x04\x05\x12\x04\xb0\x07\
    \r\x13\n\r\n\x05\x049\x02\x04\x01\x12\x04\xb0\x07\x14\x1b\n\r\n\x05\x049\
    \x02\x04\x03\x12\x04\xb0\x07\x1e\x1f\n\x0c\n\x04\x049\x02\x05\x12\x04\
    \xb1\x07\x04\x20\n\r\n\x05\x049\x02\x05\x04\x12\x04\xb1\x07\x04\x0c\n\r\
    \n\x05\x049\x02\x05\x05\x12\x04\xb1\x07\r\x12\n\r\n\x05\x049\x02\x05\x01\
    \x12\x04\xb1\x07\x13\x1b\n\r\n\x05\x049\x02\x05\x03\x12\x04\xb1\x07\x1e\
    \x1f\n\x0c\n\x04\x049\x02\x06\x12\x04\xb2\x07\x04\x20\n\r\n\x05\x049\x02\
    \x06\x04\x12\x04\xb2\x07\x04\x0c\n\r\n\x05\x049\x02\x06\x05\x12\x04\xb2\
    \x07\r\x13\n\r\n\x05\x049\x02\x06\x01\x12\x04\xb2\x07\x14\x1b\n\r\n\x05\
    \x049\x02\x06\x03\x12\x04\xb2\x07\x1e\x1f\n\x0c\n\x04\x049\x02\x07\x12\
    \x04\xb3\x07\x04\"\n\r\n\x05\x049\x02\x07\x04\x12\x04\xb3\x07\x04\x0c\n\
    \r\n\x05\x049\x02\x07\x05\x12\x04\xb3\x07\r\x11\n\r\n\x05\x049\x02\x07\
    \x01\x12\x04\xb3\x07\x12\x1d\n\r\n\x05\x049\x02\x07\x03\x12\x04\xb3\x07\
    \x20!\n\x0c\n\x04\x049\x02\x08\x12\x04\xb4\x07\x04\x1f\n\r\n\x05\x049\
    \x02\x08\x04\x12\x04\xb4\x07\x04\x0c\n\r\n\x05\x049\x02\x08\x05\x12\x04\
    \xb4\x07\r\x13\n\r\n\x05\x049\x02\x08\x01\x12\x04\xb4\x07\x14\x1a\n\r\n\
    \x05\x049\x02\x08\x03\x12\x04\xb4\x07\x1d\x1e\n\x0c\n\x04\x049\x02\t\x12\
    \x04\xb5\x07\x04\x1f\n\r\n\x05\x049\x02\t\x04\x12\x04\xb5\x07\x04\x0c\n\
    \r\n\x05\x049\x02\t\x05\x12\x04\xb5\x07\r\x13\n\r\n\x05\x049\x02\t\x01\
    \x12\x04\xb5\x07\x14\x19\n\r\n\x05\x049\x02\t\x03\x12\x04\xb5\x07\x1c\
    \x1e\n\x0c\n\x04\x049\x02\n\x12\x04\xb6\x07\x04&\n\r\n\x05\x049\x02\n\
    \x04\x12\x04\xb6\x07\x04\x0c\n\r\n\x05\x049\x02\n\x05\x12\x04\xb6\x07\r\
    \x12\n\r\n\x05\x049\x02\n\x01\x12\x04\xb6\x07\x13\x20\n\r\n\x05\x049\x02\
    \n\x03\x12\x04\xb6\x07#%\n\x0c\n\x04\x049\x02\x0b\x12\x04\xb7\x07\x04?\n\
    \r\n\x05\x049\x02\x0b\x04\x12\x04\xb7\x07\x04\x0c\n\r\n\x05\x049\x02\x0b\
    \x06\x12\x04\xb7\x07\r\"\n\r\n\x05\x049\x02\x0b\x01\x12\x04\xb7\x07#9\n\
    \r\n\x05\x049\x02\x0b\x03\x12\x04\xb7\x07<>\n\x0c\n\x04\x049\x02\x0c\x12\
    \x04\xb8\x07\x04$\n\r\n\x05\x049\x02\x0c\x04\x12\x04\xb8\x07\x04\x0c\n\r\
    \n\x05\x049\x02\x0c\x05\x12\x04\xb8\x07\r\x13\n\r\n\x05\x049\x02\x0c\x01\
    \x12\x04\xb8\x07\x14\x1e\n\r\n\x05\x049\x02\x0c\x03\x12\x04\xb8\x07!#\n\
    \x0c\n\x04\x049\x02\r\x12\x04\xb9\x07\x04*\n\r\n\x05\x049\x02\r\x04\x12\
    \x04\xb9\x07\x04\x0c\n\r\n\x05\x049\x02\r\x05\x12\x04\xb9\x07\r\x12\n\r\
    \n\x05\x049\x02\r\x01\x12\x04\xb9\x07\x13$\n\r\n\x05\x049\x02\r\x03\x12\
    \x04\xb9\x07')\n\x0c\n\x04\x049\x02\x0e\x12\x04\xba\x07\x04&\n\r\n\x05\
    \x049\x02\x0e\x04\x12\x04\xba\x07\x04\x0c\n\r\n\x05\x049\x02\x0e\x05\x12\
    \x04\xba\x07\r\x12\n\r\n\x05\x049\x02\x0e\x01\x12\x04\xba\x07\x13\x20\n\
    \r\n\x05\x049\x02\x0e\x03\x12\x04\xba\x07#%\n\x0c\n\x04\x049\x02\x0f\x12\
    \x04\xbb\x07\x04*\n\r\n\x05\x049\x02\x0f\x04\x12\x04\xbb\x07\x04\x0c\n\r\
    \n\x05\x049\x02\x0f\x06\x12\x04\xbb\x07\r\x18\n\r\n\x05\x049\x02\x0f\x01\
    \x12\x04\xbb\x07\x19$\n\r\n\x05\x049\x02\x0f\x03\x12\x04\xbb\x07')\n\x0c\
    \n\x04\x049\x02\x10\x12\x04\xbc\x07\x04)\n\r\n\x05\x049\x02\x10\x04\x12\
    \x04\xbc\x07\x04\x0c\n\r\n\x05\x049\x02\x10\x05\x12\x04\xbc\x07\r\x12\n\
    \r\n\x05\x049\x02\x10\x01\x12\x04\xbc\x07\x13#\n\r\n\x05\x049\x02\x10\
    \x03\x12\x04\xbc\x07&(\n\x0c\n\x04\x049\x02\x11\x12\x04\xbd\x07\x04-\n\r\
    \n\x05\x049\x02\x11\x04\x12\x04\xbd\x07\x04\x0c\n\r\n\x05\x049\x02\x11\
    \x06\x12\x04\xbd\x07\r\x18\n\r\n\x05\x049\x02\x11\x01\x12\x04\xbd\x07\
    \x19'\n\r\n\x05\x049\x02\x11\x03\x12\x04\xbd\x07*,\n\x0c\n\x04\x049\x02\
    \x12\x12\x04\xbe\x07\x04\x20\n\r\n\x05\x049\x02\x12\x04\x12\x04\xbe\x07\
    \x04\x0c\n\r\n\x05\x049\x02\x12\x05\x12\x04\xbe\x07\r\x11\n\r\n\x05\x049\
    \x02\x12\x01\x12\x04\xbe\x07\x12\x1a\n\r\n\x05\x049\x02\x12\x03\x12\x04\
    \xbe\x07\x1d\x1f\n\x0c\n\x04\x049\x02\x13\x12\x04\xbf\x07\x04-\n\r\n\x05\
    \x049\x02\x13\x04\x12\x04\xbf\x07\x04\x0c\n\r\n\x05\x049\x02\x13\x05\x12\
    \x04\xbf\x07\r\x13\n\r\n\x05\x049\x02\x13\x01\x12\x04\xbf\x07\x14'\n\r\n\
    \x05\x049\x02\x13\x03\x12\x04\xbf\x07*,\n\x0c\n\x04\x049\x02\x14\x12\x04\
    \xc0\x07\x04(\n\r\n\x05\x049\x02\x14\x04\x12\x04\xc0\x07\x04\x0c\n\r\n\
    \x05\x049\x02\x14\x05\x12\x04\xc0\x07\r\x12\n\r\n\x05\x049\x02\x14\x01\
    \x12\x04\xc0\x07\x13\"\n\r\n\x05\x049\x02\x14\x03\x12\x04\xc0\x07%'\n\
    \x0c\n\x04\x049\x02\x15\x12\x04\xc1\x07\x04+\n\r\n\x05\x049\x02\x15\x04\
    \x12\x04\xc1\x07\x04\x0c\n\r\n\x05\x049\x02\x15\x05\x12\x04\xc1\x07\r\
    \x12\n\r\n\x05\x049\x02\x15\x01\x12\x04\xc1\x07\x13%\n\r\n\x05\x049\x02\
    \x15\x03\x12\x04\xc1\x07(*\n\x0c\n\x04\x049\x02\x16\x12\x04\xc2\x07\x04#\
    \n\r\n\x05\x049\x02\x16\x04\x12\x04\xc2\x07\x04\x0c\n\r\n\x05\x049\x02\
    \x16\x05\x12\x04\xc2\x07\r\x13\n\r\n\x05\x049\x02\x16\x01\x12\x04\xc2\
    \x07\x14\x1d\n\r\n\x05\x049\x02\x16\x03\x12\x04\xc2\x07\x20\"\n\x0c\n\
    \x02\x04:\x12\x06\xc5\x07\0\xe9\x07\x01\n\x0b\n\x03\x04:\x01\x12\x04\xc5\
    \x07\x08\x17\n\x0e\n\x04\x04:\x03\0\x12\x06\xc6\x07\x04\xd2\x07\x05\n\r\
    \n\x05\x04:\x03\0\x01\x12\x04\xc6\x07\x0c#\n\x0e\n\x06\x04:\x03\0\x02\0\
    \x12\x04\xc7\x07\x080\n\x0f\n\x07\x04:\x03\0\x02\0\x04\x12\x04\xc7\x07\
    \x08\x10\n\x0f\n\x07\x04:\x03\0\x02\0\x05\x12\x04\xc7\x07\x11\x17\n\x0f\
    \n\x07\x04:\x03\0\x02\0\x01\x12\x04\xc7\x07\x18+\n\x0f\n\x07\x04:\x03\0\
    \x02\0\x03\x12\x04\xc7\x07./\n\x0e\n\x06\x04:\x03\0\x02\x01\x12\x04\xc8\
    \x07\x08/\n\x0f\n\x07\x04:\x03\0\x02\x01\x04\x12\x04\xc8\x07\x08\x10\n\
    \x0f\n\x07\x04:\x03\0\x02\x01\x05\x12\x04\xc8\x07\x11\x17\n\x0f\n\x07\
    \x04:\x03\0\x02\x01\x01\x12\x04\xc8\x07\x18*\n\x0f\n\x07\x04:\x03\0\x02\
    \x01\x03\x12\x04\xc8\x07-.\n\x0e\n\x06\x04:\x03\0\x02\x02\x12\x04\xc9\
    \x07\x08<\n\x0f\n\x07\x04:\x03\0\x02\x02\x04\x12\x04\xc9\x07\x08\x10\n\
    \x0f\n\x07\x04:\x03\0\x02\x02\x06\x12\x04\xc9\x07\x11'\n\x0f\n\x07\x04:\
    \x03\0\x02\x02\x01\x12\x04\xc9\x07(7\n\x0f\n\x07\x04:\x03\0\x02\x02\x03\
    \x12\x04\xc9\x07:;\n\x0e\n\x06\x04:\x03\0\x02\x03\x12\x04\xca\x07\x08'\n\
    \x0f\n\x07\x04:\x03\0\x02\x03\x04\x12\x04\xca\x07\x08\x10\n\x0f\n\x07\
    \x04:\x03\0\x02\x03\x05\x12\x04\xca\x07\x11\x17\n\x0f\n\x07\x04:\x03\0\
    \x02\x03\x01\x12\x04\xca\x07\x18\"\n\x0f\n\x07\x04:\x03\0\x02\x03\x03\
    \x12\x04\xca\x07%&\n\x10\n\x06\x04:\x03\0\x08\0\x12\x06\xcb\x07\x08\xd1\
    \x07\t\n\x0f\n\x07\x04:\x03\0\x08\0\x01\x12\x04\xcb\x07\x0e\x13\n\x0e\n\
    \x06\x04:\x03\0\x02\x04\x12\x04\xcc\x07\x0c0\n\x0f\n\x07\x04:\x03\0\x02\
    \x04\x06\x12\x04\xcc\x07\x0c\x1b\n\x0f\n\x07\x04:\x03\0\x02\x04\x01\x12\
    \x04\xcc\x07\x1c+\n\x0f\n\x07\x04:\x03\0\x02\x04\x03\x12\x04\xcc\x07./\n\
    \x0e\n\x06\x04:\x03\0\x02\x05\x12\x04\xcd\x07\x0c)\n\x0f\n\x07\x04:\x03\
    \0\x02\x05\x05\x12\x04\xcd\x07\x0c\x12\n\x0f\n\x07\x04:\x03\0\x02\x05\
    \x01\x12\x04\xcd\x07\x13$\n\x0f\n\x07\x04:\x03\0\x02\x05\x03\x12\x04\xcd\
    \x07'(\n\x0e\n\x06\x04:\x03\0\x02\x06\x12\x04\xce\x07\x0c*\n\x0f\n\x07\
    \x04:\x03\0\x02\x06\x06\x12\x04\xce\x07\x0c\x18\n\x0f\n\x07\x04:\x03\0\
    \x02\x06\x01\x12\x04\xce\x07\x19%\n\x0f\n\x07\x04:\x03\0\x02\x06\x03\x12\
    \x04\xce\x07()\n\x0e\n\x06\x04:\x03\0\x02\x07\x12\x04\xcf\x07\x0c*\n\x0f\
    \n\x07\x04:\x03\0\x02\x07\x06\x12\x04\xcf\x07\x0c\x18\n\x0f\n\x07\x04:\
    \x03\0\x02\x07\x01\x12\x04\xcf\x07\x19%\n\x0f\n\x07\x04:\x03\0\x02\x07\
    \x03\x12\x04\xcf\x07()\n\x0e\n\x06\x04:\x03\0\x02\x08\x12\x04\xd0\x07\
    \x0c0\n\x0f\n\x07\x04:\x03\0\x02\x08\x06\x12\x04\xd0\x07\x0c\x1b\n\x0f\n\
    \x07\x04:\x03\0\x02\x08\x01\x12\x04\xd0\x07\x1c+\n\x0f\n\x07\x04:\x03\0\
    \x02\x08\x03\x12\x04\xd0\x07./\n\x0e\n\x04\x04:\x03\x01\x12\x06\xd4\x07\
    \x04\xdf\x07\x05\n\r\n\x05\x04:\x03\x01\x01\x12\x04\xd4\x07\x0c\x1b\n\
    \x0e\n\x06\x04:\x03\x01\x02\0\x12\x04\xd5\x07\x085\n\x0f\n\x07\x04:\x03\
    \x01\x02\0\x04\x12\x04\xd5\x07\x08\x10\n\x0f\n\x07\x04:\x03\x01\x02\0\
    \x06\x12\x04\xd5\x07\x11(\n\x0f\n\x07\x04:\x03\x01\x02\0\x01\x12\x04\xd5\
    \x07)0\n\x0f\n\x07\x04:\x03\x01\x02\0\x03\x12\x04\xd5\x0734\n\x0e\n\x06\
    \x04:\x03\x01\x02\x01\x12\x04\xd6\x07\x084\n\x0f\n\x07\x04:\x03\x01\x02\
    \x01\x04\x12\x04\xd6\x07\x08\x10\n\x0f\n\x07\x04:\x03\x01\x02\x01\x06\
    \x12\x04\xd6\x07\x11(\n\x0f\n\x07\x04:\x03\x01\x02\x01\x01\x12\x04\xd6\
    \x07)/\n\x0f\n\x07\x04:\x03\x01\x02\x01\x03\x12\x04\xd6\x0723\n\x0e\n\
    \x06\x04:\x03\x01\x02\x02\x12\x04\xd7\x07\x08,\n\x0f\n\x07\x04:\x03\x01\
    \x02\x02\x04\x12\x04\xd7\x07\x08\x10\n\x0f\n\x07\x04:\x03\x01\x02\x02\
    \x06\x12\x04\xd7\x07\x11\x1f\n\x0f\n\x07\x04:\x03\x01\x02\x02\x01\x12\
    \x04\xd7\x07\x20'\n\x0f\n\x07\x04:\x03\x01\x02\x02\x03\x12\x04\xd7\x07*+\
    \n\x10\n\x06\x04:\x03\x01\x08\0\x12\x06\xd8\x07\x08\xde\x07\t\n\x0f\n\
    \x07\x04:\x03\x01\x08\0\x01\x12\x04\xd8\x07\x0e\x13\n\x0e\n\x06\x04:\x03\
    \x01\x02\x03\x12\x04\xd9\x07\x0c0\n\x0f\n\x07\x04:\x03\x01\x02\x03\x06\
    \x12\x04\xd9\x07\x0c\x1b\n\x0f\n\x07\x04:\x03\x01\x02\x03\x01\x12\x04\
    \xd9\x07\x1c+\n\x0f\n\x07\x04:\x03\x01\x02\x03\x03\x12\x04\xd9\x07./\n\
    \x0e\n\x06\x04:\x03\x01\x02\x04\x12\x04\xda\x07\x0c@\n\x0f\n\x07\x04:\
    \x03\x01\x02\x04\x06\x12\x04\xda\x07\x0c#\n\x0f\n\x07\x04:\x03\x01\x02\
    \x04\x01\x12\x04\xda\x07$;\n\x0f\n\x07\x04:\x03\x01\x02\x04\x03\x12\x04\
    \xda\x07>?\n\x0e\n\x06\x04:\x03\x01\x02\x05\x12\x04\xdb\x07\x0c*\n\x0f\n\
    \x07\x04:\x03\x01\x02\x05\x06\x12\x04\xdb\x07\x0c\x18\n\x0f\n\x07\x04:\
    \x03\x01\x02\x05\x01\x12\x04\xdb\x07\x19%\n\x0f\n\x07\x04:\x03\x01\x02\
    \x05\x03\x12\x04\xdb\x07()\n\x0e\n\x06\x04:\x03\x01\x02\x06\x12\x04\xdc\
    \x07\x0c*\n\x0f\n\x07\x04:\x03\x01\x02\x06\x06\x12\x04\xdc\x07\x0c\x18\n\
    \x0f\n\x07\x04:\x03\x01\x02\x06\x01\x12\x04\xdc\x07\x19%\n\x0f\n\x07\x04\
    :\x03\x01\x02\x06\x03\x12\x04\xdc\x07()\n\x0e\n\x06\x04:\x03\x01\x02\x07\
    \x12\x04\xdd\x07\x0c0\n\x0f\n\x07\x04:\x03\x01\x02\x07\x06\x12\x04\xdd\
    \x07\x0c\x1b\n\x0f\n\x07\x04:\x03\x01\x02\x07\x01\x12\x04\xdd\x07\x1c+\n\
    \x0f\n\x07\x04:\x03\x01\x02\x07\x03\x12\x04\xdd\x07./\n\x0c\n\x04\x04:\
    \x02\0\x12\x04\xe1\x07\x04)\n\r\n\x05\x04:\x02\0\x04\x12\x04\xe1\x07\x04\
    \x0c\n\r\n\x05\x04:\x02\0\x06\x12\x04\xe1\x07\r\x18\n\r\n\x05\x04:\x02\0\
    \x01\x12\x04\xe1\x07\x19$\n\r\n\x05\x04:\x02\0\x03\x12\x04\xe1\x07'(\n\
    \x0c\n\x04\x04:\x02\x01\x12\x04\xe2\x07\x04:\n\r\n\x05\x04:\x02\x01\x04\
    \x12\x04\xe2\x07\x04\x0c\n\r\n\x05\x04:\x02\x01\x06\x12\x04\xe2\x07\r$\n\
    \r\n\x05\x04:\x02\x01\x01\x12\x04\xe2\x07%5\n\r\n\x05\x04:\x02\x01\x03\
    \x12\x04\xe2\x0789\n\x0c\n\x04\x04:\x02\x02\x12\x04\xe3\x07\x04#\n\r\n\
    \x05\x04:\x02\x02\x04\x12\x04\xe3\x07\x04\x0c\n\r\n\x05\x04:\x02\x02\x05\
    \x12\x04\xe3\x07\r\x13\n\r\n\x05\x04:\x02\x02\x01\x12\x04\xe3\x07\x14\
    \x1e\n\r\n\x05\x04:\x02\x02\x03\x12\x04\xe3\x07!\"\n\x0e\n\x04\x04:\x08\
    \0\x12\x06\xe4\x07\x04\xe8\x07\x05\n\r\n\x05\x04:\x08\0\x01\x12\x04\xe4\
    \x07\n\x10\n\x0c\n\x04\x04:\x02\x03\x12\x04\xe5\x07\x08,\n\r\n\x05\x04:\
    \x02\x03\x06\x12\x04\xe5\x07\x08\x17\n\r\n\x05\x04:\x02\x03\x01\x12\x04\
    \xe5\x07\x18'\n\r\n\x05\x04:\x02\x03\x03\x12\x04\xe5\x07*+\n\x0c\n\x04\
    \x04:\x02\x04\x12\x04\xe6\x07\x08<\n\r\n\x05\x04:\x02\x04\x06\x12\x04\
    \xe6\x07\x08\x1f\n\r\n\x05\x04:\x02\x04\x01\x12\x04\xe6\x07\x207\n\r\n\
    \x05\x04:\x02\x04\x03\x12\x04\xe6\x07:;\n\x0c\n\x04\x04:\x02\x05\x12\x04\
    \xe7\x07\x08:\n\r\n\x05\x04:\x02\x05\x06\x12\x04\xe7\x07\x08\x1a\n\r\n\
    \x05\x04:\x02\x05\x01\x12\x04\xe7\x07\x1b5\n\r\n\x05\x04:\x02\x05\x03\
    \x12\x04\xe7\x0789\n\x0c\n\x02\x04;\x12\x06\xeb\x07\0\xf0\x07\x01\n\x0b\
    \n\x03\x04;\x01\x12\x04\xeb\x07\x08\"\n\x0c\n\x04\x04;\x02\0\x12\x04\xec\
    \x07\x04#\n\r\n\x05\x04;\x02\0\x04\x12\x04\xec\x07\x04\x0c\n\r\n\x05\x04\
    ;\x02\0\x05\x12\x04\xec\x07\r\x13\n\r\n\x05\x04;\x02\0\x01\x12\x04\xec\
    \x07\x14\x1e\n\r\n\x05\x04;\x02\0\x03\x12\x04\xec\x07!\"\n\x0c\n\x04\x04\
    ;\x02\x01\x12\x04\xed\x07\x04,\n\r\n\x05\x04;\x02\x01\x04\x12\x04\xed\
    \x07\x04\x0c\n\r\n\x05\x04;\x02\x01\x05\x12\x04\xed\x07\r\x13\n\r\n\x05\
    \x04;\x02\x01\x01\x12\x04\xed\x07\x14'\n\r\n\x05\x04;\x02\x01\x03\x12\
    \x04\xed\x07*+\n\x0c\n\x04\x04;\x02\x02\x12\x04\xee\x07\x04)\n\r\n\x05\
    \x04;\x02\x02\x04\x12\x04\xee\x07\x04\x0c\n\r\n\x05\x04;\x02\x02\x06\x12\
    \x04\xee\x07\r\x18\n\r\n\x05\x04;\x02\x02\x01\x12\x04\xee\x07\x19$\n\r\n\
    \x05\x04;\x02\x02\x03\x12\x04\xee\x07'(\n\x0c\n\x04\x04;\x02\x03\x12\x04\
    \xef\x07\x04&\n\r\n\x05\x04;\x02\x03\x04\x12\x04\xef\x07\x04\x0c\n\r\n\
    \x05\x04;\x02\x03\x05\x12\x04\xef\x07\r\x13\n\r\n\x05\x04;\x02\x03\x01\
    \x12\x04\xef\x07\x14!\n\r\n\x05\x04;\x02\x03\x03\x12\x04\xef\x07$%\n\x0c\
    \n\x02\x04<\x12\x06\xf2\x07\0\xf6\x07\x01\n\x0b\n\x03\x04<\x01\x12\x04\
    \xf2\x07\x08\x1d\n\x0c\n\x04\x04<\x02\0\x12\x04\xf3\x07\x04!\n\r\n\x05\
    \x04<\x02\0\x04\x12\x04\xf3\x07\x04\x0c\n\r\n\x05\x04<\x02\0\x05\x12\x04\
    \xf3\x07\r\x13\n\r\n\x05\x04<\x02\0\x01\x12\x04\xf3\x07\x14\x1c\n\r\n\
    \x05\x04<\x02\0\x03\x12\x04\xf3\x07\x1f\x20\n\x0c\n\x04\x04<\x02\x01\x12\
    \x04\xf4\x07\x04\"\n\r\n\x05\x04<\x02\x01\x04\x12\x04\xf4\x07\x04\x0c\n\
    \r\n\x05\x04<\x02\x01\x05\x12\x04\xf4\x07\r\x13\n\r\n\x05\x04<\x02\x01\
    \x01\x12\x04\xf4\x07\x14\x1d\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xf4\x07\
    \x20!\n\x0c\n\x04\x04<\x02\x02\x12\x04\xf5\x07\x04(\n\r\n\x05\x04<\x02\
    \x02\x04\x12\x04\xf5\x07\x04\x0c\n\r\n\x05\x04<\x02\x02\x05\x12\x04\xf5\
    \x07\r\x12\n\r\n\x05\x04<\x02\x02\x01\x12\x04\xf5\x07\x13#\n\r\n\x05\x04\
    <\x02\x02\x03\x12\x04\xf5\x07&'\n\x0c\n\x02\x04=\x12\x06\xf8\x07\0\x8a\
    \x08\x01\n\x0b\n\x03\x04=\x01\x12\x04\xf8\x07\x08\x16\n\x0c\n\x04\x04=\
    \x02\0\x12\x04\xf9\x07\x04\x1c\n\r\n\x05\x04=\x02\0\x04\x12\x04\xf9\x07\
    \x04\x0c\n\r\n\x05\x04=\x02\0\x05\x12\x04\xf9\x07\r\x13\n\r\n\x05\x04=\
    \x02\0\x01\x12\x04\xf9\x07\x14\x17\n\r\n\x05\x04=\x02\0\x03\x12\x04\xf9\
    \x07\x1a\x1b\n\x0c\n\x04\x04=\x02\x01\x12\x04\xfa\x07\x04\"\n\r\n\x05\
    \x04=\x02\x01\x04\x12\x04\xfa\x07\x04\x0c\n\r\n\x05\x04=\x02\x01\x05\x12\
    \x04\xfa\x07\r\x12\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xfa\x07\x13\x1d\n\
    \r\n\x05\x04=\x02\x01\x03\x12\x04\xfa\x07\x20!\n\x0c\n\x04\x04=\x02\x02\
    \x12\x04\xfb\x07\x04%\n\r\n\x05\x04=\x02\x02\x04\x12\x04\xfb\x07\x04\x0c\
    \n\r\n\x05\x04=\x02\x02\x05\x12\x04\xfb\x07\r\x12\n\r\n\x05\x04=\x02\x02\
    \x01\x12\x04\xfb\x07\x13\x20\n\r\n\x05\x04=\x02\x02\x03\x12\x04\xfb\x07#\
    $\n\x0c\n\x04\x04=\x02\x03\x12\x04\xfc\x07\x04\x20\n\r\n\x05\x04=\x02\
    \x03\x04\x12\x04\xfc\x07\x04\x0c\n\r\n\x05\x04=\x02\x03\x05\x12\x04\xfc\
    \x07\r\x12\n\r\n\x05\x04=\x02\x03\x01\x12\x04\xfc\x07\x13\x1b\n\r\n\x05\
    \x04=\x02\x03\x03\x12\x04\xfc\x07\x1e\x1f\n\x0c\n\x04\x04=\x02\x04\x12\
    \x04\xfd\x07\x04!\n\r\n\x05\x04=\x02\x04\x04\x12\x04\xfd\x07\x04\x0c\n\r\
    \n\x05\x04=\x02\x04\x05\x12\x04\xfd\x07\r\x13\n\r\n\x05\x04=\x02\x04\x01\
    \x12\x04\xfd\x07\x14\x1c\n\r\n\x05\x04=\x02\x04\x03\x12\x04\xfd\x07\x1f\
    \x20\n\x0c\n\x04\x04=\x02\x05\x12\x04\xfe\x07\x04\x1f\n\r\n\x05\x04=\x02\
    \x05\x04\x12\x04\xfe\x07\x04\x0c\n\r\n\x05\x04=\x02\x05\x05\x12\x04\xfe\
    \x07\r\x13\n\r\n\x05\x04=\x02\x05\x01\x12\x04\xfe\x07\x14\x1a\n\r\n\x05\
    \x04=\x02\x05\x03\x12\x04\xfe\x07\x1d\x1e\n\x0c\n\x04\x04=\x02\x06\x12\
    \x04\xff\x07\x04\x1e\n\r\n\x05\x04=\x02\x06\x04\x12\x04\xff\x07\x04\x0c\
    \n\r\n\x05\x04=\x02\x06\x05\x12\x04\xff\x07\r\x13\n\r\n\x05\x04=\x02\x06\
    \x01\x12\x04\xff\x07\x14\x19\n\r\n\x05\x04=\x02\x06\x03\x12\x04\xff\x07\
    \x1c\x1d\n\x0c\n\x04\x04=\x02\x07\x12\x04\x80\x08\x04#\n\r\n\x05\x04=\
    \x02\x07\x04\x12\x04\x80\x08\x04\x0c\n\r\n\x05\x04=\x02\x07\x05\x12\x04\
    \x80\x08\r\x13\n\r\n\x05\x04=\x02\x07\x01\x12\x04\x80\x08\x14\x1e\n\r\n\
    \x05\x04=\x02\x07\x03\x12\x04\x80\x08!\"\n\x0c\n\x04\x04=\x02\x08\x12\
    \x04\x81\x08\x04#\n\r\n\x05\x04=\x02\x08\x04\x12\x04\x81\x08\x04\x0c\n\r\
    \n\x05\x04=\x02\x08\x05\x12\x04\x81\x08\r\x13\n\r\n\x05\x04=\x02\x08\x01\
    \x12\x04\x81\x08\x14\x1e\n\r\n\x05\x04=\x02\x08\x03\x12\x04\x81\x08!\"\n\
    \x0c\n\x04\x04=\x02\t\x12\x04\x82\x08\x04*\n\r\n\x05\x04=\x02\t\x04\x12\
    \x04\x82\x08\x04\x0c\n\r\n\x05\x04=\x02\t\x05\x12\x04\x82\x08\r\x12\n\r\
    \n\x05\x04=\x02\t\x01\x12\x04\x82\x08\x13$\n\r\n\x05\x04=\x02\t\x03\x12\
    \x04\x82\x08')\n\x0c\n\x04\x04=\x02\n\x12\x04\x83\x08\x04*\n\r\n\x05\x04\
    =\x02\n\x04\x12\x04\x83\x08\x04\x0c\n\r\n\x05\x04=\x02\n\x05\x12\x04\x83\
    \x08\r\x13\n\r\n\x05\x04=\x02\n\x01\x12\x04\x83\x08\x14$\n\r\n\x05\x04=\
    \x02\n\x03\x12\x04\x83\x08')\n\x0c\n\x04\x04=\x02\x0b\x12\x04\x84\x08\
    \x04*\n\r\n\x05\x04=\x02\x0b\x04\x12\x04\x84\x08\x04\x0c\n\r\n\x05\x04=\
    \x02\x0b\x05\x12\x04\x84\x08\r\x12\n\r\n\x05\x04=\x02\x0b\x01\x12\x04\
    \x84\x08\x13$\n\r\n\x05\x04=\x02\x0b\x03\x12\x04\x84\x08')\n\x0c\n\x04\
    \x04=\x02\x0c\x12\x04\x85\x08\x04\"\n\r\n\x05\x04=\x02\x0c\x04\x12\x04\
    \x85\x08\x04\x0c\n\r\n\x05\x04=\x02\x0c\x05\x12\x04\x85\x08\r\x11\n\r\n\
    \x05\x04=\x02\x0c\x01\x12\x04\x85\x08\x12\x1c\n\r\n\x05\x04=\x02\x0c\x03\
    \x12\x04\x85\x08\x1f!\n\x0c\n\x04\x04=\x02\r\x12\x04\x86\x08\x04%\n\r\n\
    \x05\x04=\x02\r\x04\x12\x04\x86\x08\x04\x0c\n\r\n\x05\x04=\x02\r\x05\x12\
    \x04\x86\x08\r\x12\n\r\n\x05\x04=\x02\r\x01\x12\x04\x86\x08\x13\x1f\n\r\
    \n\x05\x04=\x02\r\x03\x12\x04\x86\x08\"$\n\x0c\n\x04\x04=\x02\x0e\x12\
    \x04\x87\x08\x04*\n\r\n\x05\x04=\x02\x0e\x04\x12\x04\x87\x08\x04\x0c\n\r\
    \n\x05\x04=\x02\x0e\x06\x12\x04\x87\x08\r\x18\n\r\n\x05\x04=\x02\x0e\x01\
    \x12\x04\x87\x08\x19$\n\r\n\x05\x04=\x02\x0e\x03\x12\x04\x87\x08')\n\x0c\
    \n\x04\x04=\x02\x0f\x12\x04\x88\x08\x04&\n\r\n\x05\x04=\x02\x0f\x04\x12\
    \x04\x88\x08\x04\x0c\n\r\n\x05\x04=\x02\x0f\x05\x12\x04\x88\x08\r\x12\n\
    \r\n\x05\x04=\x02\x0f\x01\x12\x04\x88\x08\x13\x20\n\r\n\x05\x04=\x02\x0f\
    \x03\x12\x04\x88\x08#%\n\x0c\n\x04\x04=\x02\x10\x12\x04\x89\x08\x04\x20\
    \n\r\n\x05\x04=\x02\x10\x04\x12\x04\x89\x08\x04\x0c\n\r\n\x05\x04=\x02\
    \x10\x05\x12\x04\x89\x08\r\x11\n\r\n\x05\x04=\x02\x10\x01\x12\x04\x89\
    \x08\x12\x1a\n\r\n\x05\x04=\x02\x10\x03\x12\x04\x89\x08\x1d\x1f\n\x0c\n\
    \x02\x04>\x12\x06\x8c\x08\0\x8f\x08\x01\n\x0b\n\x03\x04>\x01\x12\x04\x8c\
    \x08\x08$\n\x0c\n\x04\x04>\x02\0\x12\x04\x8d\x08\x04\x20\n\r\n\x05\x04>\
    \x02\0\x04\x12\x04\x8d\x08\x04\x0c\n\r\n\x05\x04>\x02\0\x05\x12\x04\x8d\
    \x08\r\x13\n\r\n\x05\x04>\x02\0\x01\x12\x04\x8d\x08\x14\x1b\n\r\n\x05\
    \x04>\x02\0\x03\x12\x04\x8d\x08\x1e\x1f\n\x0c\n\x04\x04>\x02\x01\x12\x04\
    \x8e\x08\x04;\n\r\n\x05\x04>\x02\x01\x04\x12\x04\x8e\x08\x04\x0c\n\r\n\
    \x05\x04>\x02\x01\x05\x12\x04\x8e\x08\r\x12\n\r\n\x05\x04>\x02\x01\x01\
    \x12\x04\x8e\x08\x136\n\r\n\x05\x04>\x02\x01\x03\x12\x04\x8e\x089:\n\x0c\
    \n\x02\x04?\x12\x06\x91\x08\0\x95\x08\x01\n\x0b\n\x03\x04?\x01\x12\x04\
    \x91\x08\x08\x1a\n\x0c\n\x04\x04?\x02\0\x12\x04\x92\x08\x04%\n\r\n\x05\
    \x04?\x02\0\x04\x12\x04\x92\x08\x04\x0c\n\r\n\x05\x04?\x02\0\x06\x12\x04\
    \x92\x08\r\x14\n\r\n\x05\x04?\x02\0\x01\x12\x04\x92\x08\x15\x20\n\r\n\
    \x05\x04?\x02\0\x03\x12\x04\x92\x08#$\n\x0c\n\x04\x04?\x02\x01\x12\x04\
    \x93\x08\x04.\n\r\n\x05\x04?\x02\x01\x04\x12\x04\x93\x08\x04\x0c\n\r\n\
    \x05\x04?\x02\x01\x06\x12\x04\x93\x08\r\x17\n\r\n\x05\x04?\x02\x01\x01\
    \x12\x04\x93\x08\x18)\n\r\n\x05\x04?\x02\x01\x03\x12\x04\x93\x08,-\n\x0c\
    \n\x04\x04?\x02\x02\x12\x04\x94\x08\x04.\n\r\n\x05\x04?\x02\x02\x04\x12\
    \x04\x94\x08\x04\x0c\n\r\n\x05\x04?\x02\x02\x06\x12\x04\x94\x08\r\x1e\n\
    \r\n\x05\x04?\x02\x02\x01\x12\x04\x94\x08\x1f)\n\r\n\x05\x04?\x02\x02\
    \x03\x12\x04\x94\x08,-\n\x0c\n\x02\x04@\x12\x06\x97\x08\0\x9e\x08\x01\n\
    \x0b\n\x03\x04@\x01\x12\x04\x97\x08\x08\x20\n\x0e\n\x04\x04@\x04\0\x12\
    \x06\x98\x08\x04\x9b\x08\x05\n\r\n\x05\x04@\x04\0\x01\x12\x04\x98\x08\t\
    \x11\n\x0e\n\x06\x04@\x04\0\x02\0\x12\x04\x99\x08\x08\x14\n\x0f\n\x07\
    \x04@\x04\0\x02\0\x01\x12\x04\x99\x08\x08\x0f\n\x0f\n\x07\x04@\x04\0\x02\
    \0\x02\x12\x04\x99\x08\x12\x13\n\x0e\n\x06\x04@\x04\0\x02\x01\x12\x04\
    \x9a\x08\x08\x13\n\x0f\n\x07\x04@\x04\0\x02\x01\x01\x12\x04\x9a\x08\x08\
    \x0e\n\x0f\n\x07\x04@\x04\0\x02\x01\x02\x12\x04\x9a\x08\x11\x12\n\x0c\n\
    \x04\x04@\x02\0\x12\x04\x9c\x08\x04\x20\n\r\n\x05\x04@\x02\0\x04\x12\x04\
    \x9c\x08\x04\x0c\n\r\n\x05\x04@\x02\0\x06\x12\x04\x9c\x08\r\x17\n\r\n\
    \x05\x04@\x02\0\x01\x12\x04\x9c\x08\x18\x1b\n\r\n\x05\x04@\x02\0\x03\x12\
    \x04\x9c\x08\x1e\x1f\n\x0c\n\x04\x04@\x02\x01\x12\x04\x9d\x08\x04#\n\r\n\
    \x05\x04@\x02\x01\x04\x12\x04\x9d\x08\x04\x0c\n\r\n\x05\x04@\x02\x01\x06\
    \x12\x04\x9d\x08\r\x15\n\r\n\x05\x04@\x02\x01\x01\x12\x04\x9d\x08\x16\
    \x1e\n\r\n\x05\x04@\x02\x01\x03\x12\x04\x9d\x08!\"\n\x0c\n\x02\x04A\x12\
    \x06\xa0\x08\0\xa9\x08\x01\n\x0b\n\x03\x04A\x01\x12\x04\xa0\x08\x08$\n\
    \x0e\n\x04\x04A\x04\0\x12\x06\xa1\x08\x04\xa5\x08\x05\n\r\n\x05\x04A\x04\
    \0\x01\x12\x04\xa1\x08\t\x11\n\x0e\n\x06\x04A\x04\0\x02\0\x12\x04\xa2\
    \x08\x08\x14\n\x0f\n\x07\x04A\x04\0\x02\0\x01\x12\x04\xa2\x08\x08\x0f\n\
    \x0f\n\x07\x04A\x04\0\x02\0\x02\x12\x04\xa2\x08\x12\x13\n\x0e\n\x06\x04A\
    \x04\0\x02\x01\x12\x04\xa3\x08\x08\x12\n\x0f\n\x07\x04A\x04\0\x02\x01\
    \x01\x12\x04\xa3\x08\x08\r\n\x0f\n\x07\x04A\x04\0\x02\x01\x02\x12\x04\
    \xa3\x08\x10\x11\n\x0e\n\x06\x04A\x04\0\x02\x02\x12\x04\xa4\x08\x08\x12\
    \n\x0f\n\x07\x04A\x04\0\x02\x02\x01\x12\x04\xa4\x08\x08\r\n\x0f\n\x07\
    \x04A\x04\0\x02\x02\x02\x12\x04\xa4\x08\x10\x11\n\x0c\n\x04\x04A\x02\0\
    \x12\x04\xa6\x08\x04,\n\r\n\x05\x04A\x02\0\x04\x12\x04\xa6\x08\x04\x0c\n\
    \r\n\x05\x04A\x02\0\x05\x12\x04\xa6\x08\r\x12\n\r\n\x05\x04A\x02\0\x01\
    \x12\x04\xa6\x08\x13'\n\r\n\x05\x04A\x02\0\x03\x12\x04\xa6\x08*+\n\x0c\n\
    \x04\x04A\x02\x01\x12\x04\xa7\x08\x04#\n\r\n\x05\x04A\x02\x01\x04\x12\
    \x04\xa7\x08\x04\x0c\n\r\n\x05\x04A\x02\x01\x06\x12\x04\xa7\x08\r\x15\n\
    \r\n\x05\x04A\x02\x01\x01\x12\x04\xa7\x08\x16\x1e\n\r\n\x05\x04A\x02\x01\
    \x03\x12\x04\xa7\x08!\"\n\x0c\n\x04\x04A\x02\x02\x12\x04\xa8\x08\x04\x1e\
    \n\r\n\x05\x04A\x02\x02\x04\x12\x04\xa8\x08\x04\x0c\n\r\n\x05\x04A\x02\
    \x02\x05\x12\x04\xa8\x08\r\x13\n\r\n\x05\x04A\x02\x02\x01\x12\x04\xa8\
    \x08\x14\x19\n\r\n\x05\x04A\x02\x02\x03\x12\x04\xa8\x08\x1c\x1d\n\x0c\n\
    \x02\x04B\x12\x06\xab\x08\0\xad\x08\x01\n\x0b\n\x03\x04B\x01\x12\x04\xab\
    \x08\x08!\n\x0c\n\x04\x04B\x02\0\x12\x04\xac\x08\x04)\n\r\n\x05\x04B\x02\
    \0\x04\x12\x04\xac\x08\x04\x0c\n\r\n\x05\x04B\x02\0\x06\x12\x04\xac\x08\
    \r\x18\n\r\n\x05\x04B\x02\0\x01\x12\x04\xac\x08\x19$\n\r\n\x05\x04B\x02\
    \0\x03\x12\x04\xac\x08'(\n\x0c\n\x02\x04C\x12\x06\xaf\x08\0\xb7\x08\x01\
    \n\x0b\n\x03\x04C\x01\x12\x04\xaf\x08\x08\x1d\n\x0c\n\x04\x04C\x02\0\x12\
    \x04\xb0\x08\x04%\n\r\n\x05\x04C\x02\0\x04\x12\x04\xb0\x08\x04\x0c\n\r\n\
    \x05\x04C\x02\0\x06\x12\x04\xb0\x08\r\x14\n\r\n\x05\x04C\x02\0\x01\x12\
    \x04\xb0\x08\x15\x20\n\r\n\x05\x04C\x02\0\x03\x12\x04\xb0\x08#$\n\x0c\n\
    \x04\x04C\x02\x01\x12\x04\xb1\x08\x04,\n\r\n\x05\x04C\x02\x01\x04\x12\
    \x04\xb1\x08\x04\x0c\n\r\n\x05\x04C\x02\x01\x05\x12\x04\xb1\x08\r\x13\n\
    \r\n\x05\x04C\x02\x01\x01\x12\x04\xb1\x08\x14'\n\r\n\x05\x04C\x02\x01\
    \x03\x12\x04\xb1\x08*+\n\x0c\n\x04\x04C\x02\x02\x12\x04\xb2\x08\x04#\n\r\
    \n\x05\x04C\x02\x02\x04\x12\x04\xb2\x08\x04\x0c\n\r\n\x05\x04C\x02\x02\
    \x05\x12\x04\xb2\x08\r\x13\n\r\n\x05\x04C\x02\x02\x01\x12\x04\xb2\x08\
    \x14\x1e\n\r\n\x05\x04C\x02\x02\x03\x12\x04\xb2\x08!\"\n\x0c\n\x04\x04C\
    \x02\x03\x12\x04\xb3\x08\x04$\n\r\n\x05\x04C\x02\x03\x04\x12\x04\xb3\x08\
    \x04\x0c\n\r\n\x05\x04C\x02\x03\x05\x12\x04\xb3\x08\r\x13\n\r\n\x05\x04C\
    \x02\x03\x01\x12\x04\xb3\x08\x14\x1f\n\r\n\x05\x04C\x02\x03\x03\x12\x04\
    \xb3\x08\"#\n\x0c\n\x04\x04C\x02\x04\x12\x04\xb4\x08\x04'\n\r\n\x05\x04C\
    \x02\x04\x04\x12\x04\xb4\x08\x04\x0c\n\r\n\x05\x04C\x02\x04\x05\x12\x04\
    \xb4\x08\r\x12\n\r\n\x05\x04C\x02\x04\x01\x12\x04\xb4\x08\x13\"\n\r\n\
    \x05\x04C\x02\x04\x03\x12\x04\xb4\x08%&\n\x0c\n\x04\x04C\x02\x05\x12\x04\
    \xb5\x08\x04\x1e\n\r\n\x05\x04C\x02\x05\x04\x12\x04\xb5\x08\x04\x0c\n\r\
    \n\x05\x04C\x02\x05\x06\x12\x04\xb5\x08\r\x12\n\r\n\x05\x04C\x02\x05\x01\
    \x12\x04\xb5\x08\x13\x19\n\r\n\x05\x04C\x02\x05\x03\x12\x04\xb5\x08\x1c\
    \x1d\n\x0c\n\x04\x04C\x02\x06\x12\x04\xb6\x08\x04.\n\r\n\x05\x04C\x02\
    \x06\x04\x12\x04\xb6\x08\x04\x0c\n\r\n\x05\x04C\x02\x06\x06\x12\x04\xb6\
    \x08\r\x1e\n\r\n\x05\x04C\x02\x06\x01\x12\x04\xb6\x08\x1f)\n\r\n\x05\x04\
    C\x02\x06\x03\x12\x04\xb6\x08,-\n\x0c\n\x02\x04D\x12\x06\xb9\x08\0\xbe\
    \x08\x01\n\x0b\n\x03\x04D\x01\x12\x04\xb9\x08\x08\x17\n\x0c\n\x04\x04D\
    \x02\0\x12\x04\xba\x08\x04\x20\n\r\n\x05\x04D\x02\0\x04\x12\x04\xba\x08\
    \x04\x0c\n\r\n\x05\x04D\x02\0\x06\x12\x04\xba\x08\r\x17\n\r\n\x05\x04D\
    \x02\0\x01\x12\x04\xba\x08\x18\x1b\n\r\n\x05\x04D\x02\0\x03\x12\x04\xba\
    \x08\x1e\x1f\n\x0c\n\x04\x04D\x02\x01\x12\x04\xbb\x08\x04\x1d\n\r\n\x05\
    \x04D\x02\x01\x04\x12\x04\xbb\x08\x04\x0c\n\r\n\x05\x04D\x02\x01\x05\x12\
    \x04\xbb\x08\r\x13\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xbb\x08\x14\x18\n\
    \r\n\x05\x04D\x02\x01\x03\x12\x04\xbb\x08\x1b\x1c\n\x0c\n\x04\x04D\x02\
    \x02\x12\x04\xbc\x08\x04$\n\r\n\x05\x04D\x02\x02\x04\x12\x04\xbc\x08\x04\
    \x0c\n\r\n\x05\x04D\x02\x02\x05\x12\x04\xbc\x08\r\x13\n\r\n\x05\x04D\x02\
    \x02\x01\x12\x04\xbc\x08\x14\x1f\n\r\n\x05\x04D\x02\x02\x03\x12\x04\xbc\
    \x08\"#\n\x0c\n\x04\x04D\x02\x03\x12\x04\xbd\x08\x04)\n\r\n\x05\x04D\x02\
    \x03\x04\x12\x04\xbd\x08\x04\x0c\n\r\n\x05\x04D\x02\x03\x05\x12\x04\xbd\
    \x08\r\x12\n\r\n\x05\x04D\x02\x03\x01\x12\x04\xbd\x08\x13$\n\r\n\x05\x04\
    D\x02\x03\x03\x12\x04\xbd\x08'(\n\x0c\n\x02\x04E\x12\x06\xc0\x08\0\xde\
    \x08\x01\n\x0b\n\x03\x04E\x01\x12\x04\xc0\x08\x08\x17\n\x0e\n\x04\x04E\
    \x04\0\x12\x06\xc1\x08\x04\xcf\x08\x05\n\r\n\x05\x04E\x04\0\x01\x12\x04\
    \xc1\x08\t\r\n\x0e\n\x06\x04E\x04\0\x02\0\x12\x04\xc2\x08\x08\x13\n\x0f\
    \n\x07\x04E\x04\0\x02\0\x01\x12\x04\xc2\x08\x08\x0e\n\x0f\n\x07\x04E\x04\
    \0\x02\0\x02\x12\x04\xc2\x08\x11\x12\n\x0e\n\x06\x04E\x04\0\x02\x01\x12\
    \x04\xc3\x08\x08\x1e\n\x0f\n\x07\x04E\x04\0\x02\x01\x01\x12\x04\xc3\x08\
    \x08\x19\n\x0f\n\x07\x04E\x04\0\x02\x01\x02\x12\x04\xc3\x08\x1c\x1d\n\
    \x0e\n\x06\x04E\x04\0\x02\x02\x12\x04\xc4\x08\x08$\n\x0f\n\x07\x04E\x04\
    \0\x02\x02\x01\x12\x04\xc4\x08\x08\x1f\n\x0f\n\x07\x04E\x04\0\x02\x02\
    \x02\x12\x04\xc4\x08\"#\n\x0e\n\x06\x04E\x04\0\x02\x03\x12\x04\xc5\x08\
    \x08&\n\x0f\n\x07\x04E\x04\0\x02\x03\x01\x12\x04\xc5\x08\x08!\n\x0f\n\
    \x07\x04E\x04\0\x02\x03\x02\x12\x04\xc5\x08$%\n\x0e\n\x06\x04E\x04\0\x02\
    \x04\x12\x04\xc6\x08\x08%\n\x0f\n\x07\x04E\x04\0\x02\x04\x01\x12\x04\xc6\
    \x08\x08\x20\n\x0f\n\x07\x04E\x04\0\x02\x04\x02\x12\x04\xc6\x08#$\n\x0e\
    \n\x06\x04E\x04\0\x02\x05\x12\x04\xc7\x08\x08'\n\x0f\n\x07\x04E\x04\0\
    \x02\x05\x01\x12\x04\xc7\x08\x08\"\n\x0f\n\x07\x04E\x04\0\x02\x05\x02\
    \x12\x04\xc7\x08%&\n\x0e\n\x06\x04E\x04\0\x02\x06\x12\x04\xc8\x08\x08(\n\
    \x0f\n\x07\x04E\x04\0\x02\x06\x01\x12\x04\xc8\x08\x08#\n\x0f\n\x07\x04E\
    \x04\0\x02\x06\x02\x12\x04\xc8\x08&'\n\x0e\n\x06\x04E\x04\0\x02\x07\x12\
    \x04\xc9\x08\x087\n\x0f\n\x07\x04E\x04\0\x02\x07\x01\x12\x04\xc9\x08\x08\
    2\n\x0f\n\x07\x04E\x04\0\x02\x07\x02\x12\x04\xc9\x0856\n\x0e\n\x06\x04E\
    \x04\0\x02\x08\x12\x04\xca\x08\x084\n\x0f\n\x07\x04E\x04\0\x02\x08\x01\
    \x12\x04\xca\x08\x08.\n\x0f\n\x07\x04E\x04\0\x02\x08\x02\x12\x04\xca\x08\
    13\n\x0e\n\x06\x04E\x04\0\x02\t\x12\x04\xcb\x08\x08\x20\n\x0f\n\x07\x04E\
    \x04\0\x02\t\x01\x12\x04\xcb\x08\x08\x1a\n\x0f\n\x07\x04E\x04\0\x02\t\
    \x02\x12\x04\xcb\x08\x1d\x1f\n\x0e\n\x06\x04E\x04\0\x02\n\x12\x04\xcc\
    \x08\x08\x1a\n\x0f\n\x07\x04E\x04\0\x02\n\x01\x12\x04\xcc\x08\x08\x14\n\
    \x0f\n\x07\x04E\x04\0\x02\n\x02\x12\x04\xcc\x08\x17\x19\n\x0e\n\x06\x04E\
    \x04\0\x02\x0b\x12\x04\xcd\x08\x081\n\x0f\n\x07\x04E\x04\0\x02\x0b\x01\
    \x12\x04\xcd\x08\x08+\n\x0f\n\x07\x04E\x04\0\x02\x0b\x02\x12\x04\xcd\x08\
    .0\n\x0e\n\x06\x04E\x04\0\x02\x0c\x12\x04\xce\x08\x08:\n\x0f\n\x07\x04E\
    \x04\0\x02\x0c\x01\x12\x04\xce\x08\x084\n\x0f\n\x07\x04E\x04\0\x02\x0c\
    \x02\x12\x04\xce\x0879\n\x0c\n\x04\x04E\x02\0\x12\x04\xd0\x08\x04\x20\n\
    \r\n\x05\x04E\x02\0\x04\x12\x04\xd0\x08\x04\x0c\n\r\n\x05\x04E\x02\0\x06\
    \x12\x04\xd0\x08\r\x17\n\r\n\x05\x04E\x02\0\x01\x12\x04\xd0\x08\x18\x1b\
    \n\r\n\x05\x04E\x02\0\x03\x12\x04\xd0\x08\x1e\x1f\n\x0c\n\x04\x04E\x02\
    \x01\x12\x04\xd1\x08\x04\x1b\n\r\n\x05\x04E\x02\x01\x04\x12\x04\xd1\x08\
    \x04\x0c\n\r\n\x05\x04E\x02\x01\x06\x12\x04\xd1\x08\r\x11\n\r\n\x05\x04E\
    \x02\x01\x01\x12\x04\xd1\x08\x12\x16\n\r\n\x05\x04E\x02\x01\x03\x12\x04\
    \xd1\x08\x19\x1a\n\x0c\n\x04\x04E\x02\x02\x12\x04\xd2\x08\x04,\n\r\n\x05\
    \x04E\x02\x02\x04\x12\x04\xd2\x08\x04\x0c\n\r\n\x05\x04E\x02\x02\x05\x12\
    \x04\xd2\x08\r\x13\n\r\n\x05\x04E\x02\x02\x01\x12\x04\xd2\x08\x14'\n\r\n\
    \x05\x04E\x02\x02\x03\x12\x04\xd2\x08*+\n\x0c\n\x04\x04E\x02\x03\x12\x04\
    \xd3\x08\x041\n\r\n\x05\x04E\x02\x03\x04\x12\x04\xd3\x08\x04\x0c\n\r\n\
    \x05\x04E\x02\x03\x05\x12\x04\xd3\x08\r\x12\n\r\n\x05\x04E\x02\x03\x01\
    \x12\x04\xd3\x08\x13,\n\r\n\x05\x04E\x02\x03\x03\x12\x04\xd3\x08/0\n\x0c\
    \n\x04\x04E\x02\x04\x12\x04\xd4\x08\x04A\n\r\n\x05\x04E\x02\x04\x04\x12\
    \x04\xd4\x08\x04\x0c\n\r\n\x05\x04E\x02\x04\x06\x12\x04\xd4\x08\r$\n\r\n\
    \x05\x04E\x02\x04\x01\x12\x04\xd4\x08%<\n\r\n\x05\x04E\x02\x04\x03\x12\
    \x04\xd4\x08?@\n\x0c\n\x04\x04E\x02\x05\x12\x04\xd5\x08\x04;\n\r\n\x05\
    \x04E\x02\x05\x04\x12\x04\xd5\x08\x04\x0c\n\r\n\x05\x04E\x02\x05\x06\x12\
    \x04\xd5\x08\r!\n\r\n\x05\x04E\x02\x05\x01\x12\x04\xd5\x08\"6\n\r\n\x05\
    \x04E\x02\x05\x03\x12\x04\xd5\x089:\n\x0c\n\x04\x04E\x02\x06\x12\x04\xd6\
    \x08\x04?\n\r\n\x05\x04E\x02\x06\x04\x12\x04\xd6\x08\x04\x0c\n\r\n\x05\
    \x04E\x02\x06\x06\x12\x04\xd6\x08\r#\n\r\n\x05\x04E\x02\x06\x01\x12\x04\
    \xd6\x08$:\n\r\n\x05\x04E\x02\x06\x03\x12\x04\xd6\x08=>\n\x0c\n\x04\x04E\
    \x02\x07\x12\x04\xd7\x08\x04_\n\r\n\x05\x04E\x02\x07\x04\x12\x04\xd7\x08\
    \x04\x0c\n\r\n\x05\x04E\x02\x07\x06\x12\x04\xd7\x08\r3\n\r\n\x05\x04E\
    \x02\x07\x01\x12\x04\xd7\x084Z\n\r\n\x05\x04E\x02\x07\x03\x12\x04\xd7\
    \x08]^\n\x0c\n\x04\x04E\x02\x08\x12\x04\xd8\x08\x04X\n\r\n\x05\x04E\x02\
    \x08\x04\x12\x04\xd8\x08\x04\x0c\n\r\n\x05\x04E\x02\x08\x06\x12\x04\xd8\
    \x08\r/\n\r\n\x05\x04E\x02\x08\x01\x12\x04\xd8\x080R\n\r\n\x05\x04E\x02\
    \x08\x03\x12\x04\xd8\x08UW\n\x0c\n\x04\x04E\x02\t\x12\x04\xd9\x08\x044\n\
    \r\n\x05\x04E\x02\t\x04\x12\x04\xd9\x08\x04\x0c\n\r\n\x05\x04E\x02\t\x06\
    \x12\x04\xd9\x08\r\x1d\n\r\n\x05\x04E\x02\t\x01\x12\x04\xd9\x08\x1e.\n\r\
    \n\x05\x04E\x02\t\x03\x12\x04\xd9\x0813\n\x0c\n\x04\x04E\x02\n\x12\x04\
    \xda\x08\x04(\n\r\n\x05\x04E\x02\n\x04\x12\x04\xda\x08\x04\x0c\n\r\n\x05\
    \x04E\x02\n\x06\x12\x04\xda\x08\r\x14\n\r\n\x05\x04E\x02\n\x01\x12\x04\
    \xda\x08\x15\"\n\r\n\x05\x04E\x02\n\x03\x12\x04\xda\x08%'\n\x0c\n\x04\
    \x04E\x02\x0b\x12\x04\xdb\x08\x04$\n\r\n\x05\x04E\x02\x0b\x04\x12\x04\
    \xdb\x08\x04\x0c\n\r\n\x05\x04E\x02\x0b\x05\x12\x04\xdb\x08\r\x12\n\r\n\
    \x05\x04E\x02\x0b\x01\x12\x04\xdb\x08\x13\x1e\n\r\n\x05\x04E\x02\x0b\x03\
    \x12\x04\xdb\x08!#\n\x0c\n\x04\x04E\x02\x0c\x12\x04\xdc\x08\x04R\n\r\n\
    \x05\x04E\x02\x0c\x04\x12\x04\xdc\x08\x04\x0c\n\r\n\x05\x04E\x02\x0c\x06\
    \x12\x04\xdc\x08\r,\n\r\n\x05\x04E\x02\x0c\x01\x12\x04\xdc\x08-L\n\r\n\
    \x05\x04E\x02\x0c\x03\x12\x04\xdc\x08OQ\n\x0c\n\x04\x04E\x02\r\x12\x04\
    \xdd\x08\x04b\n\r\n\x05\x04E\x02\r\x04\x12\x04\xdd\x08\x04\x0c\n\r\n\x05\
    \x04E\x02\r\x06\x12\x04\xdd\x08\r4\n\r\n\x05\x04E\x02\r\x01\x12\x04\xdd\
    \x085\\\n\r\n\x05\x04E\x02\r\x03\x12\x04\xdd\x08_a\n\x0c\n\x02\x04F\x12\
    \x06\xe0\x08\0\xfb\x08\x01\n\x0b\n\x03\x04F\x01\x12\x04\xe0\x08\x08\x16\
    \n\x0e\n\x04\x04F\x03\0\x12\x06\xe1\x08\x04\xed\x08\x05\n\r\n\x05\x04F\
    \x03\0\x01\x12\x04\xe1\x08\x0c\x1b\n\x0e\n\x06\x04F\x03\0\x02\0\x12\x04\
    \xe2\x08\x08/\n\x0f\n\x07\x04F\x03\0\x02\0\x04\x12\x04\xe2\x08\x08\x10\n\
    \x0f\n\x07\x04F\x03\0\x02\0\x06\x12\x04\xe2\x08\x11\x1d\n\x0f\n\x07\x04F\
    \x03\0\x02\0\x01\x12\x04\xe2\x08\x1e*\n\x0f\n\x07\x04F\x03\0\x02\0\x03\
    \x12\x04\xe2\x08-.\n\x0e\n\x06\x04F\x03\0\x02\x01\x12\x04\xe3\x08\x08&\n\
    \x0f\n\x07\x04F\x03\0\x02\x01\x04\x12\x04\xe3\x08\x08\x10\n\x0f\n\x07\
    \x04F\x03\0\x02\x01\x05\x12\x04\xe3\x08\x11\x17\n\x0f\n\x07\x04F\x03\0\
    \x02\x01\x01\x12\x04\xe3\x08\x18!\n\x0f\n\x07\x04F\x03\0\x02\x01\x03\x12\
    \x04\xe3\x08$%\n\x0e\n\x06\x04F\x03\0\x02\x02\x12\x04\xe4\x08\x08\"\n\
    \x0f\n\x07\x04F\x03\0\x02\x02\x04\x12\x04\xe4\x08\x08\x10\n\x0f\n\x07\
    \x04F\x03\0\x02\x02\x05\x12\x04\xe4\x08\x11\x17\n\x0f\n\x07\x04F\x03\0\
    \x02\x02\x01\x12\x04\xe4\x08\x18\x1d\n\x0f\n\x07\x04F\x03\0\x02\x02\x03\
    \x12\x04\xe4\x08\x20!\n\x0e\n\x06\x04F\x03\0\x02\x03\x12\x04\xe5\x08\x08\
    (\n\x0f\n\x07\x04F\x03\0\x02\x03\x04\x12\x04\xe5\x08\x08\x10\n\x0f\n\x07\
    \x04F\x03\0\x02\x03\x05\x12\x04\xe5\x08\x11\x17\n\x0f\n\x07\x04F\x03\0\
    \x02\x03\x01\x12\x04\xe5\x08\x18#\n\x0f\n\x07\x04F\x03\0\x02\x03\x03\x12\
    \x04\xe5\x08&'\n\x0e\n\x06\x04F\x03\0\x02\x04\x12\x04\xe6\x08\x08)\n\x0f\
    \n\x07\x04F\x03\0\x02\x04\x04\x12\x04\xe6\x08\x08\x10\n\x0f\n\x07\x04F\
    \x03\0\x02\x04\x05\x12\x04\xe6\x08\x11\x17\n\x0f\n\x07\x04F\x03\0\x02\
    \x04\x01\x12\x04\xe6\x08\x18$\n\x0f\n\x07\x04F\x03\0\x02\x04\x03\x12\x04\
    \xe6\x08'(\n\x0e\n\x06\x04F\x03\0\x02\x05\x12\x04\xe7\x08\x08+\n\x0f\n\
    \x07\x04F\x03\0\x02\x05\x04\x12\x04\xe7\x08\x08\x10\n\x0f\n\x07\x04F\x03\
    \0\x02\x05\x05\x12\x04\xe7\x08\x11\x16\n\x0f\n\x07\x04F\x03\0\x02\x05\
    \x01\x12\x04\xe7\x08\x17&\n\x0f\n\x07\x04F\x03\0\x02\x05\x03\x12\x04\xe7\
    \x08)*\n\x0e\n\x06\x04F\x03\0\x02\x06\x12\x04\xe8\x08\x08'\n\x0f\n\x07\
    \x04F\x03\0\x02\x06\x04\x12\x04\xe8\x08\x08\x10\n\x0f\n\x07\x04F\x03\0\
    \x02\x06\x05\x12\x04\xe8\x08\x11\x17\n\x0f\n\x07\x04F\x03\0\x02\x06\x01\
    \x12\x04\xe8\x08\x18\"\n\x0f\n\x07\x04F\x03\0\x02\x06\x03\x12\x04\xe8\
    \x08%&\n\x0e\n\x06\x04F\x03\0\x02\x07\x12\x04\xe9\x08\x08\x20\n\x0f\n\
    \x07\x04F\x03\0\x02\x07\x04\x12\x04\xe9\x08\x08\x10\n\x0f\n\x07\x04F\x03\
    \0\x02\x07\x05\x12\x04\xe9\x08\x11\x17\n\x0f\n\x07\x04F\x03\0\x02\x07\
    \x01\x12\x04\xe9\x08\x18\x1b\n\x0f\n\x07\x04F\x03\0\x02\x07\x03\x12\x04\
    \xe9\x08\x1e\x1f\n\x0e\n\x06\x04F\x03\0\x02\x08\x12\x04\xea\x08\x08.\n\
    \x0f\n\x07\x04F\x03\0\x02\x08\x04\x12\x04\xea\x08\x08\x10\n\x0f\n\x07\
    \x04F\x03\0\x02\x08\x05\x12\x04\xea\x08\x11\x17\n\x0f\n\x07\x04F\x03\0\
    \x02\x08\x01\x12\x04\xea\x08\x18)\n\x0f\n\x07\x04F\x03\0\x02\x08\x03\x12\
    \x04\xea\x08,-\n\x0e\n\x06\x04F\x03\0\x02\t\x12\x04\xeb\x08\x08*\n\x0f\n\
    \x07\x04F\x03\0\x02\t\x04\x12\x04\xeb\x08\x08\x10\n\x0f\n\x07\x04F\x03\0\
    \x02\t\x05\x12\x04\xeb\x08\x11\x17\n\x0f\n\x07\x04F\x03\0\x02\t\x01\x12\
    \x04\xeb\x08\x18$\n\x0f\n\x07\x04F\x03\0\x02\t\x03\x12\x04\xeb\x08')\n\
    \x0e\n\x06\x04F\x03\0\x02\n\x12\x04\xec\x08\x080\n\x0f\n\x07\x04F\x03\0\
    \x02\n\x04\x12\x04\xec\x08\x08\x10\n\x0f\n\x07\x04F\x03\0\x02\n\x05\x12\
    \x04\xec\x08\x11\x16\n\x0f\n\x07\x04F\x03\0\x02\n\x01\x12\x04\xec\x08\
    \x17*\n\x0f\n\x07\x04F\x03\0\x02\n\x03\x12\x04\xec\x08-/\n\x0e\n\x04\x04\
    F\x03\x01\x12\x06\xef\x08\x04\xf3\x08\x05\n\r\n\x05\x04F\x03\x01\x01\x12\
    \x04\xef\x08\x0c\x1b\n\x0e\n\x06\x04F\x03\x01\x02\0\x12\x04\xf0\x08\x08/\
    \n\x0f\n\x07\x04F\x03\x01\x02\0\x04\x12\x04\xf0\x08\x08\x10\n\x0f\n\x07\
    \x04F\x03\x01\x02\0\x06\x12\x04\xf0\x08\x11\x1d\n\x0f\n\x07\x04F\x03\x01\
    \x02\0\x01\x12\x04\xf0\x08\x1e*\n\x0f\n\x07\x04F\x03\x01\x02\0\x03\x12\
    \x04\xf0\x08-.\n\x0e\n\x06\x04F\x03\x01\x02\x01\x12\x04\xf1\x08\x08\"\n\
    \x0f\n\x07\x04F\x03\x01\x02\x01\x04\x12\x04\xf1\x08\x08\x10\n\x0f\n\x07\
    \x04F\x03\x01\x02\x01\x05\x12\x04\xf1\x08\x11\x17\n\x0f\n\x07\x04F\x03\
    \x01\x02\x01\x01\x12\x04\xf1\x08\x18\x1d\n\x0f\n\x07\x04F\x03\x01\x02\
    \x01\x03\x12\x04\xf1\x08\x20!\n\x0e\n\x06\x04F\x03\x01\x02\x02\x12\x04\
    \xf2\x08\x08(\n\x0f\n\x07\x04F\x03\x01\x02\x02\x04\x12\x04\xf2\x08\x08\
    \x10\n\x0f\n\x07\x04F\x03\x01\x02\x02\x05\x12\x04\xf2\x08\x11\x17\n\x0f\
    \n\x07\x04F\x03\x01\x02\x02\x01\x12\x04\xf2\x08\x18#\n\x0f\n\x07\x04F\
    \x03\x01\x02\x02\x03\x12\x04\xf2\x08&'\n\x0c\n\x04\x04F\x02\0\x12\x04\
    \xf5\x08\x04)\n\r\n\x05\x04F\x02\0\x04\x12\x04\xf5\x08\x04\x0c\n\r\n\x05\
    \x04F\x02\0\x06\x12\x04\xf5\x08\r\x1c\n\r\n\x05\x04F\x02\0\x01\x12\x04\
    \xf5\x08\x1d$\n\r\n\x05\x04F\x02\0\x03\x12\x04\xf5\x08'(\n\x0c\n\x04\x04\
    F\x02\x01\x12\x04\xf6\x08\x04)\n\r\n\x05\x04F\x02\x01\x04\x12\x04\xf6\
    \x08\x04\x0c\n\r\n\x05\x04F\x02\x01\x05\x12\x04\xf6\x08\r\x13\n\r\n\x05\
    \x04F\x02\x01\x01\x12\x04\xf6\x08\x14$\n\r\n\x05\x04F\x02\x01\x03\x12\
    \x04\xf6\x08'(\n\x0c\n\x04\x04F\x02\x02\x12\x04\xf7\x08\x04)\n\r\n\x05\
    \x04F\x02\x02\x04\x12\x04\xf7\x08\x04\x0c\n\r\n\x05\x04F\x02\x02\x06\x12\
    \x04\xf7\x08\r\x1c\n\r\n\x05\x04F\x02\x02\x01\x12\x04\xf7\x08\x1d$\n\r\n\
    \x05\x04F\x02\x02\x03\x12\x04\xf7\x08'(\n\x0c\n\x04\x04F\x02\x03\x12\x04\
    \xf8\x08\x04\x1d\n\r\n\x05\x04F\x02\x03\x04\x12\x04\xf8\x08\x04\x0c\n\r\
    \n\x05\x04F\x02\x03\x05\x12\x04\xf8\x08\r\x13\n\r\n\x05\x04F\x02\x03\x01\
    \x12\x04\xf8\x08\x14\x18\n\r\n\x05\x04F\x02\x03\x03\x12\x04\xf8\x08\x1b\
    \x1c\n\x0c\n\x04\x04F\x02\x04\x12\x04\xf9\x08\x04\x1f\n\r\n\x05\x04F\x02\
    \x04\x04\x12\x04\xf9\x08\x04\x0c\n\r\n\x05\x04F\x02\x04\x05\x12\x04\xf9\
    \x08\r\x13\n\r\n\x05\x04F\x02\x04\x01\x12\x04\xf9\x08\x14\x1a\n\r\n\x05\
    \x04F\x02\x04\x03\x12\x04\xf9\x08\x1d\x1e\n\x0c\n\x04\x04F\x02\x05\x12\
    \x04\xfa\x08\x04*\n\r\n\x05\x04F\x02\x05\x04\x12\x04\xfa\x08\x04\x0c\n\r\
    \n\x05\x04F\x02\x05\x06\x12\x04\xfa\x08\r\x18\n\r\n\x05\x04F\x02\x05\x01\
    \x12\x04\xfa\x08\x19$\n\r\n\x05\x04F\x02\x05\x03\x12\x04\xfa\x08')\n\x0c\
    \n\x02\x04G\x12\x06\xfd\x08\0\xff\x08\x01\n\x0b\n\x03\x04G\x01\x12\x04\
    \xfd\x08\x08\x17\n\x0c\n\x04\x04G\x02\0\x12\x04\xfe\x08\x04'\n\r\n\x05\
    \x04G\x02\0\x04\x12\x04\xfe\x08\x04\x0c\n\r\n\x05\x04G\x02\0\x05\x12\x04\
    \xfe\x08\r\x12\n\r\n\x05\x04G\x02\0\x01\x12\x04\xfe\x08\x13\"\n\r\n\x05\
    \x04G\x02\0\x03\x12\x04\xfe\x08%&\n\x0c\n\x02\x04H\x12\x06\x81\t\0\x86\t\
    \x01\n\x0b\n\x03\x04H\x01\x12\x04\x81\t\x08\x19\n\x0c\n\x04\x04H\x02\0\
    \x12\x04\x82\t\x043\n\r\n\x05\x04H\x02\0\x04\x12\x04\x82\t\x04\x0c\n\r\n\
    \x05\x04H\x02\0\x06\x12\x04\x82\t\r\x17\n\r\n\x05\x04H\x02\0\x01\x12\x04\
    \x82\t\x18.\n\r\n\x05\x04H\x02\0\x03\x12\x04\x82\t12\n\x0c\n\x04\x04H\
    \x02\x01\x12\x04\x83\t\x04#\n\r\n\x05\x04H\x02\x01\x04\x12\x04\x83\t\x04\
    \x0c\n\r\n\x05\x04H\x02\x01\x06\x12\x04\x83\t\r\x19\n\r\n\x05\x04H\x02\
    \x01\x01\x12\x04\x83\t\x1a\x1e\n\r\n\x05\x04H\x02\x01\x03\x12\x04\x83\t!\
    \"\n\x0c\n\x04\x04H\x02\x02\x12\x04\x84\t\x044\n\r\n\x05\x04H\x02\x02\
    \x04\x12\x04\x84\t\x04\x0c\n\r\n\x05\x04H\x02\x02\x06\x12\x04\x84\t\r&\n\
    \r\n\x05\x04H\x02\x02\x01\x12\x04\x84\t'/\n\r\n\x05\x04H\x02\x02\x03\x12\
    \x04\x84\t23\n\x0c\n\x04\x04H\x02\x03\x12\x04\x85\t\x04)\n\r\n\x05\x04H\
    \x02\x03\x04\x12\x04\x85\t\x04\x0c\n\r\n\x05\x04H\x02\x03\x05\x12\x04\
    \x85\t\r\x12\n\r\n\x05\x04H\x02\x03\x01\x12\x04\x85\t\x13$\n\r\n\x05\x04\
    H\x02\x03\x03\x12\x04\x85\t'(\n\x0c\n\x02\x04I\x12\x06\x88\t\0\x89\t\x01\
    \n\x0b\n\x03\x04I\x01\x12\x04\x88\t\x08!\n\x0c\n\x02\x04J\x12\x06\x8b\t\
    \0\x8e\t\x01\n\x0b\n\x03\x04J\x01\x12\x04\x8b\t\x08\x14\n\x0c\n\x04\x04J\
    \x02\0\x12\x04\x8c\t\x04\"\n\r\n\x05\x04J\x02\0\x04\x12\x04\x8c\t\x04\
    \x0c\n\r\n\x05\x04J\x02\0\x05\x12\x04\x8c\t\r\x12\n\r\n\x05\x04J\x02\0\
    \x01\x12\x04\x8c\t\x13\x1d\n\r\n\x05\x04J\x02\0\x03\x12\x04\x8c\t\x20!\n\
    \x0c\n\x04\x04J\x02\x01\x12\x04\x8d\t\x04\x1d\n\r\n\x05\x04J\x02\x01\x04\
    \x12\x04\x8d\t\x04\x0c\n\r\n\x05\x04J\x02\x01\x05\x12\x04\x8d\t\r\x12\n\
    \r\n\x05\x04J\x02\x01\x01\x12\x04\x8d\t\x13\x18\n\r\n\x05\x04J\x02\x01\
    \x03\x12\x04\x8d\t\x1b\x1c\n\x0c\n\x02\x04K\x12\x06\x90\t\0\x9a\t\x01\n\
    \x0b\n\x03\x04K\x01\x12\x04\x90\t\x08\x1b\n\x0e\n\x04\x04K\x03\0\x12\x06\
    \x91\t\x04\x93\t\x05\n\r\n\x05\x04K\x03\0\x01\x12\x04\x91\t\x0c\x12\n\
    \x0e\n\x06\x04K\x03\0\x02\0\x12\x04\x92\t\x08'\n\x0f\n\x07\x04K\x03\0\
    \x02\0\x04\x12\x04\x92\t\x08\x10\n\x0f\n\x07\x04K\x03\0\x02\0\x05\x12\
    \x04\x92\t\x11\x17\n\x0f\n\x07\x04K\x03\0\x02\0\x01\x12\x04\x92\t\x18\"\
    \n\x0f\n\x07\x04K\x03\0\x02\0\x03\x12\x04\x92\t%&\n\x0c\n\x04\x04K\x02\0\
    \x12\x04\x95\t\x04\x1e\n\r\n\x05\x04K\x02\0\x04\x12\x04\x95\t\x04\x0c\n\
    \r\n\x05\x04K\x02\0\x05\x12\x04\x95\t\r\x12\n\r\n\x05\x04K\x02\0\x01\x12\
    \x04\x95\t\x13\x19\n\r\n\x05\x04K\x02\0\x03\x12\x04\x95\t\x1c\x1d\n\x0c\
    \n\x04\x04K\x02\x01\x12\x04\x96\t\x04\x1d\n\r\n\x05\x04K\x02\x01\x04\x12\
    \x04\x96\t\x04\x0c\n\r\n\x05\x04K\x02\x01\x05\x12\x04\x96\t\r\x13\n\r\n\
    \x05\x04K\x02\x01\x01\x12\x04\x96\t\x14\x18\n\r\n\x05\x04K\x02\x01\x03\
    \x12\x04\x96\t\x1b\x1c\n\x0c\n\x04\x04K\x02\x02\x12\x04\x97\t\x04\x20\n\
    \r\n\x05\x04K\x02\x02\x04\x12\x04\x97\t\x04\x0c\n\r\n\x05\x04K\x02\x02\
    \x06\x12\x04\x97\t\r\x13\n\r\n\x05\x04K\x02\x02\x01\x12\x04\x97\t\x14\
    \x1b\n\r\n\x05\x04K\x02\x02\x03\x12\x04\x97\t\x1e\x1f\n\x0c\n\x04\x04K\
    \x02\x03\x12\x04\x98\t\x04/\n\r\n\x05\x04K\x02\x03\x04\x12\x04\x98\t\x04\
    \x0c\n\r\n\x05\x04K\x02\x03\x05\x12\x04\x98\t\r\x13\n\r\n\x05\x04K\x02\
    \x03\x01\x12\x04\x98\t\x14*\n\r\n\x05\x04K\x02\x03\x03\x12\x04\x98\t-.\n\
    \x0c\n\x04\x04K\x02\x04\x12\x04\x99\t\x04)\n\r\n\x05\x04K\x02\x04\x04\
    \x12\x04\x99\t\x04\x0c\n\r\n\x05\x04K\x02\x04\x06\x12\x04\x99\t\r\x18\n\
    \r\n\x05\x04K\x02\x04\x01\x12\x04\x99\t\x19$\n\r\n\x05\x04K\x02\x04\x03\
    \x12\x04\x99\t'(\n\x0c\n\x02\x04L\x12\x06\x9c\t\0\xa5\t\x01\n\x0b\n\x03\
    \x04L\x01\x12\x04\x9c\t\x08\x12\n\x0e\n\x04\x04L\x04\0\x12\x06\x9d\t\x04\
    \xa1\t\x05\n\r\n\x05\x04L\x04\0\x01\x12\x04\x9d\t\t\x17\n\x0e\n\x06\x04L\
    \x04\0\x02\0\x12\x04\x9e\t\x08%\n\x0f\n\x07\x04L\x04\0\x02\0\x01\x12\x04\
    \x9e\t\x08\x20\n\x0f\n\x07\x04L\x04\0\x02\0\x02\x12\x04\x9e\t#$\n\x0e\n\
    \x06\x04L\x04\0\x02\x01\x12\x04\x9f\t\x08\x18\n\x0f\n\x07\x04L\x04\0\x02\
    \x01\x01\x12\x04\x9f\t\x08\x13\n\x0f\n\x07\x04L\x04\0\x02\x01\x02\x12\
    \x04\x9f\t\x16\x17\n\x0e\n\x06\x04L\x04\0\x02\x02\x12\x04\xa0\t\x08\x1a\
    \n\x0f\n\x07\x04L\x04\0\x02\x02\x01\x12\x04\xa0\t\x08\x15\n\x0f\n\x07\
    \x04L\x04\0\x02\x02\x02\x12\x04\xa0\t\x18\x19\n\x0c\n\x04\x04L\x02\0\x12\
    \x04\xa2\t\x04\x20\n\r\n\x05\x04L\x02\0\x04\x12\x04\xa2\t\x04\x0c\n\r\n\
    \x05\x04L\x02\0\x06\x12\x04\xa2\t\r\x17\n\r\n\x05\x04L\x02\0\x01\x12\x04\
    \xa2\t\x18\x1b\n\r\n\x05\x04L\x02\0\x03\x12\x04\xa2\t\x1e\x1f\n\x0c\n\
    \x04\x04L\x02\x01\x12\x04\xa3\t\x04/\n\r\n\x05\x04L\x02\x01\x04\x12\x04\
    \xa3\t\x04\x0c\n\r\n\x05\x04L\x02\x01\x06\x12\x04\xa3\t\r\x1b\n\r\n\x05\
    \x04L\x02\x01\x01\x12\x04\xa3\t\x1c*\n\r\n\x05\x04L\x02\x01\x03\x12\x04\
    \xa3\t-.\n\x0c\n\x04\x04L\x02\x02\x12\x04\xa4\t\x04)\n\r\n\x05\x04L\x02\
    \x02\x04\x12\x04\xa4\t\x04\x0c\n\r\n\x05\x04L\x02\x02\x05\x12\x04\xa4\t\
    \r\x12\n\r\n\x05\x04L\x02\x02\x01\x12\x04\xa4\t\x13$\n\r\n\x05\x04L\x02\
    \x02\x03\x12\x04\xa4\t'(\n\x0c\n\x02\x05\x01\x12\x06\xa7\t\0\xab\t\x01\n\
    \x0b\n\x03\x05\x01\x01\x12\x04\xa7\t\x05!\n\x0c\n\x04\x05\x01\x02\0\x12\
    \x04\xa8\t\x04\x17\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xa8\t\x04\x12\n\r\
    \n\x05\x05\x01\x02\0\x02\x12\x04\xa8\t\x15\x16\n\x0c\n\x04\x05\x01\x02\
    \x01\x12\x04\xa9\t\x04&\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xa9\t\x04!\
    \n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xa9\t$%\n\x0c\n\x04\x05\x01\x02\
    \x02\x12\x04\xaa\t\x04\x1e\n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\xaa\t\
    \x04\x19\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\xaa\t\x1c\x1d\n\x0c\n\x02\
    \x04M\x12\x06\xac\t\0\xc0\t\x01\n\x0b\n\x03\x04M\x01\x12\x04\xac\t\x08/\
    \n\x0e\n\x04\x04M\x03\0\x12\x06\xad\t\x04\xbb\t\x05\n\r\n\x05\x04M\x03\0\
    \x01\x12\x04\xad\t\x0c#\n\x10\n\x06\x04M\x03\0\x03\0\x12\x06\xae\t\x08\
    \xb6\t\t\n\x0f\n\x07\x04M\x03\0\x03\0\x01\x12\x04\xae\t\x10#\n\x10\n\x08\
    \x04M\x03\0\x03\0\x02\0\x12\x04\xaf\t\x0c$\n\x11\n\t\x04M\x03\0\x03\0\
    \x02\0\x04\x12\x04\xaf\t\x0c\x14\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x05\
    \x12\x04\xaf\t\x15\x1b\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x01\x12\x04\xaf\
    \t\x1c\x1f\n\x11\n\t\x04M\x03\0\x03\0\x02\0\x03\x12\x04\xaf\t\"#\n\x10\n\
    \x08\x04M\x03\0\x03\0\x02\x01\x12\x04\xb0\t\x0c&\n\x11\n\t\x04M\x03\0\
    \x03\0\x02\x01\x04\x12\x04\xb0\t\x0c\x14\n\x11\n\t\x04M\x03\0\x03\0\x02\
    \x01\x05\x12\x04\xb0\t\x15\x1b\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x01\
    \x12\x04\xb0\t\x1c!\n\x11\n\t\x04M\x03\0\x03\0\x02\x01\x03\x12\x04\xb0\t\
    $%\n\x10\n\x08\x04M\x03\0\x03\0\x02\x02\x12\x04\xb1\t\x0c,\n\x11\n\t\x04\
    M\x03\0\x03\0\x02\x02\x04\x12\x04\xb1\t\x0c\x14\n\x11\n\t\x04M\x03\0\x03\
    \0\x02\x02\x05\x12\x04\xb1\t\x15\x1b\n\x11\n\t\x04M\x03\0\x03\0\x02\x02\
    \x01\x12\x04\xb1\t\x1c'\n\x11\n\t\x04M\x03\0\x03\0\x02\x02\x03\x12\x04\
    \xb1\t*+\n\x10\n\x08\x04M\x03\0\x03\0\x02\x03\x12\x04\xb2\t\x0c)\n\x11\n\
    \t\x04M\x03\0\x03\0\x02\x03\x04\x12\x04\xb2\t\x0c\x14\n\x11\n\t\x04M\x03\
    \0\x03\0\x02\x03\x05\x12\x04\xb2\t\x15\x1a\n\x11\n\t\x04M\x03\0\x03\0\
    \x02\x03\x01\x12\x04\xb2\t\x1b$\n\x11\n\t\x04M\x03\0\x03\0\x02\x03\x03\
    \x12\x04\xb2\t'(\n\x10\n\x08\x04M\x03\0\x03\0\x02\x04\x12\x04\xb3\t\x0c-\
    \n\x11\n\t\x04M\x03\0\x03\0\x02\x04\x04\x12\x04\xb3\t\x0c\x14\n\x11\n\t\
    \x04M\x03\0\x03\0\x02\x04\x05\x12\x04\xb3\t\x15\x1b\n\x11\n\t\x04M\x03\0\
    \x03\0\x02\x04\x01\x12\x04\xb3\t\x1c(\n\x11\n\t\x04M\x03\0\x03\0\x02\x04\
    \x03\x12\x04\xb3\t+,\n\x10\n\x08\x04M\x03\0\x03\0\x02\x05\x12\x04\xb4\t\
    \x0c*\n\x11\n\t\x04M\x03\0\x03\0\x02\x05\x04\x12\x04\xb4\t\x0c\x14\n\x11\
    \n\t\x04M\x03\0\x03\0\x02\x05\x05\x12\x04\xb4\t\x15\x1b\n\x11\n\t\x04M\
    \x03\0\x03\0\x02\x05\x01\x12\x04\xb4\t\x1c%\n\x11\n\t\x04M\x03\0\x03\0\
    \x02\x05\x03\x12\x04\xb4\t()\n\x10\n\x08\x04M\x03\0\x03\0\x02\x06\x12\
    \x04\xb5\t\x0c,\n\x11\n\t\x04M\x03\0\x03\0\x02\x06\x04\x12\x04\xb5\t\x0c\
    \x14\n\x11\n\t\x04M\x03\0\x03\0\x02\x06\x05\x12\x04\xb5\t\x15\x1b\n\x11\
    \n\t\x04M\x03\0\x03\0\x02\x06\x01\x12\x04\xb5\t\x1c'\n\x11\n\t\x04M\x03\
    \0\x03\0\x02\x06\x03\x12\x04\xb5\t*+\n\x0e\n\x06\x04M\x03\0\x02\0\x12\
    \x04\xb8\t\x08I\n\x0f\n\x07\x04M\x03\0\x02\0\x04\x12\x04\xb8\t\x08\x10\n\
    \x0f\n\x07\x04M\x03\0\x02\0\x06\x12\x04\xb8\t\x112\n\x0f\n\x07\x04M\x03\
    \0\x02\0\x01\x12\x04\xb8\t3D\n\x0f\n\x07\x04M\x03\0\x02\0\x03\x12\x04\
    \xb8\tGH\n\x0e\n\x06\x04M\x03\0\x02\x01\x12\x04\xb9\t\x083\n\x0f\n\x07\
    \x04M\x03\0\x02\x01\x04\x12\x04\xb9\t\x08\x10\n\x0f\n\x07\x04M\x03\0\x02\
    \x01\x06\x12\x04\xb9\t\x11\x1f\n\x0f\n\x07\x04M\x03\0\x02\x01\x01\x12\
    \x04\xb9\t\x20.\n\x0f\n\x07\x04M\x03\0\x02\x01\x03\x12\x04\xb9\t12\n\x0e\
    \n\x06\x04M\x03\0\x02\x02\x12\x04\xba\t\x08=\n\x0f\n\x07\x04M\x03\0\x02\
    \x02\x04\x12\x04\xba\t\x08\x10\n\x0f\n\x07\x04M\x03\0\x02\x02\x06\x12\
    \x04\xba\t\x11$\n\x0f\n\x07\x04M\x03\0\x02\x02\x01\x12\x04\xba\t%8\n\x0f\
    \n\x07\x04M\x03\0\x02\x02\x03\x12\x04\xba\t;<\n\x0c\n\x04\x04M\x02\0\x12\
    \x04\xbd\t\x04K\n\r\n\x05\x04M\x02\0\x04\x12\x04\xbd\t\x04\x0c\n\r\n\x05\
    \x04M\x02\0\x06\x12\x04\xbd\t\r)\n\r\n\x05\x04M\x02\0\x01\x12\x04\xbd\t*\
    F\n\r\n\x05\x04M\x02\0\x03\x12\x04\xbd\tIJ\n\x0c\n\x04\x04M\x02\x01\x12\
    \x04\xbe\t\x04!\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xbe\t\x04\x0c\n\r\n\
    \x05\x04M\x02\x01\x05\x12\x04\xbe\t\r\x13\n\r\n\x05\x04M\x02\x01\x01\x12\
    \x04\xbe\t\x14\x1c\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xbe\t\x1f\x20\n\
    \x0c\n\x04\x04M\x02\x02\x12\x04\xbf\t\x04A\n\r\n\x05\x04M\x02\x02\x04\
    \x12\x04\xbf\t\x04\x0c\n\r\n\x05\x04M\x02\x02\x06\x12\x04\xbf\t\r$\n\r\n\
    \x05\x04M\x02\x02\x01\x12\x04\xbf\t%<\n\r\n\x05\x04M\x02\x02\x03\x12\x04\
    \xbf\t?@\n\x0c\n\x02\x04N\x12\x06\xc2\t\0\xc5\t\x01\n\x0b\n\x03\x04N\x01\
    \x12\x04\xc2\t\x08\x18\n\x0c\n\x04\x04N\x02\0\x12\x04\xc3\t\x04#\n\r\n\
    \x05\x04N\x02\0\x04\x12\x04\xc3\t\x04\x0c\n\r\n\x05\x04N\x02\0\x05\x12\
    \x04\xc3\t\r\x15\n\r\n\x05\x04N\x02\0\x01\x12\x04\xc3\t\x16\x1e\n\r\n\
    \x05\x04N\x02\0\x03\x12\x04\xc3\t!\"\n\x0c\n\x04\x04N\x02\x01\x12\x04\
    \xc4\t\x04$\n\r\n\x05\x04N\x02\x01\x04\x12\x04\xc4\t\x04\x0c\n\r\n\x05\
    \x04N\x02\x01\x05\x12\x04\xc4\t\r\x15\n\r\n\x05\x04N\x02\x01\x01\x12\x04\
    \xc4\t\x16\x1f\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xc4\t\"#\n\x0c\n\x02\
    \x04O\x12\x06\xc7\t\0\xca\t\x01\n\x0b\n\x03\x04O\x01\x12\x04\xc7\t\x08\
    \x19\n\x0c\n\x04\x04O\x02\0\x12\x04\xc8\t\x04!\n\r\n\x05\x04O\x02\0\x04\
    \x12\x04\xc8\t\x04\x0c\n\r\n\x05\x04O\x02\0\x05\x12\x04\xc8\t\r\x13\n\r\
    \n\x05\x04O\x02\0\x01\x12\x04\xc8\t\x14\x1c\n\r\n\x05\x04O\x02\0\x03\x12\
    \x04\xc8\t\x1f\x20\n\x0c\n\x04\x04O\x02\x01\x12\x04\xc9\t\x04\x20\n\r\n\
    \x05\x04O\x02\x01\x04\x12\x04\xc9\t\x04\x0c\n\r\n\x05\x04O\x02\x01\x05\
    \x12\x04\xc9\t\r\x13\n\r\n\x05\x04O\x02\x01\x01\x12\x04\xc9\t\x14\x1b\n\
    \r\n\x05\x04O\x02\x01\x03\x12\x04\xc9\t\x1e\x1f\n\x0c\n\x02\x04P\x12\x06\
    \xcc\t\0\xd8\t\x01\n\x0b\n\x03\x04P\x01\x12\x04\xcc\t\x08\x17\n\x0c\n\
    \x04\x04P\x02\0\x12\x04\xcd\t\x04\x1c\n\r\n\x05\x04P\x02\0\x04\x12\x04\
    \xcd\t\x04\x0c\n\r\n\x05\x04P\x02\0\x05\x12\x04\xcd\t\r\x13\n\r\n\x05\
    \x04P\x02\0\x01\x12\x04\xcd\t\x14\x17\n\r\n\x05\x04P\x02\0\x03\x12\x04\
    \xcd\t\x1a\x1b\n\x0c\n\x04\x04P\x02\x01\x12\x04\xce\t\x04\"\n\r\n\x05\
    \x04P\x02\x01\x04\x12\x04\xce\t\x04\x0c\n\r\n\x05\x04P\x02\x01\x05\x12\
    \x04\xce\t\r\x12\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xce\t\x13\x1d\n\r\n\
    \x05\x04P\x02\x01\x03\x12\x04\xce\t\x20!\n\x0c\n\x04\x04P\x02\x02\x12\
    \x04\xcf\t\x04%\n\r\n\x05\x04P\x02\x02\x04\x12\x04\xcf\t\x04\x0c\n\r\n\
    \x05\x04P\x02\x02\x05\x12\x04\xcf\t\r\x12\n\r\n\x05\x04P\x02\x02\x01\x12\
    \x04\xcf\t\x13\x20\n\r\n\x05\x04P\x02\x02\x03\x12\x04\xcf\t#$\n\x0c\n\
    \x04\x04P\x02\x03\x12\x04\xd0\t\x04\x20\n\r\n\x05\x04P\x02\x03\x04\x12\
    \x04\xd0\t\x04\x0c\n\r\n\x05\x04P\x02\x03\x05\x12\x04\xd0\t\r\x12\n\r\n\
    \x05\x04P\x02\x03\x01\x12\x04\xd0\t\x13\x1b\n\r\n\x05\x04P\x02\x03\x03\
    \x12\x04\xd0\t\x1e\x1f\n\x0c\n\x04\x04P\x02\x04\x12\x04\xd1\t\x04!\n\r\n\
    \x05\x04P\x02\x04\x04\x12\x04\xd1\t\x04\x0c\n\r\n\x05\x04P\x02\x04\x05\
    \x12\x04\xd1\t\r\x13\n\r\n\x05\x04P\x02\x04\x01\x12\x04\xd1\t\x14\x1c\n\
    \r\n\x05\x04P\x02\x04\x03\x12\x04\xd1\t\x1f\x20\n\x0c\n\x04\x04P\x02\x05\
    \x12\x04\xd2\t\x04\x1f\n\r\n\x05\x04P\x02\x05\x04\x12\x04\xd2\t\x04\x0c\
    \n\r\n\x05\x04P\x02\x05\x05\x12\x04\xd2\t\r\x13\n\r\n\x05\x04P\x02\x05\
    \x01\x12\x04\xd2\t\x14\x1a\n\r\n\x05\x04P\x02\x05\x03\x12\x04\xd2\t\x1d\
    \x1e\n\x0c\n\x04\x04P\x02\x06\x12\x04\xd3\t\x04\x1e\n\r\n\x05\x04P\x02\
    \x06\x04\x12\x04\xd3\t\x04\x0c\n\r\n\x05\x04P\x02\x06\x05\x12\x04\xd3\t\
    \r\x13\n\r\n\x05\x04P\x02\x06\x01\x12\x04\xd3\t\x14\x19\n\r\n\x05\x04P\
    \x02\x06\x03\x12\x04\xd3\t\x1c\x1d\n\x0c\n\x04\x04P\x02\x07\x12\x04\xd4\
    \t\x04#\n\r\n\x05\x04P\x02\x07\x04\x12\x04\xd4\t\x04\x0c\n\r\n\x05\x04P\
    \x02\x07\x05\x12\x04\xd4\t\r\x13\n\r\n\x05\x04P\x02\x07\x01\x12\x04\xd4\
    \t\x14\x1e\n\r\n\x05\x04P\x02\x07\x03\x12\x04\xd4\t!\"\n\x0c\n\x04\x04P\
    \x02\x08\x12\x04\xd5\t\x04#\n\r\n\x05\x04P\x02\x08\x04\x12\x04\xd5\t\x04\
    \x0c\n\r\n\x05\x04P\x02\x08\x05\x12\x04\xd5\t\r\x13\n\r\n\x05\x04P\x02\
    \x08\x01\x12\x04\xd5\t\x14\x1e\n\r\n\x05\x04P\x02\x08\x03\x12\x04\xd5\t!\
    \"\n\x0c\n\x04\x04P\x02\t\x12\x04\xd6\t\x04\x1f\n\r\n\x05\x04P\x02\t\x04\
    \x12\x04\xd6\t\x04\x0c\n\r\n\x05\x04P\x02\t\x05\x12\x04\xd6\t\r\x12\n\r\
    \n\x05\x04P\x02\t\x01\x12\x04\xd6\t\x13\x19\n\r\n\x05\x04P\x02\t\x03\x12\
    \x04\xd6\t\x1c\x1e\n\x0c\n\x04\x04P\x02\n\x12\x04\xd7\t\x04*\n\r\n\x05\
    \x04P\x02\n\x04\x12\x04\xd7\t\x04\x0c\n\r\n\x05\x04P\x02\n\x05\x12\x04\
    \xd7\t\r\x12\n\r\n\x05\x04P\x02\n\x01\x12\x04\xd7\t\x13$\n\r\n\x05\x04P\
    \x02\n\x03\x12\x04\xd7\t')\n\x0c\n\x02\x04Q\x12\x06\xda\t\0\xdd\t\x01\n\
    \x0b\n\x03\x04Q\x01\x12\x04\xda\t\x08\x10\n\x0c\n\x04\x04Q\x02\0\x12\x04\
    \xdb\t\x04\x1b\n\r\n\x05\x04Q\x02\0\x04\x12\x04\xdb\t\x04\x0c\n\r\n\x05\
    \x04Q\x02\0\x05\x12\x04\xdb\t\r\x13\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xdb\
    \t\x14\x16\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xdb\t\x19\x1a\n\x0c\n\x04\
    \x04Q\x02\x01\x12\x04\xdc\t\x04!\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xdc\
    \t\x04\x0c\n\r\n\x05\x04Q\x02\x01\x05\x12\x04\xdc\t\r\x13\n\r\n\x05\x04Q\
    \x02\x01\x01\x12\x04\xdc\t\x14\x1c\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\
    \xdc\t\x1f\x20\n\x0c\n\x02\x04R\x12\x06\xdf\t\0\xe2\t\x01\n\x0b\n\x03\
    \x04R\x01\x12\x04\xdf\t\x08\x18\n\x0c\n\x04\x04R\x02\0\x12\x04\xe0\t\x04\
    !\n\r\n\x05\x04R\x02\0\x04\x12\x04\xe0\t\x04\x0c\n\r\n\x05\x04R\x02\0\
    \x05\x12\x04\xe0\t\r\x13\n\r\n\x05\x04R\x02\0\x01\x12\x04\xe0\t\x14\x1c\
    \n\r\n\x05\x04R\x02\0\x03\x12\x04\xe0\t\x1f\x20\n\x0c\n\x04\x04R\x02\x01\
    \x12\x04\xe1\t\x042\n\r\n\x05\x04R\x02\x01\x04\x12\x04\xe1\t\x04\x0c\n\r\
    \n\x05\x04R\x02\x01\x06\x12\x04\xe1\t\r\x1c\n\r\n\x05\x04R\x02\x01\x01\
    \x12\x04\xe1\t\x1d-\n\r\n\x05\x04R\x02\x01\x03\x12\x04\xe1\t01\n\x0c\n\
    \x02\x04S\x12\x06\xe4\t\0\xec\t\x01\n\x0b\n\x03\x04S\x01\x12\x04\xe4\t\
    \x08\x17\n\x0e\n\x04\x04S\x04\0\x12\x06\xe5\t\x04\xe8\t\x05\n\r\n\x05\
    \x04S\x04\0\x01\x12\x04\xe5\t\t\x14\n\x0e\n\x06\x04S\x04\0\x02\0\x12\x04\
    \xe6\t\x08\x11\n\x0f\n\x07\x04S\x04\0\x02\0\x01\x12\x04\xe6\t\x08\x0c\n\
    \x0f\n\x07\x04S\x04\0\x02\0\x02\x12\x04\xe6\t\x0f\x10\n\x0e\n\x06\x04S\
    \x04\0\x02\x01\x12\x04\xe7\t\x08\x14\n\x0f\n\x07\x04S\x04\0\x02\x01\x01\
    \x12\x04\xe7\t\x08\x0f\n\x0f\n\x07\x04S\x04\0\x02\x01\x02\x12\x04\xe7\t\
    \x12\x13\n\x0c\n\x04\x04S\x02\0\x12\x04\xe9\t\x04\x20\n\r\n\x05\x04S\x02\
    \0\x04\x12\x04\xe9\t\x04\x0c\n\r\n\x05\x04S\x02\0\x05\x12\x04\xe9\t\r\
    \x13\n\r\n\x05\x04S\x02\0\x01\x12\x04\xe9\t\x14\x1b\n\r\n\x05\x04S\x02\0\
    \x03\x12\x04\xe9\t\x1e\x1f\n\x0c\n\x04\x04S\x02\x01\x12\x04\xea\t\x04)\n\
    \r\n\x05\x04S\x02\x01\x04\x12\x04\xea\t\x04\x0c\n\r\n\x05\x04S\x02\x01\
    \x06\x12\x04\xea\t\r\x18\n\r\n\x05\x04S\x02\x01\x01\x12\x04\xea\t\x19$\n\
    \r\n\x05\x04S\x02\x01\x03\x12\x04\xea\t'(\n\x0c\n\x04\x04S\x02\x02\x12\
    \x04\xeb\t\x04\x20\n\r\n\x05\x04S\x02\x02\x04\x12\x04\xeb\t\x04\x0c\n\r\
    \n\x05\x04S\x02\x02\x05\x12\x04\xeb\t\r\x13\n\r\n\x05\x04S\x02\x02\x01\
    \x12\x04\xeb\t\x14\x1b\n\r\n\x05\x04S\x02\x02\x03\x12\x04\xeb\t\x1e\x1f\
    \n\x0c\n\x02\x05\x02\x12\x06\xee\t\0\xf2\t\x01\n\x0b\n\x03\x05\x02\x01\
    \x12\x04\xee\t\x05\x14\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xef\t\x04\x10\n\
    \r\n\x05\x05\x02\x02\0\x01\x12\x04\xef\t\x04\x0b\n\r\n\x05\x05\x02\x02\0\
    \x02\x12\x04\xef\t\x0e\x0f\n\x0c\n\x04\x05\x02\x02\x01\x12\x04\xf0\t\x04\
    \x0c\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xf0\t\x04\x07\n\r\n\x05\x05\
    \x02\x02\x01\x02\x12\x04\xf0\t\n\x0b\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\
    \xf1\t\x04\x0b\n\r\n\x05\x05\x02\x02\x02\x01\x12\x04\xf1\t\x04\x06\n\r\n\
    \x05\x05\x02\x02\x02\x02\x12\x04\xf1\t\t\n\n\x0c\n\x02\x04T\x12\x06\xf3\
    \t\0\x87\n\x01\n\x0b\n\x03\x04T\x01\x12\x04\xf3\t\x08\x13\n\x0e\n\x04\
    \x04T\x04\0\x12\x06\xf4\t\x04\xfb\t\x05\n\r\n\x05\x04T\x04\0\x01\x12\x04\
    \xf4\t\t\x18\n\x0e\n\x06\x04T\x04\0\x02\0\x12\x04\xf5\t\x08\x1e\n\x0f\n\
    \x07\x04T\x04\0\x02\0\x01\x12\x04\xf5\t\x08\x19\n\x0f\n\x07\x04T\x04\0\
    \x02\0\x02\x12\x04\xf5\t\x1c\x1d\n\x0e\n\x06\x04T\x04\0\x02\x01\x12\x04\
    \xf6\t\x08\x1e\n\x0f\n\x07\x04T\x04\0\x02\x01\x01\x12\x04\xf6\t\x08\x19\
    \n\x0f\n\x07\x04T\x04\0\x02\x01\x02\x12\x04\xf6\t\x1c\x1d\n\x0e\n\x06\
    \x04T\x04\0\x02\x02\x12\x04\xf7\t\x08\x11\n\x0f\n\x07\x04T\x04\0\x02\x02\
    \x01\x12\x04\xf7\t\x08\x0c\n\x0f\n\x07\x04T\x04\0\x02\x02\x02\x12\x04\
    \xf7\t\x0f\x10\n\x0e\n\x06\x04T\x04\0\x02\x03\x12\x04\xf8\t\x08\x13\n\
    \x0f\n\x07\x04T\x04\0\x02\x03\x01\x12\x04\xf8\t\x08\x0e\n\x0f\n\x07\x04T\
    \x04\0\x02\x03\x02\x12\x04\xf8\t\x11\x12\n\x0e\n\x06\x04T\x04\0\x02\x04\
    \x12\x04\xf9\t\x08\x16\n\x0f\n\x07\x04T\x04\0\x02\x04\x01\x12\x04\xf9\t\
    \x08\x11\n\x0f\n\x07\x04T\x04\0\x02\x04\x02\x12\x04\xf9\t\x14\x15\n\x0e\
    \n\x06\x04T\x04\0\x02\x05\x12\x04\xfa\t\x08\x1e\n\x0f\n\x07\x04T\x04\0\
    \x02\x05\x01\x12\x04\xfa\t\x08\x19\n\x0f\n\x07\x04T\x04\0\x02\x05\x02\
    \x12\x04\xfa\t\x1c\x1d\n\x0c\n\x04\x04T\x02\0\x12\x04\xfc\t\x04*\n\r\n\
    \x05\x04T\x02\0\x04\x12\x04\xfc\t\x04\x0c\n\r\n\x05\x04T\x02\0\x06\x12\
    \x04\xfc\t\r\x1c\n\r\n\x05\x04T\x02\0\x01\x12\x04\xfc\t\x1d%\n\r\n\x05\
    \x04T\x02\0\x03\x12\x04\xfc\t()\n\x0c\n\x04\x04T\x02\x01\x12\x04\xfd\t\
    \x04,\n\r\n\x05\x04T\x02\x01\x04\x12\x04\xfd\t\x04\x0c\n\r\n\x05\x04T\
    \x02\x01\x06\x12\x04\xfd\t\r\x19\n\r\n\x05\x04T\x02\x01\x01\x12\x04\xfd\
    \t\x1a'\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xfd\t*+\n\x0c\n\x04\x04T\x02\
    \x02\x12\x04\xfe\t\x041\n\r\n\x05\x04T\x02\x02\x04\x12\x04\xfe\t\x04\x0c\
    \n\r\n\x05\x04T\x02\x02\x06\x12\x04\xfe\t\r\x1b\n\r\n\x05\x04T\x02\x02\
    \x01\x12\x04\xfe\t\x1c,\n\r\n\x05\x04T\x02\x02\x03\x12\x04\xfe\t/0\n\x0c\
    \n\x04\x04T\x02\x03\x12\x04\xff\t\x04#\n\r\n\x05\x04T\x02\x03\x04\x12\
    \x04\xff\t\x04\x0c\n\r\n\x05\x04T\x02\x03\x05\x12\x04\xff\t\r\x13\n\r\n\
    \x05\x04T\x02\x03\x01\x12\x04\xff\t\x14\x1e\n\r\n\x05\x04T\x02\x03\x03\
    \x12\x04\xff\t!\"\n\x0c\n\x04\x04T\x02\x04\x12\x04\x80\n\x04!\n\r\n\x05\
    \x04T\x02\x04\x04\x12\x04\x80\n\x04\x0c\n\r\n\x05\x04T\x02\x04\x05\x12\
    \x04\x80\n\r\x13\n\r\n\x05\x04T\x02\x04\x01\x12\x04\x80\n\x14\x1c\n\r\n\
    \x05\x04T\x02\x04\x03\x12\x04\x80\n\x1f\x20\n\x0c\n\x04\x04T\x02\x05\x12\
    \x04\x81\n\x04$\n\r\n\x05\x04T\x02\x05\x04\x12\x04\x81\n\x04\x0c\n\r\n\
    \x05\x04T\x02\x05\x06\x12\x04\x81\n\r\x15\n\r\n\x05\x04T\x02\x05\x01\x12\
    \x04\x81\n\x16\x1f\n\r\n\x05\x04T\x02\x05\x03\x12\x04\x81\n\"#\n\x0c\n\
    \x04\x04T\x02\x06\x12\x04\x82\n\x04/\n\r\n\x05\x04T\x02\x06\x04\x12\x04\
    \x82\n\x04\x0c\n\r\n\x05\x04T\x02\x06\x06\x12\x04\x82\n\r\x1b\n\r\n\x05\
    \x04T\x02\x06\x01\x12\x04\x82\n\x1c*\n\r\n\x05\x04T\x02\x06\x03\x12\x04\
    \x82\n-.\n\x0c\n\x04\x04T\x02\x07\x12\x04\x83\n\x04*\n\r\n\x05\x04T\x02\
    \x07\x04\x12\x04\x83\n\x04\x0c\n\r\n\x05\x04T\x02\x07\x05\x12\x04\x83\n\
    \r\x12\n\r\n\x05\x04T\x02\x07\x01\x12\x04\x83\n\x13%\n\r\n\x05\x04T\x02\
    \x07\x03\x12\x04\x83\n()\n\x0c\n\x04\x04T\x02\x08\x12\x04\x84\n\x041\n\r\
    \n\x05\x04T\x02\x08\x04\x12\x04\x84\n\x04\x0c\n\r\n\x05\x04T\x02\x08\x05\
    \x12\x04\x84\n\r\x13\n\r\n\x05\x04T\x02\x08\x01\x12\x04\x84\n\x14+\n\r\n\
    \x05\x04T\x02\x08\x03\x12\x04\x84\n.0\n\x0c\n\x04\x04T\x02\t\x12\x04\x85\
    \n\x041\n\r\n\x05\x04T\x02\t\x04\x12\x04\x85\n\x04\x0c\n\r\n\x05\x04T\
    \x02\t\x06\x12\x04\x85\n\r\x1c\n\r\n\x05\x04T\x02\t\x01\x12\x04\x85\n\
    \x1d+\n\r\n\x05\x04T\x02\t\x03\x12\x04\x85\n.0\n\x0c\n\x04\x04T\x02\n\
    \x12\x04\x86\n\x044\n\r\n\x05\x04T\x02\n\x04\x12\x04\x86\n\x04\x0c\n\r\n\
    \x05\x04T\x02\n\x06\x12\x04\x86\n\r\x1d\n\r\n\x05\x04T\x02\n\x01\x12\x04\
    \x86\n\x1e.\n\r\n\x05\x04T\x02\n\x03\x12\x04\x86\n13\n\x0c\n\x02\x04U\
    \x12\x06\x89\n\0\x8c\n\x01\n\x0b\n\x03\x04U\x01\x12\x04\x89\n\x08\x16\n\
    \x0c\n\x04\x04U\x02\0\x12\x04\x8a\n\x04(\n\r\n\x05\x04U\x02\0\x04\x12\
    \x04\x8a\n\x04\x0c\n\r\n\x05\x04U\x02\0\x06\x12\x04\x8a\n\r\x1b\n\r\n\
    \x05\x04U\x02\0\x01\x12\x04\x8a\n\x1c#\n\r\n\x05\x04U\x02\0\x03\x12\x04\
    \x8a\n&'\n\x0c\n\x04\x04U\x02\x01\x12\x04\x8b\n\x04#\n\r\n\x05\x04U\x02\
    \x01\x04\x12\x04\x8b\n\x04\x0c\n\r\n\x05\x04U\x02\x01\x05\x12\x04\x8b\n\
    \r\x13\n\r\n\x05\x04U\x02\x01\x01\x12\x04\x8b\n\x14\x1e\n\r\n\x05\x04U\
    \x02\x01\x03\x12\x04\x8b\n!\"\n\x0c\n\x02\x04V\x12\x06\x8e\n\0\x96\n\x01\
    \n\x0b\n\x03\x04V\x01\x12\x04\x8e\n\x08\x18\n\x0e\n\x04\x04V\x04\0\x12\
    \x06\x8f\n\x04\x93\n\x05\n\r\n\x05\x04V\x04\0\x01\x12\x04\x8f\n\t\r\n\
    \x0e\n\x06\x04V\x04\0\x02\0\x12\x04\x90\n\x08\x14\n\x0f\n\x07\x04V\x04\0\
    \x02\0\x01\x12\x04\x90\n\x08\x0f\n\x0f\n\x07\x04V\x04\0\x02\0\x02\x12\
    \x04\x90\n\x12\x13\n\x0e\n\x06\x04V\x04\0\x02\x01\x12\x04\x91\n\x08\x12\
    \n\x0f\n\x07\x04V\x04\0\x02\x01\x01\x12\x04\x91\n\x08\r\n\x0f\n\x07\x04V\
    \x04\0\x02\x01\x02\x12\x04\x91\n\x10\x11\n\x0e\n\x06\x04V\x04\0\x02\x02\
    \x12\x04\x92\n\x08\x17\n\x0f\n\x07\x04V\x04\0\x02\x02\x01\x12\x04\x92\n\
    \x08\x12\n\x0f\n\x07\x04V\x04\0\x02\x02\x02\x12\x04\x92\n\x15\x16\n\x0c\
    \n\x04\x04V\x02\0\x12\x04\x94\n\x04\x20\n\r\n\x05\x04V\x02\0\x04\x12\x04\
    \x94\n\x04\x0c\n\r\n\x05\x04V\x02\0\x05\x12\x04\x94\n\r\x13\n\r\n\x05\
    \x04V\x02\0\x01\x12\x04\x94\n\x14\x1b\n\r\n\x05\x04V\x02\0\x03\x12\x04\
    \x94\n\x1e\x1f\n\x0c\n\x04\x04V\x02\x01\x12\x04\x95\n\x04\x1b\n\r\n\x05\
    \x04V\x02\x01\x04\x12\x04\x95\n\x04\x0c\n\r\n\x05\x04V\x02\x01\x06\x12\
    \x04\x95\n\r\x11\n\r\n\x05\x04V\x02\x01\x01\x12\x04\x95\n\x12\x16\n\r\n\
    \x05\x04V\x02\x01\x03\x12\x04\x95\n\x19\x1a\n\x0c\n\x02\x04W\x12\x06\x98\
    \n\0\xa4\n\x01\n\x0b\n\x03\x04W\x01\x12\x04\x98\n\x08\x16\n\x0c\n\x04\
    \x04W\x02\0\x12\x04\x99\n\x047\n\r\n\x05\x04W\x02\0\x04\x12\x04\x99\n\
    \x04\x0c\n\r\n\x05\x04W\x02\0\x06\x12\x04\x99\n\r\x1e\n\r\n\x05\x04W\x02\
    \0\x01\x12\x04\x99\n\x1f2\n\r\n\x05\x04W\x02\0\x03\x12\x04\x99\n56\n\x0c\
    \n\x04\x04W\x02\x01\x12\x04\x9a\n\x041\n\r\n\x05\x04W\x02\x01\x04\x12\
    \x04\x9a\n\x04\x0c\n\r\n\x05\x04W\x02\x01\x06\x12\x04\x9a\n\r\x1c\n\r\n\
    \x05\x04W\x02\x01\x01\x12\x04\x9a\n\x1d,\n\r\n\x05\x04W\x02\x01\x03\x12\
    \x04\x9a\n/0\n\x0c\n\x04\x04W\x02\x02\x12\x04\x9b\n\x046\n\r\n\x05\x04W\
    \x02\x02\x04\x12\x04\x9b\n\x04\x0c\n\r\n\x05\x04W\x02\x02\x06\x12\x04\
    \x9b\n\r\x1e\n\r\n\x05\x04W\x02\x02\x01\x12\x04\x9b\n\x1f1\n\r\n\x05\x04\
    W\x02\x02\x03\x12\x04\x9b\n45\n\x0c\n\x04\x04W\x02\x03\x12\x04\x9c\n\x04\
    7\n\r\n\x05\x04W\x02\x03\x04\x12\x04\x9c\n\x04\x0c\n\r\n\x05\x04W\x02\
    \x03\x06\x12\x04\x9c\n\r!\n\r\n\x05\x04W\x02\x03\x01\x12\x04\x9c\n\"2\n\
    \r\n\x05\x04W\x02\x03\x03\x12\x04\x9c\n56\n\x0c\n\x04\x04W\x02\x04\x12\
    \x04\x9d\n\x04;\n\r\n\x05\x04W\x02\x04\x04\x12\x04\x9d\n\x04\x0c\n\r\n\
    \x05\x04W\x02\x04\x06\x12\x04\x9d\n\r!\n\r\n\x05\x04W\x02\x04\x01\x12\
    \x04\x9d\n\"6\n\r\n\x05\x04W\x02\x04\x03\x12\x04\x9d\n9:\n\x0c\n\x04\x04\
    W\x02\x05\x12\x04\x9e\n\x04:\n\r\n\x05\x04W\x02\x05\x04\x12\x04\x9e\n\
    \x04\x0c\n\r\n\x05\x04W\x02\x05\x06\x12\x04\x9e\n\r!\n\r\n\x05\x04W\x02\
    \x05\x01\x12\x04\x9e\n\"5\n\r\n\x05\x04W\x02\x05\x03\x12\x04\x9e\n89\n\
    \x0c\n\x04\x04W\x02\x06\x12\x04\x9f\n\x049\n\r\n\x05\x04W\x02\x06\x04\
    \x12\x04\x9f\n\x04\x0c\n\r\n\x05\x04W\x02\x06\x05\x12\x04\x9f\n\r\x11\n\
    \r\n\x05\x04W\x02\x06\x01\x12\x04\x9f\n\x124\n\r\n\x05\x04W\x02\x06\x03\
    \x12\x04\x9f\n78\n\x0c\n\x04\x04W\x02\x07\x12\x04\xa0\n\x044\n\r\n\x05\
    \x04W\x02\x07\x04\x12\x04\xa0\n\x04\x0c\n\r\n\x05\x04W\x02\x07\x05\x12\
    \x04\xa0\n\r\x11\n\r\n\x05\x04W\x02\x07\x01\x12\x04\xa0\n\x12/\n\r\n\x05\
    \x04W\x02\x07\x03\x12\x04\xa0\n23\n\x0c\n\x04\x04W\x02\x08\x12\x04\xa1\n\
    \x040\n\r\n\x05\x04W\x02\x08\x04\x12\x04\xa1\n\x04\x0c\n\r\n\x05\x04W\
    \x02\x08\x05\x12\x04\xa1\n\r\x12\n\r\n\x05\x04W\x02\x08\x01\x12\x04\xa1\
    \n\x13+\n\r\n\x05\x04W\x02\x08\x03\x12\x04\xa1\n./\n\x0c\n\x04\x04W\x02\
    \t\x12\x04\xa2\n\x042\n\r\n\x05\x04W\x02\t\x04\x12\x04\xa2\n\x04\x0c\n\r\
    \n\x05\x04W\x02\t\x05\x12\x04\xa2\n\r\x12\n\r\n\x05\x04W\x02\t\x01\x12\
    \x04\xa2\n\x13,\n\r\n\x05\x04W\x02\t\x03\x12\x04\xa2\n/1\n\x0c\n\x04\x04\
    W\x02\n\x12\x04\xa3\n\x048\n\r\n\x05\x04W\x02\n\x04\x12\x04\xa3\n\x04\
    \x0c\n\r\n\x05\x04W\x02\n\x06\x12\x04\xa3\n\r\x1f\n\r\n\x05\x04W\x02\n\
    \x01\x12\x04\xa3\n\x202\n\r\n\x05\x04W\x02\n\x03\x12\x04\xa3\n57\n\x0c\n\
    \x02\x04X\x12\x06\xa6\n\0\xd5\n\x01\n\x0b\n\x03\x04X\x01\x12\x04\xa6\n\
    \x08\x14\n\x0e\n\x04\x04X\x04\0\x12\x06\xa7\n\x04\xaa\n\x05\n\r\n\x05\
    \x04X\x04\0\x01\x12\x04\xa7\n\t!\n\x0e\n\x06\x04X\x04\0\x02\0\x12\x04\
    \xa8\n\x089\n\x0f\n\x07\x04X\x04\0\x02\0\x01\x12\x04\xa8\n\x084\n\x0f\n\
    \x07\x04X\x04\0\x02\0\x02\x12\x04\xa8\n78\n\x0e\n\x06\x04X\x04\0\x02\x01\
    \x12\x04\xa9\n\x08;\n\x0f\n\x07\x04X\x04\0\x02\x01\x01\x12\x04\xa9\n\x08\
    6\n\x0f\n\x07\x04X\x04\0\x02\x01\x02\x12\x04\xa9\n9:\n\x0c\n\x04\x04X\
    \x02\0\x12\x04\xab\n\x04\x1b\n\r\n\x05\x04X\x02\0\x04\x12\x04\xab\n\x04\
    \x0c\n\r\n\x05\x04X\x02\0\x05\x12\x04\xab\n\r\x13\n\r\n\x05\x04X\x02\0\
    \x01\x12\x04\xab\n\x14\x16\n\r\n\x05\x04X\x02\0\x03\x12\x04\xab\n\x19\
    \x1a\n\x0c\n\x04\x04X\x02\x01\x12\x04\xac\n\x04)\n\r\n\x05\x04X\x02\x01\
    \x04\x12\x04\xac\n\x04\x0c\n\r\n\x05\x04X\x02\x01\x06\x12\x04\xac\n\r\
    \x1b\n\r\n\x05\x04X\x02\x01\x01\x12\x04\xac\n\x1c$\n\r\n\x05\x04X\x02\
    \x01\x03\x12\x04\xac\n'(\n\x0c\n\x04\x04X\x02\x02\x12\x04\xad\n\x04\x1f\
    \n\r\n\x05\x04X\x02\x02\x04\x12\x04\xad\n\x04\x0c\n\r\n\x05\x04X\x02\x02\
    \x05\x12\x04\xad\n\r\x13\n\r\n\x05\x04X\x02\x02\x01\x12\x04\xad\n\x14\
    \x1a\n\r\n\x05\x04X\x02\x02\x03\x12\x04\xad\n\x1d\x1e\n\x0c\n\x04\x04X\
    \x02\x03\x12\x04\xae\n\x04\x1f\n\r\n\x05\x04X\x02\x03\x04\x12\x04\xae\n\
    \x04\x0c\n\r\n\x05\x04X\x02\x03\x05\x12\x04\xae\n\r\x13\n\r\n\x05\x04X\
    \x02\x03\x01\x12\x04\xae\n\x14\x1a\n\r\n\x05\x04X\x02\x03\x03\x12\x04\
    \xae\n\x1d\x1e\n\x0c\n\x04\x04X\x02\x04\x12\x04\xaf\n\x04)\n\r\n\x05\x04\
    X\x02\x04\x04\x12\x04\xaf\n\x04\x0c\n\r\n\x05\x04X\x02\x04\x05\x12\x04\
    \xaf\n\r\x13\n\r\n\x05\x04X\x02\x04\x01\x12\x04\xaf\n\x14$\n\r\n\x05\x04\
    X\x02\x04\x03\x12\x04\xaf\n'(\n\x0c\n\x04\x04X\x02\x05\x12\x04\xb0\n\x04\
    $\n\r\n\x05\x04X\x02\x05\x04\x12\x04\xb0\n\x04\x0c\n\r\n\x05\x04X\x02\
    \x05\x05\x12\x04\xb0\n\r\x13\n\r\n\x05\x04X\x02\x05\x01\x12\x04\xb0\n\
    \x14\x1f\n\r\n\x05\x04X\x02\x05\x03\x12\x04\xb0\n\"#\n\x0c\n\x04\x04X\
    \x02\x06\x12\x04\xb1\n\x04\x1f\n\r\n\x05\x04X\x02\x06\x04\x12\x04\xb1\n\
    \x04\x0c\n\r\n\x05\x04X\x02\x06\x05\x12\x04\xb1\n\r\x11\n\r\n\x05\x04X\
    \x02\x06\x01\x12\x04\xb1\n\x12\x1a\n\r\n\x05\x04X\x02\x06\x03\x12\x04\
    \xb1\n\x1d\x1e\n\x0c\n\x04\x04X\x02\x07\x12\x04\xb2\n\x04+\n\r\n\x05\x04\
    X\x02\x07\x04\x12\x04\xb2\n\x04\x0c\n\r\n\x05\x04X\x02\x07\x05\x12\x04\
    \xb2\n\r\x11\n\r\n\x05\x04X\x02\x07\x01\x12\x04\xb2\n\x12&\n\r\n\x05\x04\
    X\x02\x07\x03\x12\x04\xb2\n)*\n\x0c\n\x04\x04X\x02\x08\x12\x04\xb3\n\x04\
    ,\n\r\n\x05\x04X\x02\x08\x04\x12\x04\xb3\n\x04\x0c\n\r\n\x05\x04X\x02\
    \x08\x05\x12\x04\xb3\n\r\x13\n\r\n\x05\x04X\x02\x08\x01\x12\x04\xb3\n\
    \x14'\n\r\n\x05\x04X\x02\x08\x03\x12\x04\xb3\n*+\n\x0c\n\x04\x04X\x02\t\
    \x12\x04\xb4\n\x042\n\r\n\x05\x04X\x02\t\x04\x12\x04\xb4\n\x04\x0c\n\r\n\
    \x05\x04X\x02\t\x05\x12\x04\xb4\n\r\x12\n\r\n\x05\x04X\x02\t\x01\x12\x04\
    \xb4\n\x13,\n\r\n\x05\x04X\x02\t\x03\x12\x04\xb4\n/1\n\x0c\n\x04\x04X\
    \x02\n\x12\x04\xb5\n\x04D\n\r\n\x05\x04X\x02\n\x04\x12\x04\xb5\n\x04\x0c\
    \n\r\n\x05\x04X\x02\n\x06\x12\x04\xb5\n\r%\n\r\n\x05\x04X\x02\n\x01\x12\
    \x04\xb5\n&>\n\r\n\x05\x04X\x02\n\x03\x12\x04\xb5\nAC\n\x0c\n\x04\x04X\
    \x02\x0b\x12\x04\xb6\n\x04/\n\r\n\x05\x04X\x02\x0b\x04\x12\x04\xb6\n\x04\
    \x0c\n\r\n\x05\x04X\x02\x0b\x05\x12\x04\xb6\n\r\x13\n\r\n\x05\x04X\x02\
    \x0b\x01\x12\x04\xb6\n\x14)\n\r\n\x05\x04X\x02\x0b\x03\x12\x04\xb6\n,.\n\
    \x0c\n\x04\x04X\x02\x0c\x12\x04\xb7\n\x04\x1e\n\r\n\x05\x04X\x02\x0c\x04\
    \x12\x04\xb7\n\x04\x0c\n\r\n\x05\x04X\x02\x0c\x05\x12\x04\xb7\n\r\x13\n\
    \r\n\x05\x04X\x02\x0c\x01\x12\x04\xb7\n\x14\x18\n\r\n\x05\x04X\x02\x0c\
    \x03\x12\x04\xb7\n\x1b\x1d\n\x0c\n\x04\x04X\x02\r\x12\x04\xb8\n\x04\x1f\
    \n\r\n\x05\x04X\x02\r\x04\x12\x04\xb8\n\x04\x0c\n\r\n\x05\x04X\x02\r\x05\
    \x12\x04\xb8\n\r\x13\n\r\n\x05\x04X\x02\r\x01\x12\x04\xb8\n\x14\x19\n\r\
    \n\x05\x04X\x02\r\x03\x12\x04\xb8\n\x1c\x1e\n\x0c\n\x04\x04X\x02\x0e\x12\
    \x04\xb9\n\x04\x1f\n\r\n\x05\x04X\x02\x0e\x04\x12\x04\xb9\n\x04\x0c\n\r\
    \n\x05\x04X\x02\x0e\x05\x12\x04\xb9\n\r\x11\n\r\n\x05\x04X\x02\x0e\x01\
    \x12\x04\xb9\n\x12\x19\n\r\n\x05\x04X\x02\x0e\x03\x12\x04\xb9\n\x1c\x1e\
    \n\x0c\n\x04\x04X\x02\x0f\x12\x04\xba\n\x04\x20\n\r\n\x05\x04X\x02\x0f\
    \x04\x12\x04\xba\n\x04\x0c\n\r\n\x05\x04X\x02\x0f\x05\x12\x04\xba\n\r\
    \x11\n\r\n\x05\x04X\x02\x0f\x01\x12\x04\xba\n\x12\x1a\n\r\n\x05\x04X\x02\
    \x0f\x03\x12\x04\xba\n\x1d\x1f\n\x0c\n\x04\x04X\x02\x10\x12\x04\xbb\n\
    \x044\n\r\n\x05\x04X\x02\x10\x04\x12\x04\xbb\n\x04\x0c\n\r\n\x05\x04X\
    \x02\x10\x06\x12\x04\xbb\n\r\x1d\n\r\n\x05\x04X\x02\x10\x01\x12\x04\xbb\
    \n\x1e.\n\r\n\x05\x04X\x02\x10\x03\x12\x04\xbb\n13\n\x0c\n\x04\x04X\x02\
    \x11\x12\x04\xbc\n\x04,\n\r\n\x05\x04X\x02\x11\x04\x12\x04\xbc\n\x04\x0c\
    \n\r\n\x05\x04X\x02\x11\x05\x12\x04\xbc\n\r\x13\n\r\n\x05\x04X\x02\x11\
    \x01\x12\x04\xbc\n\x14&\n\r\n\x05\x04X\x02\x11\x03\x12\x04\xbc\n)+\n\x0c\
    \n\x04\x04X\x02\x12\x12\x04\xbd\n\x04&\n\r\n\x05\x04X\x02\x12\x04\x12\
    \x04\xbd\n\x04\x0c\n\r\n\x05\x04X\x02\x12\x05\x12\x04\xbd\n\r\x11\n\r\n\
    \x05\x04X\x02\x12\x01\x12\x04\xbd\n\x12\x20\n\r\n\x05\x04X\x02\x12\x03\
    \x12\x04\xbd\n#%\n\x0c\n\x04\x04X\x02\x13\x12\x04\xbe\n\x04/\n\r\n\x05\
    \x04X\x02\x13\x04\x12\x04\xbe\n\x04\x0c\n\r\n\x05\x04X\x02\x13\x06\x12\
    \x04\xbe\n\r\x1d\n\r\n\x05\x04X\x02\x13\x01\x12\x04\xbe\n\x1e)\n\r\n\x05\
    \x04X\x02\x13\x03\x12\x04\xbe\n,.\n\x0c\n\x04\x04X\x02\x14\x12\x04\xbf\n\
    \x04\x20\n\r\n\x05\x04X\x02\x14\x04\x12\x04\xbf\n\x04\x0c\n\r\n\x05\x04X\
    \x02\x14\x05\x12\x04\xbf\n\r\x12\n\r\n\x05\x04X\x02\x14\x01\x12\x04\xbf\
    \n\x13\x1a\n\r\n\x05\x04X\x02\x14\x03\x12\x04\xbf\n\x1d\x1f\n\x0c\n\x04\
    \x04X\x02\x15\x12\x04\xc0\n\x04*\n\r\n\x05\x04X\x02\x15\x04\x12\x04\xc0\
    \n\x04\x0c\n\r\n\x05\x04X\x02\x15\x05\x12\x04\xc0\n\r\x13\n\r\n\x05\x04X\
    \x02\x15\x01\x12\x04\xc0\n\x14$\n\r\n\x05\x04X\x02\x15\x03\x12\x04\xc0\n\
    ')\n\x0c\n\x04\x04X\x02\x16\x12\x04\xc1\n\x042\n\r\n\x05\x04X\x02\x16\
    \x04\x12\x04\xc1\n\x04\x0c\n\r\n\x05\x04X\x02\x16\x05\x12\x04\xc1\n\r\
    \x12\n\r\n\x05\x04X\x02\x16\x01\x12\x04\xc1\n\x13,\n\r\n\x05\x04X\x02\
    \x16\x03\x12\x04\xc1\n/1\n\x0c\n\x04\x04X\x02\x17\x12\x04\xc2\n\x04\x20\
    \n\r\n\x05\x04X\x02\x17\x04\x12\x04\xc2\n\x04\x0c\n\r\n\x05\x04X\x02\x17\
    \x05\x12\x04\xc2\n\r\x13\n\r\n\x05\x04X\x02\x17\x01\x12\x04\xc2\n\x14\
    \x1a\n\r\n\x05\x04X\x02\x17\x03\x12\x04\xc2\n\x1d\x1f\n\x0c\n\x04\x04X\
    \x02\x18\x12\x04\xc3\n\x04%\n\r\n\x05\x04X\x02\x18\x04\x12\x04\xc3\n\x04\
    \x0c\n\r\n\x05\x04X\x02\x18\x05\x12\x04\xc3\n\r\x13\n\r\n\x05\x04X\x02\
    \x18\x01\x12\x04\xc3\n\x14\x1f\n\r\n\x05\x04X\x02\x18\x03\x12\x04\xc3\n\
    \"$\n\x0c\n\x04\x04X\x02\x19\x12\x04\xc4\n\x04.\n\r\n\x05\x04X\x02\x19\
    \x04\x12\x04\xc4\n\x04\x0c\n\r\n\x05\x04X\x02\x19\x06\x12\x04\xc4\n\r\
    \x1e\n\r\n\x05\x04X\x02\x19\x01\x12\x04\xc4\n\x1f(\n\r\n\x05\x04X\x02\
    \x19\x03\x12\x04\xc4\n+-\n\x0c\n\x04\x04X\x02\x1a\x12\x04\xc5\n\x042\n\r\
    \n\x05\x04X\x02\x1a\x04\x12\x04\xc5\n\x04\x0c\n\r\n\x05\x04X\x02\x1a\x06\
    \x12\x04\xc5\n\r\x1c\n\r\n\x05\x04X\x02\x1a\x01\x12\x04\xc5\n\x1d,\n\r\n\
    \x05\x04X\x02\x1a\x03\x12\x04\xc5\n/1\n\x0c\n\x04\x04X\x02\x1b\x12\x04\
    \xc6\n\x040\n\r\n\x05\x04X\x02\x1b\x04\x12\x04\xc6\n\x04\x0c\n\r\n\x05\
    \x04X\x02\x1b\x05\x12\x04\xc6\n\r\x13\n\r\n\x05\x04X\x02\x1b\x01\x12\x04\
    \xc6\n\x14*\n\r\n\x05\x04X\x02\x1b\x03\x12\x04\xc6\n-/\n\x0c\n\x04\x04X\
    \x02\x1c\x12\x04\xc7\n\x04!\n\r\n\x05\x04X\x02\x1c\x04\x12\x04\xc7\n\x04\
    \x0c\n\r\n\x05\x04X\x02\x1c\x05\x12\x04\xc7\n\r\x11\n\r\n\x05\x04X\x02\
    \x1c\x01\x12\x04\xc7\n\x12\x1b\n\r\n\x05\x04X\x02\x1c\x03\x12\x04\xc7\n\
    \x1e\x20\n\x0c\n\x04\x04X\x02\x1d\x12\x04\xc8\n\x04\"\n\r\n\x05\x04X\x02\
    \x1d\x04\x12\x04\xc8\n\x04\x0c\n\r\n\x05\x04X\x02\x1d\x05\x12\x04\xc8\n\
    \r\x11\n\r\n\x05\x04X\x02\x1d\x01\x12\x04\xc8\n\x12\x1c\n\r\n\x05\x04X\
    \x02\x1d\x03\x12\x04\xc8\n\x1f!\n\x0c\n\x04\x04X\x02\x1e\x12\x04\xc9\n\
    \x04#\n\r\n\x05\x04X\x02\x1e\x04\x12\x04\xc9\n\x04\x0c\n\r\n\x05\x04X\
    \x02\x1e\x05\x12\x04\xc9\n\r\x13\n\r\n\x05\x04X\x02\x1e\x01\x12\x04\xc9\
    \n\x14\x1d\n\r\n\x05\x04X\x02\x1e\x03\x12\x04\xc9\n\x20\"\n\x0c\n\x04\
    \x04X\x02\x1f\x12\x04\xca\n\x04#\n\r\n\x05\x04X\x02\x1f\x04\x12\x04\xca\
    \n\x04\x0c\n\r\n\x05\x04X\x02\x1f\x05\x12\x04\xca\n\r\x13\n\r\n\x05\x04X\
    \x02\x1f\x01\x12\x04\xca\n\x14\x1d\n\r\n\x05\x04X\x02\x1f\x03\x12\x04\
    \xca\n\x20\"\n\x0c\n\x04\x04X\x02\x20\x12\x04\xcb\n\x04%\n\r\n\x05\x04X\
    \x02\x20\x04\x12\x04\xcb\n\x04\x0c\n\r\n\x05\x04X\x02\x20\x05\x12\x04\
    \xcb\n\r\x13\n\r\n\x05\x04X\x02\x20\x01\x12\x04\xcb\n\x14\x1f\n\r\n\x05\
    \x04X\x02\x20\x03\x12\x04\xcb\n\"$\n\x0c\n\x04\x04X\x02!\x12\x04\xcc\n\
    \x04\x1f\n\r\n\x05\x04X\x02!\x04\x12\x04\xcc\n\x04\x0c\n\r\n\x05\x04X\
    \x02!\x05\x12\x04\xcc\n\r\x11\n\r\n\x05\x04X\x02!\x01\x12\x04\xcc\n\x12\
    \x19\n\r\n\x05\x04X\x02!\x03\x12\x04\xcc\n\x1c\x1e\n\x0c\n\x04\x04X\x02\
    \"\x12\x04\xcd\n\x04%\n\r\n\x05\x04X\x02\"\x04\x12\x04\xcd\n\x04\x0c\n\r\
    \n\x05\x04X\x02\"\x05\x12\x04\xcd\n\r\x11\n\r\n\x05\x04X\x02\"\x01\x12\
    \x04\xcd\n\x12\x1f\n\r\n\x05\x04X\x02\"\x03\x12\x04\xcd\n\"$\n\x0c\n\x04\
    \x04X\x02#\x12\x04\xce\n\x04)\n\r\n\x05\x04X\x02#\x04\x12\x04\xce\n\x04\
    \x0c\n\r\n\x05\x04X\x02#\x05\x12\x04\xce\n\r\x11\n\r\n\x05\x04X\x02#\x01\
    \x12\x04\xce\n\x12#\n\r\n\x05\x04X\x02#\x03\x12\x04\xce\n&(\n\x0c\n\x04\
    \x04X\x02$\x12\x04\xcf\n\x04'\n\r\n\x05\x04X\x02$\x04\x12\x04\xcf\n\x04\
    \x0c\n\r\n\x05\x04X\x02$\x05\x12\x04\xcf\n\r\x13\n\r\n\x05\x04X\x02$\x01\
    \x12\x04\xcf\n\x14!\n\r\n\x05\x04X\x02$\x03\x12\x04\xcf\n$&\n\x0c\n\x04\
    \x04X\x02%\x12\x04\xd0\n\x04%\n\r\n\x05\x04X\x02%\x04\x12\x04\xd0\n\x04\
    \x0c\n\r\n\x05\x04X\x02%\x05\x12\x04\xd0\n\r\x13\n\r\n\x05\x04X\x02%\x01\
    \x12\x04\xd0\n\x14\x1f\n\r\n\x05\x04X\x02%\x03\x12\x04\xd0\n\"$\n\x0c\n\
    \x04\x04X\x02&\x12\x04\xd1\n\x04\x1f\n\r\n\x05\x04X\x02&\x04\x12\x04\xd1\
    \n\x04\x0c\n\r\n\x05\x04X\x02&\x05\x12\x04\xd1\n\r\x13\n\r\n\x05\x04X\
    \x02&\x01\x12\x04\xd1\n\x14\x19\n\r\n\x05\x04X\x02&\x03\x12\x04\xd1\n\
    \x1c\x1e\n\x0c\n\x04\x04X\x02'\x12\x04\xd2\n\x04\"\n\r\n\x05\x04X\x02'\
    \x04\x12\x04\xd2\n\x04\x0c\n\r\n\x05\x04X\x02'\x05\x12\x04\xd2\n\r\x11\n\
    \r\n\x05\x04X\x02'\x01\x12\x04\xd2\n\x12\x1c\n\r\n\x05\x04X\x02'\x03\x12\
    \x04\xd2\n\x1f!\n\x0c\n\x04\x04X\x02(\x12\x04\xd3\n\x04-\n\r\n\x05\x04X\
    \x02(\x04\x12\x04\xd3\n\x04\x0c\n\r\n\x05\x04X\x02(\x05\x12\x04\xd3\n\r\
    \x11\n\r\n\x05\x04X\x02(\x01\x12\x04\xd3\n\x12'\n\r\n\x05\x04X\x02(\x03\
    \x12\x04\xd3\n*,\n\x0c\n\x04\x04X\x02)\x12\x04\xd4\n\x04\x20\n\r\n\x05\
    \x04X\x02)\x04\x12\x04\xd4\n\x04\x0c\n\r\n\x05\x04X\x02)\x05\x12\x04\xd4\
    \n\r\x13\n\r\n\x05\x04X\x02)\x01\x12\x04\xd4\n\x14\x1a\n\r\n\x05\x04X\
    \x02)\x03\x12\x04\xd4\n\x1d\x1f\n\x0c\n\x02\x04Y\x12\x06\xd7\n\0\xda\n\
    \x01\n\x0b\n\x03\x04Y\x01\x12\x04\xd7\n\x08\x1a\n\x0c\n\x04\x04Y\x02\0\
    \x12\x04\xd8\n\x04\x1d\n\r\n\x05\x04Y\x02\0\x04\x12\x04\xd8\n\x04\x0c\n\
    \r\n\x05\x04Y\x02\0\x05\x12\x04\xd8\n\r\x13\n\r\n\x05\x04Y\x02\0\x01\x12\
    \x04\xd8\n\x14\x18\n\r\n\x05\x04Y\x02\0\x03\x12\x04\xd8\n\x1b\x1c\n\x0c\
    \n\x04\x04Y\x02\x01\x12\x04\xd9\n\x04!\n\r\n\x05\x04Y\x02\x01\x04\x12\
    \x04\xd9\n\x04\x0c\n\r\n\x05\x04Y\x02\x01\x05\x12\x04\xd9\n\r\x13\n\r\n\
    \x05\x04Y\x02\x01\x01\x12\x04\xd9\n\x14\x1c\n\r\n\x05\x04Y\x02\x01\x03\
    \x12\x04\xd9\n\x1f\x20\n\x0c\n\x02\x04Z\x12\x06\xdc\n\0\xe1\n\x01\n\x0b\
    \n\x03\x04Z\x01\x12\x04\xdc\n\x08\x1c\n\x0c\n\x04\x04Z\x02\0\x12\x04\xdd\
    \n\x04%\n\r\n\x05\x04Z\x02\0\x04\x12\x04\xdd\n\x04\x0c\n\r\n\x05\x04Z\
    \x02\0\x05\x12\x04\xdd\n\r\x11\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xdd\n\
    \x12\x20\n\r\n\x05\x04Z\x02\0\x03\x12\x04\xdd\n#$\n\x0c\n\x04\x04Z\x02\
    \x01\x12\x04\xde\n\x04$\n\r\n\x05\x04Z\x02\x01\x04\x12\x04\xde\n\x04\x0c\
    \n\r\n\x05\x04Z\x02\x01\x05\x12\x04\xde\n\r\x11\n\r\n\x05\x04Z\x02\x01\
    \x01\x12\x04\xde\n\x12\x1f\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\xde\n\"#\n\
    \x0c\n\x04\x04Z\x02\x02\x12\x04\xdf\n\x04$\n\r\n\x05\x04Z\x02\x02\x04\
    \x12\x04\xdf\n\x04\x0c\n\r\n\x05\x04Z\x02\x02\x05\x12\x04\xdf\n\r\x11\n\
    \r\n\x05\x04Z\x02\x02\x01\x12\x04\xdf\n\x12\x1f\n\r\n\x05\x04Z\x02\x02\
    \x03\x12\x04\xdf\n\"#\n\x0c\n\x04\x04Z\x02\x03\x12\x04\xe0\n\x04(\n\r\n\
    \x05\x04Z\x02\x03\x04\x12\x04\xe0\n\x04\x0c\n\r\n\x05\x04Z\x02\x03\x05\
    \x12\x04\xe0\n\r\x11\n\r\n\x05\x04Z\x02\x03\x01\x12\x04\xe0\n\x12#\n\r\n\
    \x05\x04Z\x02\x03\x03\x12\x04\xe0\n&'\n\x80\x01\n\x02\x04[\x12\x06\xe9\n\
    \0\xec\n\x012r\x20Duplicate\x20type\x20omitted\nmessage\x20PollEncValue\
    \x20{\n\x20\x20\x20\x20optional\x20bytes\x20encPayload\x20=\x201;\n\x20\
    \x20\x20\x20optional\x20bytes\x20encIv\x20=\x202;\n}\n\n\x0b\n\x03\x04[\
    \x01\x12\x04\xe9\n\x08\x18\n\x0c\n\x04\x04[\x02\0\x12\x04\xea\n\x04*\n\r\
    \n\x05\x04[\x02\0\x04\x12\x04\xea\n\x04\x0c\n\r\n\x05\x04[\x02\0\x06\x12\
    \x04\xea\n\r\x1a\n\r\n\x05\x04[\x02\0\x01\x12\x04\xea\n\x1b%\n\r\n\x05\
    \x04[\x02\0\x03\x12\x04\xea\n()\n\x0c\n\x04\x04[\x02\x01\x12\x04\xeb\n\
    \x04)\n\r\n\x05\x04[\x02\x01\x04\x12\x04\xeb\n\x04\x0c\n\r\n\x05\x04[\
    \x02\x01\x06\x12\x04\xeb\n\r\x1a\n\r\n\x05\x04[\x02\x01\x01\x12\x04\xeb\
    \n\x1b$\n\r\n\x05\x04[\x02\x01\x03\x12\x04\xeb\n'(\n\x0c\n\x02\x04\\\x12\
    \x06\xee\n\0\x8d\x0b\x01\n\x0b\n\x03\x04\\\x01\x12\x04\xee\n\x08\x15\n\
    \x0e\n\x04\x04\\\x03\0\x12\x06\xef\n\x04\xf1\n\x05\n\r\n\x05\x04\\\x03\0\
    \x01\x12\x04\xef\n\x0c\x16\n\x0e\n\x06\x04\\\x03\0\x02\0\x12\x04\xf0\n\
    \x08!\n\x0f\n\x07\x04\\\x03\0\x02\0\x04\x12\x04\xf0\n\x08\x10\n\x0f\n\
    \x07\x04\\\x03\0\x02\0\x05\x12\x04\xf0\n\x11\x17\n\x0f\n\x07\x04\\\x03\0\
    \x02\0\x01\x12\x04\xf0\n\x18\x1c\n\x0f\n\x07\x04\\\x03\0\x02\0\x03\x12\
    \x04\xf0\n\x1f\x20\n\x0c\n\x04\x04\\\x02\0\x12\x04\xf3\n\x04\x1d\n\r\n\
    \x05\x04\\\x02\0\x04\x12\x04\xf3\n\x04\x0c\n\r\n\x05\x04\\\x02\0\x05\x12\
    \x04\xf3\n\r\x13\n\r\n\x05\x04\\\x02\0\x01\x12\x04\xf3\n\x14\x18\n\r\n\
    \x05\x04\\\x02\0\x03\x12\x04\xf3\n\x1b\x1c\n\x0c\n\x04\x04\\\x02\x01\x12\
    \x04\xf4\n\x04\x20\n\r\n\x05\x04\\\x02\x01\x04\x12\x04\xf4\n\x04\x0c\n\r\
    \n\x05\x04\\\x02\x01\x05\x12\x04\xf4\n\r\x13\n\r\n\x05\x04\\\x02\x01\x01\
    \x12\x04\xf4\n\x14\x1b\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\xf4\n\x1e\x1f\
    \n\x0c\n\x04\x04\\\x02\x02\x12\x04\xf5\n\x04\x1c\n\r\n\x05\x04\\\x02\x02\
    \x04\x12\x04\xf5\n\x04\x0c\n\r\n\x05\x04\\\x02\x02\x05\x12\x04\xf5\n\r\
    \x13\n\r\n\x05\x04\\\x02\x02\x01\x12\x04\xf5\n\x14\x17\n\r\n\x05\x04\\\
    \x02\x02\x03\x12\x04\xf5\n\x1a\x1b\n\x0c\n\x04\x04\\\x02\x03\x12\x04\xf6\
    \n\x04\x1d\n\r\n\x05\x04\\\x02\x03\x04\x12\x04\xf6\n\x04\x0c\n\r\n\x05\
    \x04\\\x02\x03\x05\x12\x04\xf6\n\r\x11\n\r\n\x05\x04\\\x02\x03\x01\x12\
    \x04\xf6\n\x12\x18\n\r\n\x05\x04\\\x02\x03\x03\x12\x04\xf6\n\x1b\x1c\n\
    \x0c\n\x04\x04\\\x02\x04\x12\x04\xf7\n\x04\x1c\n\r\n\x05\x04\\\x02\x04\
    \x04\x12\x04\xf7\n\x04\x0c\n\r\n\x05\x04\\\x02\x04\x05\x12\x04\xf7\n\r\
    \x13\n\r\n\x05\x04\\\x02\x04\x01\x12\x04\xf7\n\x14\x17\n\r\n\x05\x04\\\
    \x02\x04\x03\x12\x04\xf7\n\x1a\x1b\n\x0c\n\x04\x04\\\x02\x05\x12\x04\xf8\
    \n\x04)\n\r\n\x05\x04\\\x02\x05\x04\x12\x04\xf8\n\x04\x0c\n\r\n\x05\x04\
    \\\x02\x05\x05\x12\x04\xf8\n\r\x12\n\r\n\x05\x04\\\x02\x05\x01\x12\x04\
    \xf8\n\x13$\n\r\n\x05\x04\\\x02\x05\x03\x12\x04\xf8\n'(\n\x0c\n\x04\x04\
    \\\x02\x06\x12\x04\xf9\n\x04+\n\r\n\x05\x04\\\x02\x06\x04\x12\x04\xf9\n\
    \x04\x0c\n\r\n\x05\x04\\\x02\x06\x05\x12\x04\xf9\n\r\x13\n\r\n\x05\x04\\\
    \x02\x06\x01\x12\x04\xf9\n\x14&\n\r\n\x05\x04\\\x02\x06\x03\x12\x04\xf9\
    \n)*\n\x0c\n\x04\x04\\\x02\x07\x12\x04\xfa\n\x04&\n\r\n\x05\x04\\\x02\
    \x07\x04\x12\x04\xfa\n\x04\x0c\n\r\n\x05\x04\\\x02\x07\x05\x12\x04\xfa\n\
    \r\x13\n\r\n\x05\x04\\\x02\x07\x01\x12\x04\xfa\n\x14\x20\n\r\n\x05\x04\\\
    \x02\x07\x03\x12\x04\xfa\n#%\n\x0c\n\x04\x04\\\x02\x08\x12\x04\xfb\n\x04\
    %\n\r\n\x05\x04\\\x02\x08\x04\x12\x04\xfb\n\x04\x0c\n\r\n\x05\x04\\\x02\
    \x08\x05\x12\x04\xfb\n\r\x13\n\r\n\x05\x04\\\x02\x08\x01\x12\x04\xfb\n\
    \x14\x1f\n\r\n\x05\x04\\\x02\x08\x03\x12\x04\xfb\n\"$\n\x0c\n\x04\x04\\\
    \x02\t\x12\x04\xfc\n\x04\x1f\n\r\n\x05\x04\\\x02\t\x04\x12\x04\xfc\n\x04\
    \x0c\n\r\n\x05\x04\\\x02\t\x05\x12\x04\xfc\n\r\x13\n\r\n\x05\x04\\\x02\t\
    \x01\x12\x04\xfc\n\x14\x19\n\r\n\x05\x04\\\x02\t\x03\x12\x04\xfc\n\x1c\
    \x1e\n\x0c\n\x04\x04\\\x02\n\x12\x04\xfd\n\x04%\n\r\n\x05\x04\\\x02\n\
    \x04\x12\x04\xfd\n\x04\x0c\n\r\n\x05\x04\\\x02\n\x05\x12\x04\xfd\n\r\x13\
    \n\r\n\x05\x04\\\x02\n\x01\x12\x04\xfd\n\x14\x1f\n\r\n\x05\x04\\\x02\n\
    \x03\x12\x04\xfd\n\"$\n\x0c\n\x04\x04\\\x02\x0b\x12\x04\xfe\n\x04*\n\r\n\
    \x05\x04\\\x02\x0b\x04\x12\x04\xfe\n\x04\x0c\n\r\n\x05\x04\\\x02\x0b\x05\
    \x12\x04\xfe\n\r\x12\n\r\n\x05\x04\\\x02\x0b\x01\x12\x04\xfe\n\x13$\n\r\
    \n\x05\x04\\\x02\x0b\x03\x12\x04\xfe\n')\n\x0c\n\x04\x04\\\x02\x0c\x12\
    \x04\xff\n\x04#\n\r\n\x05\x04\\\x02\x0c\x04\x12\x04\xff\n\x04\x0c\n\r\n\
    \x05\x04\\\x02\x0c\x05\x12\x04\xff\n\r\x13\n\r\n\x05\x04\\\x02\x0c\x01\
    \x12\x04\xff\n\x14\x1d\n\r\n\x05\x04\\\x02\x0c\x03\x12\x04\xff\n\x20\"\n\
    \x0c\n\x04\x04\\\x02\r\x12\x04\x80\x0b\x04\x1d\n\r\n\x05\x04\\\x02\r\x04\
    \x12\x04\x80\x0b\x04\x0c\n\r\n\x05\x04\\\x02\r\x05\x12\x04\x80\x0b\r\x13\
    \n\r\n\x05\x04\\\x02\r\x01\x12\x04\x80\x0b\x14\x17\n\r\n\x05\x04\\\x02\r\
    \x03\x12\x04\x80\x0b\x1a\x1c\n\x0c\n\x04\x04\\\x02\x0e\x12\x04\x81\x0b\
    \x04\"\n\r\n\x05\x04\\\x02\x0e\x04\x12\x04\x81\x0b\x04\x0c\n\r\n\x05\x04\
    \\\x02\x0e\x05\x12\x04\x81\x0b\r\x13\n\r\n\x05\x04\\\x02\x0e\x01\x12\x04\
    \x81\x0b\x14\x1c\n\r\n\x05\x04\\\x02\x0e\x03\x12\x04\x81\x0b\x1f!\n\x0c\
    \n\x04\x04\\\x02\x0f\x12\x04\x82\x0b\x04)\n\r\n\x05\x04\\\x02\x0f\x04\
    \x12\x04\x82\x0b\x04\x0c\n\r\n\x05\x04\\\x02\x0f\x06\x12\x04\x82\x0b\r\
    \x17\n\r\n\x05\x04\\\x02\x0f\x01\x12\x04\x82\x0b\x18#\n\r\n\x05\x04\\\
    \x02\x0f\x03\x12\x04\x82\x0b&(\n\x0c\n\x04\x04\\\x02\x10\x12\x04\x83\x0b\
    \x044\n\r\n\x05\x04\\\x02\x10\x04\x12\x04\x83\x0b\x04\x0c\n\r\n\x05\x04\
    \\\x02\x10\x05\x12\x04\x83\x0b\r\x13\n\r\n\x05\x04\\\x02\x10\x01\x12\x04\
    \x83\x0b\x14.\n\r\n\x05\x04\\\x02\x10\x03\x12\x04\x83\x0b13\n\x0c\n\x04\
    \x04\\\x02\x11\x12\x04\x84\x0b\x04&\n\r\n\x05\x04\\\x02\x11\x04\x12\x04\
    \x84\x0b\x04\x0c\n\r\n\x05\x04\\\x02\x11\x05\x12\x04\x84\x0b\r\x12\n\r\n\
    \x05\x04\\\x02\x11\x01\x12\x04\x84\x0b\x13\x20\n\r\n\x05\x04\\\x02\x11\
    \x03\x12\x04\x84\x0b#%\n\x0c\n\x04\x04\\\x02\x12\x12\x04\x85\x0b\x04,\n\
    \r\n\x05\x04\\\x02\x12\x04\x12\x04\x85\x0b\x04\x0c\n\r\n\x05\x04\\\x02\
    \x12\x05\x12\x04\x85\x0b\r\x13\n\r\n\x05\x04\\\x02\x12\x01\x12\x04\x85\
    \x0b\x14&\n\r\n\x05\x04\\\x02\x12\x03\x12\x04\x85\x0b)+\n\x0c\n\x04\x04\
    \\\x02\x13\x12\x04\x86\x0b\x04*\n\r\n\x05\x04\\\x02\x13\x04\x12\x04\x86\
    \x0b\x04\x0c\n\r\n\x05\x04\\\x02\x13\x05\x12\x04\x86\x0b\r\x12\n\r\n\x05\
    \x04\\\x02\x13\x01\x12\x04\x86\x0b\x13$\n\r\n\x05\x04\\\x02\x13\x03\x12\
    \x04\x86\x0b')\n\x0c\n\x04\x04\\\x02\x14\x12\x04\x87\x0b\x04-\n\r\n\x05\
    \x04\\\x02\x14\x04\x12\x04\x87\x0b\x04\x0c\n\r\n\x05\x04\\\x02\x14\x05\
    \x12\x04\x87\x0b\r\x13\n\r\n\x05\x04\\\x02\x14\x01\x12\x04\x87\x0b\x14'\
    \n\r\n\x05\x04\\\x02\x14\x03\x12\x04\x87\x0b*,\n\x0c\n\x04\x04\\\x02\x15\
    \x12\x04\x88\x0b\x04+\n\r\n\x05\x04\\\x02\x15\x04\x12\x04\x88\x0b\x04\
    \x0c\n\r\n\x05\x04\\\x02\x15\x06\x12\x04\x88\x0b\r\x19\n\r\n\x05\x04\\\
    \x02\x15\x01\x12\x04\x88\x0b\x1a%\n\r\n\x05\x04\\\x02\x15\x03\x12\x04\
    \x88\x0b(*\n\x0c\n\x04\x04\\\x02\x16\x12\x04\x89\x0b\x04-\n\r\n\x05\x04\
    \\\x02\x16\x04\x12\x04\x89\x0b\x04\x0c\n\r\n\x05\x04\\\x02\x16\x05\x12\
    \x04\x89\x0b\r\x11\n\r\n\x05\x04\\\x02\x16\x01\x12\x04\x89\x0b\x12'\n\r\
    \n\x05\x04\\\x02\x16\x03\x12\x04\x89\x0b*,\n\x0c\n\x04\x04\\\x02\x17\x12\
    \x04\x8a\x0b\x045\n\r\n\x05\x04\\\x02\x17\x04\x12\x04\x8a\x0b\x04\x0c\n\
    \r\n\x05\x04\\\x02\x17\x05\x12\x04\x8a\x0b\r\x13\n\r\n\x05\x04\\\x02\x17\
    \x01\x12\x04\x8a\x0b\x14/\n\r\n\x05\x04\\\x02\x17\x03\x12\x04\x8a\x0b24\
    \n\x0c\n\x04\x04\\\x02\x18\x12\x04\x8b\x0b\x04.\n\r\n\x05\x04\\\x02\x18\
    \x04\x12\x04\x8b\x0b\x04\x0c\n\r\n\x05\x04\\\x02\x18\x05\x12\x04\x8b\x0b\
    \r\x12\n\r\n\x05\x04\\\x02\x18\x01\x12\x04\x8b\x0b\x13(\n\r\n\x05\x04\\\
    \x02\x18\x03\x12\x04\x8b\x0b+-\n\x0c\n\x04\x04\\\x02\x19\x12\x04\x8c\x0b\
    \x04)\n\r\n\x05\x04\\\x02\x19\x04\x12\x04\x8c\x0b\x04\x0c\n\r\n\x05\x04\
    \\\x02\x19\x05\x12\x04\x8c\x0b\r\x12\n\r\n\x05\x04\\\x02\x19\x01\x12\x04\
    \x8c\x0b\x13#\n\r\n\x05\x04\\\x02\x19\x03\x12\x04\x8c\x0b&(\n\x0c\n\x02\
    \x04]\x12\x06\x8f\x0b\0\x91\x0b\x01\n\x0b\n\x03\x04]\x01\x12\x04\x8f\x0b\
    \x08\x1a\n\x0c\n\x04\x04]\x02\0\x12\x04\x90\x0b\x04!\n\r\n\x05\x04]\x02\
    \0\x04\x12\x04\x90\x0b\x04\x0c\n\r\n\x05\x04]\x02\0\x05\x12\x04\x90\x0b\
    \r\x13\n\r\n\x05\x04]\x02\0\x01\x12\x04\x90\x0b\x14\x1c\n\r\n\x05\x04]\
    \x02\0\x03\x12\x04\x90\x0b\x1f\x20\n\x0c\n\x02\x04^\x12\x06\x93\x0b\0\
    \x9d\x0b\x01\n\x0b\n\x03\x04^\x01\x12\x04\x93\x0b\x08\x1e\n\x0e\n\x04\
    \x04^\x04\0\x12\x06\x94\x0b\x04\x99\x0b\x05\n\r\n\x05\x04^\x04\0\x01\x12\
    \x04\x94\x0b\t\x13\n\x0e\n\x06\x04^\x04\0\x02\0\x12\x04\x95\x0b\x08\x1a\
    \n\x0f\n\x07\x04^\x04\0\x02\0\x01\x12\x04\x95\x0b\x08\x15\n\x0f\n\x07\
    \x04^\x04\0\x02\0\x02\x12\x04\x95\x0b\x18\x19\n\x0e\n\x06\x04^\x04\0\x02\
    \x01\x12\x04\x96\x0b\x08\x14\n\x0f\n\x07\x04^\x04\0\x02\x01\x01\x12\x04\
    \x96\x0b\x08\x0f\n\x0f\n\x07\x04^\x04\0\x02\x01\x02\x12\x04\x96\x0b\x12\
    \x13\n\x0e\n\x06\x04^\x04\0\x02\x02\x12\x04\x97\x0b\x08\x16\n\x0f\n\x07\
    \x04^\x04\0\x02\x02\x01\x12\x04\x97\x0b\x08\x11\n\x0f\n\x07\x04^\x04\0\
    \x02\x02\x02\x12\x04\x97\x0b\x14\x15\n\x0e\n\x06\x04^\x04\0\x02\x03\x12\
    \x04\x98\x0b\x08\x1d\n\x0f\n\x07\x04^\x04\0\x02\x03\x01\x12\x04\x98\x0b\
    \x08\x18\n\x0f\n\x07\x04^\x04\0\x02\x03\x02\x12\x04\x98\x0b\x1b\x1c\n\
    \x0c\n\x04\x04^\x02\0\x12\x04\x9a\x0b\x04!\n\r\n\x05\x04^\x02\0\x04\x12\
    \x04\x9a\x0b\x04\x0c\n\r\n\x05\x04^\x02\0\x05\x12\x04\x9a\x0b\r\x13\n\r\
    \n\x05\x04^\x02\0\x01\x12\x04\x9a\x0b\x14\x1c\n\r\n\x05\x04^\x02\0\x03\
    \x12\x04\x9a\x0b\x1f\x20\n\x0c\n\x04\x04^\x02\x01\x12\x04\x9b\x0b\x04#\n\
    \r\n\x05\x04^\x02\x01\x04\x12\x04\x9b\x0b\x04\x0c\n\r\n\x05\x04^\x02\x01\
    \x05\x12\x04\x9b\x0b\r\x13\n\r\n\x05\x04^\x02\x01\x01\x12\x04\x9b\x0b\
    \x14\x1e\n\r\n\x05\x04^\x02\x01\x03\x12\x04\x9b\x0b!\"\n\x0c\n\x04\x04^\
    \x02\x02\x12\x04\x9c\x0b\x04#\n\r\n\x05\x04^\x02\x02\x04\x12\x04\x9c\x0b\
    \x04\x0c\n\r\n\x05\x04^\x02\x02\x06\x12\x04\x9c\x0b\r\x17\n\r\n\x05\x04^\
    \x02\x02\x01\x12\x04\x9c\x0b\x18\x1e\n\r\n\x05\x04^\x02\x02\x03\x12\x04\
    \x9c\x0b!\"\n\x0c\n\x02\x04_\x12\x06\x9f\x0b\0\xa4\x0b\x01\n\x0b\n\x03\
    \x04_\x01\x12\x04\x9f\x0b\x08\x12\n\x0c\n\x04\x04_\x02\0\x12\x04\xa0\x0b\
    \x04\"\n\r\n\x05\x04_\x02\0\x04\x12\x04\xa0\x0b\x04\x0c\n\r\n\x05\x04_\
    \x02\0\x05\x12\x04\xa0\x0b\r\x13\n\r\n\x05\x04_\x02\0\x01\x12\x04\xa0\
    \x0b\x14\x1d\n\r\n\x05\x04_\x02\0\x03\x12\x04\xa0\x0b\x20!\n\x0c\n\x04\
    \x04_\x02\x01\x12\x04\xa1\x0b\x04\x1d\n\r\n\x05\x04_\x02\x01\x04\x12\x04\
    \xa1\x0b\x04\x0c\n\r\n\x05\x04_\x02\x01\x05\x12\x04\xa1\x0b\r\x11\n\r\n\
    \x05\x04_\x02\x01\x01\x12\x04\xa1\x0b\x12\x18\n\r\n\x05\x04_\x02\x01\x03\
    \x12\x04\xa1\x0b\x1b\x1c\n\x0c\n\x04\x04_\x02\x02\x12\x04\xa2\x0b\x04\
    \x1b\n\r\n\x05\x04_\x02\x02\x04\x12\x04\xa2\x0b\x04\x0c\n\r\n\x05\x04_\
    \x02\x02\x05\x12\x04\xa2\x0b\r\x13\n\r\n\x05\x04_\x02\x02\x01\x12\x04\
    \xa2\x0b\x14\x16\n\r\n\x05\x04_\x02\x02\x03\x12\x04\xa2\x0b\x19\x1a\n\
    \x0c\n\x04\x04_\x02\x03\x12\x04\xa3\x0b\x04$\n\r\n\x05\x04_\x02\x03\x04\
    \x12\x04\xa3\x0b\x04\x0c\n\r\n\x05\x04_\x02\x03\x05\x12\x04\xa3\x0b\r\
    \x13\n\r\n\x05\x04_\x02\x03\x01\x12\x04\xa3\x0b\x14\x1f\n\r\n\x05\x04_\
    \x02\x03\x03\x12\x04\xa3\x0b\"#\n\xc0\x01\n\x02\x04`\x12\x06\xae\x0b\0\
    \xb0\x0b\x012\xb1\x01\x20Duplicate\x20type\x20omitted\nmessage\x20Messag\
    eKey\x20{\n\x20\x20\x20\x20optional\x20string\x20remoteJid\x20=\x201;\n\
    \x20\x20\x20\x20optional\x20bool\x20fromMe\x20=\x202;\n\x20\x20\x20\x20o\
    ptional\x20string\x20id\x20=\x203;\n\x20\x20\x20\x20optional\x20string\
    \x20participant\x20=\x204;\n}\n\n\x0b\n\x03\x04`\x01\x12\x04\xae\x0b\x08\
    \x14\n\x0c\n\x04\x04`\x02\0\x12\x04\xaf\x0b\x04\x20\n\r\n\x05\x04`\x02\0\
    \x04\x12\x04\xaf\x0b\x04\x0c\n\r\n\x05\x04`\x02\0\x05\x12\x04\xaf\x0b\r\
    \x13\n\r\n\x05\x04`\x02\0\x01\x12\x04\xaf\x0b\x14\x1b\n\r\n\x05\x04`\x02\
    \0\x03\x12\x04\xaf\x0b\x1e\x1f\n\x0c\n\x02\x04a\x12\x06\xb2\x0b\0\xb4\
    \x0b\x01\n\x0b\n\x03\x04a\x01\x12\x04\xb2\x0b\x08\x12\n\x0c\n\x04\x04a\
    \x02\0\x12\x04\xb3\x0b\x04\x1c\n\r\n\x05\x04a\x02\0\x04\x12\x04\xb3\x0b\
    \x04\x0c\n\r\n\x05\x04a\x02\0\x05\x12\x04\xb3\x0b\r\x12\n\r\n\x05\x04a\
    \x02\0\x01\x12\x04\xb3\x0b\x13\x17\n\r\n\x05\x04a\x02\0\x03\x12\x04\xb3\
    \x0b\x1a\x1b\n\x0c\n\x02\x04b\x12\x06\xb6\x0b\0\xbb\x0b\x01\n\x0b\n\x03\
    \x04b\x01\x12\x04\xb6\x0b\x08\x15\n\x0c\n\x04\x04b\x02\0\x12\x04\xb7\x0b\
    \x04&\n\r\n\x05\x04b\x02\0\x04\x12\x04\xb7\x0b\x04\x0c\n\r\n\x05\x04b\
    \x02\0\x06\x12\x04\xb7\x0b\r\x19\n\r\n\x05\x04b\x02\0\x01\x12\x04\xb7\
    \x0b\x1a!\n\r\n\x05\x04b\x02\0\x03\x12\x04\xb7\x0b$%\n\x0c\n\x04\x04b\
    \x02\x01\x12\x04\xb8\x0b\x04%\n\r\n\x05\x04b\x02\x01\x04\x12\x04\xb8\x0b\
    \x04\x0c\n\r\n\x05\x04b\x02\x01\x06\x12\x04\xb8\x0b\r\x18\n\r\n\x05\x04b\
    \x02\x01\x01\x12\x04\xb8\x0b\x19\x20\n\r\n\x05\x04b\x02\x01\x03\x12\x04\
    \xb8\x0b#$\n\x0c\n\x04\x04b\x02\x02\x12\x04\xb9\x0b\x04\x1b\n\r\n\x05\
    \x04b\x02\x02\x04\x12\x04\xb9\x0b\x04\x0c\n\r\n\x05\x04b\x02\x02\x05\x12\
    \x04\xb9\x0b\r\x12\n\r\n\x05\x04b\x02\x02\x01\x12\x04\xb9\x0b\x13\x16\n\
    \r\n\x05\x04b\x02\x02\x03\x12\x04\xb9\x0b\x19\x1a\n\x0c\n\x04\x04b\x02\
    \x03\x12\x04\xba\x0b\x04\x1d\n\r\n\x05\x04b\x02\x03\x04\x12\x04\xba\x0b\
    \x04\x0c\n\r\n\x05\x04b\x02\x03\x06\x12\x04\xba\x0b\r\x12\n\r\n\x05\x04b\
    \x02\x03\x01\x12\x04\xba\x0b\x13\x18\n\r\n\x05\x04b\x02\x03\x03\x12\x04\
    \xba\x0b\x1b\x1c\n\x0c\n\x02\x04c\x12\x06\xbd\x0b\0\xc1\x0b\x01\n\x0b\n\
    \x03\x04c\x01\x12\x04\xbd\x0b\x08\x13\n\x0c\n\x04\x04c\x02\0\x12\x04\xbe\
    \x0b\x04\"\n\r\n\x05\x04c\x02\0\x04\x12\x04\xbe\x0b\x04\x0c\n\r\n\x05\
    \x04c\x02\0\x06\x12\x04\xbe\x0b\r\x17\n\r\n\x05\x04c\x02\0\x01\x12\x04\
    \xbe\x0b\x18\x1d\n\r\n\x05\x04c\x02\0\x03\x12\x04\xbe\x0b\x20!\n\x0c\n\
    \x04\x04c\x02\x01\x12\x04\xbf\x0b\x04\"\n\r\n\x05\x04c\x02\x01\x04\x12\
    \x04\xbf\x0b\x04\x0c\n\r\n\x05\x04c\x02\x01\x06\x12\x04\xbf\x0b\r\x17\n\
    \r\n\x05\x04c\x02\x01\x01\x12\x04\xbf\x0b\x18\x1d\n\r\n\x05\x04c\x02\x01\
    \x03\x12\x04\xbf\x0b\x20!\n\x0c\n\x04\x04c\x02\x02\x12\x04\xc0\x0b\x04\
    \x1d\n\r\n\x05\x04c\x02\x02\x04\x12\x04\xc0\x0b\x04\x0c\n\r\n\x05\x04c\
    \x02\x02\x06\x12\x04\xc0\x0b\r\x12\n\r\n\x05\x04c\x02\x02\x01\x12\x04\
    \xc0\x0b\x13\x18\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xc0\x0b\x1b\x1c\n\
    \x0c\n\x02\x04d\x12\x06\xc3\x0b\0\xcc\x0b\x01\n\x0b\n\x03\x04d\x01\x12\
    \x04\xc3\x0b\x08\x12\n\x0c\n\x04\x04d\x02\0\x12\x04\xc4\x0b\x04&\n\r\n\
    \x05\x04d\x02\0\x04\x12\x04\xc4\x0b\x04\x0c\n\r\n\x05\x04d\x02\0\x06\x12\
    \x04\xc4\x0b\r\x19\n\r\n\x05\x04d\x02\0\x01\x12\x04\xc4\x0b\x1a!\n\r\n\
    \x05\x04d\x02\0\x03\x12\x04\xc4\x0b$%\n\x0c\n\x04\x04d\x02\x01\x12\x04\
    \xc5\x0b\x04)\n\r\n\x05\x04d\x02\x01\x04\x12\x04\xc5\x0b\x04\x0c\n\r\n\
    \x05\x04d\x02\x01\x06\x12\x04\xc5\x0b\r\x1a\n\r\n\x05\x04d\x02\x01\x01\
    \x12\x04\xc5\x0b\x1b$\n\r\n\x05\x04d\x02\x01\x03\x12\x04\xc5\x0b'(\n\x0c\
    \n\x04\x04d\x02\x02\x12\x04\xc6\x0b\x049\n\r\n\x05\x04d\x02\x02\x04\x12\
    \x04\xc6\x0b\x04\x0c\n\r\n\x05\x04d\x02\x02\x06\x12\x04\xc6\x0b\r\"\n\r\
    \n\x05\x04d\x02\x02\x01\x12\x04\xc6\x0b#4\n\r\n\x05\x04d\x02\x02\x03\x12\
    \x04\xc6\x0b78\n\x0c\n\x04\x04d\x02\x03\x12\x04\xc7\x0b\x04#\n\r\n\x05\
    \x04d\x02\x03\x04\x12\x04\xc7\x0b\x04\x0c\n\r\n\x05\x04d\x02\x03\x05\x12\
    \x04\xc7\x0b\r\x12\n\r\n\x05\x04d\x02\x03\x01\x12\x04\xc7\x0b\x13\x1e\n\
    \r\n\x05\x04d\x02\x03\x03\x12\x04\xc7\x0b!\"\n\x0c\n\x04\x04d\x02\x04\
    \x12\x04\xc8\x0b\x04\x20\n\r\n\x05\x04d\x02\x04\x04\x12\x04\xc8\x0b\x04\
    \x0c\n\r\n\x05\x04d\x02\x04\x05\x12\x04\xc8\x0b\r\x12\n\r\n\x05\x04d\x02\
    \x04\x01\x12\x04\xc8\x0b\x13\x1b\n\r\n\x05\x04d\x02\x04\x03\x12\x04\xc8\
    \x0b\x1e\x1f\n\x0c\n\x04\x04d\x02\x05\x12\x04\xc9\x0b\x04\x1d\n\r\n\x05\
    \x04d\x02\x05\x04\x12\x04\xc9\x0b\x04\x0c\n\r\n\x05\x04d\x02\x05\x06\x12\
    \x04\xc9\x0b\r\x12\n\r\n\x05\x04d\x02\x05\x01\x12\x04\xc9\x0b\x13\x18\n\
    \r\n\x05\x04d\x02\x05\x03\x12\x04\xc9\x0b\x1b\x1c\n\x0c\n\x04\x04d\x02\
    \x06\x12\x04\xca\x0b\x04#\n\r\n\x05\x04d\x02\x06\x04\x12\x04\xca\x0b\x04\
    \x0c\n\r\n\x05\x04d\x02\x06\x06\x12\x04\xca\x0b\r\x15\n\r\n\x05\x04d\x02\
    \x06\x01\x12\x04\xca\x0b\x16\x1e\n\r\n\x05\x04d\x02\x06\x03\x12\x04\xca\
    \x0b!\"\n\x0c\n\x04\x04d\x02\x07\x12\x04\xcb\x0b\x04$\n\r\n\x05\x04d\x02\
    \x07\x04\x12\x04\xcb\x0b\x04\x0c\n\r\n\x05\x04d\x02\x07\x05\x12\x04\xcb\
    \x0b\r\x13\n\r\n\x05\x04d\x02\x07\x01\x12\x04\xcb\x0b\x14\x1f\n\r\n\x05\
    \x04d\x02\x07\x03\x12\x04\xcb\x0b\"#\n\x0c\n\x02\x04e\x12\x06\xce\x0b\0\
    \xd0\x0b\x01\n\x0b\n\x03\x04e\x01\x12\x04\xce\x0b\x08\x16\n\x0c\n\x04\
    \x04e\x02\0\x12\x04\xcf\x0b\x04)\n\r\n\x05\x04e\x02\0\x04\x12\x04\xcf\
    \x0b\x04\x0c\n\r\n\x05\x04e\x02\0\x06\x12\x04\xcf\x0b\r\x1a\n\r\n\x05\
    \x04e\x02\0\x01\x12\x04\xcf\x0b\x1b$\n\r\n\x05\x04e\x02\0\x03\x12\x04\
    \xcf\x0b'(\n\x0c\n\x02\x04f\x12\x06\xd2\x0b\0\xd9\x0b\x01\n\x0b\n\x03\
    \x04f\x01\x12\x04\xd2\x0b\x08\x15\n\x0e\n\x04\x04f\x04\0\x12\x06\xd3\x0b\
    \x04\xd6\x0b\x05\n\r\n\x05\x04f\x04\0\x01\x12\x04\xd3\x0b\t\x17\n\x0e\n\
    \x06\x04f\x04\0\x02\0\x12\x04\xd4\x0b\x08\x10\n\x0f\n\x07\x04f\x04\0\x02\
    \0\x01\x12\x04\xd4\x0b\x08\x0b\n\x0f\n\x07\x04f\x04\0\x02\0\x02\x12\x04\
    \xd4\x0b\x0e\x0f\n\x0e\n\x06\x04f\x04\0\x02\x01\x12\x04\xd5\x0b\x08\x13\
    \n\x0f\n\x07\x04f\x04\0\x02\x01\x01\x12\x04\xd5\x0b\x08\x0e\n\x0f\n\x07\
    \x04f\x04\0\x02\x01\x02\x12\x04\xd5\x0b\x11\x12\n\x0c\n\x04\x04f\x02\0\
    \x12\x04\xd7\x0b\x04*\n\r\n\x05\x04f\x02\0\x04\x12\x04\xd7\x0b\x04\x0c\n\
    \r\n\x05\x04f\x02\0\x06\x12\x04\xd7\x0b\r\x1b\n\r\n\x05\x04f\x02\0\x01\
    \x12\x04\xd7\x0b\x1c%\n\r\n\x05\x04f\x02\0\x03\x12\x04\xd7\x0b()\n\x0c\n\
    \x04\x04f\x02\x01\x12\x04\xd8\x0b\x04$\n\r\n\x05\x04f\x02\x01\x04\x12\
    \x04\xd8\x0b\x04\x0c\n\r\n\x05\x04f\x02\x01\x06\x12\x04\xd8\x0b\r\x18\n\
    \r\n\x05\x04f\x02\x01\x01\x12\x04\xd8\x0b\x19\x1f\n\r\n\x05\x04f\x02\x01\
    \x03\x12\x04\xd8\x0b\"#\n\x0c\n\x02\x04g\x12\x06\xdb\x0b\0\xdd\x0b\x01\n\
    \x0b\n\x03\x04g\x01\x12\x04\xdb\x0b\x08\x12\n\x0c\n\x04\x04g\x02\0\x12\
    \x04\xdc\x0b\x04\x1c\n\r\n\x05\x04g\x02\0\x04\x12\x04\xdc\x0b\x04\x0c\n\
    \r\n\x05\x04g\x02\0\x05\x12\x04\xdc\x0b\r\x12\n\r\n\x05\x04g\x02\0\x01\
    \x12\x04\xdc\x0b\x13\x17\n\r\n\x05\x04g\x02\0\x03\x12\x04\xdc\x0b\x1a\
    \x1b\n\x0c\n\x02\x04h\x12\x06\xdf\x0b\0\xe1\x0b\x01\n\x0b\n\x03\x04h\x01\
    \x12\x04\xdf\x0b\x08\r\n\x0c\n\x04\x04h\x02\0\x12\x04\xe0\x0b\x04\x1a\n\
    \r\n\x05\x04h\x02\0\x04\x12\x04\xe0\x0b\x04\x0c\n\r\n\x05\x04h\x02\0\x05\
    \x12\x04\xe0\x0b\r\x12\n\r\n\x05\x04h\x02\0\x01\x12\x04\xe0\x0b\x13\x15\
    \n\r\n\x05\x04h\x02\0\x03\x12\x04\xe0\x0b\x18\x19\n\x0c\n\x02\x04i\x12\
    \x06\xe3\x0b\0\xea\x0b\x01\n\x0b\n\x03\x04i\x01\x12\x04\xe3\x0b\x08\x1d\
    \n\x0c\n\x04\x04i\x02\0\x12\x04\xe4\x0b\x04\x20\n\r\n\x05\x04i\x02\0\x04\
    \x12\x04\xe4\x0b\x04\x0c\n\r\n\x05\x04i\x02\0\x05\x12\x04\xe4\x0b\r\x12\
    \n\r\n\x05\x04i\x02\0\x01\x12\x04\xe4\x0b\x13\x1b\n\r\n\x05\x04i\x02\0\
    \x03\x12\x04\xe4\x0b\x1e\x1f\n\x0c\n\x04\x04i\x02\x01\x12\x04\xe5\x0b\
    \x04#\n\r\n\x05\x04i\x02\x01\x04\x12\x04\xe5\x0b\x04\x0c\n\r\n\x05\x04i\
    \x02\x01\x05\x12\x04\xe5\x0b\r\x13\n\r\n\x05\x04i\x02\x01\x01\x12\x04\
    \xe5\x0b\x14\x1e\n\r\n\x05\x04i\x02\x01\x03\x12\x04\xe5\x0b!\"\n\x0c\n\
    \x04\x04i\x02\x02\x12\x04\xe6\x0b\x04\x1f\n\r\n\x05\x04i\x02\x02\x04\x12\
    \x04\xe6\x0b\x04\x0c\n\r\n\x05\x04i\x02\x02\x05\x12\x04\xe6\x0b\r\x13\n\
    \r\n\x05\x04i\x02\x02\x01\x12\x04\xe6\x0b\x14\x1a\n\r\n\x05\x04i\x02\x02\
    \x03\x12\x04\xe6\x0b\x1d\x1e\n\x0c\n\x04\x04i\x02\x03\x12\x04\xe7\x0b\
    \x04&\n\r\n\x05\x04i\x02\x03\x04\x12\x04\xe7\x0b\x04\x0c\n\r\n\x05\x04i\
    \x02\x03\x05\x12\x04\xe7\x0b\r\x13\n\r\n\x05\x04i\x02\x03\x01\x12\x04\
    \xe7\x0b\x14!\n\r\n\x05\x04i\x02\x03\x03\x12\x04\xe7\x0b$%\n\x0c\n\x04\
    \x04i\x02\x04\x12\x04\xe8\x0b\x04\"\n\r\n\x05\x04i\x02\x04\x04\x12\x04\
    \xe8\x0b\x04\x0c\n\r\n\x05\x04i\x02\x04\x05\x12\x04\xe8\x0b\r\x12\n\r\n\
    \x05\x04i\x02\x04\x01\x12\x04\xe8\x0b\x13\x1d\n\r\n\x05\x04i\x02\x04\x03\
    \x12\x04\xe8\x0b\x20!\n\x0c\n\x04\x04i\x02\x05\x12\x04\xe9\x0b\x04%\n\r\
    \n\x05\x04i\x02\x05\x04\x12\x04\xe9\x0b\x04\x0c\n\r\n\x05\x04i\x02\x05\
    \x05\x12\x04\xe9\x0b\r\x12\n\r\n\x05\x04i\x02\x05\x01\x12\x04\xe9\x0b\
    \x13\x20\n\r\n\x05\x04i\x02\x05\x03\x12\x04\xe9\x0b#$\n\x0c\n\x02\x04j\
    \x12\x06\xec\x0b\0\xef\x0b\x01\n\x0b\n\x03\x04j\x01\x12\x04\xec\x0b\x08\
    \x10\n\x0c\n\x04\x04j\x02\0\x12\x04\xed\x0b\x04\x1d\n\r\n\x05\x04j\x02\0\
    \x04\x12\x04\xed\x0b\x04\x0c\n\r\n\x05\x04j\x02\0\x05\x12\x04\xed\x0b\r\
    \x13\n\r\n\x05\x04j\x02\0\x01\x12\x04\xed\x0b\x14\x18\n\r\n\x05\x04j\x02\
    \0\x03\x12\x04\xed\x0b\x1b\x1c\n\x0c\n\x04\x04j\x02\x01\x12\x04\xee\x0b\
    \x04\x1d\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xee\x0b\x04\x0c\n\r\n\x05\
    \x04j\x02\x01\x05\x12\x04\xee\x0b\r\x13\n\r\n\x05\x04j\x02\x01\x01\x12\
    \x04\xee\x0b\x14\x18\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xee\x0b\x1b\x1c\
    \n\x0c\n\x02\x04k\x12\x06\xf1\x0b\0\x92\x0c\x01\n\x0b\n\x03\x04k\x01\x12\
    \x04\xf1\x0b\x08\x17\n\x0c\n\x04\x04k\x02\0\x12\x04\xf2\x0b\x04!\n\r\n\
    \x05\x04k\x02\0\x04\x12\x04\xf2\x0b\x04\x0c\n\r\n\x05\x04k\x02\0\x05\x12\
    \x04\xf2\x0b\r\x12\n\r\n\x05\x04k\x02\0\x01\x12\x04\xf2\x0b\x13\x1c\n\r\
    \n\x05\x04k\x02\0\x03\x12\x04\xf2\x0b\x1f\x20\n\x0c\n\x04\x04k\x02\x01\
    \x12\x04\xf3\x0b\x04'\n\r\n\x05\x04k\x02\x01\x04\x12\x04\xf3\x0b\x04\x0c\
    \n\r\n\x05\x04k\x02\x01\x06\x12\x04\xf3\x0b\r\x17\n\r\n\x05\x04k\x02\x01\
    \x01\x12\x04\xf3\x0b\x18\"\n\r\n\x05\x04k\x02\x01\x03\x12\x04\xf3\x0b%&\
    \n\x0c\n\x04\x04k\x02\x02\x12\x04\xf4\x0b\x04-\n\r\n\x05\x04k\x02\x02\
    \x04\x12\x04\xf4\x0b\x04\x0c\n\r\n\x05\x04k\x02\x02\x06\x12\x04\xf4\x0b\
    \r\x1a\n\r\n\x05\x04k\x02\x02\x01\x12\x04\xf4\x0b\x1b(\n\r\n\x05\x04k\
    \x02\x02\x03\x12\x04\xf4\x0b+,\n\x0c\n\x04\x04k\x02\x03\x12\x04\xf5\x0b\
    \x04'\n\r\n\x05\x04k\x02\x03\x04\x12\x04\xf5\x0b\x04\x0c\n\r\n\x05\x04k\
    \x02\x03\x06\x12\x04\xf5\x0b\r\x17\n\r\n\x05\x04k\x02\x03\x01\x12\x04\
    \xf5\x0b\x18\"\n\r\n\x05\x04k\x02\x03\x03\x12\x04\xf5\x0b%&\n\x0c\n\x04\
    \x04k\x02\x04\x12\x04\xf6\x0b\x04%\n\r\n\x05\x04k\x02\x04\x04\x12\x04\
    \xf6\x0b\x04\x0c\n\r\n\x05\x04k\x02\x04\x06\x12\x04\xf6\x0b\r\x16\n\r\n\
    \x05\x04k\x02\x04\x01\x12\x04\xf6\x0b\x17\x20\n\r\n\x05\x04k\x02\x04\x03\
    \x12\x04\xf6\x0b#$\n\x0c\n\x04\x04k\x02\x05\x12\x04\xf7\x0b\x04I\n\r\n\
    \x05\x04k\x02\x05\x04\x12\x04\xf7\x0b\x04\x0c\n\r\n\x05\x04k\x02\x05\x06\
    \x12\x04\xf7\x0b\r(\n\r\n\x05\x04k\x02\x05\x01\x12\x04\xf7\x0b)D\n\r\n\
    \x05\x04k\x02\x05\x03\x12\x04\xf7\x0bGH\n\x0c\n\x04\x04k\x02\x06\x12\x04\
    \xf8\x0b\x041\n\r\n\x05\x04k\x02\x06\x04\x12\x04\xf8\x0b\x04\x0c\n\r\n\
    \x05\x04k\x02\x06\x06\x12\x04\xf8\x0b\r\x1c\n\r\n\x05\x04k\x02\x06\x01\
    \x12\x04\xf8\x0b\x1d,\n\r\n\x05\x04k\x02\x06\x03\x12\x04\xf8\x0b/0\n\x0c\
    \n\x04\x04k\x02\x07\x12\x04\xf9\x0b\x043\n\r\n\x05\x04k\x02\x07\x04\x12\
    \x04\xf9\x0b\x04\x0c\n\r\n\x05\x04k\x02\x07\x06\x12\x04\xf9\x0b\r\x1d\n\
    \r\n\x05\x04k\x02\x07\x01\x12\x04\xf9\x0b\x1e.\n\r\n\x05\x04k\x02\x07\
    \x03\x12\x04\xf9\x0b12\n\x0c\n\x04\x04k\x02\x08\x12\x04\xfa\x0b\x04D\n\r\
    \n\x05\x04k\x02\x08\x04\x12\x04\xfa\x0b\x04\x0c\n\r\n\x05\x04k\x02\x08\
    \x06\x12\x04\xfa\x0b\r%\n\r\n\x05\x04k\x02\x08\x01\x12\x04\xfa\x0b&>\n\r\
    \n\x05\x04k\x02\x08\x03\x12\x04\xfa\x0bAC\n\x0c\n\x04\x04k\x02\t\x12\x04\
    \xfb\x0b\x042\n\r\n\x05\x04k\x02\t\x04\x12\x04\xfb\x0b\x04\x0c\n\r\n\x05\
    \x04k\x02\t\x06\x12\x04\xfb\x0b\r\x1c\n\r\n\x05\x04k\x02\t\x01\x12\x04\
    \xfb\x0b\x1d,\n\r\n\x05\x04k\x02\t\x03\x12\x04\xfb\x0b/1\n\x0c\n\x04\x04\
    k\x02\n\x12\x04\xfc\x0b\x04@\n\r\n\x05\x04k\x02\n\x04\x12\x04\xfc\x0b\
    \x04\x0c\n\r\n\x05\x04k\x02\n\x06\x12\x04\xfc\x0b\r#\n\r\n\x05\x04k\x02\
    \n\x01\x12\x04\xfc\x0b$:\n\r\n\x05\x04k\x02\n\x03\x12\x04\xfc\x0b=?\n\
    \x0c\n\x04\x04k\x02\x0b\x12\x04\xfd\x0b\x04.\n\r\n\x05\x04k\x02\x0b\x04\
    \x12\x04\xfd\x0b\x04\x0c\n\r\n\x05\x04k\x02\x0b\x06\x12\x04\xfd\x0b\r\
    \x1a\n\r\n\x05\x04k\x02\x0b\x01\x12\x04\xfd\x0b\x1b(\n\r\n\x05\x04k\x02\
    \x0b\x03\x12\x04\xfd\x0b+-\n\x0c\n\x04\x04k\x02\x0c\x12\x04\xfe\x0b\x046\
    \n\r\n\x05\x04k\x02\x0c\x04\x12\x04\xfe\x0b\x04\x0c\n\r\n\x05\x04k\x02\
    \x0c\x06\x12\x04\xfe\x0b\r\x1e\n\r\n\x05\x04k\x02\x0c\x01\x12\x04\xfe\
    \x0b\x1f0\n\r\n\x05\x04k\x02\x0c\x03\x12\x04\xfe\x0b35\n\x0c\n\x04\x04k\
    \x02\r\x12\x04\xff\x0b\x04D\n\r\n\x05\x04k\x02\r\x04\x12\x04\xff\x0b\x04\
    \x0c\n\r\n\x05\x04k\x02\r\x06\x12\x04\xff\x0b\r%\n\r\n\x05\x04k\x02\r\
    \x01\x12\x04\xff\x0b&>\n\r\n\x05\x04k\x02\r\x03\x12\x04\xff\x0bAC\n\x0c\
    \n\x04\x04k\x02\x0e\x12\x04\x80\x0c\x04.\n\r\n\x05\x04k\x02\x0e\x04\x12\
    \x04\x80\x0c\x04\x0c\n\r\n\x05\x04k\x02\x0e\x06\x12\x04\x80\x0c\r\x1a\n\
    \r\n\x05\x04k\x02\x0e\x01\x12\x04\x80\x0c\x1b(\n\r\n\x05\x04k\x02\x0e\
    \x03\x12\x04\x80\x0c+-\n\x0c\n\x04\x04k\x02\x0f\x12\x04\x81\x0c\x04<\n\r\
    \n\x05\x04k\x02\x0f\x04\x12\x04\x81\x0c\x04\x0c\n\r\n\x05\x04k\x02\x0f\
    \x06\x12\x04\x81\x0c\r!\n\r\n\x05\x04k\x02\x0f\x01\x12\x04\x81\x0c\"6\n\
    \r\n\x05\x04k\x02\x0f\x03\x12\x04\x81\x0c9;\n\x0c\n\x04\x04k\x02\x10\x12\
    \x04\x82\x0c\x042\n\r\n\x05\x04k\x02\x10\x04\x12\x04\x82\x0c\x04\x0c\n\r\
    \n\x05\x04k\x02\x10\x06\x12\x04\x82\x0c\r\x1c\n\r\n\x05\x04k\x02\x10\x01\
    \x12\x04\x82\x0c\x1d,\n\r\n\x05\x04k\x02\x10\x03\x12\x04\x82\x0c/1\n\x0c\
    \n\x04\x04k\x02\x11\x12\x04\x83\x0c\x044\n\r\n\x05\x04k\x02\x11\x04\x12\
    \x04\x83\x0c\x04\x0c\n\r\n\x05\x04k\x02\x11\x06\x12\x04\x83\x0c\r\x1d\n\
    \r\n\x05\x04k\x02\x11\x01\x12\x04\x83\x0c\x1e.\n\r\n\x05\x04k\x02\x11\
    \x03\x12\x04\x83\x0c13\n\x0c\n\x04\x04k\x02\x12\x12\x04\x84\x0c\x04>\n\r\
    \n\x05\x04k\x02\x12\x04\x12\x04\x84\x0c\x04\x0c\n\r\n\x05\x04k\x02\x12\
    \x06\x12\x04\x84\x0c\r\"\n\r\n\x05\x04k\x02\x12\x01\x12\x04\x84\x0c#8\n\
    \r\n\x05\x04k\x02\x12\x03\x12\x04\x84\x0c;=\n\x0c\n\x04\x04k\x02\x13\x12\
    \x04\x85\x0c\x040\n\r\n\x05\x04k\x02\x13\x04\x12\x04\x85\x0c\x04\x0c\n\r\
    \n\x05\x04k\x02\x13\x06\x12\x04\x85\x0c\r\x1b\n\r\n\x05\x04k\x02\x13\x01\
    \x12\x04\x85\x0c\x1c*\n\r\n\x05\x04k\x02\x13\x03\x12\x04\x85\x0c-/\n\x0c\
    \n\x04\x04k\x02\x14\x12\x04\x86\x0c\x04F\n\r\n\x05\x04k\x02\x14\x04\x12\
    \x04\x86\x0c\x04\x0c\n\r\n\x05\x04k\x02\x14\x06\x12\x04\x86\x0c\r&\n\r\n\
    \x05\x04k\x02\x14\x01\x12\x04\x86\x0c'@\n\r\n\x05\x04k\x02\x14\x03\x12\
    \x04\x86\x0cCE\n\x0c\n\x04\x04k\x02\x15\x12\x04\x87\x0c\x04*\n\r\n\x05\
    \x04k\x02\x15\x04\x12\x04\x87\x0c\x04\x0c\n\r\n\x05\x04k\x02\x15\x06\x12\
    \x04\x87\x0c\r\x18\n\r\n\x05\x04k\x02\x15\x01\x12\x04\x87\x0c\x19$\n\r\n\
    \x05\x04k\x02\x15\x03\x12\x04\x87\x0c')\n\x0c\n\x04\x04k\x02\x16\x12\x04\
    \x88\x0c\x048\n\r\n\x05\x04k\x02\x16\x04\x12\x04\x88\x0c\x04\x0c\n\r\n\
    \x05\x04k\x02\x16\x06\x12\x04\x88\x0c\r\x1f\n\r\n\x05\x04k\x02\x16\x01\
    \x12\x04\x88\x0c\x202\n\r\n\x05\x04k\x02\x16\x03\x12\x04\x88\x0c57\n\x0c\
    \n\x04\x04k\x02\x17\x12\x04\x89\x0c\x04<\n\r\n\x05\x04k\x02\x17\x04\x12\
    \x04\x89\x0c\x04\x0c\n\r\n\x05\x04k\x02\x17\x06\x12\x04\x89\x0c\r!\n\r\n\
    \x05\x04k\x02\x17\x01\x12\x04\x89\x0c\"6\n\r\n\x05\x04k\x02\x17\x03\x12\
    \x04\x89\x0c9;\n\x0c\n\x04\x04k\x02\x18\x12\x04\x8a\x0c\x044\n\r\n\x05\
    \x04k\x02\x18\x04\x12\x04\x8a\x0c\x04\x0c\n\r\n\x05\x04k\x02\x18\x06\x12\
    \x04\x8a\x0c\r\x1d\n\r\n\x05\x04k\x02\x18\x01\x12\x04\x8a\x0c\x1e.\n\r\n\
    \x05\x04k\x02\x18\x03\x12\x04\x8a\x0c13\n\x0c\n\x04\x04k\x02\x19\x12\x04\
    \x8b\x0c\x04&\n\r\n\x05\x04k\x02\x19\x04\x12\x04\x8b\x0c\x04\x0c\n\r\n\
    \x05\x04k\x02\x19\x06\x12\x04\x8b\x0c\r\x16\n\r\n\x05\x04k\x02\x19\x01\
    \x12\x04\x8b\x0c\x17\x20\n\r\n\x05\x04k\x02\x19\x03\x12\x04\x8b\x0c#%\n\
    \x0c\n\x04\x04k\x02\x1a\x12\x04\x8c\x0c\x04<\n\r\n\x05\x04k\x02\x1a\x04\
    \x12\x04\x8c\x0c\x04\x0c\n\r\n\x05\x04k\x02\x1a\x06\x12\x04\x8c\x0c\r!\n\
    \r\n\x05\x04k\x02\x1a\x01\x12\x04\x8c\x0c\"6\n\r\n\x05\x04k\x02\x1a\x03\
    \x12\x04\x8c\x0c9;\n\x0c\n\x04\x04k\x02\x1b\x12\x04\x8d\x0c\x04.\n\r\n\
    \x05\x04k\x02\x1b\x04\x12\x04\x8d\x0c\x04\x0c\n\r\n\x05\x04k\x02\x1b\x06\
    \x12\x04\x8d\x0c\r\x1a\n\r\n\x05\x04k\x02\x1b\x01\x12\x04\x8d\x0c\x1b(\n\
    \r\n\x05\x04k\x02\x1b\x03\x12\x04\x8d\x0c+-\n\x0c\n\x04\x04k\x02\x1c\x12\
    \x04\x8e\x0c\x04F\n\r\n\x05\x04k\x02\x1c\x04\x12\x04\x8e\x0c\x04\x0c\n\r\
    \n\x05\x04k\x02\x1c\x06\x12\x04\x8e\x0c\r&\n\r\n\x05\x04k\x02\x1c\x01\
    \x12\x04\x8e\x0c'@\n\r\n\x05\x04k\x02\x1c\x03\x12\x04\x8e\x0cCE\n\x0c\n\
    \x04\x04k\x02\x1d\x12\x04\x8f\x0c\x046\n\r\n\x05\x04k\x02\x1d\x04\x12\
    \x04\x8f\x0c\x04\x0c\n\r\n\x05\x04k\x02\x1d\x06\x12\x04\x8f\x0c\r!\n\r\n\
    \x05\x04k\x02\x1d\x01\x12\x04\x8f\x0c\"0\n\r\n\x05\x04k\x02\x1d\x03\x12\
    \x04\x8f\x0c35\n\x0c\n\x04\x04k\x02\x1e\x12\x04\x90\x0c\x04N\n\r\n\x05\
    \x04k\x02\x1e\x04\x12\x04\x90\x0c\x04\x0c\n\r\n\x05\x04k\x02\x1e\x06\x12\
    \x04\x90\x0c\r-\n\r\n\x05\x04k\x02\x1e\x01\x12\x04\x90\x0c.H\n\r\n\x05\
    \x04k\x02\x1e\x03\x12\x04\x90\x0cKM\n\x0c\n\x04\x04k\x02\x1f\x12\x04\x91\
    \x0c\x048\n\r\n\x05\x04k\x02\x1f\x04\x12\x04\x91\x0c\x04\x0c\n\r\n\x05\
    \x04k\x02\x1f\x06\x12\x04\x91\x0c\r\x1f\n\r\n\x05\x04k\x02\x1f\x01\x12\
    \x04\x91\x0c\x202\n\r\n\x05\x04k\x02\x1f\x03\x12\x04\x91\x0c57\n\x0c\n\
    \x02\x04l\x12\x06\x94\x0c\0\x96\x0c\x01\n\x0b\n\x03\x04l\x01\x12\x04\x94\
    \x0c\x08\x1c\n\x0c\n\x04\x04l\x02\0\x12\x04\x95\x0c\x04\x1c\n\r\n\x05\
    \x04l\x02\0\x04\x12\x04\x95\x0c\x04\x0c\n\r\n\x05\x04l\x02\0\x05\x12\x04\
    \x95\x0c\r\x11\n\r\n\x05\x04l\x02\0\x01\x12\x04\x95\x0c\x12\x17\n\r\n\
    \x05\x04l\x02\0\x03\x12\x04\x95\x0c\x1a\x1b\n\x0c\n\x02\x04m\x12\x06\x98\
    \x0c\0\x9a\x0c\x01\n\x0b\n\x03\x04m\x01\x12\x04\x98\x0c\x08\x1d\n\x0c\n\
    \x04\x04m\x02\0\x12\x04\x99\x0c\x04%\n\r\n\x05\x04m\x02\0\x04\x12\x04\
    \x99\x0c\x04\x0c\n\r\n\x05\x04m\x02\0\x05\x12\x04\x99\x0c\r\x11\n\r\n\
    \x05\x04m\x02\0\x01\x12\x04\x99\x0c\x12\x20\n\r\n\x05\x04m\x02\0\x03\x12\
    \x04\x99\x0c#$\n\x0c\n\x02\x04n\x12\x06\x9c\x0c\0\x9e\x0c\x01\n\x0b\n\
    \x03\x04n\x01\x12\x04\x9c\x0c\x08\x18\n\x0c\n\x04\x04n\x02\0\x12\x04\x9d\
    \x0c\x044\n\r\n\x05\x04n\x02\0\x04\x12\x04\x9d\x0c\x04\x0c\n\r\n\x05\x04\
    n\x02\0\x05\x12\x04\x9d\x0c\r\x11\n\r\n\x05\x04n\x02\0\x01\x12\x04\x9d\
    \x0c\x12/\n\r\n\x05\x04n\x02\0\x03\x12\x04\x9d\x0c23\n\x0c\n\x02\x04o\
    \x12\x06\xa0\x0c\0\xa3\x0c\x01\n\x0b\n\x03\x04o\x01\x12\x04\xa0\x0c\x08\
    \x19\n\x0c\n\x04\x04o\x02\0\x12\x04\xa1\x0c\x04\x20\n\r\n\x05\x04o\x02\0\
    \x04\x12\x04\xa1\x0c\x04\x0c\n\r\n\x05\x04o\x02\0\x06\x12\x04\xa1\x0c\r\
    \x17\n\r\n\x05\x04o\x02\0\x01\x12\x04\xa1\x0c\x18\x1b\n\r\n\x05\x04o\x02\
    \0\x03\x12\x04\xa1\x0c\x1e\x1f\n\x0c\n\x04\x04o\x02\x01\x12\x04\xa2\x0c\
    \x04!\n\r\n\x05\x04o\x02\x01\x04\x12\x04\xa2\x0c\x04\x0c\n\r\n\x05\x04o\
    \x02\x01\x05\x12\x04\xa2\x0c\r\x12\n\r\n\x05\x04o\x02\x01\x01\x12\x04\
    \xa2\x0c\x13\x1c\n\r\n\x05\x04o\x02\x01\x03\x12\x04\xa2\x0c\x1f\x20\n\
    \x0c\n\x02\x04p\x12\x06\xa5\x0c\0\xa9\x0c\x01\n\x0b\n\x03\x04p\x01\x12\
    \x04\xa5\x0c\x08\x1e\n\x0c\n\x04\x04p\x02\0\x12\x04\xa6\x0c\x04,\n\r\n\
    \x05\x04p\x02\0\x04\x12\x04\xa6\x0c\x04\x0c\n\r\n\x05\x04p\x02\0\x05\x12\
    \x04\xa6\x0c\r\x12\n\r\n\x05\x04p\x02\0\x01\x12\x04\xa6\x0c\x13'\n\r\n\
    \x05\x04p\x02\0\x03\x12\x04\xa6\x0c*+\n\x0c\n\x04\x04p\x02\x01\x12\x04\
    \xa7\x0c\x042\n\r\n\x05\x04p\x02\x01\x04\x12\x04\xa7\x0c\x04\x0c\n\r\n\
    \x05\x04p\x02\x01\x05\x12\x04\xa7\x0c\r\x12\n\r\n\x05\x04p\x02\x01\x01\
    \x12\x04\xa7\x0c\x13-\n\r\n\x05\x04p\x02\x01\x03\x12\x04\xa7\x0c01\n\x0c\
    \n\x04\x04p\x02\x02\x12\x04\xa8\x0c\x04,\n\r\n\x05\x04p\x02\x02\x04\x12\
    \x04\xa8\x0c\x04\x0c\n\r\n\x05\x04p\x02\x02\x06\x12\x04\xa8\x0c\r\x1e\n\
    \r\n\x05\x04p\x02\x02\x01\x12\x04\xa8\x0c\x1f'\n\r\n\x05\x04p\x02\x02\
    \x03\x12\x04\xa8\x0c*+\n\x0c\n\x02\x04q\x12\x06\xab\x0c\0\xaf\x0c\x01\n\
    \x0b\n\x03\x04q\x01\x12\x04\xab\x0c\x08\x1a\n\x0c\n\x04\x04q\x02\0\x12\
    \x04\xac\x0c\x04$\n\r\n\x05\x04q\x02\0\x04\x12\x04\xac\x0c\x04\x0c\n\r\n\
    \x05\x04q\x02\0\x05\x12\x04\xac\x0c\r\x11\n\r\n\x05\x04q\x02\0\x01\x12\
    \x04\xac\x0c\x12\x1f\n\r\n\x05\x04q\x02\0\x03\x12\x04\xac\x0c\"#\n\x0c\n\
    \x04\x04q\x02\x01\x12\x04\xad\x0c\x04%\n\r\n\x05\x04q\x02\x01\x04\x12\
    \x04\xad\x0c\x04\x0c\n\r\n\x05\x04q\x02\x01\x05\x12\x04\xad\x0c\r\x11\n\
    \r\n\x05\x04q\x02\x01\x01\x12\x04\xad\x0c\x12\x20\n\r\n\x05\x04q\x02\x01\
    \x03\x12\x04\xad\x0c#$\n\x0c\n\x04\x04q\x02\x02\x12\x04\xae\x0c\x04&\n\r\
    \n\x05\x04q\x02\x02\x04\x12\x04\xae\x0c\x04\x0c\n\r\n\x05\x04q\x02\x02\
    \x05\x12\x04\xae\x0c\r\x12\n\r\n\x05\x04q\x02\x02\x01\x12\x04\xae\x0c\
    \x13!\n\r\n\x05\x04q\x02\x02\x03\x12\x04\xae\x0c$%\n\x0c\n\x02\x04r\x12\
    \x06\xb1\x0c\0\xbc\x0c\x01\n\x0b\n\x03\x04r\x01\x12\x04\xb1\x0c\x08\x15\
    \n\x0c\n\x04\x04r\x02\0\x12\x04\xb2\x0c\x04\x1c\n\r\n\x05\x04r\x02\0\x04\
    \x12\x04\xb2\x0c\x04\x0c\n\r\n\x05\x04r\x02\0\x05\x12\x04\xb2\x0c\r\x13\
    \n\r\n\x05\x04r\x02\0\x01\x12\x04\xb2\x0c\x14\x17\n\r\n\x05\x04r\x02\0\
    \x03\x12\x04\xb2\x0c\x1a\x1b\n\x0c\n\x04\x04r\x02\x01\x12\x04\xb3\x0c\
    \x04%\n\r\n\x05\x04r\x02\x01\x04\x12\x04\xb3\x0c\x04\x0c\n\r\n\x05\x04r\
    \x02\x01\x05\x12\x04\xb3\x0c\r\x12\n\r\n\x05\x04r\x02\x01\x01\x12\x04\
    \xb3\x0c\x13\x20\n\r\n\x05\x04r\x02\x01\x03\x12\x04\xb3\x0c#$\n\x0c\n\
    \x04\x04r\x02\x02\x12\x04\xb4\x0c\x04\x20\n\r\n\x05\x04r\x02\x02\x04\x12\
    \x04\xb4\x0c\x04\x0c\n\r\n\x05\x04r\x02\x02\x05\x12\x04\xb4\x0c\r\x12\n\
    \r\n\x05\x04r\x02\x02\x01\x12\x04\xb4\x0c\x13\x1b\n\r\n\x05\x04r\x02\x02\
    \x03\x12\x04\xb4\x0c\x1e\x1f\n\x0c\n\x04\x04r\x02\x03\x12\x04\xb5\x0c\
    \x04!\n\r\n\x05\x04r\x02\x03\x04\x12\x04\xb5\x0c\x04\x0c\n\r\n\x05\x04r\
    \x02\x03\x05\x12\x04\xb5\x0c\r\x13\n\r\n\x05\x04r\x02\x03\x01\x12\x04\
    \xb5\x0c\x14\x1c\n\r\n\x05\x04r\x02\x03\x03\x12\x04\xb5\x0c\x1f\x20\n\
    \x0c\n\x04\x04r\x02\x04\x12\x04\xb6\x0c\x04\x1f\n\r\n\x05\x04r\x02\x04\
    \x04\x12\x04\xb6\x0c\x04\x0c\n\r\n\x05\x04r\x02\x04\x05\x12\x04\xb6\x0c\
    \r\x13\n\r\n\x05\x04r\x02\x04\x01\x12\x04\xb6\x0c\x14\x1a\n\r\n\x05\x04r\
    \x02\x04\x03\x12\x04\xb6\x0c\x1d\x1e\n\x0c\n\x04\x04r\x02\x05\x12\x04\
    \xb7\x0c\x04\x1e\n\r\n\x05\x04r\x02\x05\x04\x12\x04\xb7\x0c\x04\x0c\n\r\
    \n\x05\x04r\x02\x05\x05\x12\x04\xb7\x0c\r\x13\n\r\n\x05\x04r\x02\x05\x01\
    \x12\x04\xb7\x0c\x14\x19\n\r\n\x05\x04r\x02\x05\x03\x12\x04\xb7\x0c\x1c\
    \x1d\n\x0c\n\x04\x04r\x02\x06\x12\x04\xb8\x0c\x04#\n\r\n\x05\x04r\x02\
    \x06\x04\x12\x04\xb8\x0c\x04\x0c\n\r\n\x05\x04r\x02\x06\x05\x12\x04\xb8\
    \x0c\r\x13\n\r\n\x05\x04r\x02\x06\x01\x12\x04\xb8\x0c\x14\x1e\n\r\n\x05\
    \x04r\x02\x06\x03\x12\x04\xb8\x0c!\"\n\x0c\n\x04\x04r\x02\x07\x12\x04\
    \xb9\x0c\x04#\n\r\n\x05\x04r\x02\x07\x04\x12\x04\xb9\x0c\x04\x0c\n\r\n\
    \x05\x04r\x02\x07\x05\x12\x04\xb9\x0c\r\x13\n\r\n\x05\x04r\x02\x07\x01\
    \x12\x04\xb9\x0c\x14\x1e\n\r\n\x05\x04r\x02\x07\x03\x12\x04\xb9\x0c!\"\n\
    \x0c\n\x04\x04r\x02\x08\x12\x04\xba\x0c\x04!\n\r\n\x05\x04r\x02\x08\x04\
    \x12\x04\xba\x0c\x04\x0c\n\r\n\x05\x04r\x02\x08\x05\x12\x04\xba\x0c\r\
    \x11\n\r\n\x05\x04r\x02\x08\x01\x12\x04\xba\x0c\x12\x1c\n\r\n\x05\x04r\
    \x02\x08\x03\x12\x04\xba\x0c\x1f\x20\n\x0c\n\x04\x04r\x02\t\x12\x04\xbb\
    \x0c\x04&\n\r\n\x05\x04r\x02\t\x04\x12\x04\xbb\x0c\x04\x0c\n\r\n\x05\x04\
    r\x02\t\x05\x12\x04\xbb\x0c\r\x13\n\r\n\x05\x04r\x02\t\x01\x12\x04\xbb\
    \x0c\x14\x20\n\r\n\x05\x04r\x02\t\x03\x12\x04\xbb\x0c#%\n\x0c\n\x02\x04s\
    \x12\x06\xbe\x0c\0\xc0\x0c\x01\n\x0b\n\x03\x04s\x01\x12\x04\xbe\x0c\x08\
    \x12\n\x0c\n\x04\x04s\x02\0\x12\x04\xbf\x0c\x04\x1e\n\r\n\x05\x04s\x02\0\
    \x04\x12\x04\xbf\x0c\x04\x0c\n\r\n\x05\x04s\x02\0\x05\x12\x04\xbf\x0c\r\
    \x11\n\r\n\x05\x04s\x02\0\x01\x12\x04\xbf\x0c\x12\x19\n\r\n\x05\x04s\x02\
    \0\x03\x12\x04\xbf\x0c\x1c\x1d\n\x0c\n\x02\x04t\x12\x06\xc2\x0c\0\xc4\
    \x0c\x01\n\x0b\n\x03\x04t\x01\x12\x04\xc2\x0c\x08#\n\x0c\n\x04\x04t\x02\
    \0\x12\x04\xc3\x0c\x04'\n\r\n\x05\x04t\x02\0\x04\x12\x04\xc3\x0c\x04\x0c\
    \n\r\n\x05\x04t\x02\0\x05\x12\x04\xc3\x0c\r\x11\n\r\n\x05\x04t\x02\0\x01\
    \x12\x04\xc3\x0c\x12\"\n\r\n\x05\x04t\x02\0\x03\x12\x04\xc3\x0c%&\n\x0c\
    \n\x02\x04u\x12\x06\xc6\x0c\0\xc8\x0c\x01\n\x0b\n\x03\x04u\x01\x12\x04\
    \xc6\x0c\x08!\n\x0c\n\x04\x04u\x02\0\x12\x04\xc7\x0c\x04)\n\r\n\x05\x04u\
    \x02\0\x04\x12\x04\xc7\x0c\x04\x0c\n\r\n\x05\x04u\x02\0\x05\x12\x04\xc7\
    \x0c\r\x12\n\r\n\x05\x04u\x02\0\x01\x12\x04\xc7\x0c\x13$\n\r\n\x05\x04u\
    \x02\0\x03\x12\x04\xc7\x0c'(\n\x0c\n\x02\x04v\x12\x06\xca\x0c\0\xcc\x0c\
    \x01\n\x0b\n\x03\x04v\x01\x12\x04\xca\x0c\x08\x20\n\x0c\n\x04\x04v\x02\0\
    \x12\x04\xcb\x0c\x04+\n\r\n\x05\x04v\x02\0\x04\x12\x04\xcb\x0c\x04\x0c\n\
    \r\n\x05\x04v\x02\0\x06\x12\x04\xcb\x0c\r\x1e\n\r\n\x05\x04v\x02\0\x01\
    \x12\x04\xcb\x0c\x1f&\n\r\n\x05\x04v\x02\0\x03\x12\x04\xcb\x0c)*\n\x0c\n\
    \x02\x04w\x12\x06\xce\x0c\0\xd4\x0c\x01\n\x0b\n\x03\x04w\x01\x12\x04\xce\
    \x0c\x08\x18\n\x0c\n\x04\x04w\x02\0\x12\x04\xcf\x0c\x04!\n\r\n\x05\x04w\
    \x02\0\x04\x12\x04\xcf\x0c\x04\x0c\n\r\n\x05\x04w\x02\0\x05\x12\x04\xcf\
    \x0c\r\x13\n\r\n\x05\x04w\x02\0\x01\x12\x04\xcf\x0c\x14\x1c\n\r\n\x05\
    \x04w\x02\0\x03\x12\x04\xcf\x0c\x1f\x20\n\x0c\n\x04\x04w\x02\x01\x12\x04\
    \xd0\x0c\x04\x20\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xd0\x0c\x04\x0c\n\r\
    \n\x05\x04w\x02\x01\x05\x12\x04\xd0\x0c\r\x13\n\r\n\x05\x04w\x02\x01\x01\
    \x12\x04\xd0\x0c\x14\x1b\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xd0\x0c\x1e\
    \x1f\n\x0c\n\x04\x04w\x02\x02\x12\x04\xd1\x0c\x04!\n\r\n\x05\x04w\x02\
    \x02\x04\x12\x04\xd1\x0c\x04\x0c\n\r\n\x05\x04w\x02\x02\x05\x12\x04\xd1\
    \x0c\r\x13\n\r\n\x05\x04w\x02\x02\x01\x12\x04\xd1\x0c\x14\x1c\n\r\n\x05\
    \x04w\x02\x02\x03\x12\x04\xd1\x0c\x1f\x20\n\x0c\n\x04\x04w\x02\x03\x12\
    \x04\xd2\x0c\x04\x1d\n\r\n\x05\x04w\x02\x03\x04\x12\x04\xd2\x0c\x04\x0c\
    \n\r\n\x05\x04w\x02\x03\x05\x12\x04\xd2\x0c\r\x12\n\r\n\x05\x04w\x02\x03\
    \x01\x12\x04\xd2\x0c\x13\x18\n\r\n\x05\x04w\x02\x03\x03\x12\x04\xd2\x0c\
    \x1b\x1c\n\x0c\n\x04\x04w\x02\x04\x12\x04\xd3\x0c\x04\x1e\n\r\n\x05\x04w\
    \x02\x04\x04\x12\x04\xd3\x0c\x04\x0c\n\r\n\x05\x04w\x02\x04\x05\x12\x04\
    \xd3\x0c\r\x11\n\r\n\x05\x04w\x02\x04\x01\x12\x04\xd3\x0c\x12\x19\n\r\n\
    \x05\x04w\x02\x04\x03\x12\x04\xd3\x0c\x1c\x1d\n\x0c\n\x02\x04x\x12\x06\
    \xd6\x0c\0\xd8\x0c\x01\n\x0b\n\x03\x04x\x01\x12\x04\xd6\x0c\x08\x17\n\
    \x0c\n\x04\x04x\x02\0\x12\x04\xd7\x0c\x04\x1d\n\r\n\x05\x04x\x02\0\x04\
    \x12\x04\xd7\x0c\x04\x0c\n\r\n\x05\x04x\x02\0\x05\x12\x04\xd7\x0c\r\x13\
    \n\r\n\x05\x04x\x02\0\x01\x12\x04\xd7\x0c\x14\x18\n\r\n\x05\x04x\x02\0\
    \x03\x12\x04\xd7\x0c\x1b\x1c\n\x0c\n\x02\x04y\x12\x06\xda\x0c\0\xdc\x0c\
    \x01\n\x0b\n\x03\x04y\x01\x12\x04\xda\x0c\x08\x1c\n\x0c\n\x04\x04y\x02\0\
    \x12\x04\xdb\x0c\x04\x20\n\r\n\x05\x04y\x02\0\x04\x12\x04\xdb\x0c\x04\
    \x0c\n\r\n\x05\x04y\x02\0\x05\x12\x04\xdb\x0c\r\x13\n\r\n\x05\x04y\x02\0\
    \x01\x12\x04\xdb\x0c\x14\x1b\n\r\n\x05\x04y\x02\0\x03\x12\x04\xdb\x0c\
    \x1e\x1f\n\x0c\n\x02\x04z\x12\x06\xde\x0c\0\xe0\x0c\x01\n\x0b\n\x03\x04z\
    \x01\x12\x04\xde\x0c\x08\x16\n\x0c\n\x04\x04z\x02\0\x12\x04\xdf\x0c\x04\
    \x1e\n\r\n\x05\x04z\x02\0\x04\x12\x04\xdf\x0c\x04\x0c\n\r\n\x05\x04z\x02\
    \0\x05\x12\x04\xdf\x0c\r\x13\n\r\n\x05\x04z\x02\0\x01\x12\x04\xdf\x0c\
    \x14\x19\n\r\n\x05\x04z\x02\0\x03\x12\x04\xdf\x0c\x1c\x1d\n\x0c\n\x02\
    \x04{\x12\x06\xe2\x0c\0\xe4\x0c\x01\n\x0b\n\x03\x04{\x01\x12\x04\xe2\x0c\
    \x08\x1a\n\x0c\n\x04\x04{\x02\0\x12\x04\xe3\x0c\x04\x1e\n\r\n\x05\x04{\
    \x02\0\x04\x12\x04\xe3\x0c\x04\x0c\n\r\n\x05\x04{\x02\0\x05\x12\x04\xe3\
    \x0c\r\x13\n\r\n\x05\x04{\x02\0\x01\x12\x04\xe3\x0c\x14\x19\n\r\n\x05\
    \x04{\x02\0\x03\x12\x04\xe3\x0c\x1c\x1d\n\x0c\n\x02\x04|\x12\x06\xe6\x0c\
    \0\xe8\x0c\x01\n\x0b\n\x03\x04|\x01\x12\x04\xe6\x0c\x08\x11\n\x0c\n\x04\
    \x04|\x02\0\x12\x04\xe7\x0c\x04\x1d\n\r\n\x05\x04|\x02\0\x04\x12\x04\xe7\
    \x0c\x04\x0c\n\r\n\x05\x04|\x02\0\x05\x12\x04\xe7\x0c\r\x11\n\r\n\x05\
    \x04|\x02\0\x01\x12\x04\xe7\x0c\x12\x18\n\r\n\x05\x04|\x02\0\x03\x12\x04\
    \xe7\x0c\x1b\x1c\n\x0c\n\x02\x04}\x12\x06\xea\x0c\0\xec\x0c\x01\n\x0b\n\
    \x03\x04}\x01\x12\x04\xea\x0c\x08\x11\n\x0c\n\x04\x04}\x02\0\x12\x04\xeb\
    \x0c\x04#\n\r\n\x05\x04}\x02\0\x04\x12\x04\xeb\x0c\x04\x0c\n\r\n\x05\x04\
    }\x02\0\x05\x12\x04\xeb\x0c\r\x11\n\r\n\x05\x04}\x02\0\x01\x12\x04\xeb\
    \x0c\x12\x1e\n\r\n\x05\x04}\x02\0\x03\x12\x04\xeb\x0c!\"\n\x0c\n\x02\x04\
    ~\x12\x06\xee\x0c\0\xf2\x0c\x01\n\x0b\n\x03\x04~\x01\x12\x04\xee\x0c\x08\
    \x12\n\x0c\n\x04\x04~\x02\0\x12\x04\xef\x0c\x04\x1c\n\r\n\x05\x04~\x02\0\
    \x04\x12\x04\xef\x0c\x04\x0c\n\r\n\x05\x04~\x02\0\x05\x12\x04\xef\x0c\r\
    \x11\n\r\n\x05\x04~\x02\0\x01\x12\x04\xef\x0c\x12\x17\n\r\n\x05\x04~\x02\
    \0\x03\x12\x04\xef\x0c\x1a\x1b\n\x0c\n\x04\x04~\x02\x01\x12\x04\xf0\x0c\
    \x04(\n\r\n\x05\x04~\x02\x01\x04\x12\x04\xf0\x0c\x04\x0c\n\r\n\x05\x04~\
    \x02\x01\x05\x12\x04\xf0\x0c\r\x12\n\r\n\x05\x04~\x02\x01\x01\x12\x04\
    \xf0\x0c\x13#\n\r\n\x05\x04~\x02\x01\x03\x12\x04\xf0\x0c&'\n\x0c\n\x04\
    \x04~\x02\x02\x12\x04\xf1\x0c\x04\x20\n\r\n\x05\x04~\x02\x02\x04\x12\x04\
    \xf1\x0c\x04\x0c\n\r\n\x05\x04~\x02\x02\x05\x12\x04\xf1\x0c\r\x11\n\r\n\
    \x05\x04~\x02\x02\x01\x12\x04\xf1\x0c\x12\x1b\n\r\n\x05\x04~\x02\x02\x03\
    \x12\x04\xf1\x0c\x1e\x1f\n\x0c\n\x02\x04\x7f\x12\x06\xf4\x0c\0\xf7\x0c\
    \x01\n\x0b\n\x03\x04\x7f\x01\x12\x04\xf4\x0c\x08\x1c\n\x0c\n\x04\x04\x7f\
    \x02\0\x12\x04\xf5\x0c\x04\x1b\n\r\n\x05\x04\x7f\x02\0\x04\x12\x04\xf5\
    \x0c\x04\x0c\n\r\n\x05\x04\x7f\x02\0\x05\x12\x04\xf5\x0c\r\x11\n\r\n\x05\
    \x04\x7f\x02\0\x01\x12\x04\xf5\x0c\x12\x16\n\r\n\x05\x04\x7f\x02\0\x03\
    \x12\x04\xf5\x0c\x19\x1a\n\x0c\n\x04\x04\x7f\x02\x01\x12\x04\xf6\x0c\x04\
    5\n\r\n\x05\x04\x7f\x02\x01\x04\x12\x04\xf6\x0c\x04\x0c\n\r\n\x05\x04\
    \x7f\x02\x01\x06\x12\x04\xf6\x0c\r#\n\r\n\x05\x04\x7f\x02\x01\x01\x12\
    \x04\xf6\x0c$0\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\xf6\x0c34\n\r\n\x03\
    \x04\x80\x01\x12\x06\xf9\x0c\0\xfb\x0c\x01\n\x0c\n\x04\x04\x80\x01\x01\
    \x12\x04\xf9\x0c\x08\x15\n\r\n\x05\x04\x80\x01\x02\0\x12\x04\xfa\x0c\x04\
    \x1f\n\x0e\n\x06\x04\x80\x01\x02\0\x04\x12\x04\xfa\x0c\x04\x0c\n\x0e\n\
    \x06\x04\x80\x01\x02\0\x05\x12\x04\xfa\x0c\r\x13\n\x0e\n\x06\x04\x80\x01\
    \x02\0\x01\x12\x04\xfa\x0c\x14\x1a\n\x0e\n\x06\x04\x80\x01\x02\0\x03\x12\
    \x04\xfa\x0c\x1d\x1e\n\r\n\x03\x04\x81\x01\x12\x06\xfd\x0c\0\x82\r\x01\n\
    \x0c\n\x04\x04\x81\x01\x01\x12\x04\xfd\x0c\x08\x17\n\r\n\x05\x04\x81\x01\
    \x02\0\x12\x04\xfe\x0c\x04\x1d\n\x0e\n\x06\x04\x81\x01\x02\0\x04\x12\x04\
    \xfe\x0c\x04\x0c\n\x0e\n\x06\x04\x81\x01\x02\0\x05\x12\x04\xfe\x0c\r\x13\
    \n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\x04\xfe\x0c\x14\x18\n\x0e\n\x06\
    \x04\x81\x01\x02\0\x03\x12\x04\xfe\x0c\x1b\x1c\n\r\n\x05\x04\x81\x01\x02\
    \x01\x12\x04\xff\x0c\x04\x1d\n\x0e\n\x06\x04\x81\x01\x02\x01\x04\x12\x04\
    \xff\x0c\x04\x0c\n\x0e\n\x06\x04\x81\x01\x02\x01\x05\x12\x04\xff\x0c\r\
    \x12\n\x0e\n\x06\x04\x81\x01\x02\x01\x01\x12\x04\xff\x0c\x13\x18\n\x0e\n\
    \x06\x04\x81\x01\x02\x01\x03\x12\x04\xff\x0c\x1b\x1c\n\r\n\x05\x04\x81\
    \x01\x02\x02\x12\x04\x80\r\x04$\n\x0e\n\x06\x04\x81\x01\x02\x02\x04\x12\
    \x04\x80\r\x04\x0c\n\x0e\n\x06\x04\x81\x01\x02\x02\x05\x12\x04\x80\r\r\
    \x12\n\x0e\n\x06\x04\x81\x01\x02\x02\x01\x12\x04\x80\r\x13\x1f\n\x0e\n\
    \x06\x04\x81\x01\x02\x02\x03\x12\x04\x80\r\"#\n\r\n\x05\x04\x81\x01\x02\
    \x03\x12\x04\x81\r\x04\x1e\n\x0e\n\x06\x04\x81\x01\x02\x03\x04\x12\x04\
    \x81\r\x04\x0c\n\x0e\n\x06\x04\x81\x01\x02\x03\x05\x12\x04\x81\r\r\x11\n\
    \x0e\n\x06\x04\x81\x01\x02\x03\x01\x12\x04\x81\r\x12\x19\n\x0e\n\x06\x04\
    \x81\x01\x02\x03\x03\x12\x04\x81\r\x1c\x1d\n\r\n\x03\x04\x82\x01\x12\x06\
    \x84\r\0\x86\r\x01\n\x0c\n\x04\x04\x82\x01\x01\x12\x04\x84\r\x08\x1e\n\r\
    \n\x05\x04\x82\x01\x02\0\x12\x04\x85\r\x04\x1e\n\x0e\n\x06\x04\x82\x01\
    \x02\0\x04\x12\x04\x85\r\x04\x0c\n\x0e\n\x06\x04\x82\x01\x02\0\x05\x12\
    \x04\x85\r\r\x11\n\x0e\n\x06\x04\x82\x01\x02\0\x01\x12\x04\x85\r\x12\x19\
    \n\x0e\n\x06\x04\x82\x01\x02\0\x03\x12\x04\x85\r\x1c\x1d\n\r\n\x03\x04\
    \x83\x01\x12\x06\x88\r\0\x8a\r\x01\n\x0c\n\x04\x04\x83\x01\x01\x12\x04\
    \x88\r\x08\x15\n\r\n\x05\x04\x83\x01\x02\0\x12\x04\x89\r\x04'\n\x0e\n\
    \x06\x04\x83\x01\x02\0\x04\x12\x04\x89\r\x04\x0c\n\x0e\n\x06\x04\x83\x01\
    \x02\0\x05\x12\x04\x89\r\r\x12\n\x0e\n\x06\x04\x83\x01\x02\0\x01\x12\x04\
    \x89\r\x13\"\n\x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\x89\r%&\n\r\n\x03\
    \x04\x84\x01\x12\x06\x8c\r\0\x8f\r\x01\n\x0c\n\x04\x04\x84\x01\x01\x12\
    \x04\x8c\r\x08\x20\n\r\n\x05\x04\x84\x01\x02\0\x12\x04\x8d\r\x04\"\n\x0e\
    \n\x06\x04\x84\x01\x02\0\x04\x12\x04\x8d\r\x04\x0c\n\x0e\n\x06\x04\x84\
    \x01\x02\0\x05\x12\x04\x8d\r\r\x11\n\x0e\n\x06\x04\x84\x01\x02\0\x01\x12\
    \x04\x8d\r\x12\x1d\n\x0e\n\x06\x04\x84\x01\x02\0\x03\x12\x04\x8d\r\x20!\
    \n\r\n\x05\x04\x84\x01\x02\x01\x12\x04\x8e\r\x04(\n\x0e\n\x06\x04\x84\
    \x01\x02\x01\x04\x12\x04\x8e\r\x04\x0c\n\x0e\n\x06\x04\x84\x01\x02\x01\
    \x05\x12\x04\x8e\r\r\x12\n\x0e\n\x06\x04\x84\x01\x02\x01\x01\x12\x04\x8e\
    \r\x13#\n\x0e\n\x06\x04\x84\x01\x02\x01\x03\x12\x04\x8e\r&'\n\r\n\x03\
    \x04\x85\x01\x12\x06\x91\r\0\x93\r\x01\n\x0c\n\x04\x04\x85\x01\x01\x12\
    \x04\x91\r\x08\x18\n\r\n\x05\x04\x85\x01\x02\0\x12\x04\x92\r\x045\n\x0e\
    \n\x06\x04\x85\x01\x02\0\x04\x12\x04\x92\r\x04\x0c\n\x0e\n\x06\x04\x85\
    \x01\x02\0\x06\x12\x04\x92\r\r#\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\
    \x04\x92\r$0\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\x04\x92\r34\n\r\n\x03\
    \x04\x86\x01\x12\x06\x95\r\0\x99\r\x01\n\x0c\n\x04\x04\x86\x01\x01\x12\
    \x04\x95\r\x08\x15\n\r\n\x05\x04\x86\x01\x02\0\x12\x04\x96\r\x04!\n\x0e\
    \n\x06\x04\x86\x01\x02\0\x04\x12\x04\x96\r\x04\x0c\n\x0e\n\x06\x04\x86\
    \x01\x02\0\x05\x12\x04\x96\r\r\x13\n\x0e\n\x06\x04\x86\x01\x02\0\x01\x12\
    \x04\x96\r\x14\x1c\n\x0e\n\x06\x04\x86\x01\x02\0\x03\x12\x04\x96\r\x1f\
    \x20\n\r\n\x05\x04\x86\x01\x02\x01\x12\x04\x97\r\x04\"\n\x0e\n\x06\x04\
    \x86\x01\x02\x01\x04\x12\x04\x97\r\x04\x0c\n\x0e\n\x06\x04\x86\x01\x02\
    \x01\x05\x12\x04\x97\r\r\x13\n\x0e\n\x06\x04\x86\x01\x02\x01\x01\x12\x04\
    \x97\r\x14\x1d\n\x0e\n\x06\x04\x86\x01\x02\x01\x03\x12\x04\x97\r\x20!\n\
    \r\n\x05\x04\x86\x01\x02\x02\x12\x04\x98\r\x04\x1f\n\x0e\n\x06\x04\x86\
    \x01\x02\x02\x04\x12\x04\x98\r\x04\x0c\n\x0e\n\x06\x04\x86\x01\x02\x02\
    \x05\x12\x04\x98\r\r\x13\n\x0e\n\x06\x04\x86\x01\x02\x02\x01\x12\x04\x98\
    \r\x14\x1a\n\x0e\n\x06\x04\x86\x01\x02\x02\x03\x12\x04\x98\r\x1d\x1e\n\r\
    \n\x03\x04\x87\x01\x12\x06\x9b\r\0\x9d\r\x01\n\x0c\n\x04\x04\x87\x01\x01\
    \x12\x04\x9b\r\x08\x17\n\r\n\x05\x04\x87\x01\x02\0\x12\x04\x9c\r\x045\n\
    \x0e\n\x06\x04\x87\x01\x02\0\x04\x12\x04\x9c\r\x04\x0c\n\x0e\n\x06\x04\
    \x87\x01\x02\0\x06\x12\x04\x9c\r\r#\n\x0e\n\x06\x04\x87\x01\x02\0\x01\
    \x12\x04\x9c\r$0\n\x0e\n\x06\x04\x87\x01\x02\0\x03\x12\x04\x9c\r34\n\r\n\
    \x03\x04\x88\x01\x12\x06\x9f\r\0\xa1\r\x01\n\x0c\n\x04\x04\x88\x01\x01\
    \x12\x04\x9f\r\x08(\n\r\n\x05\x04\x88\x01\x02\0\x12\x04\xa0\r\x04!\n\x0e\
    \n\x06\x04\x88\x01\x02\0\x04\x12\x04\xa0\r\x04\x0c\n\x0e\n\x06\x04\x88\
    \x01\x02\0\x05\x12\x04\xa0\r\r\x11\n\x0e\n\x06\x04\x88\x01\x02\0\x01\x12\
    \x04\xa0\r\x12\x1c\n\x0e\n\x06\x04\x88\x01\x02\0\x03\x12\x04\xa0\r\x1f\
    \x20\n\r\n\x03\x04\x89\x01\x12\x06\xa3\r\0\xa5\r\x01\n\x0c\n\x04\x04\x89\
    \x01\x01\x12\x04\xa3\r\x08\x1c\n\r\n\x05\x04\x89\x01\x02\0\x12\x04\xa4\r\
    \x04&\n\x0e\n\x06\x04\x89\x01\x02\0\x04\x12\x04\xa4\r\x04\x0c\n\x0e\n\
    \x06\x04\x89\x01\x02\0\x05\x12\x04\xa4\r\r\x13\n\x0e\n\x06\x04\x89\x01\
    \x02\0\x01\x12\x04\xa4\r\x14!\n\x0e\n\x06\x04\x89\x01\x02\0\x03\x12\x04\
    \xa4\r$%\n\r\n\x03\x04\x8a\x01\x12\x06\xa7\r\0\xaa\r\x01\n\x0c\n\x04\x04\
    \x8a\x01\x01\x12\x04\xa7\r\x08\x19\n\r\n\x05\x04\x8a\x01\x02\0\x12\x04\
    \xa8\r\x04\x1f\n\x0e\n\x06\x04\x8a\x01\x02\0\x04\x12\x04\xa8\r\x04\x0c\n\
    \x0e\n\x06\x04\x8a\x01\x02\0\x05\x12\x04\xa8\r\r\x11\n\x0e\n\x06\x04\x8a\
    \x01\x02\0\x01\x12\x04\xa8\r\x12\x1a\n\x0e\n\x06\x04\x8a\x01\x02\0\x03\
    \x12\x04\xa8\r\x1d\x1e\n\r\n\x05\x04\x8a\x01\x02\x01\x12\x04\xa9\r\x045\
    \n\x0e\n\x06\x04\x8a\x01\x02\x01\x04\x12\x04\xa9\r\x04\x0c\n\x0e\n\x06\
    \x04\x8a\x01\x02\x01\x06\x12\x04\xa9\r\r#\n\x0e\n\x06\x04\x8a\x01\x02\
    \x01\x01\x12\x04\xa9\r$0\n\x0e\n\x06\x04\x8a\x01\x02\x01\x03\x12\x04\xa9\
    \r34\n\r\n\x03\x04\x8b\x01\x12\x06\xac\r\0\xae\r\x01\n\x0c\n\x04\x04\x8b\
    \x01\x01\x12\x04\xac\r\x08!\n\r\n\x05\x04\x8b\x01\x02\0\x12\x04\xad\r\
    \x04\x1e\n\x0e\n\x06\x04\x8b\x01\x02\0\x04\x12\x04\xad\r\x04\x0c\n\x0e\n\
    \x06\x04\x8b\x01\x02\0\x05\x12\x04\xad\r\r\x11\n\x0e\n\x06\x04\x8b\x01\
    \x02\0\x01\x12\x04\xad\r\x12\x19\n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\
    \x04\xad\r\x1c\x1d\n\r\n\x03\x04\x8c\x01\x12\x06\xb0\r\0\xb4\r\x01\n\x0c\
    \n\x04\x04\x8c\x01\x01\x12\x04\xb0\r\x08\x13\n\r\n\x05\x04\x8c\x01\x02\0\
    \x12\x04\xb1\r\x04\x1d\n\x0e\n\x06\x04\x8c\x01\x02\0\x04\x12\x04\xb1\r\
    \x04\x0c\n\x0e\n\x06\x04\x8c\x01\x02\0\x05\x12\x04\xb1\r\r\x13\n\x0e\n\
    \x06\x04\x8c\x01\x02\0\x01\x12\x04\xb1\r\x14\x18\n\x0e\n\x06\x04\x8c\x01\
    \x02\0\x03\x12\x04\xb1\r\x1b\x1c\n\r\n\x05\x04\x8c\x01\x02\x01\x12\x04\
    \xb2\r\x04\x20\n\x0e\n\x06\x04\x8c\x01\x02\x01\x04\x12\x04\xb2\r\x04\x0c\
    \n\x0e\n\x06\x04\x8c\x01\x02\x01\x05\x12\x04\xb2\r\r\x12\n\x0e\n\x06\x04\
    \x8c\x01\x02\x01\x01\x12\x04\xb2\r\x13\x1b\n\x0e\n\x06\x04\x8c\x01\x02\
    \x01\x03\x12\x04\xb2\r\x1e\x1f\n\r\n\x05\x04\x8c\x01\x02\x02\x12\x04\xb3\
    \r\x04\x20\n\x0e\n\x06\x04\x8c\x01\x02\x02\x04\x12\x04\xb3\r\x04\x0c\n\
    \x0e\n\x06\x04\x8c\x01\x02\x02\x05\x12\x04\xb3\r\r\x11\n\x0e\n\x06\x04\
    \x8c\x01\x02\x02\x01\x12\x04\xb3\r\x12\x1b\n\x0e\n\x06\x04\x8c\x01\x02\
    \x02\x03\x12\x04\xb3\r\x1e\x1f\n\r\n\x03\x04\x8d\x01\x12\x06\xb6\r\0\xbb\
    \r\x01\n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\xb6\r\x08\x16\n\r\n\x05\x04\
    \x8d\x01\x02\0\x12\x04\xb7\r\x04\x1d\n\x0e\n\x06\x04\x8d\x01\x02\0\x04\
    \x12\x04\xb7\r\x04\x0c\n\x0e\n\x06\x04\x8d\x01\x02\0\x05\x12\x04\xb7\r\r\
    \x12\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xb7\r\x13\x18\n\x0e\n\x06\
    \x04\x8d\x01\x02\0\x03\x12\x04\xb7\r\x1b\x1c\n\r\n\x05\x04\x8d\x01\x02\
    \x01\x12\x04\xb8\r\x04'\n\x0e\n\x06\x04\x8d\x01\x02\x01\x04\x12\x04\xb8\
    \r\x04\x0c\n\x0e\n\x06\x04\x8d\x01\x02\x01\x06\x12\x04\xb8\r\r\x1c\n\x0e\
    \n\x06\x04\x8d\x01\x02\x01\x01\x12\x04\xb8\r\x1d\"\n\x0e\n\x06\x04\x8d\
    \x01\x02\x01\x03\x12\x04\xb8\r%&\n\r\n\x05\x04\x8d\x01\x02\x02\x12\x04\
    \xb9\r\x04\x1f\n\x0e\n\x06\x04\x8d\x01\x02\x02\x04\x12\x04\xb9\r\x04\x0c\
    \n\x0e\n\x06\x04\x8d\x01\x02\x02\x05\x12\x04\xb9\r\r\x12\n\x0e\n\x06\x04\
    \x8d\x01\x02\x02\x01\x12\x04\xb9\r\x13\x1a\n\x0e\n\x06\x04\x8d\x01\x02\
    \x02\x03\x12\x04\xb9\r\x1d\x1e\n\r\n\x05\x04\x8d\x01\x02\x03\x12\x04\xba\
    \r\x04\x1f\n\x0e\n\x06\x04\x8d\x01\x02\x03\x04\x12\x04\xba\r\x04\x0c\n\
    \x0e\n\x06\x04\x8d\x01\x02\x03\x05\x12\x04\xba\r\r\x12\n\x0e\n\x06\x04\
    \x8d\x01\x02\x03\x01\x12\x04\xba\r\x13\x1a\n\x0e\n\x06\x04\x8d\x01\x02\
    \x03\x03\x12\x04\xba\r\x1d\x1e\n\r\n\x03\x04\x8e\x01\x12\x06\xbd\r\0\xc0\
    \r\x01\n\x0c\n\x04\x04\x8e\x01\x01\x12\x04\xbd\r\x08\x19\n\r\n\x05\x04\
    \x8e\x01\x02\0\x12\x04\xbe\r\x04\x1e\n\x0e\n\x06\x04\x8e\x01\x02\0\x04\
    \x12\x04\xbe\r\x04\x0c\n\x0e\n\x06\x04\x8e\x01\x02\0\x05\x12\x04\xbe\r\r\
    \x13\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\x04\xbe\r\x14\x19\n\x0e\n\x06\
    \x04\x8e\x01\x02\0\x03\x12\x04\xbe\r\x1c\x1d\n\r\n\x05\x04\x8e\x01\x02\
    \x01\x12\x04\xbf\r\x04\x1e\n\x0e\n\x06\x04\x8e\x01\x02\x01\x04\x12\x04\
    \xbf\r\x04\x0c\n\x0e\n\x06\x04\x8e\x01\x02\x01\x05\x12\x04\xbf\r\r\x12\n\
    \x0e\n\x06\x04\x8e\x01\x02\x01\x01\x12\x04\xbf\r\x13\x19\n\x0e\n\x06\x04\
    \x8e\x01\x02\x01\x03\x12\x04\xbf\r\x1c\x1d\n\r\n\x03\x04\x8f\x01\x12\x06\
    \xc2\r\0\xce\r\x01\n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\xc2\r\x08\x1f\n\
    \x0f\n\x05\x04\x8f\x01\x03\0\x12\x06\xc3\r\x04\xc9\r\x05\n\x0e\n\x06\x04\
    \x8f\x01\x03\0\x01\x12\x04\xc3\r\x0c\x13\n\x0f\n\x07\x04\x8f\x01\x03\0\
    \x02\0\x12\x04\xc4\r\x08#\n\x10\n\x08\x04\x8f\x01\x03\0\x02\0\x04\x12\
    \x04\xc4\r\x08\x10\n\x10\n\x08\x04\x8f\x01\x03\0\x02\0\x05\x12\x04\xc4\r\
    \x11\x17\n\x10\n\x08\x04\x8f\x01\x03\0\x02\0\x01\x12\x04\xc4\r\x18\x1e\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\0\x03\x12\x04\xc4\r!\"\n\x0f\n\x07\x04\
    \x8f\x01\x03\0\x02\x01\x12\x04\xc5\r\x08#\n\x10\n\x08\x04\x8f\x01\x03\0\
    \x02\x01\x04\x12\x04\xc5\r\x08\x10\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\
    \x05\x12\x04\xc5\r\x11\x17\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x01\x12\
    \x04\xc5\r\x18\x1e\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x01\x03\x12\x04\xc5\
    \r!\"\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x02\x12\x04\xc6\r\x08)\n\x10\n\
    \x08\x04\x8f\x01\x03\0\x02\x02\x04\x12\x04\xc6\r\x08\x10\n\x10\n\x08\x04\
    \x8f\x01\x03\0\x02\x02\x05\x12\x04\xc6\r\x11\x17\n\x10\n\x08\x04\x8f\x01\
    \x03\0\x02\x02\x01\x12\x04\xc6\r\x18$\n\x10\n\x08\x04\x8f\x01\x03\0\x02\
    \x02\x03\x12\x04\xc6\r'(\n\x0f\n\x07\x04\x8f\x01\x03\0\x02\x03\x12\x04\
    \xc7\r\x082\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x03\x04\x12\x04\xc7\r\x08\
    \x10\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x03\x06\x12\x04\xc7\r\x11\x1e\n\
    \x10\n\x08\x04\x8f\x01\x03\0\x02\x03\x01\x12\x04\xc7\r\x1f-\n\x10\n\x08\
    \x04\x8f\x01\x03\0\x02\x03\x03\x12\x04\xc7\r01\n\x0f\n\x07\x04\x8f\x01\
    \x03\0\x02\x04\x12\x04\xc8\r\x08'\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\
    \x04\x12\x04\xc8\r\x08\x10\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x05\x12\
    \x04\xc8\r\x11\x17\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x01\x12\x04\xc8\
    \r\x18!\n\x10\n\x08\x04\x8f\x01\x03\0\x02\x04\x03\x12\x04\xc8\r$&\n\r\n\
    \x05\x04\x8f\x01\x02\0\x12\x04\xcb\r\x04\x1f\n\x0e\n\x06\x04\x8f\x01\x02\
    \0\x04\x12\x04\xcb\r\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\0\x05\x12\x04\
    \xcb\r\r\x12\n\x0e\n\x06\x04\x8f\x01\x02\0\x01\x12\x04\xcb\r\x13\x1a\n\
    \x0e\n\x06\x04\x8f\x01\x02\0\x03\x12\x04\xcb\r\x1d\x1e\n\r\n\x05\x04\x8f\
    \x01\x02\x01\x12\x04\xcc\r\x04!\n\x0e\n\x06\x04\x8f\x01\x02\x01\x04\x12\
    \x04\xcc\r\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\x01\x05\x12\x04\xcc\r\r\
    \x12\n\x0e\n\x06\x04\x8f\x01\x02\x01\x01\x12\x04\xcc\r\x13\x1c\n\x0e\n\
    \x06\x04\x8f\x01\x02\x01\x03\x12\x04\xcc\r\x1f\x20\n\r\n\x05\x04\x8f\x01\
    \x02\x02\x12\x04\xcd\r\x04'\n\x0e\n\x06\x04\x8f\x01\x02\x02\x04\x12\x04\
    \xcd\r\x04\x0c\n\x0e\n\x06\x04\x8f\x01\x02\x02\x05\x12\x04\xcd\r\r\x12\n\
    \x0e\n\x06\x04\x8f\x01\x02\x02\x01\x12\x04\xcd\r\x13\"\n\x0e\n\x06\x04\
    \x8f\x01\x02\x02\x03\x12\x04\xcd\r%&\n\r\n\x03\x04\x90\x01\x12\x06\xd0\r\
    \0\xd4\r\x01\n\x0c\n\x04\x04\x90\x01\x01\x12\x04\xd0\r\x08\x15\n\r\n\x05\
    \x04\x90\x01\x02\0\x12\x04\xd1\r\x04\x1b\n\x0e\n\x06\x04\x90\x01\x02\0\
    \x04\x12\x04\xd1\r\x04\x0c\n\x0e\n\x06\x04\x90\x01\x02\0\x05\x12\x04\xd1\
    \r\r\x13\n\x0e\n\x06\x04\x90\x01\x02\0\x01\x12\x04\xd1\r\x14\x16\n\x0e\n\
    \x06\x04\x90\x01\x02\0\x03\x12\x04\xd1\r\x19\x1a\n\r\n\x05\x04\x90\x01\
    \x02\x01\x12\x04\xd2\r\x04\x1b\n\x0e\n\x06\x04\x90\x01\x02\x01\x04\x12\
    \x04\xd2\r\x04\x0c\n\x0e\n\x06\x04\x90\x01\x02\x01\x05\x12\x04\xd2\r\r\
    \x13\n\x0e\n\x06\x04\x90\x01\x02\x01\x01\x12\x04\xd2\r\x14\x16\n\x0e\n\
    \x06\x04\x90\x01\x02\x01\x03\x12\x04\xd2\r\x19\x1a\n\r\n\x05\x04\x90\x01\
    \x02\x02\x12\x04\xd3\r\x04%\n\x0e\n\x06\x04\x90\x01\x02\x02\x04\x12\x04\
    \xd3\r\x04\x0c\n\x0e\n\x06\x04\x90\x01\x02\x02\x05\x12\x04\xd3\r\r\x13\n\
    \x0e\n\x06\x04\x90\x01\x02\x02\x01\x12\x04\xd3\r\x14\x20\n\x0e\n\x06\x04\
    \x90\x01\x02\x02\x03\x12\x04\xd3\r#$\n\r\n\x03\x04\x91\x01\x12\x06\xd6\r\
    \0\xec\r\x01\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\xd6\r\x08\x17\n\x0f\n\
    \x05\x04\x91\x01\x04\0\x12\x06\xd7\r\x04\xdb\r\x05\n\x0e\n\x06\x04\x91\
    \x01\x04\0\x01\x12\x04\xd7\r\t\x1b\n\x0f\n\x07\x04\x91\x01\x04\0\x02\0\
    \x12\x04\xd8\r\x08\x14\n\x10\n\x08\x04\x91\x01\x04\0\x02\0\x01\x12\x04\
    \xd8\r\x08\x0f\n\x10\n\x08\x04\x91\x01\x04\0\x02\0\x02\x12\x04\xd8\r\x12\
    \x13\n\x0f\n\x07\x04\x91\x01\x04\0\x02\x01\x12\x04\xd9\r\x08\x10\n\x10\n\
    \x08\x04\x91\x01\x04\0\x02\x01\x01\x12\x04\xd9\r\x08\x0b\n\x10\n\x08\x04\
    \x91\x01\x04\0\x02\x01\x02\x12\x04\xd9\r\x0e\x0f\n\x0f\n\x07\x04\x91\x01\
    \x04\0\x02\x02\x12\x04\xda\r\x08\x11\n\x10\n\x08\x04\x91\x01\x04\0\x02\
    \x02\x01\x12\x04\xda\r\x08\x0c\n\x10\n\x08\x04\x91\x01\x04\0\x02\x02\x02\
    \x12\x04\xda\r\x0f\x10\n\x0f\n\x05\x04\x91\x01\x04\x01\x12\x06\xdc\r\x04\
    \xdf\r\x05\n\x0e\n\x06\x04\x91\x01\x04\x01\x01\x12\x04\xdc\r\t\x18\n\x0f\
    \n\x07\x04\x91\x01\x04\x01\x02\0\x12\x04\xdd\r\x08\x17\n\x10\n\x08\x04\
    \x91\x01\x04\x01\x02\0\x01\x12\x04\xdd\r\x08\x12\n\x10\n\x08\x04\x91\x01\
    \x04\x01\x02\0\x02\x12\x04\xdd\r\x15\x16\n\x0f\n\x07\x04\x91\x01\x04\x01\
    \x02\x01\x12\x04\xde\r\x08\x15\n\x10\n\x08\x04\x91\x01\x04\x01\x02\x01\
    \x01\x12\x04\xde\r\x08\x10\n\x10\n\x08\x04\x91\x01\x04\x01\x02\x01\x02\
    \x12\x04\xde\r\x13\x14\n\x0f\n\x05\x04\x91\x01\x04\x02\x12\x06\xe0\r\x04\
    \xe3\r\x05\n\x0e\n\x06\x04\x91\x01\x04\x02\x01\x12\x04\xe0\r\t\x19\n\x0f\
    \n\x07\x04\x91\x01\x04\x02\x02\0\x12\x04\xe1\r\x08\x11\n\x10\n\x08\x04\
    \x91\x01\x04\x02\x02\0\x01\x12\x04\xe1\r\x08\x0c\n\x10\n\x08\x04\x91\x01\
    \x04\x02\x02\0\x02\x12\x04\xe1\r\x0f\x10\n\x0f\n\x07\x04\x91\x01\x04\x02\
    \x02\x01\x12\x04\xe2\r\x08\x10\n\x10\n\x08\x04\x91\x01\x04\x02\x02\x01\
    \x01\x12\x04\xe2\r\x08\x0b\n\x10\n\x08\x04\x91\x01\x04\x02\x02\x01\x02\
    \x12\x04\xe2\r\x0e\x0f\n\r\n\x05\x04\x91\x01\x02\0\x12\x04\xe4\r\x04+\n\
    \x0e\n\x06\x04\x91\x01\x02\0\x04\x12\x04\xe4\r\x04\x0c\n\x0e\n\x06\x04\
    \x91\x01\x02\0\x06\x12\x04\xe4\r\r\x1f\n\x0e\n\x06\x04\x91\x01\x02\0\x01\
    \x12\x04\xe4\r\x20&\n\x0e\n\x06\x04\x91\x01\x02\0\x03\x12\x04\xe4\r)*\n\
    \r\n\x05\x04\x91\x01\x02\x01\x12\x04\xe5\r\x043\n\x0e\n\x06\x04\x91\x01\
    \x02\x01\x04\x12\x04\xe5\r\x04\x0c\n\x0e\n\x06\x04\x91\x01\x02\x01\x06\
    \x12\x04\xe5\r\r$\n\x0e\n\x06\x04\x91\x01\x02\x01\x01\x12\x04\xe5\r%.\n\
    \x0e\n\x06\x04\x91\x01\x02\x01\x03\x12\x04\xe5\r12\n\r\n\x05\x04\x91\x01\
    \x02\x02\x12\x04\xe6\r\x04\x1d\n\x0e\n\x06\x04\x91\x01\x02\x02\x04\x12\
    \x04\xe6\r\x04\x0c\n\x0e\n\x06\x04\x91\x01\x02\x02\x05\x12\x04\xe6\r\r\
    \x11\n\x0e\n\x06\x04\x91\x01\x02\x02\x01\x12\x04\xe6\r\x12\x18\n\x0e\n\
    \x06\x04\x91\x01\x02\x02\x03\x12\x04\xe6\r\x1b\x1c\n\r\n\x05\x04\x91\x01\
    \x02\x03\x12\x04\xe7\r\x04\x1e\n\x0e\n\x06\x04\x91\x01\x02\x03\x04\x12\
    \x04\xe7\r\x04\x0c\n\x0e\n\x06\x04\x91\x01\x02\x03\x05\x12\x04\xe7\r\r\
    \x11\n\x0e\n\x06\x04\x91\x01\x02\x03\x01\x12\x04\xe7\r\x12\x19\n\x0e\n\
    \x06\x04\x91\x01\x02\x03\x03\x12\x04\xe7\r\x1c\x1d\n\r\n\x05\x04\x91\x01\
    \x02\x04\x12\x04\xe8\r\x04-\n\x0e\n\x06\x04\x91\x01\x02\x04\x04\x12\x04\
    \xe8\r\x04\x0c\n\x0e\n\x06\x04\x91\x01\x02\x04\x06\x12\x04\xe8\r\r\x1c\n\
    \x0e\n\x06\x04\x91\x01\x02\x04\x01\x12\x04\xe8\r\x1d(\n\x0e\n\x06\x04\
    \x91\x01\x02\x04\x03\x12\x04\xe8\r+,\n\r\n\x05\x04\x91\x01\x02\x05\x12\
    \x04\xe9\r\x04/\n\x0e\n\x06\x04\x91\x01\x02\x05\x04\x12\x04\xe9\r\x04\
    \x0c\n\x0e\n\x06\x04\x91\x01\x02\x05\x06\x12\x04\xe9\r\r\x1d\n\x0e\n\x06\
    \x04\x91\x01\x02\x05\x01\x12\x04\xe9\r\x1e*\n\x0e\n\x06\x04\x91\x01\x02\
    \x05\x03\x12\x04\xe9\r-.\n\r\n\x05\x04\x91\x01\x02\x06\x12\x04\xea\r\x04\
    &\n\x0e\n\x06\x04\x91\x01\x02\x06\x04\x12\x04\xea\r\x04\x0c\n\x0e\n\x06\
    \x04\x91\x01\x02\x06\x05\x12\x04\xea\r\r\x13\n\x0e\n\x06\x04\x91\x01\x02\
    \x06\x01\x12\x04\xea\r\x14!\n\x0e\n\x06\x04\x91\x01\x02\x06\x03\x12\x04\
    \xea\r$%\n\r\n\x05\x04\x91\x01\x02\x07\x12\x04\xeb\r\x04(\n\x0e\n\x06\
    \x04\x91\x01\x02\x07\x04\x12\x04\xeb\r\x04\x0c\n\x0e\n\x06\x04\x91\x01\
    \x02\x07\x05\x12\x04\xeb\r\r\x13\n\x0e\n\x06\x04\x91\x01\x02\x07\x01\x12\
    \x04\xeb\r\x14#\n\x0e\n\x06\x04\x91\x01\x02\x07\x03\x12\x04\xeb\r&'\n\r\
    \n\x03\x04\x92\x01\x12\x06\xee\r\0\xf1\r\x01\n\x0c\n\x04\x04\x92\x01\x01\
    \x12\x04\xee\r\x08\x19\n\r\n\x05\x04\x92\x01\x02\0\x12\x04\xef\r\x043\n\
    \x0e\n\x06\x04\x92\x01\x02\0\x04\x12\x04\xef\r\x04\x0c\n\x0e\n\x06\x04\
    \x92\x01\x02\0\x06\x12\x04\xef\r\r$\n\x0e\n\x06\x04\x92\x01\x02\0\x01\
    \x12\x04\xef\r%.\n\x0e\n\x06\x04\x92\x01\x02\0\x03\x12\x04\xef\r12\n\r\n\
    \x05\x04\x92\x01\x02\x01\x12\x04\xf0\r\x04'\n\x0e\n\x06\x04\x92\x01\x02\
    \x01\x04\x12\x04\xf0\r\x04\x0c\n\x0e\n\x06\x04\x92\x01\x02\x01\x05\x12\
    \x04\xf0\r\r\x12\n\x0e\n\x06\x04\x92\x01\x02\x01\x01\x12\x04\xf0\r\x13\"\
    \n\x0e\n\x06\x04\x92\x01\x02\x01\x03\x12\x04\xf0\r%&\n\r\n\x03\x04\x93\
    \x01\x12\x06\xf3\r\0\x80\x0e\x01\n\x0c\n\x04\x04\x93\x01\x01\x12\x04\xf3\
    \r\x08\x1a\n\x0f\n\x05\x04\x93\x01\x04\0\x12\x06\xf4\r\x04\xf7\r\x05\n\
    \x0e\n\x06\x04\x93\x01\x04\0\x01\x12\x04\xf4\r\t\x18\n\x0f\n\x07\x04\x93\
    \x01\x04\0\x02\0\x12\x04\xf5\r\x08\x17\n\x10\n\x08\x04\x93\x01\x04\0\x02\
    \0\x01\x12\x04\xf5\r\x08\x12\n\x10\n\x08\x04\x93\x01\x04\0\x02\0\x02\x12\
    \x04\xf5\r\x15\x16\n\x0f\n\x07\x04\x93\x01\x04\0\x02\x01\x12\x04\xf6\r\
    \x08\x15\n\x10\n\x08\x04\x93\x01\x04\0\x02\x01\x01\x12\x04\xf6\r\x08\x10\
    \n\x10\n\x08\x04\x93\x01\x04\0\x02\x01\x02\x12\x04\xf6\r\x13\x14\n\x0f\n\
    \x05\x04\x93\x01\x04\x01\x12\x06\xf8\r\x04\xfa\r\x05\n\x0e\n\x06\x04\x93\
    \x01\x04\x01\x01\x12\x04\xf8\r\t\x14\n\x0f\n\x07\x04\x93\x01\x04\x01\x02\
    \0\x12\x04\xf9\r\x08\x17\n\x10\n\x08\x04\x93\x01\x04\x01\x02\0\x01\x12\
    \x04\xf9\r\x08\x12\n\x10\n\x08\x04\x93\x01\x04\x01\x02\0\x02\x12\x04\xf9\
    \r\x15\x16\n\r\n\x05\x04\x93\x01\x02\0\x12\x04\xfb\r\x04,\n\x0e\n\x06\
    \x04\x93\x01\x02\0\x04\x12\x04\xfb\r\x04\x0c\n\x0e\n\x06\x04\x93\x01\x02\
    \0\x05\x12\x04\xfb\r\r\x13\n\x0e\n\x06\x04\x93\x01\x02\0\x01\x12\x04\xfb\
    \r\x14'\n\x0e\n\x06\x04\x93\x01\x02\0\x03\x12\x04\xfb\r*+\n\r\n\x05\x04\
    \x93\x01\x02\x01\x12\x04\xfc\r\x04+\n\x0e\n\x06\x04\x93\x01\x02\x01\x04\
    \x12\x04\xfc\r\x04\x0c\n\x0e\n\x06\x04\x93\x01\x02\x01\x05\x12\x04\xfc\r\
    \r\x13\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\x04\xfc\r\x14&\n\x0e\n\
    \x06\x04\x93\x01\x02\x01\x03\x12\x04\xfc\r)*\n\r\n\x05\x04\x93\x01\x02\
    \x02\x12\x04\xfd\r\x04\"\n\x0e\n\x06\x04\x93\x01\x02\x02\x04\x12\x04\xfd\
    \r\x04\x0c\n\x0e\n\x06\x04\x93\x01\x02\x02\x05\x12\x04\xfd\r\r\x13\n\x0e\
    \n\x06\x04\x93\x01\x02\x02\x01\x12\x04\xfd\r\x14\x1d\n\x0e\n\x06\x04\x93\
    \x01\x02\x02\x03\x12\x04\xfd\r\x20!\n\r\n\x05\x04\x93\x01\x02\x03\x12\
    \x04\xfe\r\x04-\n\x0e\n\x06\x04\x93\x01\x02\x03\x04\x12\x04\xfe\r\x04\
    \x0c\n\x0e\n\x06\x04\x93\x01\x02\x03\x06\x12\x04\xfe\r\r\x1c\n\x0e\n\x06\
    \x04\x93\x01\x02\x03\x01\x12\x04\xfe\r\x1d(\n\x0e\n\x06\x04\x93\x01\x02\
    \x03\x03\x12\x04\xfe\r+,\n\r\n\x05\x04\x93\x01\x02\x04\x12\x04\xff\r\x04\
    )\n\x0e\n\x06\x04\x93\x01\x02\x04\x04\x12\x04\xff\r\x04\x0c\n\x0e\n\x06\
    \x04\x93\x01\x02\x04\x06\x12\x04\xff\r\r\x18\n\x0e\n\x06\x04\x93\x01\x02\
    \x04\x01\x12\x04\xff\r\x19$\n\x0e\n\x06\x04\x93\x01\x02\x04\x03\x12\x04\
    \xff\r'(\n\r\n\x03\x04\x94\x01\x12\x06\x82\x0e\0\x86\x0e\x01\n\x0c\n\x04\
    \x04\x94\x01\x01\x12\x04\x82\x0e\x08\x18\n\r\n\x05\x04\x94\x01\x02\0\x12\
    \x04\x83\x0e\x042\n\x0e\n\x06\x04\x94\x01\x02\0\x04\x12\x04\x83\x0e\x04\
    \x0c\n\x0e\n\x06\x04\x94\x01\x02\0\x06\x12\x04\x83\x0e\r!\n\x0e\n\x06\
    \x04\x94\x01\x02\0\x01\x12\x04\x83\x0e\"-\n\x0e\n\x06\x04\x94\x01\x02\0\
    \x03\x12\x04\x83\x0e01\n\r\n\x05\x04\x94\x01\x02\x01\x12\x04\x84\x0e\x04\
    2\n\x0e\n\x06\x04\x94\x01\x02\x01\x04\x12\x04\x84\x0e\x04\x0c\n\x0e\n\
    \x06\x04\x94\x01\x02\x01\x06\x12\x04\x84\x0e\r!\n\x0e\n\x06\x04\x94\x01\
    \x02\x01\x01\x12\x04\x84\x0e\"-\n\x0e\n\x06\x04\x94\x01\x02\x01\x03\x12\
    \x04\x84\x0e01\n\r\n\x05\x04\x94\x01\x02\x02\x12\x04\x85\x0e\x044\n\x0e\
    \n\x06\x04\x94\x01\x02\x02\x04\x12\x04\x85\x0e\x04\x0c\n\x0e\n\x06\x04\
    \x94\x01\x02\x02\x06\x12\x04\x85\x0e\r\"\n\x0e\n\x06\x04\x94\x01\x02\x02\
    \x01\x12\x04\x85\x0e#/\n\x0e\n\x06\x04\x94\x01\x02\x02\x03\x12\x04\x85\
    \x0e23\n\r\n\x03\x04\x95\x01\x12\x06\x88\x0e\0\x8c\x0e\x01\n\x0c\n\x04\
    \x04\x95\x01\x01\x12\x04\x88\x0e\x08\x1c\n\r\n\x05\x04\x95\x01\x02\0\x12\
    \x04\x89\x0e\x04!\n\x0e\n\x06\x04\x95\x01\x02\0\x04\x12\x04\x89\x0e\x04\
    \x0c\n\x0e\n\x06\x04\x95\x01\x02\0\x05\x12\x04\x89\x0e\r\x12\n\x0e\n\x06\
    \x04\x95\x01\x02\0\x01\x12\x04\x89\x0e\x13\x1c\n\x0e\n\x06\x04\x95\x01\
    \x02\0\x03\x12\x04\x89\x0e\x1f\x20\n\r\n\x05\x04\x95\x01\x02\x01\x12\x04\
    \x8a\x0e\x04\x1e\n\x0e\n\x06\x04\x95\x01\x02\x01\x04\x12\x04\x8a\x0e\x04\
    \x0c\n\x0e\n\x06\x04\x95\x01\x02\x01\x05\x12\x04\x8a\x0e\r\x12\n\x0e\n\
    \x06\x04\x95\x01\x02\x01\x01\x12\x04\x8a\x0e\x13\x19\n\x0e\n\x06\x04\x95\
    \x01\x02\x01\x03\x12\x04\x8a\x0e\x1c\x1d\n\r\n\x05\x04\x95\x01\x02\x02\
    \x12\x04\x8b\x0e\x04\x1f\n\x0e\n\x06\x04\x95\x01\x02\x02\x04\x12\x04\x8b\
    \x0e\x04\x0c\n\x0e\n\x06\x04\x95\x01\x02\x02\x05\x12\x04\x8b\x0e\r\x12\n\
    \x0e\n\x06\x04\x95\x01\x02\x02\x01\x12\x04\x8b\x0e\x13\x1a\n\x0e\n\x06\
    \x04\x95\x01\x02\x02\x03\x12\x04\x8b\x0e\x1d\x1e\n\r\n\x03\x04\x96\x01\
    \x12\x06\x8e\x0e\0\x92\x0e\x01\n\x0c\n\x04\x04\x96\x01\x01\x12\x04\x8e\
    \x0e\x08\x1c\n\r\n\x05\x04\x96\x01\x02\0\x12\x04\x8f\x0e\x04!\n\x0e\n\
    \x06\x04\x96\x01\x02\0\x04\x12\x04\x8f\x0e\x04\x0c\n\x0e\n\x06\x04\x96\
    \x01\x02\0\x05\x12\x04\x8f\x0e\r\x12\n\x0e\n\x06\x04\x96\x01\x02\0\x01\
    \x12\x04\x8f\x0e\x13\x1c\n\x0e\n\x06\x04\x96\x01\x02\0\x03\x12\x04\x8f\
    \x0e\x1f\x20\n\r\n\x05\x04\x96\x01\x02\x01\x12\x04\x90\x0e\x04\x1e\n\x0e\
    \n\x06\x04\x96\x01\x02\x01\x04\x12\x04\x90\x0e\x04\x0c\n\x0e\n\x06\x04\
    \x96\x01\x02\x01\x05\x12\x04\x90\x0e\r\x12\n\x0e\n\x06\x04\x96\x01\x02\
    \x01\x01\x12\x04\x90\x0e\x13\x19\n\x0e\n\x06\x04\x96\x01\x02\x01\x03\x12\
    \x04\x90\x0e\x1c\x1d\n\r\n\x05\x04\x96\x01\x02\x02\x12\x04\x91\x0e\x04\
    \x1f\n\x0e\n\x06\x04\x96\x01\x02\x02\x04\x12\x04\x91\x0e\x04\x0c\n\x0e\n\
    \x06\x04\x96\x01\x02\x02\x05\x12\x04\x91\x0e\r\x12\n\x0e\n\x06\x04\x96\
    \x01\x02\x02\x01\x12\x04\x91\x0e\x13\x1a\n\x0e\n\x06\x04\x96\x01\x02\x02\
    \x03\x12\x04\x91\x0e\x1d\x1e\n\r\n\x03\x04\x97\x01\x12\x06\x94\x0e\0\x97\
    \x0e\x01\n\x0c\n\x04\x04\x97\x01\x01\x12\x04\x94\x0e\x08\x1d\n\r\n\x05\
    \x04\x97\x01\x02\0\x12\x04\x95\x0e\x04\x1e\n\x0e\n\x06\x04\x97\x01\x02\0\
    \x04\x12\x04\x95\x0e\x04\x0c\n\x0e\n\x06\x04\x97\x01\x02\0\x05\x12\x04\
    \x95\x0e\r\x12\n\x0e\n\x06\x04\x97\x01\x02\0\x01\x12\x04\x95\x0e\x13\x19\
    \n\x0e\n\x06\x04\x97\x01\x02\0\x03\x12\x04\x95\x0e\x1c\x1d\n\r\n\x05\x04\
    \x97\x01\x02\x01\x12\x04\x96\x0e\x04\x1f\n\x0e\n\x06\x04\x97\x01\x02\x01\
    \x04\x12\x04\x96\x0e\x04\x0c\n\x0e\n\x06\x04\x97\x01\x02\x01\x05\x12\x04\
    \x96\x0e\r\x12\n\x0e\n\x06\x04\x97\x01\x02\x01\x01\x12\x04\x96\x0e\x13\
    \x1a\n\x0e\n\x06\x04\x97\x01\x02\x01\x03\x12\x04\x96\x0e\x1d\x1e\n\r\n\
    \x03\x04\x98\x01\x12\x06\x99\x0e\0\xca\x0f\x01\n\x0c\n\x04\x04\x98\x01\
    \x01\x12\x04\x99\x0e\x08\x15\n\x0f\n\x05\x04\x98\x01\x03\0\x12\x06\x9a\
    \x0e\x04\xb4\x0e\x05\n\x0e\n\x06\x04\x98\x01\x03\0\x01\x12\x04\x9a\x0e\
    \x0c\x13\n\x11\n\x07\x04\x98\x01\x03\0\x03\0\x12\x06\x9b\x0e\x08\xa7\x0e\
    \t\n\x10\n\x08\x04\x98\x01\x03\0\x03\0\x01\x12\x04\x9b\x0e\x10\x1b\n\x11\
    \n\t\x04\x98\x01\x03\0\x03\0\x02\0\x12\x04\x9c\x0e\x0c3\n\x12\n\n\x04\
    \x98\x01\x03\0\x03\0\x02\0\x04\x12\x04\x9c\x0e\x0c\x14\n\x12\n\n\x04\x98\
    \x01\x03\0\x03\0\x02\0\x05\x12\x04\x9c\x0e\x15\x19\n\x12\n\n\x04\x98\x01\
    \x03\0\x03\0\x02\0\x01\x12\x04\x9c\x0e\x1a.\n\x12\n\n\x04\x98\x01\x03\0\
    \x03\0\x02\0\x03\x12\x04\x9c\x0e12\n\x11\n\t\x04\x98\x01\x03\0\x03\0\x02\
    \x01\x12\x04\x9d\x0e\x0c6\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x01\x04\
    \x12\x04\x9d\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x01\x05\
    \x12\x04\x9d\x0e\x15\x19\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x01\x01\
    \x12\x04\x9d\x0e\x1a1\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x01\x03\x12\
    \x04\x9d\x0e45\n\x11\n\t\x04\x98\x01\x03\0\x03\0\x02\x02\x12\x04\x9e\x0e\
    \x0c7\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x02\x04\x12\x04\x9e\x0e\x0c\
    \x14\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x02\x05\x12\x04\x9e\x0e\x15\
    \x19\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x02\x01\x12\x04\x9e\x0e\x1a2\
    \n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x02\x03\x12\x04\x9e\x0e56\n\x11\n\
    \t\x04\x98\x01\x03\0\x03\0\x02\x03\x12\x04\x9f\x0e\x0c2\n\x12\n\n\x04\
    \x98\x01\x03\0\x03\0\x02\x03\x04\x12\x04\x9f\x0e\x0c\x14\n\x12\n\n\x04\
    \x98\x01\x03\0\x03\0\x02\x03\x05\x12\x04\x9f\x0e\x15\x19\n\x12\n\n\x04\
    \x98\x01\x03\0\x03\0\x02\x03\x01\x12\x04\x9f\x0e\x1a-\n\x12\n\n\x04\x98\
    \x01\x03\0\x03\0\x02\x03\x03\x12\x04\x9f\x0e01\n\x11\n\t\x04\x98\x01\x03\
    \0\x03\0\x02\x04\x12\x04\xa0\x0e\x0c1\n\x12\n\n\x04\x98\x01\x03\0\x03\0\
    \x02\x04\x04\x12\x04\xa0\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\x03\0\x03\0\
    \x02\x04\x05\x12\x04\xa0\x0e\x15\x19\n\x12\n\n\x04\x98\x01\x03\0\x03\0\
    \x02\x04\x01\x12\x04\xa0\x0e\x1a,\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\
    \x04\x03\x12\x04\xa0\x0e/0\n\x11\n\t\x04\x98\x01\x03\0\x03\0\x02\x05\x12\
    \x04\xa1\x0e\x0c/\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x05\x04\x12\x04\
    \xa1\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x05\x05\x12\x04\
    \xa1\x0e\x15\x19\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x05\x01\x12\x04\
    \xa1\x0e\x1a*\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x05\x03\x12\x04\xa1\
    \x0e-.\n\x11\n\t\x04\x98\x01\x03\0\x03\0\x02\x06\x12\x04\xa2\x0e\x0c/\n\
    \x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x06\x04\x12\x04\xa2\x0e\x0c\x14\n\
    \x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x06\x05\x12\x04\xa2\x0e\x15\x19\n\
    \x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x06\x01\x12\x04\xa2\x0e\x1a*\n\x12\
    \n\n\x04\x98\x01\x03\0\x03\0\x02\x06\x03\x12\x04\xa2\x0e-.\n\x11\n\t\x04\
    \x98\x01\x03\0\x03\0\x02\x07\x12\x04\xa3\x0e\x0c/\n\x12\n\n\x04\x98\x01\
    \x03\0\x03\0\x02\x07\x04\x12\x04\xa3\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\
    \x03\0\x03\0\x02\x07\x05\x12\x04\xa3\x0e\x15\x19\n\x12\n\n\x04\x98\x01\
    \x03\0\x03\0\x02\x07\x01\x12\x04\xa3\x0e\x1a*\n\x12\n\n\x04\x98\x01\x03\
    \0\x03\0\x02\x07\x03\x12\x04\xa3\x0e-.\n\x11\n\t\x04\x98\x01\x03\0\x03\0\
    \x02\x08\x12\x04\xa4\x0e\x0c2\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x08\
    \x04\x12\x04\xa4\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x08\
    \x05\x12\x04\xa4\x0e\x15\x19\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x08\
    \x01\x12\x04\xa4\x0e\x1a-\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\x08\x03\
    \x12\x04\xa4\x0e01\n\x11\n\t\x04\x98\x01\x03\0\x03\0\x02\t\x12\x04\xa5\
    \x0e\x0c/\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\t\x04\x12\x04\xa5\x0e\
    \x0c\x14\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\t\x05\x12\x04\xa5\x0e\x15\
    \x1b\n\x12\n\n\x04\x98\x01\x03\0\x03\0\x02\t\x01\x12\x04\xa5\x0e\x1c)\n\
    \x12\n\n\x04\x98\x01\x03\0\x03\0\x02\t\x03\x12\x04\xa5\x0e,.\n\x11\n\t\
    \x04\x98\x01\x03\0\x03\0\x02\n\x12\x04\xa6\x0e\x0c)\n\x12\n\n\x04\x98\
    \x01\x03\0\x03\0\x02\n\x04\x12\x04\xa6\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\
    \x03\0\x03\0\x02\n\x05\x12\x04\xa6\x0e\x15\x1a\n\x12\n\n\x04\x98\x01\x03\
    \0\x03\0\x02\n\x01\x12\x04\xa6\x0e\x1b#\n\x12\n\n\x04\x98\x01\x03\0\x03\
    \0\x02\n\x03\x12\x04\xa6\x0e&(\n\x11\n\x07\x04\x98\x01\x03\0\x04\0\x12\
    \x06\xa9\x0e\x08\xaf\x0e\t\n\x10\n\x08\x04\x98\x01\x03\0\x04\0\x01\x12\
    \x04\xa9\x0e\r\x1b\n\x11\n\t\x04\x98\x01\x03\0\x04\0\x02\0\x12\x04\xaa\
    \x0e\x0c\x1c\n\x12\n\n\x04\x98\x01\x03\0\x04\0\x02\0\x01\x12\x04\xaa\x0e\
    \x0c\x17\n\x12\n\n\x04\x98\x01\x03\0\x04\0\x02\0\x02\x12\x04\xaa\x0e\x1a\
    \x1b\n\x11\n\t\x04\x98\x01\x03\0\x04\0\x02\x01\x12\x04\xab\x0e\x0c\x1a\n\
    \x12\n\n\x04\x98\x01\x03\0\x04\0\x02\x01\x01\x12\x04\xab\x0e\x0c\x15\n\
    \x12\n\n\x04\x98\x01\x03\0\x04\0\x02\x01\x02\x12\x04\xab\x0e\x18\x19\n\
    \x11\n\t\x04\x98\x01\x03\0\x04\0\x02\x02\x12\x04\xac\x0e\x0c\x1a\n\x12\n\
    \n\x04\x98\x01\x03\0\x04\0\x02\x02\x01\x12\x04\xac\x0e\x0c\x15\n\x12\n\n\
    \x04\x98\x01\x03\0\x04\0\x02\x02\x02\x12\x04\xac\x0e\x18\x19\n\x11\n\t\
    \x04\x98\x01\x03\0\x04\0\x02\x03\x12\x04\xad\x0e\x0c\x17\n\x12\n\n\x04\
    \x98\x01\x03\0\x04\0\x02\x03\x01\x12\x04\xad\x0e\x0c\x12\n\x12\n\n\x04\
    \x98\x01\x03\0\x04\0\x02\x03\x02\x12\x04\xad\x0e\x15\x16\n\x11\n\t\x04\
    \x98\x01\x03\0\x04\0\x02\x04\x12\x04\xae\x0e\x0c\x16\n\x12\n\n\x04\x98\
    \x01\x03\0\x04\0\x02\x04\x01\x12\x04\xae\x0e\x0c\x11\n\x12\n\n\x04\x98\
    \x01\x03\0\x04\0\x02\x04\x02\x12\x04\xae\x0e\x14\x15\n\x0f\n\x07\x04\x98\
    \x01\x03\0\x02\0\x12\x04\xb0\x0e\x08%\n\x10\n\x08\x04\x98\x01\x03\0\x02\
    \0\x04\x12\x04\xb0\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\x03\0\x02\0\x05\
    \x12\x04\xb0\x0e\x11\x17\n\x10\n\x08\x04\x98\x01\x03\0\x02\0\x01\x12\x04\
    \xb0\x0e\x18\x20\n\x10\n\x08\x04\x98\x01\x03\0\x02\0\x03\x12\x04\xb0\x0e\
    #$\n\x0f\n\x07\x04\x98\x01\x03\0\x02\x01\x12\x04\xb1\x0e\x08$\n\x10\n\
    \x08\x04\x98\x01\x03\0\x02\x01\x04\x12\x04\xb1\x0e\x08\x10\n\x10\n\x08\
    \x04\x98\x01\x03\0\x02\x01\x05\x12\x04\xb1\x0e\x11\x17\n\x10\n\x08\x04\
    \x98\x01\x03\0\x02\x01\x01\x12\x04\xb1\x0e\x18\x1f\n\x10\n\x08\x04\x98\
    \x01\x03\0\x02\x01\x03\x12\x04\xb1\x0e\"#\n\x0f\n\x07\x04\x98\x01\x03\0\
    \x02\x02\x12\x04\xb2\x0e\x08-\n\x10\n\x08\x04\x98\x01\x03\0\x02\x02\x04\
    \x12\x04\xb2\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\x03\0\x02\x02\x06\x12\
    \x04\xb2\x0e\x11\x1c\n\x10\n\x08\x04\x98\x01\x03\0\x02\x02\x01\x12\x04\
    \xb2\x0e\x1d(\n\x10\n\x08\x04\x98\x01\x03\0\x02\x02\x03\x12\x04\xb2\x0e+\
    ,\n\x0f\n\x07\x04\x98\x01\x03\0\x02\x03\x12\x04\xb3\x0e\x083\n\x10\n\x08\
    \x04\x98\x01\x03\0\x02\x03\x04\x12\x04\xb3\x0e\x08\x10\n\x10\n\x08\x04\
    \x98\x01\x03\0\x02\x03\x06\x12\x04\xb3\x0e\x11\x1f\n\x10\n\x08\x04\x98\
    \x01\x03\0\x02\x03\x01\x12\x04\xb3\x0e\x20.\n\x10\n\x08\x04\x98\x01\x03\
    \0\x02\x03\x03\x12\x04\xb3\x0e12\n\x0f\n\x05\x04\x98\x01\x03\x01\x12\x06\
    \xb6\x0e\x04\xf5\x0e\x05\n\x0e\n\x06\x04\x98\x01\x03\x01\x01\x12\x04\xb6\
    \x0e\x0c\x15\n\x11\n\x07\x04\x98\x01\x03\x01\x04\0\x12\x06\xb7\x0e\x08\
    \xbc\x0e\t\n\x10\n\x08\x04\x98\x01\x03\x01\x04\0\x01\x12\x04\xb7\x0e\r\
    \x1b\n\x11\n\t\x04\x98\x01\x03\x01\x04\0\x02\0\x12\x04\xb8\x0e\x0c\x18\n\
    \x12\n\n\x04\x98\x01\x03\x01\x04\0\x02\0\x01\x12\x04\xb8\x0e\x0c\x13\n\
    \x12\n\n\x04\x98\x01\x03\x01\x04\0\x02\0\x02\x12\x04\xb8\x0e\x16\x17\n\
    \x11\n\t\x04\x98\x01\x03\x01\x04\0\x02\x01\x12\x04\xb9\x0e\x0c\x15\n\x12\
    \n\n\x04\x98\x01\x03\x01\x04\0\x02\x01\x01\x12\x04\xb9\x0e\x0c\x10\n\x12\
    \n\n\x04\x98\x01\x03\x01\x04\0\x02\x01\x02\x12\x04\xb9\x0e\x13\x14\n\x11\
    \n\t\x04\x98\x01\x03\x01\x04\0\x02\x02\x12\x04\xba\x0e\x0c\x16\n\x12\n\n\
    \x04\x98\x01\x03\x01\x04\0\x02\x02\x01\x12\x04\xba\x0e\x0c\x11\n\x12\n\n\
    \x04\x98\x01\x03\x01\x04\0\x02\x02\x02\x12\x04\xba\x0e\x14\x15\n\x11\n\t\
    \x04\x98\x01\x03\x01\x04\0\x02\x03\x12\x04\xbb\x0e\x0c\x16\n\x12\n\n\x04\
    \x98\x01\x03\x01\x04\0\x02\x03\x01\x12\x04\xbb\x0e\x0c\x11\n\x12\n\n\x04\
    \x98\x01\x03\x01\x04\0\x02\x03\x02\x12\x04\xbb\x0e\x14\x15\n\x11\n\x07\
    \x04\x98\x01\x03\x01\x04\x01\x12\x06\xbd\x0e\x08\xdf\x0e\t\n\x10\n\x08\
    \x04\x98\x01\x03\x01\x04\x01\x01\x12\x04\xbd\x0e\r\x15\n\x11\n\t\x04\x98\
    \x01\x03\x01\x04\x01\x02\0\x12\x04\xbe\x0e\x0c\x18\n\x12\n\n\x04\x98\x01\
    \x03\x01\x04\x01\x02\0\x01\x12\x04\xbe\x0e\x0c\x13\n\x12\n\n\x04\x98\x01\
    \x03\x01\x04\x01\x02\0\x02\x12\x04\xbe\x0e\x16\x17\n\x11\n\t\x04\x98\x01\
    \x03\x01\x04\x01\x02\x01\x12\x04\xbf\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\
    \x03\x01\x04\x01\x02\x01\x01\x12\x04\xbf\x0e\x0c\x0f\n\x12\n\n\x04\x98\
    \x01\x03\x01\x04\x01\x02\x01\x02\x12\x04\xbf\x0e\x12\x13\n\x11\n\t\x04\
    \x98\x01\x03\x01\x04\x01\x02\x02\x12\x04\xc0\x0e\x0c\x1e\n\x12\n\n\x04\
    \x98\x01\x03\x01\x04\x01\x02\x02\x01\x12\x04\xc0\x0e\x0c\x19\n\x12\n\n\
    \x04\x98\x01\x03\x01\x04\x01\x02\x02\x02\x12\x04\xc0\x0e\x1c\x1d\n\x11\n\
    \t\x04\x98\x01\x03\x01\x04\x01\x02\x03\x12\x04\xc1\x0e\x0c\x1b\n\x12\n\n\
    \x04\x98\x01\x03\x01\x04\x01\x02\x03\x01\x12\x04\xc1\x0e\x0c\x16\n\x12\n\
    \n\x04\x98\x01\x03\x01\x04\x01\x02\x03\x02\x12\x04\xc1\x0e\x19\x1a\n\x11\
    \n\t\x04\x98\x01\x03\x01\x04\x01\x02\x04\x12\x04\xc2\x0e\x0c\x1c\n\x12\n\
    \n\x04\x98\x01\x03\x01\x04\x01\x02\x04\x01\x12\x04\xc2\x0e\x0c\x17\n\x12\
    \n\n\x04\x98\x01\x03\x01\x04\x01\x02\x04\x02\x12\x04\xc2\x0e\x1a\x1b\n\
    \x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x05\x12\x04\xc3\x0e\x0c\x14\n\
    \x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x05\x01\x12\x04\xc3\x0e\x0c\x0f\
    \n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x05\x02\x12\x04\xc3\x0e\x12\
    \x13\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x06\x12\x04\xc4\x0e\x0c\
    \x14\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x06\x01\x12\x04\xc4\x0e\
    \x0c\x0f\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x06\x02\x12\x04\xc4\
    \x0e\x12\x13\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x07\x12\x04\xc5\
    \x0e\x0c\x1e\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x07\x01\x12\x04\
    \xc5\x0e\x0c\x19\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x07\x02\x12\
    \x04\xc5\x0e\x1c\x1d\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x08\x12\
    \x04\xc6\x0e\x0c\x16\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x08\x01\
    \x12\x04\xc6\x0e\x0c\x11\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x08\
    \x02\x12\x04\xc6\x0e\x14\x15\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\t\
    \x12\x04\xc7\x0e\x0c\x1b\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\t\x01\
    \x12\x04\xc7\x0e\x0c\x16\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\t\x02\
    \x12\x04\xc7\x0e\x19\x1a\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\n\x12\
    \x04\xc8\x0e\x0c\x1d\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\n\x01\x12\
    \x04\xc8\x0e\x0c\x17\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\n\x02\x12\
    \x04\xc8\x0e\x1a\x1c\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x0b\x12\
    \x04\xc9\x0e\x0c\x17\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x0b\x01\
    \x12\x04\xc9\x0e\x0c\x11\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x0b\
    \x02\x12\x04\xc9\x0e\x14\x16\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\
    \x0c\x12\x04\xca\x0e\x0c\x19\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\
    \x0c\x01\x12\x04\xca\x0e\x0c\x13\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\
    \x02\x0c\x02\x12\x04\xca\x0e\x16\x18\n\x11\n\t\x04\x98\x01\x03\x01\x04\
    \x01\x02\r\x12\x04\xcb\x0e\x0c\x19\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\
    \x02\r\x01\x12\x04\xcb\x0e\x0c\x13\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\
    \x02\r\x02\x12\x04\xcb\x0e\x16\x18\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\
    \x02\x0e\x12\x04\xcc\x0e\x0c\x15\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\
    \x02\x0e\x01\x12\x04\xcc\x0e\x0c\x0f\n\x12\n\n\x04\x98\x01\x03\x01\x04\
    \x01\x02\x0e\x02\x12\x04\xcc\x0e\x12\x14\n\x11\n\t\x04\x98\x01\x03\x01\
    \x04\x01\x02\x0f\x12\x04\xcd\x0e\x0c\x18\n\x12\n\n\x04\x98\x01\x03\x01\
    \x04\x01\x02\x0f\x01\x12\x04\xcd\x0e\x0c\x12\n\x12\n\n\x04\x98\x01\x03\
    \x01\x04\x01\x02\x0f\x02\x12\x04\xcd\x0e\x15\x17\n\x11\n\t\x04\x98\x01\
    \x03\x01\x04\x01\x02\x10\x12\x04\xce\x0e\x0c\x1f\n\x12\n\n\x04\x98\x01\
    \x03\x01\x04\x01\x02\x10\x01\x12\x04\xce\x0e\x0c\x19\n\x12\n\n\x04\x98\
    \x01\x03\x01\x04\x01\x02\x10\x02\x12\x04\xce\x0e\x1c\x1e\n\x11\n\t\x04\
    \x98\x01\x03\x01\x04\x01\x02\x11\x12\x04\xcf\x0e\x0c\x1e\n\x12\n\n\x04\
    \x98\x01\x03\x01\x04\x01\x02\x11\x01\x12\x04\xcf\x0e\x0c\x18\n\x12\n\n\
    \x04\x98\x01\x03\x01\x04\x01\x02\x11\x02\x12\x04\xcf\x0e\x1b\x1d\n\x11\n\
    \t\x04\x98\x01\x03\x01\x04\x01\x02\x12\x12\x04\xd0\x0e\x0c\x1e\n\x12\n\n\
    \x04\x98\x01\x03\x01\x04\x01\x02\x12\x01\x12\x04\xd0\x0e\x0c\x18\n\x12\n\
    \n\x04\x98\x01\x03\x01\x04\x01\x02\x12\x02\x12\x04\xd0\x0e\x1b\x1d\n\x11\
    \n\t\x04\x98\x01\x03\x01\x04\x01\x02\x13\x12\x04\xd1\x0e\x0c\x1d\n\x12\n\
    \n\x04\x98\x01\x03\x01\x04\x01\x02\x13\x01\x12\x04\xd1\x0e\x0c\x17\n\x12\
    \n\n\x04\x98\x01\x03\x01\x04\x01\x02\x13\x02\x12\x04\xd1\x0e\x1a\x1c\n\
    \x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x14\x12\x04\xd2\x0e\x0c\x20\n\
    \x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x14\x01\x12\x04\xd2\x0e\x0c\x1a\
    \n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x14\x02\x12\x04\xd2\x0e\x1d\
    \x1f\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x15\x12\x04\xd3\x0e\x0c\
    \x1f\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x15\x01\x12\x04\xd3\x0e\
    \x0c\x19\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x15\x02\x12\x04\xd3\
    \x0e\x1c\x1e\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x16\x12\x04\xd4\
    \x0e\x0c\x20\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x16\x01\x12\x04\
    \xd4\x0e\x0c\x1a\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x16\x02\x12\
    \x04\xd4\x0e\x1d\x1f\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x17\x12\
    \x04\xd5\x0e\x0c\x16\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x17\x01\
    \x12\x04\xd5\x0e\x0c\x10\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x17\
    \x02\x12\x04\xd5\x0e\x13\x15\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\
    \x18\x12\x04\xd6\x0e\x0c\x17\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\
    \x18\x01\x12\x04\xd6\x0e\x0c\x11\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\
    \x02\x18\x02\x12\x04\xd6\x0e\x14\x16\n\x11\n\t\x04\x98\x01\x03\x01\x04\
    \x01\x02\x19\x12\x04\xd7\x0e\x0c\x1c\n\x12\n\n\x04\x98\x01\x03\x01\x04\
    \x01\x02\x19\x01\x12\x04\xd7\x0e\x0c\x16\n\x12\n\n\x04\x98\x01\x03\x01\
    \x04\x01\x02\x19\x02\x12\x04\xd7\x0e\x19\x1b\n\x11\n\t\x04\x98\x01\x03\
    \x01\x04\x01\x02\x1a\x12\x04\xd8\x0e\x0c\x1d\n\x12\n\n\x04\x98\x01\x03\
    \x01\x04\x01\x02\x1a\x01\x12\x04\xd8\x0e\x0c\x17\n\x12\n\n\x04\x98\x01\
    \x03\x01\x04\x01\x02\x1a\x02\x12\x04\xd8\x0e\x1a\x1c\n\x11\n\t\x04\x98\
    \x01\x03\x01\x04\x01\x02\x1b\x12\x04\xd9\x0e\x0c\x17\n\x12\n\n\x04\x98\
    \x01\x03\x01\x04\x01\x02\x1b\x01\x12\x04\xd9\x0e\x0c\x11\n\x12\n\n\x04\
    \x98\x01\x03\x01\x04\x01\x02\x1b\x02\x12\x04\xd9\x0e\x14\x16\n\x11\n\t\
    \x04\x98\x01\x03\x01\x04\x01\x02\x1c\x12\x04\xda\x0e\x0c\x16\n\x12\n\n\
    \x04\x98\x01\x03\x01\x04\x01\x02\x1c\x01\x12\x04\xda\x0e\x0c\x10\n\x12\n\
    \n\x04\x98\x01\x03\x01\x04\x01\x02\x1c\x02\x12\x04\xda\x0e\x13\x15\n\x11\
    \n\t\x04\x98\x01\x03\x01\x04\x01\x02\x1d\x12\x04\xdb\x0e\x0c\x18\n\x12\n\
    \n\x04\x98\x01\x03\x01\x04\x01\x02\x1d\x01\x12\x04\xdb\x0e\x0c\x12\n\x12\
    \n\n\x04\x98\x01\x03\x01\x04\x01\x02\x1d\x02\x12\x04\xdb\x0e\x15\x17\n\
    \x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x1e\x12\x04\xdc\x0e\x0c\x1a\n\
    \x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x1e\x01\x12\x04\xdc\x0e\x0c\x14\
    \n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x1e\x02\x12\x04\xdc\x0e\x17\
    \x19\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x1f\x12\x04\xdd\x0e\x0c\
    \x1a\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x1f\x01\x12\x04\xdd\x0e\
    \x0c\x14\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x1f\x02\x12\x04\xdd\
    \x0e\x17\x19\n\x11\n\t\x04\x98\x01\x03\x01\x04\x01\x02\x20\x12\x04\xde\
    \x0e\x0c\x1a\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x20\x01\x12\x04\
    \xde\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\x03\x01\x04\x01\x02\x20\x02\x12\
    \x04\xde\x0e\x17\x19\n\x11\n\x07\x04\x98\x01\x03\x01\x03\0\x12\x06\xe0\
    \x0e\x08\xe6\x0e\t\n\x10\n\x08\x04\x98\x01\x03\x01\x03\0\x01\x12\x04\xe0\
    \x0e\x10\x1a\n\x11\n\t\x04\x98\x01\x03\x01\x03\0\x02\0\x12\x04\xe1\x0e\
    \x0c(\n\x12\n\n\x04\x98\x01\x03\x01\x03\0\x02\0\x04\x12\x04\xe1\x0e\x0c\
    \x14\n\x12\n\n\x04\x98\x01\x03\x01\x03\0\x02\0\x05\x12\x04\xe1\x0e\x15\
    \x1b\n\x12\n\n\x04\x98\x01\x03\x01\x03\0\x02\0\x01\x12\x04\xe1\x0e\x1c#\
    \n\x12\n\n\x04\x98\x01\x03\x01\x03\0\x02\0\x03\x12\x04\xe1\x0e&'\n\x11\n\
    \t\x04\x98\x01\x03\x01\x03\0\x02\x01\x12\x04\xe2\x0e\x0c*\n\x12\n\n\x04\
    \x98\x01\x03\x01\x03\0\x02\x01\x04\x12\x04\xe2\x0e\x0c\x14\n\x12\n\n\x04\
    \x98\x01\x03\x01\x03\0\x02\x01\x05\x12\x04\xe2\x0e\x15\x1b\n\x12\n\n\x04\
    \x98\x01\x03\x01\x03\0\x02\x01\x01\x12\x04\xe2\x0e\x1c%\n\x12\n\n\x04\
    \x98\x01\x03\x01\x03\0\x02\x01\x03\x12\x04\xe2\x0e()\n\x11\n\t\x04\x98\
    \x01\x03\x01\x03\0\x02\x02\x12\x04\xe3\x0e\x0c)\n\x12\n\n\x04\x98\x01\
    \x03\x01\x03\0\x02\x02\x04\x12\x04\xe3\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\
    \x03\x01\x03\0\x02\x02\x05\x12\x04\xe3\x0e\x15\x1b\n\x12\n\n\x04\x98\x01\
    \x03\x01\x03\0\x02\x02\x01\x12\x04\xe3\x0e\x1c$\n\x12\n\n\x04\x98\x01\
    \x03\x01\x03\0\x02\x02\x03\x12\x04\xe3\x0e'(\n\x11\n\t\x04\x98\x01\x03\
    \x01\x03\0\x02\x03\x12\x04\xe4\x0e\x0c+\n\x12\n\n\x04\x98\x01\x03\x01\
    \x03\0\x02\x03\x04\x12\x04\xe4\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\x03\x01\
    \x03\0\x02\x03\x05\x12\x04\xe4\x0e\x15\x1b\n\x12\n\n\x04\x98\x01\x03\x01\
    \x03\0\x02\x03\x01\x12\x04\xe4\x0e\x1c&\n\x12\n\n\x04\x98\x01\x03\x01\
    \x03\0\x02\x03\x03\x12\x04\xe4\x0e)*\n\x11\n\t\x04\x98\x01\x03\x01\x03\0\
    \x02\x04\x12\x04\xe5\x0e\x0c(\n\x12\n\n\x04\x98\x01\x03\x01\x03\0\x02\
    \x04\x04\x12\x04\xe5\x0e\x0c\x14\n\x12\n\n\x04\x98\x01\x03\x01\x03\0\x02\
    \x04\x05\x12\x04\xe5\x0e\x15\x1b\n\x12\n\n\x04\x98\x01\x03\x01\x03\0\x02\
    \x04\x01\x12\x04\xe5\x0e\x1c#\n\x12\n\n\x04\x98\x01\x03\x01\x03\0\x02\
    \x04\x03\x12\x04\xe5\x0e&'\n\x0f\n\x07\x04\x98\x01\x03\x01\x02\0\x12\x04\
    \xe8\x0e\x08'\n\x10\n\x08\x04\x98\x01\x03\x01\x02\0\x04\x12\x04\xe8\x0e\
    \x08\x10\n\x10\n\x08\x04\x98\x01\x03\x01\x02\0\x06\x12\x04\xe8\x0e\x11\
    \x19\n\x10\n\x08\x04\x98\x01\x03\x01\x02\0\x01\x12\x04\xe8\x0e\x1a\"\n\
    \x10\n\x08\x04\x98\x01\x03\x01\x02\0\x03\x12\x04\xe8\x0e%&\n\x0f\n\x07\
    \x04\x98\x01\x03\x01\x02\x01\x12\x04\xe9\x0e\x08+\n\x10\n\x08\x04\x98\
    \x01\x03\x01\x02\x01\x04\x12\x04\xe9\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\
    \x03\x01\x02\x01\x06\x12\x04\xe9\x0e\x11\x1b\n\x10\n\x08\x04\x98\x01\x03\
    \x01\x02\x01\x01\x12\x04\xe9\x0e\x1c&\n\x10\n\x08\x04\x98\x01\x03\x01\
    \x02\x01\x03\x12\x04\xe9\x0e)*\n\x0f\n\x07\x04\x98\x01\x03\x01\x02\x02\
    \x12\x04\xea\x0e\x08\x20\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x02\x04\x12\
    \x04\xea\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x02\x05\x12\x04\
    \xea\x0e\x11\x17\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x02\x01\x12\x04\xea\
    \x0e\x18\x1b\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x02\x03\x12\x04\xea\x0e\
    \x1e\x1f\n\x0f\n\x07\x04\x98\x01\x03\x01\x02\x03\x12\x04\xeb\x0e\x08\x20\
    \n\x10\n\x08\x04\x98\x01\x03\x01\x02\x03\x04\x12\x04\xeb\x0e\x08\x10\n\
    \x10\n\x08\x04\x98\x01\x03\x01\x02\x03\x05\x12\x04\xeb\x0e\x11\x17\n\x10\
    \n\x08\x04\x98\x01\x03\x01\x02\x03\x01\x12\x04\xeb\x0e\x18\x1b\n\x10\n\
    \x08\x04\x98\x01\x03\x01\x02\x03\x03\x12\x04\xeb\x0e\x1e\x1f\n\x0f\n\x07\
    \x04\x98\x01\x03\x01\x02\x04\x12\x04\xec\x0e\x08&\n\x10\n\x08\x04\x98\
    \x01\x03\x01\x02\x04\x04\x12\x04\xec\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\
    \x03\x01\x02\x04\x05\x12\x04\xec\x0e\x11\x17\n\x10\n\x08\x04\x98\x01\x03\
    \x01\x02\x04\x01\x12\x04\xec\x0e\x18!\n\x10\n\x08\x04\x98\x01\x03\x01\
    \x02\x04\x03\x12\x04\xec\x0e$%\n\x0f\n\x07\x04\x98\x01\x03\x01\x02\x05\
    \x12\x04\xed\x0e\x08)\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x05\x04\x12\
    \x04\xed\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x05\x05\x12\x04\
    \xed\x0e\x11\x17\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x05\x01\x12\x04\xed\
    \x0e\x18$\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x05\x03\x12\x04\xed\x0e'(\
    \n\x0f\n\x07\x04\x98\x01\x03\x01\x02\x06\x12\x04\xee\x0e\x08#\n\x10\n\
    \x08\x04\x98\x01\x03\x01\x02\x06\x04\x12\x04\xee\x0e\x08\x10\n\x10\n\x08\
    \x04\x98\x01\x03\x01\x02\x06\x05\x12\x04\xee\x0e\x11\x17\n\x10\n\x08\x04\
    \x98\x01\x03\x01\x02\x06\x01\x12\x04\xee\x0e\x18\x1e\n\x10\n\x08\x04\x98\
    \x01\x03\x01\x02\x06\x03\x12\x04\xee\x0e!\"\n\x0f\n\x07\x04\x98\x01\x03\
    \x01\x02\x07\x12\x04\xef\x0e\x08*\n\x10\n\x08\x04\x98\x01\x03\x01\x02\
    \x07\x04\x12\x04\xef\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x07\
    \x05\x12\x04\xef\x0e\x11\x17\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x07\x01\
    \x12\x04\xef\x0e\x18%\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x07\x03\x12\
    \x04\xef\x0e()\n\x0f\n\x07\x04\x98\x01\x03\x01\x02\x08\x12\x04\xf0\x0e\
    \x08$\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x08\x04\x12\x04\xf0\x0e\x08\
    \x10\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x08\x05\x12\x04\xf0\x0e\x11\x17\
    \n\x10\n\x08\x04\x98\x01\x03\x01\x02\x08\x01\x12\x04\xf0\x0e\x18\x1f\n\
    \x10\n\x08\x04\x98\x01\x03\x01\x02\x08\x03\x12\x04\xf0\x0e\"#\n\x0f\n\
    \x07\x04\x98\x01\x03\x01\x02\t\x12\x04\xf1\x0e\x084\n\x10\n\x08\x04\x98\
    \x01\x03\x01\x02\t\x04\x12\x04\xf1\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\
    \x03\x01\x02\t\x06\x12\x04\xf1\x0e\x11\x1f\n\x10\n\x08\x04\x98\x01\x03\
    \x01\x02\t\x01\x12\x04\xf1\x0e\x20.\n\x10\n\x08\x04\x98\x01\x03\x01\x02\
    \t\x03\x12\x04\xf1\x0e13\n\x0f\n\x07\x04\x98\x01\x03\x01\x02\n\x12\x04\
    \xf2\x0e\x083\n\x10\n\x08\x04\x98\x01\x03\x01\x02\n\x04\x12\x04\xf2\x0e\
    \x08\x10\n\x10\n\x08\x04\x98\x01\x03\x01\x02\n\x05\x12\x04\xf2\x0e\x11\
    \x17\n\x10\n\x08\x04\x98\x01\x03\x01\x02\n\x01\x12\x04\xf2\x0e\x18-\n\
    \x10\n\x08\x04\x98\x01\x03\x01\x02\n\x03\x12\x04\xf2\x0e02\n\x0f\n\x07\
    \x04\x98\x01\x03\x01\x02\x0b\x12\x04\xf3\x0e\x089\n\x10\n\x08\x04\x98\
    \x01\x03\x01\x02\x0b\x04\x12\x04\xf3\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\
    \x03\x01\x02\x0b\x05\x12\x04\xf3\x0e\x11\x17\n\x10\n\x08\x04\x98\x01\x03\
    \x01\x02\x0b\x01\x12\x04\xf3\x0e\x183\n\x10\n\x08\x04\x98\x01\x03\x01\
    \x02\x0b\x03\x12\x04\xf3\x0e68\n\x0f\n\x07\x04\x98\x01\x03\x01\x02\x0c\
    \x12\x04\xf4\x0e\x08)\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x0c\x04\x12\
    \x04\xf4\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x0c\x05\x12\x04\
    \xf4\x0e\x11\x17\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x0c\x01\x12\x04\xf4\
    \x0e\x18#\n\x10\n\x08\x04\x98\x01\x03\x01\x02\x0c\x03\x12\x04\xf4\x0e&(\
    \n\x0f\n\x05\x04\x98\x01\x04\0\x12\x06\xf7\x0e\x04\xfa\x0e\x05\n\x0e\n\
    \x06\x04\x98\x01\x04\0\x01\x12\x04\xf7\x0e\t\x10\n\x0f\n\x07\x04\x98\x01\
    \x04\0\x02\0\x12\x04\xf8\x0e\x08\x15\n\x10\n\x08\x04\x98\x01\x04\0\x02\0\
    \x01\x12\x04\xf8\x0e\x08\x10\n\x10\n\x08\x04\x98\x01\x04\0\x02\0\x02\x12\
    \x04\xf8\x0e\x13\x14\n\x0f\n\x07\x04\x98\x01\x04\0\x02\x01\x12\x04\xf9\
    \x0e\x08\x16\n\x10\n\x08\x04\x98\x01\x04\0\x02\x01\x01\x12\x04\xf9\x0e\
    \x08\x11\n\x10\n\x08\x04\x98\x01\x04\0\x02\x01\x02\x12\x04\xf9\x0e\x14\
    \x15\n\x0f\n\x05\x04\x98\x01\x04\x01\x12\x06\xfb\x0e\x04\xff\x0e\x05\n\
    \x0e\n\x06\x04\x98\x01\x04\x01\x01\x12\x04\xfb\x0e\t\x18\n\x0f\n\x07\x04\
    \x98\x01\x04\x01\x02\0\x12\x04\xfc\x0e\x08\x1c\n\x10\n\x08\x04\x98\x01\
    \x04\x01\x02\0\x01\x12\x04\xfc\x0e\x08\x17\n\x10\n\x08\x04\x98\x01\x04\
    \x01\x02\0\x02\x12\x04\xfc\x0e\x1a\x1b\n\x0f\n\x07\x04\x98\x01\x04\x01\
    \x02\x01\x12\x04\xfd\x0e\x08\x1e\n\x10\n\x08\x04\x98\x01\x04\x01\x02\x01\
    \x01\x12\x04\xfd\x0e\x08\x19\n\x10\n\x08\x04\x98\x01\x04\x01\x02\x01\x02\
    \x12\x04\xfd\x0e\x1c\x1d\n\x0f\n\x07\x04\x98\x01\x04\x01\x02\x02\x12\x04\
    \xfe\x0e\x08\x1e\n\x10\n\x08\x04\x98\x01\x04\x01\x02\x02\x01\x12\x04\xfe\
    \x0e\x08\x19\n\x10\n\x08\x04\x98\x01\x04\x01\x02\x02\x02\x12\x04\xfe\x0e\
    \x1c\x1d\n\x0f\n\x05\x04\x98\x01\x03\x02\x12\x06\x80\x0f\x04\x89\x0f\x05\
    \n\x0e\n\x06\x04\x98\x01\x03\x02\x01\x12\x04\x80\x0f\x0c)\n\x0f\n\x07\
    \x04\x98\x01\x03\x02\x02\0\x12\x04\x81\x0f\x08\"\n\x10\n\x08\x04\x98\x01\
    \x03\x02\x02\0\x04\x12\x04\x81\x0f\x08\x10\n\x10\n\x08\x04\x98\x01\x03\
    \x02\x02\0\x05\x12\x04\x81\x0f\x11\x16\n\x10\n\x08\x04\x98\x01\x03\x02\
    \x02\0\x01\x12\x04\x81\x0f\x17\x1d\n\x10\n\x08\x04\x98\x01\x03\x02\x02\0\
    \x03\x12\x04\x81\x0f\x20!\n\x0f\n\x07\x04\x98\x01\x03\x02\x02\x01\x12\
    \x04\x82\x0f\x08$\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x01\x04\x12\x04\
    \x82\x0f\x08\x10\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x01\x05\x12\x04\x82\
    \x0f\x11\x16\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x01\x01\x12\x04\x82\x0f\
    \x17\x1f\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x01\x03\x12\x04\x82\x0f\"#\
    \n\x0f\n\x07\x04\x98\x01\x03\x02\x02\x02\x12\x04\x83\x0f\x08\"\n\x10\n\
    \x08\x04\x98\x01\x03\x02\x02\x02\x04\x12\x04\x83\x0f\x08\x10\n\x10\n\x08\
    \x04\x98\x01\x03\x02\x02\x02\x05\x12\x04\x83\x0f\x11\x16\n\x10\n\x08\x04\
    \x98\x01\x03\x02\x02\x02\x01\x12\x04\x83\x0f\x17\x1d\n\x10\n\x08\x04\x98\
    \x01\x03\x02\x02\x02\x03\x12\x04\x83\x0f\x20!\n\x0f\n\x07\x04\x98\x01\
    \x03\x02\x02\x03\x12\x04\x84\x0f\x08#\n\x10\n\x08\x04\x98\x01\x03\x02\
    \x02\x03\x04\x12\x04\x84\x0f\x08\x10\n\x10\n\x08\x04\x98\x01\x03\x02\x02\
    \x03\x05\x12\x04\x84\x0f\x11\x16\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x03\
    \x01\x12\x04\x84\x0f\x17\x1e\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x03\x03\
    \x12\x04\x84\x0f!\"\n\x0f\n\x07\x04\x98\x01\x03\x02\x02\x04\x12\x04\x85\
    \x0f\x08$\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x04\x04\x12\x04\x85\x0f\
    \x08\x10\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x04\x05\x12\x04\x85\x0f\x11\
    \x16\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x04\x01\x12\x04\x85\x0f\x17\x1f\
    \n\x10\n\x08\x04\x98\x01\x03\x02\x02\x04\x03\x12\x04\x85\x0f\"#\n\x0f\n\
    \x07\x04\x98\x01\x03\x02\x02\x05\x12\x04\x86\x0f\x08$\n\x10\n\x08\x04\
    \x98\x01\x03\x02\x02\x05\x04\x12\x04\x86\x0f\x08\x10\n\x10\n\x08\x04\x98\
    \x01\x03\x02\x02\x05\x05\x12\x04\x86\x0f\x11\x16\n\x10\n\x08\x04\x98\x01\
    \x03\x02\x02\x05\x01\x12\x04\x86\x0f\x17\x1f\n\x10\n\x08\x04\x98\x01\x03\
    \x02\x02\x05\x03\x12\x04\x86\x0f\"#\n\x0f\n\x07\x04\x98\x01\x03\x02\x02\
    \x06\x12\x04\x87\x0f\x08%\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x06\x04\
    \x12\x04\x87\x0f\x08\x10\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x06\x05\x12\
    \x04\x87\x0f\x11\x16\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x06\x01\x12\x04\
    \x87\x0f\x17\x20\n\x10\n\x08\x04\x98\x01\x03\x02\x02\x06\x03\x12\x04\x87\
    \x0f#$\n\x0f\n\x07\x04\x98\x01\x03\x02\x02\x07\x12\x04\x88\x0f\x08'\n\
    \x10\n\x08\x04\x98\x01\x03\x02\x02\x07\x04\x12\x04\x88\x0f\x08\x10\n\x10\
    \n\x08\x04\x98\x01\x03\x02\x02\x07\x05\x12\x04\x88\x0f\x11\x16\n\x10\n\
    \x08\x04\x98\x01\x03\x02\x02\x07\x01\x12\x04\x88\x0f\x17\"\n\x10\n\x08\
    \x04\x98\x01\x03\x02\x02\x07\x03\x12\x04\x88\x0f%&\n\x0f\n\x05\x04\x98\
    \x01\x03\x03\x12\x06\x8b\x0f\x04\x95\x0f\x05\n\x0e\n\x06\x04\x98\x01\x03\
    \x03\x01\x12\x04\x8b\x0f\x0c\x15\n\x11\n\x07\x04\x98\x01\x03\x03\x04\0\
    \x12\x06\x8c\x0f\x08\x92\x0f\t\n\x10\n\x08\x04\x98\x01\x03\x03\x04\0\x01\
    \x12\x04\x8c\x0f\r\x20\n\x11\n\t\x04\x98\x01\x03\x03\x04\0\x02\0\x12\x04\
    \x8d\x0f\x0c\x17\n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\0\x01\x12\x04\
    \x8d\x0f\x0c\x12\n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\0\x02\x12\x04\
    \x8d\x0f\x15\x16\n\x11\n\t\x04\x98\x01\x03\x03\x04\0\x02\x01\x12\x04\x8e\
    \x0f\x0c\x17\n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\x01\x01\x12\x04\x8e\
    \x0f\x0c\x12\n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\x01\x02\x12\x04\x8e\
    \x0f\x15\x16\n\x11\n\t\x04\x98\x01\x03\x03\x04\0\x02\x02\x12\x04\x8f\x0f\
    \x0c\x1a\n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\x02\x01\x12\x04\x8f\x0f\
    \x0c\x15\n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\x02\x02\x12\x04\x8f\x0f\
    \x18\x19\n\x11\n\t\x04\x98\x01\x03\x03\x04\0\x02\x03\x12\x04\x90\x0f\x0c\
    \x19\n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\x03\x01\x12\x04\x90\x0f\x0c\
    \x14\n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\x03\x02\x12\x04\x90\x0f\x17\
    \x18\n\x11\n\t\x04\x98\x01\x03\x03\x04\0\x02\x04\x12\x04\x91\x0f\x0c\x19\
    \n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\x04\x01\x12\x04\x91\x0f\x0c\x14\
    \n\x12\n\n\x04\x98\x01\x03\x03\x04\0\x02\x04\x02\x12\x04\x91\x0f\x17\x18\
    \n\x0f\n\x07\x04\x98\x01\x03\x03\x02\0\x12\x04\x93\x0f\x084\n\x10\n\x08\
    \x04\x98\x01\x03\x03\x02\0\x04\x12\x04\x93\x0f\x08\x10\n\x10\n\x08\x04\
    \x98\x01\x03\x03\x02\0\x06\x12\x04\x93\x0f\x11$\n\x10\n\x08\x04\x98\x01\
    \x03\x03\x02\0\x01\x12\x04\x93\x0f%.\n\x10\n\x08\x04\x98\x01\x03\x03\x02\
    \0\x03\x12\x04\x93\x0f13\n\x0f\n\x07\x04\x98\x01\x03\x03\x02\x01\x12\x04\
    \x94\x0f\x08%\n\x10\n\x08\x04\x98\x01\x03\x03\x02\x01\x04\x12\x04\x94\
    \x0f\x08\x10\n\x10\n\x08\x04\x98\x01\x03\x03\x02\x01\x05\x12\x04\x94\x0f\
    \x11\x15\n\x10\n\x08\x04\x98\x01\x03\x03\x02\x01\x01\x12\x04\x94\x0f\x16\
    \x1f\n\x10\n\x08\x04\x98\x01\x03\x03\x02\x01\x03\x12\x04\x94\x0f\"$\n\
    \x0f\n\x05\x04\x98\x01\x04\x02\x12\x06\x97\x0f\x04\xa7\x0f\x05\n\x0e\n\
    \x06\x04\x98\x01\x04\x02\x01\x12\x04\x97\x0f\t\x14\n\x0f\n\x07\x04\x98\
    \x01\x04\x02\x02\0\x12\x04\x98\x0f\x08\x1d\n\x10\n\x08\x04\x98\x01\x04\
    \x02\x02\0\x01\x12\x04\x98\x0f\x08\x18\n\x10\n\x08\x04\x98\x01\x04\x02\
    \x02\0\x02\x12\x04\x98\x0f\x1b\x1c\n\x0f\n\x07\x04\x98\x01\x04\x02\x02\
    \x01\x12\x04\x99\x0f\x08\x19\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x01\x01\
    \x12\x04\x99\x0f\x08\x14\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x01\x02\x12\
    \x04\x99\x0f\x17\x18\n\x0f\n\x07\x04\x98\x01\x04\x02\x02\x02\x12\x04\x9a\
    \x0f\x08\x1c\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x02\x01\x12\x04\x9a\x0f\
    \x08\x15\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x02\x02\x12\x04\x9a\x0f\x18\
    \x1b\n\x0f\n\x07\x04\x98\x01\x04\x02\x02\x03\x12\x04\x9b\x0f\x08\x1c\n\
    \x10\n\x08\x04\x98\x01\x04\x02\x02\x03\x01\x12\x04\x9b\x0f\x08\x15\n\x10\
    \n\x08\x04\x98\x01\x04\x02\x02\x03\x02\x12\x04\x9b\x0f\x18\x1b\n\x0f\n\
    \x07\x04\x98\x01\x04\x02\x02\x04\x12\x04\x9c\x0f\x08\x1c\n\x10\n\x08\x04\
    \x98\x01\x04\x02\x02\x04\x01\x12\x04\x9c\x0f\x08\x15\n\x10\n\x08\x04\x98\
    \x01\x04\x02\x02\x04\x02\x12\x04\x9c\x0f\x18\x1b\n\x0f\n\x07\x04\x98\x01\
    \x04\x02\x02\x05\x12\x04\x9d\x0f\x08\x1c\n\x10\n\x08\x04\x98\x01\x04\x02\
    \x02\x05\x01\x12\x04\x9d\x0f\x08\x15\n\x10\n\x08\x04\x98\x01\x04\x02\x02\
    \x05\x02\x12\x04\x9d\x0f\x18\x1b\n\x0f\n\x07\x04\x98\x01\x04\x02\x02\x06\
    \x12\x04\x9e\x0f\x08\x1c\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x06\x01\x12\
    \x04\x9e\x0f\x08\x15\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x06\x02\x12\x04\
    \x9e\x0f\x18\x1b\n\x0f\n\x07\x04\x98\x01\x04\x02\x02\x07\x12\x04\x9f\x0f\
    \x08\x1d\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x07\x01\x12\x04\x9f\x0f\x08\
    \x16\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x07\x02\x12\x04\x9f\x0f\x19\x1c\
    \n\x0f\n\x07\x04\x98\x01\x04\x02\x02\x08\x12\x04\xa0\x0f\x08\x1d\n\x10\n\
    \x08\x04\x98\x01\x04\x02\x02\x08\x01\x12\x04\xa0\x0f\x08\x16\n\x10\n\x08\
    \x04\x98\x01\x04\x02\x02\x08\x02\x12\x04\xa0\x0f\x19\x1c\n\x0f\n\x07\x04\
    \x98\x01\x04\x02\x02\t\x12\x04\xa1\x0f\x08\x1c\n\x10\n\x08\x04\x98\x01\
    \x04\x02\x02\t\x01\x12\x04\xa1\x0f\x08\x15\n\x10\n\x08\x04\x98\x01\x04\
    \x02\x02\t\x02\x12\x04\xa1\x0f\x18\x1b\n\x0f\n\x07\x04\x98\x01\x04\x02\
    \x02\n\x12\x04\xa2\x0f\x08\x1c\n\x10\n\x08\x04\x98\x01\x04\x02\x02\n\x01\
    \x12\x04\xa2\x0f\x08\x15\n\x10\n\x08\x04\x98\x01\x04\x02\x02\n\x02\x12\
    \x04\xa2\x0f\x18\x1b\n\x0f\n\x07\x04\x98\x01\x04\x02\x02\x0b\x12\x04\xa3\
    \x0f\x08\x1d\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x0b\x01\x12\x04\xa3\x0f\
    \x08\x16\n\x10\n\x08\x04\x98\x01\x04\x02\x02\x0b\x02\x12\x04\xa3\x0f\x19\
    \x1c\n\x0f\n\x07\x04\x98\x01\x04\x02\x02\x0c\x12\x04\xa4\x0f\x08\x1d\n\
    \x10\n\x08\x04\x98\x01\x04\x02\x02\x0c\x01\x12\x04\xa4\x0f\x08\x16\n\x10\
    \n\x08\x04\x98\x01\x04\x02\x02\x0c\x02\x12\x04\xa4\x0f\x19\x1c\n\x0f\n\
    \x07\x04\x98\x01\x04\x02\x02\r\x12\x04\xa5\x0f\x08\x1b\n\x10\n\x08\x04\
    \x98\x01\x04\x02\x02\r\x01\x12\x04\xa5\x0f\x08\x14\n\x10\n\x08\x04\x98\
    \x01\x04\x02\x02\r\x02\x12\x04\xa5\x0f\x17\x1a\n\x0f\n\x07\x04\x98\x01\
    \x04\x02\x02\x0e\x12\x04\xa6\x0f\x08\x1d\n\x10\n\x08\x04\x98\x01\x04\x02\
    \x02\x0e\x01\x12\x04\xa6\x0f\x08\x16\n\x10\n\x08\x04\x98\x01\x04\x02\x02\
    \x0e\x02\x12\x04\xa6\x0f\x19\x1c\n\x0f\n\x05\x04\x98\x01\x04\x03\x12\x06\
    \xa8\x0f\x04\xaf\x0f\x05\n\x0e\n\x06\x04\x98\x01\x04\x03\x01\x12\x04\xa8\
    \x0f\t\x16\n\x0f\n\x07\x04\x98\x01\x04\x03\x02\0\x12\x04\xa9\x0f\x08\x11\
    \n\x10\n\x08\x04\x98\x01\x04\x03\x02\0\x01\x12\x04\xa9\x0f\x08\x0c\n\x10\
    \n\x08\x04\x98\x01\x04\x03\x02\0\x02\x12\x04\xa9\x0f\x0f\x10\n\x0f\n\x07\
    \x04\x98\x01\x04\x03\x02\x01\x12\x04\xaa\x0f\x08\x1b\n\x10\n\x08\x04\x98\
    \x01\x04\x03\x02\x01\x01\x12\x04\xaa\x0f\x08\x16\n\x10\n\x08\x04\x98\x01\
    \x04\x03\x02\x01\x02\x12\x04\xaa\x0f\x19\x1a\n\x0f\n\x07\x04\x98\x01\x04\
    \x03\x02\x02\x12\x04\xab\x0f\x08\x16\n\x10\n\x08\x04\x98\x01\x04\x03\x02\
    \x02\x01\x12\x04\xab\x0f\x08\x11\n\x10\n\x08\x04\x98\x01\x04\x03\x02\x02\
    \x02\x12\x04\xab\x0f\x14\x15\n\x0f\n\x07\x04\x98\x01\x04\x03\x02\x03\x12\
    \x04\xac\x0f\x08\x1c\n\x10\n\x08\x04\x98\x01\x04\x03\x02\x03\x01\x12\x04\
    \xac\x0f\x08\x17\n\x10\n\x08\x04\x98\x01\x04\x03\x02\x03\x02\x12\x04\xac\
    \x0f\x1a\x1b\n\x0f\n\x07\x04\x98\x01\x04\x03\x02\x04\x12\x04\xad\x0f\x08\
    \x1b\n\x10\n\x08\x04\x98\x01\x04\x03\x02\x04\x01\x12\x04\xad\x0f\x08\x16\
    \n\x10\n\x08\x04\x98\x01\x04\x03\x02\x04\x02\x12\x04\xad\x0f\x19\x1a\n\
    \x0f\n\x07\x04\x98\x01\x04\x03\x02\x05\x12\x04\xae\x0f\x08\x1b\n\x10\n\
    \x08\x04\x98\x01\x04\x03\x02\x05\x01\x12\x04\xae\x0f\x08\x16\n\x10\n\x08\
    \x04\x98\x01\x04\x03\x02\x05\x02\x12\x04\xae\x0f\x19\x1a\n\r\n\x05\x04\
    \x98\x01\x02\0\x12\x04\xb0\x0f\x04!\n\x0e\n\x06\x04\x98\x01\x02\0\x04\
    \x12\x04\xb0\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\0\x05\x12\x04\xb0\
    \x0f\r\x13\n\x0e\n\x06\x04\x98\x01\x02\0\x01\x12\x04\xb0\x0f\x14\x1c\n\
    \x0e\n\x06\x04\x98\x01\x02\0\x03\x12\x04\xb0\x0f\x1f\x20\n\r\n\x05\x04\
    \x98\x01\x02\x01\x12\x04\xb1\x0f\x04\x1e\n\x0e\n\x06\x04\x98\x01\x02\x01\
    \x04\x12\x04\xb1\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x01\x05\x12\x04\
    \xb1\x0f\r\x11\n\x0e\n\x06\x04\x98\x01\x02\x01\x01\x12\x04\xb1\x0f\x12\
    \x19\n\x0e\n\x06\x04\x98\x01\x02\x01\x03\x12\x04\xb1\x0f\x1c\x1d\n\r\n\
    \x05\x04\x98\x01\x02\x02\x12\x04\xb2\x0f\x04%\n\x0e\n\x06\x04\x98\x01\
    \x02\x02\x04\x12\x04\xb2\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x02\x06\
    \x12\x04\xb2\x0f\r\x16\n\x0e\n\x06\x04\x98\x01\x02\x02\x01\x12\x04\xb2\
    \x0f\x17\x20\n\x0e\n\x06\x04\x98\x01\x02\x02\x03\x12\x04\xb2\x0f#$\n\r\n\
    \x05\x04\x98\x01\x02\x03\x12\x04\xb3\x0f\x04!\n\x0e\n\x06\x04\x98\x01\
    \x02\x03\x04\x12\x04\xb3\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x03\x06\
    \x12\x04\xb3\x0f\r\x14\n\x0e\n\x06\x04\x98\x01\x02\x03\x01\x12\x04\xb3\
    \x0f\x15\x1c\n\x0e\n\x06\x04\x98\x01\x02\x03\x03\x12\x04\xb3\x0f\x1f\x20\
    \n\r\n\x05\x04\x98\x01\x02\x04\x12\x04\xb4\x0f\x04!\n\x0e\n\x06\x04\x98\
    \x01\x02\x04\x04\x12\x04\xb4\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x04\
    \x05\x12\x04\xb4\x0f\r\x13\n\x0e\n\x06\x04\x98\x01\x02\x04\x01\x12\x04\
    \xb4\x0f\x14\x1c\n\x0e\n\x06\x04\x98\x01\x02\x04\x03\x12\x04\xb4\x0f\x1f\
    \x20\n\r\n\x05\x04\x98\x01\x02\x05\x12\x04\xb5\x0f\x04$\n\x0e\n\x06\x04\
    \x98\x01\x02\x05\x04\x12\x04\xb5\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\
    \x05\x05\x12\x04\xb5\x0f\r\x15\n\x0e\n\x06\x04\x98\x01\x02\x05\x01\x12\
    \x04\xb5\x0f\x16\x1f\n\x0e\n\x06\x04\x98\x01\x02\x05\x03\x12\x04\xb5\x0f\
    \"#\n\r\n\x05\x04\x98\x01\x02\x06\x12\x04\xb6\x0f\x04$\n\x0e\n\x06\x04\
    \x98\x01\x02\x06\x04\x12\x04\xb6\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\
    \x06\x05\x12\x04\xb6\x0f\r\x11\n\x0e\n\x06\x04\x98\x01\x02\x06\x01\x12\
    \x04\xb6\x0f\x12\x1e\n\x0e\n\x06\x04\x98\x01\x02\x06\x03\x12\x04\xb6\x0f\
    !#\n\r\n\x05\x04\x98\x01\x02\x07\x12\x04\xb7\x0f\x04*\n\x0e\n\x06\x04\
    \x98\x01\x02\x07\x04\x12\x04\xb7\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\
    \x07\x06\x12\x04\xb7\x0f\r\x18\n\x0e\n\x06\x04\x98\x01\x02\x07\x01\x12\
    \x04\xb7\x0f\x19$\n\x0e\n\x06\x04\x98\x01\x02\x07\x03\x12\x04\xb7\x0f')\
    \n\r\n\x05\x04\x98\x01\x02\x08\x12\x04\xb8\x0f\x04.\n\x0e\n\x06\x04\x98\
    \x01\x02\x08\x04\x12\x04\xb8\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x08\
    \x06\x12\x04\xb8\x0f\r\x1a\n\x0e\n\x06\x04\x98\x01\x02\x08\x01\x12\x04\
    \xb8\x0f\x1b(\n\x0e\n\x06\x04\x98\x01\x02\x08\x03\x12\x04\xb8\x0f+-\n\r\
    \n\x05\x04\x98\x01\x02\t\x12\x04\xb9\x0f\x04\x1f\n\x0e\n\x06\x04\x98\x01\
    \x02\t\x04\x12\x04\xb9\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\t\x05\x12\
    \x04\xb9\x0f\r\x12\n\x0e\n\x06\x04\x98\x01\x02\t\x01\x12\x04\xb9\x0f\x13\
    \x19\n\x0e\n\x06\x04\x98\x01\x02\t\x03\x12\x04\xb9\x0f\x1c\x1e\n\r\n\x05\
    \x04\x98\x01\x02\n\x12\x04\xba\x0f\x04&\n\x0e\n\x06\x04\x98\x01\x02\n\
    \x04\x12\x04\xba\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\n\x06\x12\x04\
    \xba\x0f\r\x16\n\x0e\n\x06\x04\x98\x01\x02\n\x01\x12\x04\xba\x0f\x17\x20\
    \n\x0e\n\x06\x04\x98\x01\x02\n\x03\x12\x04\xba\x0f#%\n\r\n\x05\x04\x98\
    \x01\x02\x0b\x12\x04\xbb\x0f\x04-\n\x0e\n\x06\x04\x98\x01\x02\x0b\x04\
    \x12\x04\xbb\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x0b\x05\x12\x04\xbb\
    \x0f\r\x13\n\x0e\n\x06\x04\x98\x01\x02\x0b\x01\x12\x04\xbb\x0f\x14'\n\
    \x0e\n\x06\x04\x98\x01\x02\x0b\x03\x12\x04\xbb\x0f*,\n\r\n\x05\x04\x98\
    \x01\x02\x0c\x12\x04\xbc\x0f\x04\x20\n\x0e\n\x06\x04\x98\x01\x02\x0c\x04\
    \x12\x04\xbc\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x0c\x05\x12\x04\xbc\
    \x0f\r\x13\n\x0e\n\x06\x04\x98\x01\x02\x0c\x01\x12\x04\xbc\x0f\x14\x1a\n\
    \x0e\n\x06\x04\x98\x01\x02\x0c\x03\x12\x04\xbc\x0f\x1d\x1f\n\r\n\x05\x04\
    \x98\x01\x02\r\x12\x04\xbd\x0f\x04B\n\x0e\n\x06\x04\x98\x01\x02\r\x04\
    \x12\x04\xbd\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\r\x06\x12\x04\xbd\
    \x0f\r*\n\x0e\n\x06\x04\x98\x01\x02\r\x01\x12\x04\xbd\x0f+<\n\x0e\n\x06\
    \x04\x98\x01\x02\r\x03\x12\x04\xbd\x0f?A\n\r\n\x05\x04\x98\x01\x02\x0e\
    \x12\x04\xbe\x0f\x04\"\n\x0e\n\x06\x04\x98\x01\x02\x0e\x04\x12\x04\xbe\
    \x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x0e\x06\x12\x04\xbe\x0f\r\x14\n\
    \x0e\n\x06\x04\x98\x01\x02\x0e\x01\x12\x04\xbe\x0f\x15\x1c\n\x0e\n\x06\
    \x04\x98\x01\x02\x0e\x03\x12\x04\xbe\x0f\x1f!\n\r\n\x05\x04\x98\x01\x02\
    \x0f\x12\x04\xbf\x0f\x04\x1e\n\x0e\n\x06\x04\x98\x01\x02\x0f\x04\x12\x04\
    \xbf\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x0f\x05\x12\x04\xbf\x0f\r\
    \x12\n\x0e\n\x06\x04\x98\x01\x02\x0f\x01\x12\x04\xbf\x0f\x13\x18\n\x0e\n\
    \x06\x04\x98\x01\x02\x0f\x03\x12\x04\xbf\x0f\x1b\x1d\n\r\n\x05\x04\x98\
    \x01\x02\x10\x12\x04\xc0\x0f\x04$\n\x0e\n\x06\x04\x98\x01\x02\x10\x04\
    \x12\x04\xc0\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x10\x05\x12\x04\xc0\
    \x0f\r\x12\n\x0e\n\x06\x04\x98\x01\x02\x10\x01\x12\x04\xc0\x0f\x13\x1e\n\
    \x0e\n\x06\x04\x98\x01\x02\x10\x03\x12\x04\xc0\x0f!#\n\r\n\x05\x04\x98\
    \x01\x02\x11\x12\x04\xc1\x0f\x04\x1a\n\x0e\n\x06\x04\x98\x01\x02\x11\x04\
    \x12\x04\xc1\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x11\x05\x12\x04\xc1\
    \x0f\r\x11\n\x0e\n\x06\x04\x98\x01\x02\x11\x01\x12\x04\xc1\x0f\x12\x14\n\
    \x0e\n\x06\x04\x98\x01\x02\x11\x03\x12\x04\xc1\x0f\x17\x19\n\r\n\x05\x04\
    \x98\x01\x02\x12\x12\x04\xc2\x0f\x04\x1b\n\x0e\n\x06\x04\x98\x01\x02\x12\
    \x04\x12\x04\xc2\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x12\x05\x12\x04\
    \xc2\x0f\r\x12\n\x0e\n\x06\x04\x98\x01\x02\x12\x01\x12\x04\xc2\x0f\x13\
    \x15\n\x0e\n\x06\x04\x98\x01\x02\x12\x03\x12\x04\xc2\x0f\x18\x1a\n\r\n\
    \x05\x04\x98\x01\x02\x13\x12\x04\xc3\x0f\x042\n\x0e\n\x06\x04\x98\x01\
    \x02\x13\x04\x12\x04\xc3\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x13\x06\
    \x12\x04\xc3\x0f\r\x1c\n\x0e\n\x06\x04\x98\x01\x02\x13\x01\x12\x04\xc3\
    \x0f\x1d,\n\x0e\n\x06\x04\x98\x01\x02\x13\x03\x12\x04\xc3\x0f/1\n\r\n\
    \x05\x04\x98\x01\x02\x14\x12\x04\xc4\x0f\x04!\n\x0e\n\x06\x04\x98\x01\
    \x02\x14\x04\x12\x04\xc4\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x14\x05\
    \x12\x04\xc4\x0f\r\x13\n\x0e\n\x06\x04\x98\x01\x02\x14\x01\x12\x04\xc4\
    \x0f\x14\x1b\n\x0e\n\x06\x04\x98\x01\x02\x14\x03\x12\x04\xc4\x0f\x1e\x20\
    \n\r\n\x05\x04\x98\x01\x02\x15\x12\x04\xc5\x0f\x04#\n\x0e\n\x06\x04\x98\
    \x01\x02\x15\x04\x12\x04\xc5\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\x15\
    \x05\x12\x04\xc5\x0f\r\x12\n\x0e\n\x06\x04\x98\x01\x02\x15\x01\x12\x04\
    \xc5\x0f\x13\x1d\n\x0e\n\x06\x04\x98\x01\x02\x15\x03\x12\x04\xc5\x0f\x20\
    \"\n\r\n\x05\x04\x98\x01\x02\x16\x12\x04\xc6\x0f\x04\x1c\n\x0e\n\x06\x04\
    \x98\x01\x02\x16\x04\x12\x04\xc6\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\x02\
    \x16\x05\x12\x04\xc6\x0f\r\x11\n\x0e\n\x06\x04\x98\x01\x02\x16\x01\x12\
    \x04\xc6\x0f\x12\x16\n\x0e\n\x06\x04\x98\x01\x02\x16\x03\x12\x04\xc6\x0f\
    \x19\x1b\n\r\n\x05\x04\x98\x01\x02\x17\x12\x04\xc7\x0f\x04%\n\x0e\n\x06\
    \x04\x98\x01\x02\x17\x04\x12\x04\xc7\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\
    \x02\x17\x05\x12\x04\xc7\x0f\r\x12\n\x0e\n\x06\x04\x98\x01\x02\x17\x01\
    \x12\x04\xc7\x0f\x13\x1f\n\x0e\n\x06\x04\x98\x01\x02\x17\x03\x12\x04\xc7\
    \x0f\"$\n\r\n\x05\x04\x98\x01\x02\x18\x12\x04\xc8\x0f\x04\"\n\x0e\n\x06\
    \x04\x98\x01\x02\x18\x04\x12\x04\xc8\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\
    \x02\x18\x05\x12\x04\xc8\x0f\r\x12\n\x0e\n\x06\x04\x98\x01\x02\x18\x01\
    \x12\x04\xc8\x0f\x13\x1c\n\x0e\n\x06\x04\x98\x01\x02\x18\x03\x12\x04\xc8\
    \x0f\x1f!\n\r\n\x05\x04\x98\x01\x02\x19\x12\x04\xc9\x0f\x04!\n\x0e\n\x06\
    \x04\x98\x01\x02\x19\x04\x12\x04\xc9\x0f\x04\x0c\n\x0e\n\x06\x04\x98\x01\
    \x02\x19\x05\x12\x04\xc9\x0f\r\x12\n\x0e\n\x06\x04\x98\x01\x02\x19\x01\
    \x12\x04\xc9\x0f\x13\x1b\n\x0e\n\x06\x04\x98\x01\x02\x19\x03\x12\x04\xc9\
    \x0f\x1e\x20\n\r\n\x03\x04\x99\x01\x12\x06\xcc\x0f\0\xd1\x0f\x01\n\x0c\n\
    \x04\x04\x99\x01\x01\x12\x04\xcc\x0f\x08\x1c\n\r\n\x05\x04\x99\x01\x02\0\
    \x12\x04\xcd\x0f\x04\"\n\x0e\n\x06\x04\x99\x01\x02\0\x04\x12\x04\xcd\x0f\
    \x04\x0c\n\x0e\n\x06\x04\x99\x01\x02\0\x05\x12\x04\xcd\x0f\r\x13\n\x0e\n\
    \x06\x04\x99\x01\x02\0\x01\x12\x04\xcd\x0f\x14\x1d\n\x0e\n\x06\x04\x99\
    \x01\x02\0\x03\x12\x04\xcd\x0f\x20!\n\r\n\x05\x04\x99\x01\x02\x01\x12\
    \x04\xce\x0f\x04$\n\x0e\n\x06\x04\x99\x01\x02\x01\x04\x12\x04\xce\x0f\
    \x04\x0c\n\x0e\n\x06\x04\x99\x01\x02\x01\x05\x12\x04\xce\x0f\r\x13\n\x0e\
    \n\x06\x04\x99\x01\x02\x01\x01\x12\x04\xce\x0f\x14\x1f\n\x0e\n\x06\x04\
    \x99\x01\x02\x01\x03\x12\x04\xce\x0f\"#\n\r\n\x05\x04\x99\x01\x02\x02\
    \x12\x04\xcf\x0f\x04+\n\x0e\n\x06\x04\x99\x01\x02\x02\x04\x12\x04\xcf\
    \x0f\x04\x0c\n\x0e\n\x06\x04\x99\x01\x02\x02\x05\x12\x04\xcf\x0f\r\x13\n\
    \x0e\n\x06\x04\x99\x01\x02\x02\x01\x12\x04\xcf\x0f\x14&\n\x0e\n\x06\x04\
    \x99\x01\x02\x02\x03\x12\x04\xcf\x0f)*\n\r\n\x05\x04\x99\x01\x02\x03\x12\
    \x04\xd0\x0f\x04/\n\x0e\n\x06\x04\x99\x01\x02\x03\x04\x12\x04\xd0\x0f\
    \x04\x0c\n\x0e\n\x06\x04\x99\x01\x02\x03\x06\x12\x04\xd0\x0f\r\x1b\n\x0e\
    \n\x06\x04\x99\x01\x02\x03\x01\x12\x04\xd0\x0f\x1c*\n\x0e\n\x06\x04\x99\
    \x01\x02\x03\x03\x12\x04\xd0\x0f-.\n\r\n\x03\x04\x9a\x01\x12\x06\xd3\x0f\
    \0\xb1\x11\x01\n\x0c\n\x04\x04\x9a\x01\x01\x12\x04\xd3\x0f\x08\x16\n\x0f\
    \n\x05\x04\x9a\x01\x04\0\x12\x06\xd4\x0f\x04\xf7\x10\x05\n\x0e\n\x06\x04\
    \x9a\x01\x04\0\x01\x12\x04\xd4\x0f\t\x11\n\x0f\n\x07\x04\x9a\x01\x04\0\
    \x02\0\x12\x04\xd5\x0f\x08\x14\n\x10\n\x08\x04\x9a\x01\x04\0\x02\0\x01\
    \x12\x04\xd5\x0f\x08\x0f\n\x10\n\x08\x04\x9a\x01\x04\0\x02\0\x02\x12\x04\
    \xd5\x0f\x12\x13\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x01\x12\x04\xd6\x0f\
    \x08\x13\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x01\x01\x12\x04\xd6\x0f\x08\
    \x0e\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x01\x02\x12\x04\xd6\x0f\x11\x12\n\
    \x0f\n\x07\x04\x9a\x01\x04\0\x02\x02\x12\x04\xd7\x0f\x08\x17\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x02\x01\x12\x04\xd7\x0f\x08\x12\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x02\x02\x12\x04\xd7\x0f\x15\x16\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02\x03\x12\x04\xd8\x0f\x08\x18\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02\x03\x01\x12\x04\xd8\x0f\x08\x13\n\x10\n\x08\x04\x9a\x01\x04\0\x02\
    \x03\x02\x12\x04\xd8\x0f\x16\x17\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x04\
    \x12\x04\xd9\x0f\x08$\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x04\x01\x12\x04\
    \xd9\x0f\x08\x1f\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x04\x02\x12\x04\xd9\
    \x0f\"#\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x05\x12\x04\xda\x0f\x08\"\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02\x05\x01\x12\x04\xda\x0f\x08\x1d\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02\x05\x02\x12\x04\xda\x0f\x20!\n\x0f\n\x07\x04\
    \x9a\x01\x04\0\x02\x06\x12\x04\xdb\x0f\x08\x20\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02\x06\x01\x12\x04\xdb\x0f\x08\x1b\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02\x06\x02\x12\x04\xdb\x0f\x1e\x1f\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\
    \x07\x12\x04\xdc\x0f\x08!\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x07\x01\x12\
    \x04\xdc\x0f\x08\x1c\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x07\x02\x12\x04\
    \xdc\x0f\x1f\x20\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x08\x12\x04\xdd\x0f\
    \x08\x1a\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x08\x01\x12\x04\xdd\x0f\x08\
    \x15\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x08\x02\x12\x04\xdd\x0f\x18\x19\n\
    \x0f\n\x07\x04\x9a\x01\x04\0\x02\t\x12\x04\xde\x0f\x08%\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\t\x01\x12\x04\xde\x0f\x08\x20\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02\t\x02\x12\x04\xde\x0f#$\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\n\
    \x12\x04\xdf\x0f\x08\"\n\x10\n\x08\x04\x9a\x01\x04\0\x02\n\x01\x12\x04\
    \xdf\x0f\x08\x1c\n\x10\n\x08\x04\x9a\x01\x04\0\x02\n\x02\x12\x04\xdf\x0f\
    \x1f!\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x0b\x12\x04\xe0\x0f\x08#\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02\x0b\x01\x12\x04\xe0\x0f\x08\x1d\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x0b\x02\x12\x04\xe0\x0f\x20\"\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02\x0c\x12\x04\xe1\x0f\x08-\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02\x0c\x01\x12\x04\xe1\x0f\x08'\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x0c\
    \x02\x12\x04\xe1\x0f*,\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\r\x12\x04\xe2\
    \x0f\x08-\n\x10\n\x08\x04\x9a\x01\x04\0\x02\r\x01\x12\x04\xe2\x0f\x08'\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02\r\x02\x12\x04\xe2\x0f*,\n\x0f\n\x07\x04\
    \x9a\x01\x04\0\x02\x0e\x12\x04\xe3\x0f\x08-\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02\x0e\x01\x12\x04\xe3\x0f\x08'\n\x10\n\x08\x04\x9a\x01\x04\0\x02\
    \x0e\x02\x12\x04\xe3\x0f*,\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x0f\x12\x04\
    \xe4\x0f\x081\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x0f\x01\x12\x04\xe4\x0f\
    \x08+\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x0f\x02\x12\x04\xe4\x0f.0\n\x0f\
    \n\x07\x04\x9a\x01\x04\0\x02\x10\x12\x04\xe5\x0f\x080\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x10\x01\x12\x04\xe5\x0f\x08*\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02\x10\x02\x12\x04\xe5\x0f-/\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\
    \x11\x12\x04\xe6\x0f\x080\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x11\x01\x12\
    \x04\xe6\x0f\x08*\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x11\x02\x12\x04\xe6\
    \x0f-/\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x12\x12\x04\xe7\x0f\x08-\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02\x12\x01\x12\x04\xe7\x0f\x08'\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x12\x02\x12\x04\xe7\x0f*,\n\x0f\n\x07\x04\x9a\x01\
    \x04\0\x02\x13\x12\x04\xe8\x0f\x081\n\x10\n\x08\x04\x9a\x01\x04\0\x02\
    \x13\x01\x12\x04\xe8\x0f\x08+\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x13\x02\
    \x12\x04\xe8\x0f.0\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x14\x12\x04\xe9\x0f\
    \x08\x1a\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x14\x01\x12\x04\xe9\x0f\x08\
    \x14\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x14\x02\x12\x04\xe9\x0f\x17\x19\n\
    \x0f\n\x07\x04\x9a\x01\x04\0\x02\x15\x12\x04\xea\x0f\x08\"\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x15\x01\x12\x04\xea\x0f\x08\x1c\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x15\x02\x12\x04\xea\x0f\x1f!\n\x0f\n\x07\x04\x9a\x01\
    \x04\0\x02\x16\x12\x04\xeb\x0f\x08\x1f\n\x10\n\x08\x04\x9a\x01\x04\0\x02\
    \x16\x01\x12\x04\xeb\x0f\x08\x19\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x16\
    \x02\x12\x04\xeb\x0f\x1c\x1e\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x17\x12\
    \x04\xec\x0f\x08&\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x17\x01\x12\x04\xec\
    \x0f\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x17\x02\x12\x04\xec\x0f#%\
    \n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x18\x12\x04\xed\x0f\x08&\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x18\x01\x12\x04\xed\x0f\x08\x20\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x18\x02\x12\x04\xed\x0f#%\n\x0f\n\x07\x04\x9a\x01\x04\
    \0\x02\x19\x12\x04\xee\x0f\x08#\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x19\
    \x01\x12\x04\xee\x0f\x08\x1d\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x19\x02\
    \x12\x04\xee\x0f\x20\"\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x1a\x12\x04\xef\
    \x0f\x08#\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x1a\x01\x12\x04\xef\x0f\x08\
    \x1d\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x1a\x02\x12\x04\xef\x0f\x20\"\n\
    \x0f\n\x07\x04\x9a\x01\x04\0\x02\x1b\x12\x04\xf0\x0f\x08#\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x1b\x01\x12\x04\xf0\x0f\x08\x1d\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x1b\x02\x12\x04\xf0\x0f\x20\"\n\x0f\n\x07\x04\x9a\x01\
    \x04\0\x02\x1c\x12\x04\xf1\x0f\x08&\n\x10\n\x08\x04\x9a\x01\x04\0\x02\
    \x1c\x01\x12\x04\xf1\x0f\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x1c\
    \x02\x12\x04\xf1\x0f#%\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x1d\x12\x04\xf2\
    \x0f\x08'\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x1d\x01\x12\x04\xf2\x0f\x08!\
    \n\x10\n\x08\x04\x9a\x01\x04\0\x02\x1d\x02\x12\x04\xf2\x0f$&\n\x0f\n\x07\
    \x04\x9a\x01\x04\0\x02\x1e\x12\x04\xf3\x0f\x08&\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02\x1e\x01\x12\x04\xf3\x0f\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02\x1e\x02\x12\x04\xf3\x0f#%\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x1f\x12\
    \x04\xf4\x0f\x08&\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x1f\x01\x12\x04\xf4\
    \x0f\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x1f\x02\x12\x04\xf4\x0f#%\
    \n\x0f\n\x07\x04\x9a\x01\x04\0\x02\x20\x12\x04\xf5\x0f\x08%\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x20\x01\x12\x04\xf5\x0f\x08\x1f\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x20\x02\x12\x04\xf5\x0f\"$\n\x0f\n\x07\x04\x9a\x01\
    \x04\0\x02!\x12\x04\xf6\x0f\x08-\n\x10\n\x08\x04\x9a\x01\x04\0\x02!\x01\
    \x12\x04\xf6\x0f\x08'\n\x10\n\x08\x04\x9a\x01\x04\0\x02!\x02\x12\x04\xf6\
    \x0f*,\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\"\x12\x04\xf7\x0f\x08\x1e\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02\"\x01\x12\x04\xf7\x0f\x08\x18\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\"\x02\x12\x04\xf7\x0f\x1b\x1d\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02#\x12\x04\xf8\x0f\x08\x1b\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02#\x01\x12\x04\xf8\x0f\x08\x15\n\x10\n\x08\x04\x9a\x01\x04\0\x02#\x02\
    \x12\x04\xf8\x0f\x18\x1a\n\x0f\n\x07\x04\x9a\x01\x04\0\x02$\x12\x04\xf9\
    \x0f\x08\x1e\n\x10\n\x08\x04\x9a\x01\x04\0\x02$\x01\x12\x04\xf9\x0f\x08\
    \x18\n\x10\n\x08\x04\x9a\x01\x04\0\x02$\x02\x12\x04\xf9\x0f\x1b\x1d\n\
    \x0f\n\x07\x04\x9a\x01\x04\0\x02%\x12\x04\xfa\x0f\x08\"\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02%\x01\x12\x04\xfa\x0f\x08\x1c\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02%\x02\x12\x04\xfa\x0f\x1f!\n\x0f\n\x07\x04\x9a\x01\x04\0\x02&\
    \x12\x04\xfb\x0f\x08\"\n\x10\n\x08\x04\x9a\x01\x04\0\x02&\x01\x12\x04\
    \xfb\x0f\x08\x1c\n\x10\n\x08\x04\x9a\x01\x04\0\x02&\x02\x12\x04\xfb\x0f\
    \x1f!\n\x0f\n\x07\x04\x9a\x01\x04\0\x02'\x12\x04\xfc\x0f\x08\x1b\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02'\x01\x12\x04\xfc\x0f\x08\x15\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02'\x02\x12\x04\xfc\x0f\x18\x1a\n\x0f\n\x07\x04\x9a\x01\
    \x04\0\x02(\x12\x04\xfd\x0f\x08\x1f\n\x10\n\x08\x04\x9a\x01\x04\0\x02(\
    \x01\x12\x04\xfd\x0f\x08\x19\n\x10\n\x08\x04\x9a\x01\x04\0\x02(\x02\x12\
    \x04\xfd\x0f\x1c\x1e\n\x0f\n\x07\x04\x9a\x01\x04\0\x02)\x12\x04\xfe\x0f\
    \x08\x1f\n\x10\n\x08\x04\x9a\x01\x04\0\x02)\x01\x12\x04\xfe\x0f\x08\x19\
    \n\x10\n\x08\x04\x9a\x01\x04\0\x02)\x02\x12\x04\xfe\x0f\x1c\x1e\n\x0f\n\
    \x07\x04\x9a\x01\x04\0\x02*\x12\x04\xff\x0f\x08&\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02*\x01\x12\x04\xff\x0f\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02*\x02\x12\x04\xff\x0f#%\n\x0f\n\x07\x04\x9a\x01\x04\0\x02+\x12\x04\
    \x80\x10\x08\x1a\n\x10\n\x08\x04\x9a\x01\x04\0\x02+\x01\x12\x04\x80\x10\
    \x08\x14\n\x10\n\x08\x04\x9a\x01\x04\0\x02+\x02\x12\x04\x80\x10\x17\x19\
    \n\x0f\n\x07\x04\x9a\x01\x04\0\x02,\x12\x04\x81\x10\x080\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02,\x01\x12\x04\x81\x10\x08*\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02,\x02\x12\x04\x81\x10-/\n\x0f\n\x07\x04\x9a\x01\x04\0\x02-\x12\x04\
    \x82\x10\x08%\n\x10\n\x08\x04\x9a\x01\x04\0\x02-\x01\x12\x04\x82\x10\x08\
    \x1f\n\x10\n\x08\x04\x9a\x01\x04\0\x02-\x02\x12\x04\x82\x10\"$\n\x0f\n\
    \x07\x04\x9a\x01\x04\0\x02.\x12\x04\x83\x10\x08%\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02.\x01\x12\x04\x83\x10\x08\x1f\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02.\x02\x12\x04\x83\x10\"$\n\x0f\n\x07\x04\x9a\x01\x04\0\x02/\x12\x04\
    \x84\x10\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\x02/\x01\x12\x04\x84\x10\
    \x08\x1a\n\x10\n\x08\x04\x9a\x01\x04\0\x02/\x02\x12\x04\x84\x10\x1d\x1f\
    \n\x0f\n\x07\x04\x9a\x01\x04\0\x020\x12\x04\x85\x10\x08!\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x020\x01\x12\x04\x85\x10\x08\x1b\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x020\x02\x12\x04\x85\x10\x1e\x20\n\x0f\n\x07\x04\x9a\x01\x04\0\
    \x021\x12\x04\x86\x10\x086\n\x10\n\x08\x04\x9a\x01\x04\0\x021\x01\x12\
    \x04\x86\x10\x080\n\x10\n\x08\x04\x9a\x01\x04\0\x021\x02\x12\x04\x86\x10\
    35\n\x0f\n\x07\x04\x9a\x01\x04\0\x022\x12\x04\x87\x10\x088\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x022\x01\x12\x04\x87\x10\x082\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x022\x02\x12\x04\x87\x1057\n\x0f\n\x07\x04\x9a\x01\x04\0\x023\x12\
    \x04\x88\x10\x08=\n\x10\n\x08\x04\x9a\x01\x04\0\x023\x01\x12\x04\x88\x10\
    \x087\n\x10\n\x08\x04\x9a\x01\x04\0\x023\x02\x12\x04\x88\x10:<\n\x0f\n\
    \x07\x04\x9a\x01\x04\0\x024\x12\x04\x89\x10\x08?\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x024\x01\x12\x04\x89\x10\x089\n\x10\n\x08\x04\x9a\x01\x04\0\x024\
    \x02\x12\x04\x89\x10<>\n\x0f\n\x07\x04\x9a\x01\x04\0\x025\x12\x04\x8a\
    \x10\x08F\n\x10\n\x08\x04\x9a\x01\x04\0\x025\x01\x12\x04\x8a\x10\x08@\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x025\x02\x12\x04\x8a\x10CE\n\x0f\n\x07\x04\
    \x9a\x01\x04\0\x026\x12\x04\x8b\x10\x083\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x026\x01\x12\x04\x8b\x10\x08-\n\x10\n\x08\x04\x9a\x01\x04\0\x026\x02\
    \x12\x04\x8b\x1002\n\x0f\n\x07\x04\x9a\x01\x04\0\x027\x12\x04\x8c\x10\
    \x082\n\x10\n\x08\x04\x9a\x01\x04\0\x027\x01\x12\x04\x8c\x10\x08,\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x027\x02\x12\x04\x8c\x10/1\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x028\x12\x04\x8d\x10\x084\n\x10\n\x08\x04\x9a\x01\x04\0\x028\
    \x01\x12\x04\x8d\x10\x08.\n\x10\n\x08\x04\x9a\x01\x04\0\x028\x02\x12\x04\
    \x8d\x1013\n\x0f\n\x07\x04\x9a\x01\x04\0\x029\x12\x04\x8e\x10\x08-\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x029\x01\x12\x04\x8e\x10\x08'\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x029\x02\x12\x04\x8e\x10*,\n\x0f\n\x07\x04\x9a\x01\x04\0\
    \x02:\x12\x04\x8f\x10\x08,\n\x10\n\x08\x04\x9a\x01\x04\0\x02:\x01\x12\
    \x04\x8f\x10\x08&\n\x10\n\x08\x04\x9a\x01\x04\0\x02:\x02\x12\x04\x8f\x10\
    )+\n\x0f\n\x07\x04\x9a\x01\x04\0\x02;\x12\x04\x90\x10\x08.\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02;\x01\x12\x04\x90\x10\x08(\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02;\x02\x12\x04\x90\x10+-\n\x0f\n\x07\x04\x9a\x01\x04\0\x02<\x12\
    \x04\x91\x10\x083\n\x10\n\x08\x04\x9a\x01\x04\0\x02<\x01\x12\x04\x91\x10\
    \x08-\n\x10\n\x08\x04\x9a\x01\x04\0\x02<\x02\x12\x04\x91\x1002\n\x0f\n\
    \x07\x04\x9a\x01\x04\0\x02=\x12\x04\x92\x10\x083\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02=\x01\x12\x04\x92\x10\x08-\n\x10\n\x08\x04\x9a\x01\x04\0\x02=\
    \x02\x12\x04\x92\x1002\n\x0f\n\x07\x04\x9a\x01\x04\0\x02>\x12\x04\x93\
    \x10\x08\x1b\n\x10\n\x08\x04\x9a\x01\x04\0\x02>\x01\x12\x04\x93\x10\x08\
    \x15\n\x10\n\x08\x04\x9a\x01\x04\0\x02>\x02\x12\x04\x93\x10\x18\x1a\n\
    \x0f\n\x07\x04\x9a\x01\x04\0\x02?\x12\x04\x94\x10\x08\x1e\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02?\x01\x12\x04\x94\x10\x08\x18\n\x10\n\x08\x04\x9a\
    \x01\x04\0\x02?\x02\x12\x04\x94\x10\x1b\x1d\n\x0f\n\x07\x04\x9a\x01\x04\
    \0\x02@\x12\x04\x95\x10\x08\x1d\n\x10\n\x08\x04\x9a\x01\x04\0\x02@\x01\
    \x12\x04\x95\x10\x08\x17\n\x10\n\x08\x04\x9a\x01\x04\0\x02@\x02\x12\x04\
    \x95\x10\x1a\x1c\n\x0f\n\x07\x04\x9a\x01\x04\0\x02A\x12\x04\x96\x10\x08&\
    \n\x10\n\x08\x04\x9a\x01\x04\0\x02A\x01\x12\x04\x96\x10\x08\x20\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02A\x02\x12\x04\x96\x10#%\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02B\x12\x04\x97\x10\x08(\n\x10\n\x08\x04\x9a\x01\x04\0\x02B\
    \x01\x12\x04\x97\x10\x08\"\n\x10\n\x08\x04\x9a\x01\x04\0\x02B\x02\x12\
    \x04\x97\x10%'\n\x0f\n\x07\x04\x9a\x01\x04\0\x02C\x12\x04\x98\x10\x08+\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02C\x01\x12\x04\x98\x10\x08%\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02C\x02\x12\x04\x98\x10(*\n\x0f\n\x07\x04\x9a\x01\
    \x04\0\x02D\x12\x04\x99\x10\x08\x17\n\x10\n\x08\x04\x9a\x01\x04\0\x02D\
    \x01\x12\x04\x99\x10\x08\x11\n\x10\n\x08\x04\x9a\x01\x04\0\x02D\x02\x12\
    \x04\x99\x10\x14\x16\n\x0f\n\x07\x04\x9a\x01\x04\0\x02E\x12\x04\x9a\x10\
    \x082\n\x10\n\x08\x04\x9a\x01\x04\0\x02E\x01\x12\x04\x9a\x10\x08,\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02E\x02\x12\x04\x9a\x10/1\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02F\x12\x04\x9b\x10\x08&\n\x10\n\x08\x04\x9a\x01\x04\0\x02F\
    \x01\x12\x04\x9b\x10\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\x02F\x02\x12\
    \x04\x9b\x10#%\n\x0f\n\x07\x04\x9a\x01\x04\0\x02G\x12\x04\x9c\x10\x080\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02G\x01\x12\x04\x9c\x10\x08*\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02G\x02\x12\x04\x9c\x10-/\n\x0f\n\x07\x04\x9a\x01\
    \x04\0\x02H\x12\x04\x9d\x10\x08&\n\x10\n\x08\x04\x9a\x01\x04\0\x02H\x01\
    \x12\x04\x9d\x10\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\x02H\x02\x12\x04\
    \x9d\x10#%\n\x0f\n\x07\x04\x9a\x01\x04\0\x02I\x12\x04\x9e\x10\x08\x20\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02I\x01\x12\x04\x9e\x10\x08\x1a\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02I\x02\x12\x04\x9e\x10\x1d\x1f\n\x0f\n\x07\x04\
    \x9a\x01\x04\0\x02J\x12\x04\x9f\x10\x08\x19\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02J\x01\x12\x04\x9f\x10\x08\x13\n\x10\n\x08\x04\x9a\x01\x04\0\x02J\
    \x02\x12\x04\x9f\x10\x16\x18\n\x0f\n\x07\x04\x9a\x01\x04\0\x02K\x12\x04\
    \xa0\x10\x08\x1f\n\x10\n\x08\x04\x9a\x01\x04\0\x02K\x01\x12\x04\xa0\x10\
    \x08\x19\n\x10\n\x08\x04\x9a\x01\x04\0\x02K\x02\x12\x04\xa0\x10\x1c\x1e\
    \n\x0f\n\x07\x04\x9a\x01\x04\0\x02L\x12\x04\xa1\x10\x08,\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02L\x01\x12\x04\xa1\x10\x08&\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02L\x02\x12\x04\xa1\x10)+\n\x0f\n\x07\x04\x9a\x01\x04\0\x02M\x12\x04\
    \xa2\x10\x08(\n\x10\n\x08\x04\x9a\x01\x04\0\x02M\x01\x12\x04\xa2\x10\x08\
    \"\n\x10\n\x08\x04\x9a\x01\x04\0\x02M\x02\x12\x04\xa2\x10%'\n\x0f\n\x07\
    \x04\x9a\x01\x04\0\x02N\x12\x04\xa3\x10\x08-\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02N\x01\x12\x04\xa3\x10\x08'\n\x10\n\x08\x04\x9a\x01\x04\0\x02N\x02\
    \x12\x04\xa3\x10*,\n\x0f\n\x07\x04\x9a\x01\x04\0\x02O\x12\x04\xa4\x10\
    \x08(\n\x10\n\x08\x04\x9a\x01\x04\0\x02O\x01\x12\x04\xa4\x10\x08\"\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02O\x02\x12\x04\xa4\x10%'\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02P\x12\x04\xa5\x10\x08A\n\x10\n\x08\x04\x9a\x01\x04\0\x02P\
    \x01\x12\x04\xa5\x10\x08;\n\x10\n\x08\x04\x9a\x01\x04\0\x02P\x02\x12\x04\
    \xa5\x10>@\n\x0f\n\x07\x04\x9a\x01\x04\0\x02Q\x12\x04\xa6\x10\x08&\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02Q\x01\x12\x04\xa6\x10\x08\x20\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02Q\x02\x12\x04\xa6\x10#%\n\x0f\n\x07\x04\x9a\x01\
    \x04\0\x02R\x12\x04\xa7\x10\x08A\n\x10\n\x08\x04\x9a\x01\x04\0\x02R\x01\
    \x12\x04\xa7\x10\x08;\n\x10\n\x08\x04\x9a\x01\x04\0\x02R\x02\x12\x04\xa7\
    \x10>@\n\x0f\n\x07\x04\x9a\x01\x04\0\x02S\x12\x04\xa8\x10\x082\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02S\x01\x12\x04\xa8\x10\x08,\n\x10\n\x08\x04\x9a\
    \x01\x04\0\x02S\x02\x12\x04\xa8\x10/1\n\x0f\n\x07\x04\x9a\x01\x04\0\x02T\
    \x12\x04\xa9\x10\x08-\n\x10\n\x08\x04\x9a\x01\x04\0\x02T\x01\x12\x04\xa9\
    \x10\x08'\n\x10\n\x08\x04\x9a\x01\x04\0\x02T\x02\x12\x04\xa9\x10*,\n\x0f\
    \n\x07\x04\x9a\x01\x04\0\x02U\x12\x04\xaa\x10\x08F\n\x10\n\x08\x04\x9a\
    \x01\x04\0\x02U\x01\x12\x04\xaa\x10\x08@\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02U\x02\x12\x04\xaa\x10CE\n\x0f\n\x07\x04\x9a\x01\x04\0\x02V\x12\x04\
    \xab\x10\x08+\n\x10\n\x08\x04\x9a\x01\x04\0\x02V\x01\x12\x04\xab\x10\x08\
    %\n\x10\n\x08\x04\x9a\x01\x04\0\x02V\x02\x12\x04\xab\x10(*\n\x0f\n\x07\
    \x04\x9a\x01\x04\0\x02W\x12\x04\xac\x10\x08F\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02W\x01\x12\x04\xac\x10\x08@\n\x10\n\x08\x04\x9a\x01\x04\0\x02W\x02\
    \x12\x04\xac\x10CE\n\x0f\n\x07\x04\x9a\x01\x04\0\x02X\x12\x04\xad\x10\
    \x084\n\x10\n\x08\x04\x9a\x01\x04\0\x02X\x01\x12\x04\xad\x10\x08.\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02X\x02\x12\x04\xad\x1013\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02Y\x12\x04\xae\x10\x089\n\x10\n\x08\x04\x9a\x01\x04\0\x02Y\
    \x01\x12\x04\xae\x10\x083\n\x10\n\x08\x04\x9a\x01\x04\0\x02Y\x02\x12\x04\
    \xae\x1068\n\x0f\n\x07\x04\x9a\x01\x04\0\x02Z\x12\x04\xaf\x10\x085\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02Z\x01\x12\x04\xaf\x10\x08/\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02Z\x02\x12\x04\xaf\x1024\n\x0f\n\x07\x04\x9a\x01\x04\0\
    \x02[\x12\x04\xb0\x10\x08:\n\x10\n\x08\x04\x9a\x01\x04\0\x02[\x01\x12\
    \x04\xb0\x10\x084\n\x10\n\x08\x04\x9a\x01\x04\0\x02[\x02\x12\x04\xb0\x10\
    79\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\\\x12\x04\xb1\x10\x08-\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\\\x01\x12\x04\xb1\x10\x08'\n\x10\n\x08\x04\x9a\
    \x01\x04\0\x02\\\x02\x12\x04\xb1\x10*,\n\x0f\n\x07\x04\x9a\x01\x04\0\x02\
    ]\x12\x04\xb2\x10\x08.\n\x10\n\x08\x04\x9a\x01\x04\0\x02]\x01\x12\x04\
    \xb2\x10\x08(\n\x10\n\x08\x04\x9a\x01\x04\0\x02]\x02\x12\x04\xb2\x10+-\n\
    \x0f\n\x07\x04\x9a\x01\x04\0\x02^\x12\x04\xb3\x10\x08)\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02^\x01\x12\x04\xb3\x10\x08#\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02^\x02\x12\x04\xb3\x10&(\n\x0f\n\x07\x04\x9a\x01\x04\0\x02_\x12\x04\
    \xb4\x10\x08B\n\x10\n\x08\x04\x9a\x01\x04\0\x02_\x01\x12\x04\xb4\x10\x08\
    <\n\x10\n\x08\x04\x9a\x01\x04\0\x02_\x02\x12\x04\xb4\x10?A\n\x0f\n\x07\
    \x04\x9a\x01\x04\0\x02`\x12\x04\xb5\x10\x08'\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02`\x01\x12\x04\xb5\x10\x08!\n\x10\n\x08\x04\x9a\x01\x04\0\x02`\x02\
    \x12\x04\xb5\x10$&\n\x0f\n\x07\x04\x9a\x01\x04\0\x02a\x12\x04\xb6\x10\
    \x08B\n\x10\n\x08\x04\x9a\x01\x04\0\x02a\x01\x12\x04\xb6\x10\x08<\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02a\x02\x12\x04\xb6\x10?A\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02b\x12\x04\xb7\x10\x082\n\x10\n\x08\x04\x9a\x01\x04\0\x02b\
    \x01\x12\x04\xb7\x10\x08,\n\x10\n\x08\x04\x9a\x01\x04\0\x02b\x02\x12\x04\
    \xb7\x10/1\n\x0f\n\x07\x04\x9a\x01\x04\0\x02c\x12\x04\xb8\x10\x08.\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02c\x01\x12\x04\xb8\x10\x08(\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02c\x02\x12\x04\xb8\x10+-\n\x0f\n\x07\x04\x9a\x01\x04\0\
    \x02d\x12\x04\xb9\x10\x08-\n\x10\n\x08\x04\x9a\x01\x04\0\x02d\x01\x12\
    \x04\xb9\x10\x08&\n\x10\n\x08\x04\x9a\x01\x04\0\x02d\x02\x12\x04\xb9\x10\
    ),\n\x0f\n\x07\x04\x9a\x01\x04\0\x02e\x12\x04\xba\x10\x08!\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02e\x01\x12\x04\xba\x10\x08\x1a\n\x10\n\x08\x04\x9a\
    \x01\x04\0\x02e\x02\x12\x04\xba\x10\x1d\x20\n\x0f\n\x07\x04\x9a\x01\x04\
    \0\x02f\x12\x04\xbb\x10\x08#\n\x10\n\x08\x04\x9a\x01\x04\0\x02f\x01\x12\
    \x04\xbb\x10\x08\x1c\n\x10\n\x08\x04\x9a\x01\x04\0\x02f\x02\x12\x04\xbb\
    \x10\x1f\"\n\x0f\n\x07\x04\x9a\x01\x04\0\x02g\x12\x04\xbc\x10\x08\"\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02g\x01\x12\x04\xbc\x10\x08\x1b\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02g\x02\x12\x04\xbc\x10\x1e!\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02h\x12\x04\xbd\x10\x085\n\x10\n\x08\x04\x9a\x01\x04\0\x02h\
    \x01\x12\x04\xbd\x10\x08.\n\x10\n\x08\x04\x9a\x01\x04\0\x02h\x02\x12\x04\
    \xbd\x1014\n\x0f\n\x07\x04\x9a\x01\x04\0\x02i\x12\x04\xbe\x10\x08:\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02i\x01\x12\x04\xbe\x10\x083\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02i\x02\x12\x04\xbe\x1069\n\x0f\n\x07\x04\x9a\x01\x04\0\
    \x02j\x12\x04\xbf\x10\x086\n\x10\n\x08\x04\x9a\x01\x04\0\x02j\x01\x12\
    \x04\xbf\x10\x08/\n\x10\n\x08\x04\x9a\x01\x04\0\x02j\x02\x12\x04\xbf\x10\
    25\n\x0f\n\x07\x04\x9a\x01\x04\0\x02k\x12\x04\xc0\x10\x08.\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02k\x01\x12\x04\xc0\x10\x08'\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02k\x02\x12\x04\xc0\x10*-\n\x0f\n\x07\x04\x9a\x01\x04\0\x02l\x12\
    \x04\xc1\x10\x085\n\x10\n\x08\x04\x9a\x01\x04\0\x02l\x01\x12\x04\xc1\x10\
    \x08.\n\x10\n\x08\x04\x9a\x01\x04\0\x02l\x02\x12\x04\xc1\x1014\n\x0f\n\
    \x07\x04\x9a\x01\x04\0\x02m\x12\x04\xc2\x10\x08:\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02m\x01\x12\x04\xc2\x10\x083\n\x10\n\x08\x04\x9a\x01\x04\0\x02m\
    \x02\x12\x04\xc2\x1069\n\x0f\n\x07\x04\x9a\x01\x04\0\x02n\x12\x04\xc3\
    \x10\x086\n\x10\n\x08\x04\x9a\x01\x04\0\x02n\x01\x12\x04\xc3\x10\x08/\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02n\x02\x12\x04\xc3\x1025\n\x0f\n\x07\x04\
    \x9a\x01\x04\0\x02o\x12\x04\xc4\x10\x08.\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02o\x01\x12\x04\xc4\x10\x08'\n\x10\n\x08\x04\x9a\x01\x04\0\x02o\x02\
    \x12\x04\xc4\x10*-\n\x0f\n\x07\x04\x9a\x01\x04\0\x02p\x12\x04\xc5\x10\
    \x08A\n\x10\n\x08\x04\x9a\x01\x04\0\x02p\x01\x12\x04\xc5\x10\x08:\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02p\x02\x12\x04\xc5\x10=@\n\x0f\n\x07\x04\x9a\
    \x01\x04\0\x02q\x12\x04\xc6\x10\x08=\n\x10\n\x08\x04\x9a\x01\x04\0\x02q\
    \x01\x12\x04\xc6\x10\x086\n\x10\n\x08\x04\x9a\x01\x04\0\x02q\x02\x12\x04\
    \xc6\x109<\n\x0f\n\x07\x04\x9a\x01\x04\0\x02r\x12\x04\xc7\x10\x08A\n\x10\
    \n\x08\x04\x9a\x01\x04\0\x02r\x01\x12\x04\xc7\x10\x08:\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02r\x02\x12\x04\xc7\x10=@\n\x0f\n\x07\x04\x9a\x01\x04\0\
    \x02s\x12\x04\xc8\x10\x08=\n\x10\n\x08\x04\x9a\x01\x04\0\x02s\x01\x12\
    \x04\xc8\x10\x086\n\x10\n\x08\x04\x9a\x01\x04\0\x02s\x02\x12\x04\xc8\x10\
    9<\n\x0f\n\x07\x04\x9a\x01\x04\0\x02t\x12\x04\xc9\x10\x08B\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02t\x01\x12\x04\xc9\x10\x08;\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02t\x02\x12\x04\xc9\x10>A\n\x0f\n\x07\x04\x9a\x01\x04\0\x02u\x12\
    \x04\xca\x10\x08B\n\x10\n\x08\x04\x9a\x01\x04\0\x02u\x01\x12\x04\xca\x10\
    \x08;\n\x10\n\x08\x04\x9a\x01\x04\0\x02u\x02\x12\x04\xca\x10>A\n\x0f\n\
    \x07\x04\x9a\x01\x04\0\x02v\x12\x04\xcb\x10\x08'\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02v\x01\x12\x04\xcb\x10\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02v\x02\x12\x04\xcb\x10#&\n\x0f\n\x07\x04\x9a\x01\x04\0\x02w\x12\x04\
    \xcc\x10\x08\x1d\n\x10\n\x08\x04\x9a\x01\x04\0\x02w\x01\x12\x04\xcc\x10\
    \x08\x16\n\x10\n\x08\x04\x9a\x01\x04\0\x02w\x02\x12\x04\xcc\x10\x19\x1c\
    \n\x0f\n\x07\x04\x9a\x01\x04\0\x02x\x12\x04\xcd\x10\x08\"\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02x\x01\x12\x04\xcd\x10\x08\x1b\n\x10\n\x08\x04\x9a\
    \x01\x04\0\x02x\x02\x12\x04\xcd\x10\x1e!\n\x0f\n\x07\x04\x9a\x01\x04\0\
    \x02y\x12\x04\xce\x10\x08\x1c\n\x10\n\x08\x04\x9a\x01\x04\0\x02y\x01\x12\
    \x04\xce\x10\x08\x15\n\x10\n\x08\x04\x9a\x01\x04\0\x02y\x02\x12\x04\xce\
    \x10\x18\x1b\n\x0f\n\x07\x04\x9a\x01\x04\0\x02z\x12\x04\xcf\x10\x08\x1c\
    \n\x10\n\x08\x04\x9a\x01\x04\0\x02z\x01\x12\x04\xcf\x10\x08\x15\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02z\x02\x12\x04\xcf\x10\x18\x1b\n\x0f\n\x07\x04\
    \x9a\x01\x04\0\x02{\x12\x04\xd0\x10\x08,\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02{\x01\x12\x04\xd0\x10\x08%\n\x10\n\x08\x04\x9a\x01\x04\0\x02{\x02\
    \x12\x04\xd0\x10(+\n\x0f\n\x07\x04\x9a\x01\x04\0\x02|\x12\x04\xd1\x10\
    \x08\x1a\n\x10\n\x08\x04\x9a\x01\x04\0\x02|\x01\x12\x04\xd1\x10\x08\x13\
    \n\x10\n\x08\x04\x9a\x01\x04\0\x02|\x02\x12\x04\xd1\x10\x16\x19\n\x0f\n\
    \x07\x04\x9a\x01\x04\0\x02}\x12\x04\xd2\x10\x08\x16\n\x10\n\x08\x04\x9a\
    \x01\x04\0\x02}\x01\x12\x04\xd2\x10\x08\x0f\n\x10\n\x08\x04\x9a\x01\x04\
    \0\x02}\x02\x12\x04\xd2\x10\x12\x15\n\x0f\n\x07\x04\x9a\x01\x04\0\x02~\
    \x12\x04\xd3\x10\x08'\n\x10\n\x08\x04\x9a\x01\x04\0\x02~\x01\x12\x04\xd3\
    \x10\x08\x20\n\x10\n\x08\x04\x9a\x01\x04\0\x02~\x02\x12\x04\xd3\x10#&\n\
    \x0f\n\x07\x04\x9a\x01\x04\0\x02\x7f\x12\x04\xd4\x10\x08(\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x7f\x01\x12\x04\xd4\x10\x08!\n\x10\n\x08\x04\x9a\
    \x01\x04\0\x02\x7f\x02\x12\x04\xd4\x10$'\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02\x80\x01\x12\x04\xd5\x10\x08%\n\x11\n\t\x04\x9a\x01\x04\0\x02\x80\
    \x01\x01\x12\x04\xd5\x10\x08\x1e\n\x11\n\t\x04\x9a\x01\x04\0\x02\x80\x01\
    \x02\x12\x04\xd5\x10!$\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x81\x01\x12\x04\
    \xd6\x10\x08&\n\x11\n\t\x04\x9a\x01\x04\0\x02\x81\x01\x01\x12\x04\xd6\
    \x10\x08\x1f\n\x11\n\t\x04\x9a\x01\x04\0\x02\x81\x01\x02\x12\x04\xd6\x10\
    \"%\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x82\x01\x12\x04\xd7\x10\x08\x20\n\
    \x11\n\t\x04\x9a\x01\x04\0\x02\x82\x01\x01\x12\x04\xd7\x10\x08\x19\n\x11\
    \n\t\x04\x9a\x01\x04\0\x02\x82\x01\x02\x12\x04\xd7\x10\x1c\x1f\n\x10\n\
    \x08\x04\x9a\x01\x04\0\x02\x83\x01\x12\x04\xd8\x10\x08&\n\x11\n\t\x04\
    \x9a\x01\x04\0\x02\x83\x01\x01\x12\x04\xd8\x10\x08\x1f\n\x11\n\t\x04\x9a\
    \x01\x04\0\x02\x83\x01\x02\x12\x04\xd8\x10\"%\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02\x84\x01\x12\x04\xd9\x10\x08\x1b\n\x11\n\t\x04\x9a\x01\x04\0\
    \x02\x84\x01\x01\x12\x04\xd9\x10\x08\x14\n\x11\n\t\x04\x9a\x01\x04\0\x02\
    \x84\x01\x02\x12\x04\xd9\x10\x17\x1a\n\x10\n\x08\x04\x9a\x01\x04\0\x02\
    \x85\x01\x12\x04\xda\x10\x08.\n\x11\n\t\x04\x9a\x01\x04\0\x02\x85\x01\
    \x01\x12\x04\xda\x10\x08'\n\x11\n\t\x04\x9a\x01\x04\0\x02\x85\x01\x02\
    \x12\x04\xda\x10*-\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x86\x01\x12\x04\xdb\
    \x10\x08*\n\x11\n\t\x04\x9a\x01\x04\0\x02\x86\x01\x01\x12\x04\xdb\x10\
    \x08#\n\x11\n\t\x04\x9a\x01\x04\0\x02\x86\x01\x02\x12\x04\xdb\x10&)\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02\x87\x01\x12\x04\xdc\x10\x08+\n\x11\n\t\
    \x04\x9a\x01\x04\0\x02\x87\x01\x01\x12\x04\xdc\x10\x08$\n\x11\n\t\x04\
    \x9a\x01\x04\0\x02\x87\x01\x02\x12\x04\xdc\x10'*\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02\x88\x01\x12\x04\xdd\x10\x08'\n\x11\n\t\x04\x9a\x01\x04\0\x02\
    \x88\x01\x01\x12\x04\xdd\x10\x08\x20\n\x11\n\t\x04\x9a\x01\x04\0\x02\x88\
    \x01\x02\x12\x04\xdd\x10#&\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x89\x01\x12\
    \x04\xde\x10\x08,\n\x11\n\t\x04\x9a\x01\x04\0\x02\x89\x01\x01\x12\x04\
    \xde\x10\x08%\n\x11\n\t\x04\x9a\x01\x04\0\x02\x89\x01\x02\x12\x04\xde\
    \x10(+\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x8a\x01\x12\x04\xdf\x10\x08-\n\
    \x11\n\t\x04\x9a\x01\x04\0\x02\x8a\x01\x01\x12\x04\xdf\x10\x08&\n\x11\n\
    \t\x04\x9a\x01\x04\0\x02\x8a\x01\x02\x12\x04\xdf\x10),\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x8b\x01\x12\x04\xe0\x10\x08)\n\x11\n\t\x04\x9a\x01\
    \x04\0\x02\x8b\x01\x01\x12\x04\xe0\x10\x08\"\n\x11\n\t\x04\x9a\x01\x04\0\
    \x02\x8b\x01\x02\x12\x04\xe0\x10%(\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x8c\
    \x01\x12\x04\xe1\x10\x08'\n\x11\n\t\x04\x9a\x01\x04\0\x02\x8c\x01\x01\
    \x12\x04\xe1\x10\x08\x20\n\x11\n\t\x04\x9a\x01\x04\0\x02\x8c\x01\x02\x12\
    \x04\xe1\x10#&\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x8d\x01\x12\x04\xe2\x10\
    \x082\n\x11\n\t\x04\x9a\x01\x04\0\x02\x8d\x01\x01\x12\x04\xe2\x10\x08+\n\
    \x11\n\t\x04\x9a\x01\x04\0\x02\x8d\x01\x02\x12\x04\xe2\x10.1\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x8e\x01\x12\x04\xe3\x10\x08\x1f\n\x11\n\t\x04\x9a\
    \x01\x04\0\x02\x8e\x01\x01\x12\x04\xe3\x10\x08\x18\n\x11\n\t\x04\x9a\x01\
    \x04\0\x02\x8e\x01\x02\x12\x04\xe3\x10\x1b\x1e\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02\x8f\x01\x12\x04\xe4\x10\x08%\n\x11\n\t\x04\x9a\x01\x04\0\x02\
    \x8f\x01\x01\x12\x04\xe4\x10\x08\x1e\n\x11\n\t\x04\x9a\x01\x04\0\x02\x8f\
    \x01\x02\x12\x04\xe4\x10!$\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x90\x01\x12\
    \x04\xe5\x10\x085\n\x11\n\t\x04\x9a\x01\x04\0\x02\x90\x01\x01\x12\x04\
    \xe5\x10\x08.\n\x11\n\t\x04\x9a\x01\x04\0\x02\x90\x01\x02\x12\x04\xe5\
    \x1014\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x91\x01\x12\x04\xe6\x10\x082\n\
    \x11\n\t\x04\x9a\x01\x04\0\x02\x91\x01\x01\x12\x04\xe6\x10\x08+\n\x11\n\
    \t\x04\x9a\x01\x04\0\x02\x91\x01\x02\x12\x04\xe6\x10.1\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x92\x01\x12\x04\xe7\x10\x08,\n\x11\n\t\x04\x9a\x01\
    \x04\0\x02\x92\x01\x01\x12\x04\xe7\x10\x08%\n\x11\n\t\x04\x9a\x01\x04\0\
    \x02\x92\x01\x02\x12\x04\xe7\x10(+\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x93\
    \x01\x12\x04\xe8\x10\x08,\n\x11\n\t\x04\x9a\x01\x04\0\x02\x93\x01\x01\
    \x12\x04\xe8\x10\x08%\n\x11\n\t\x04\x9a\x01\x04\0\x02\x93\x01\x02\x12\
    \x04\xe8\x10(+\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x94\x01\x12\x04\xe9\x10\
    \x08+\n\x11\n\t\x04\x9a\x01\x04\0\x02\x94\x01\x01\x12\x04\xe9\x10\x08$\n\
    \x11\n\t\x04\x9a\x01\x04\0\x02\x94\x01\x02\x12\x04\xe9\x10'*\n\x10\n\x08\
    \x04\x9a\x01\x04\0\x02\x95\x01\x12\x04\xea\x10\x08-\n\x11\n\t\x04\x9a\
    \x01\x04\0\x02\x95\x01\x01\x12\x04\xea\x10\x08&\n\x11\n\t\x04\x9a\x01\
    \x04\0\x02\x95\x01\x02\x12\x04\xea\x10),\n\x10\n\x08\x04\x9a\x01\x04\0\
    \x02\x96\x01\x12\x04\xeb\x10\x08>\n\x11\n\t\x04\x9a\x01\x04\0\x02\x96\
    \x01\x01\x12\x04\xeb\x10\x087\n\x11\n\t\x04\x9a\x01\x04\0\x02\x96\x01\
    \x02\x12\x04\xeb\x10:=\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x97\x01\x12\x04\
    \xec\x10\x08>\n\x11\n\t\x04\x9a\x01\x04\0\x02\x97\x01\x01\x12\x04\xec\
    \x10\x087\n\x11\n\t\x04\x9a\x01\x04\0\x02\x97\x01\x02\x12\x04\xec\x10:=\
    \n\x10\n\x08\x04\x9a\x01\x04\0\x02\x98\x01\x12\x04\xed\x10\x08$\n\x11\n\
    \t\x04\x9a\x01\x04\0\x02\x98\x01\x01\x12\x04\xed\x10\x08\x1d\n\x11\n\t\
    \x04\x9a\x01\x04\0\x02\x98\x01\x02\x12\x04\xed\x10\x20#\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x99\x01\x12\x04\xee\x10\x08%\n\x11\n\t\x04\x9a\x01\
    \x04\0\x02\x99\x01\x01\x12\x04\xee\x10\x08\x1e\n\x11\n\t\x04\x9a\x01\x04\
    \0\x02\x99\x01\x02\x12\x04\xee\x10!$\n\x10\n\x08\x04\x9a\x01\x04\0\x02\
    \x9a\x01\x12\x04\xef\x10\x08\"\n\x11\n\t\x04\x9a\x01\x04\0\x02\x9a\x01\
    \x01\x12\x04\xef\x10\x08\x1b\n\x11\n\t\x04\x9a\x01\x04\0\x02\x9a\x01\x02\
    \x12\x04\xef\x10\x1e!\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x9b\x01\x12\x04\
    \xf0\x10\x08\x17\n\x11\n\t\x04\x9a\x01\x04\0\x02\x9b\x01\x01\x12\x04\xf0\
    \x10\x08\x10\n\x11\n\t\x04\x9a\x01\x04\0\x02\x9b\x01\x02\x12\x04\xf0\x10\
    \x13\x16\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x9c\x01\x12\x04\xf1\x10\x08)\
    \n\x11\n\t\x04\x9a\x01\x04\0\x02\x9c\x01\x01\x12\x04\xf1\x10\x08\"\n\x11\
    \n\t\x04\x9a\x01\x04\0\x02\x9c\x01\x02\x12\x04\xf1\x10%(\n\x10\n\x08\x04\
    \x9a\x01\x04\0\x02\x9d\x01\x12\x04\xf2\x10\x08(\n\x11\n\t\x04\x9a\x01\
    \x04\0\x02\x9d\x01\x01\x12\x04\xf2\x10\x08!\n\x11\n\t\x04\x9a\x01\x04\0\
    \x02\x9d\x01\x02\x12\x04\xf2\x10$'\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x9e\
    \x01\x12\x04\xf3\x10\x085\n\x11\n\t\x04\x9a\x01\x04\0\x02\x9e\x01\x01\
    \x12\x04\xf3\x10\x08.\n\x11\n\t\x04\x9a\x01\x04\0\x02\x9e\x01\x02\x12\
    \x04\xf3\x1014\n\x10\n\x08\x04\x9a\x01\x04\0\x02\x9f\x01\x12\x04\xf4\x10\
    \x08\"\n\x11\n\t\x04\x9a\x01\x04\0\x02\x9f\x01\x01\x12\x04\xf4\x10\x08\
    \x1b\n\x11\n\t\x04\x9a\x01\x04\0\x02\x9f\x01\x02\x12\x04\xf4\x10\x1e!\n\
    \x10\n\x08\x04\x9a\x01\x04\0\x02\xa0\x01\x12\x04\xf5\x10\x08+\n\x11\n\t\
    \x04\x9a\x01\x04\0\x02\xa0\x01\x01\x12\x04\xf5\x10\x08$\n\x11\n\t\x04\
    \x9a\x01\x04\0\x02\xa0\x01\x02\x12\x04\xf5\x10'*\n\x10\n\x08\x04\x9a\x01\
    \x04\0\x02\xa1\x01\x12\x04\xf6\x10\x08%\n\x11\n\t\x04\x9a\x01\x04\0\x02\
    \xa1\x01\x01\x12\x04\xf6\x10\x08\x1e\n\x11\n\t\x04\x9a\x01\x04\0\x02\xa1\
    \x01\x02\x12\x04\xf6\x10!$\n\x0f\n\x05\x04\x9a\x01\x04\x01\x12\x06\xf8\
    \x10\x04\xff\x10\x05\n\x0e\n\x06\x04\x9a\x01\x04\x01\x01\x12\x04\xf8\x10\
    \t\x0f\n\x0f\n\x07\x04\x9a\x01\x04\x01\x02\0\x12\x04\xf9\x10\x08\x12\n\
    \x10\n\x08\x04\x9a\x01\x04\x01\x02\0\x01\x12\x04\xf9\x10\x08\r\n\x10\n\
    \x08\x04\x9a\x01\x04\x01\x02\0\x02\x12\x04\xf9\x10\x10\x11\n\x0f\n\x07\
    \x04\x9a\x01\x04\x01\x02\x01\x12\x04\xfa\x10\x08\x14\n\x10\n\x08\x04\x9a\
    \x01\x04\x01\x02\x01\x01\x12\x04\xfa\x10\x08\x0f\n\x10\n\x08\x04\x9a\x01\
    \x04\x01\x02\x01\x02\x12\x04\xfa\x10\x12\x13\n\x0f\n\x07\x04\x9a\x01\x04\
    \x01\x02\x02\x12\x04\xfb\x10\x08\x17\n\x10\n\x08\x04\x9a\x01\x04\x01\x02\
    \x02\x01\x12\x04\xfb\x10\x08\x12\n\x10\n\x08\x04\x9a\x01\x04\x01\x02\x02\
    \x02\x12\x04\xfb\x10\x15\x16\n\x0f\n\x07\x04\x9a\x01\x04\x01\x02\x03\x12\
    \x04\xfc\x10\x08\x19\n\x10\n\x08\x04\x9a\x01\x04\x01\x02\x03\x01\x12\x04\
    \xfc\x10\x08\x14\n\x10\n\x08\x04\x9a\x01\x04\x01\x02\x03\x02\x12\x04\xfc\
    \x10\x17\x18\n\x0f\n\x07\x04\x9a\x01\x04\x01\x02\x04\x12\x04\xfd\x10\x08\
    \x11\n\x10\n\x08\x04\x9a\x01\x04\x01\x02\x04\x01\x12\x04\xfd\x10\x08\x0c\
    \n\x10\n\x08\x04\x9a\x01\x04\x01\x02\x04\x02\x12\x04\xfd\x10\x0f\x10\n\
    \x0f\n\x07\x04\x9a\x01\x04\x01\x02\x05\x12\x04\xfe\x10\x08\x13\n\x10\n\
    \x08\x04\x9a\x01\x04\x01\x02\x05\x01\x12\x04\xfe\x10\x08\x0e\n\x10\n\x08\
    \x04\x9a\x01\x04\x01\x02\x05\x02\x12\x04\xfe\x10\x11\x12\n\x0f\n\x05\x04\
    \x9a\x01\x04\x02\x12\x06\x80\x11\x04\x85\x11\x05\n\x0e\n\x06\x04\x9a\x01\
    \x04\x02\x01\x12\x04\x80\x11\t\x19\n\x0f\n\x07\x04\x9a\x01\x04\x02\x02\0\
    \x12\x04\x81\x11\x08\x11\n\x10\n\x08\x04\x9a\x01\x04\x02\x02\0\x01\x12\
    \x04\x81\x11\x08\x0c\n\x10\n\x08\x04\x9a\x01\x04\x02\x02\0\x02\x12\x04\
    \x81\x11\x0f\x10\n\x0f\n\x07\x04\x9a\x01\x04\x02\x02\x01\x12\x04\x82\x11\
    \x08\x0f\n\x10\n\x08\x04\x9a\x01\x04\x02\x02\x01\x01\x12\x04\x82\x11\x08\
    \n\n\x10\n\x08\x04\x9a\x01\x04\x02\x02\x01\x02\x12\x04\x82\x11\r\x0e\n\
    \x0f\n\x07\x04\x9a\x01\x04\x02\x02\x02\x12\x04\x83\x11\x08\x10\n\x10\n\
    \x08\x04\x9a\x01\x04\x02\x02\x02\x01\x12\x04\x83\x11\x08\x0b\n\x10\n\x08\
    \x04\x9a\x01\x04\x02\x02\x02\x02\x12\x04\x83\x11\x0e\x0f\n\x0f\n\x07\x04\
    \x9a\x01\x04\x02\x02\x03\x12\x04\x84\x11\x08\x17\n\x10\n\x08\x04\x9a\x01\
    \x04\x02\x02\x03\x01\x12\x04\x84\x11\x08\x12\n\x10\n\x08\x04\x9a\x01\x04\
    \x02\x02\x03\x02\x12\x04\x84\x11\x15\x16\n\r\n\x05\x04\x9a\x01\x02\0\x12\
    \x04\x86\x11\x04\x20\n\x0e\n\x06\x04\x9a\x01\x02\0\x04\x12\x04\x86\x11\
    \x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\0\x06\x12\x04\x86\x11\r\x17\n\x0e\n\
    \x06\x04\x9a\x01\x02\0\x01\x12\x04\x86\x11\x18\x1b\n\x0e\n\x06\x04\x9a\
    \x01\x02\0\x03\x12\x04\x86\x11\x1e\x1f\n\r\n\x05\x04\x9a\x01\x02\x01\x12\
    \x04\x87\x11\x04!\n\x0e\n\x06\x04\x9a\x01\x02\x01\x04\x12\x04\x87\x11\
    \x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x01\x06\x12\x04\x87\x11\r\x14\n\x0e\
    \n\x06\x04\x9a\x01\x02\x01\x01\x12\x04\x87\x11\x15\x1c\n\x0e\n\x06\x04\
    \x9a\x01\x02\x01\x03\x12\x04\x87\x11\x1f\x20\n\r\n\x05\x04\x9a\x01\x02\
    \x02\x12\x04\x88\x11\x04)\n\x0e\n\x06\x04\x9a\x01\x02\x02\x04\x12\x04\
    \x88\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x02\x05\x12\x04\x88\x11\r\
    \x13\n\x0e\n\x06\x04\x9a\x01\x02\x02\x01\x12\x04\x88\x11\x14$\n\x0e\n\
    \x06\x04\x9a\x01\x02\x02\x03\x12\x04\x88\x11'(\n\r\n\x05\x04\x9a\x01\x02\
    \x03\x12\x04\x89\x11\x04\x1f\n\x0e\n\x06\x04\x9a\x01\x02\x03\x04\x12\x04\
    \x89\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x03\x06\x12\x04\x89\x11\r\
    \x13\n\x0e\n\x06\x04\x9a\x01\x02\x03\x01\x12\x04\x89\x11\x14\x1a\n\x0e\n\
    \x06\x04\x9a\x01\x02\x03\x03\x12\x04\x89\x11\x1d\x1e\n\r\n\x05\x04\x9a\
    \x01\x02\x04\x12\x04\x8a\x11\x04$\n\x0e\n\x06\x04\x9a\x01\x02\x04\x04\
    \x12\x04\x8a\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x04\x05\x12\x04\x8a\
    \x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\x04\x01\x12\x04\x8a\x11\x14\x1f\n\
    \x0e\n\x06\x04\x9a\x01\x02\x04\x03\x12\x04\x8a\x11\"#\n\r\n\x05\x04\x9a\
    \x01\x02\x05\x12\x04\x8b\x11\x04,\n\x0e\n\x06\x04\x9a\x01\x02\x05\x04\
    \x12\x04\x8b\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x05\x05\x12\x04\x8b\
    \x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\x05\x01\x12\x04\x8b\x11\x14'\n\
    \x0e\n\x06\x04\x9a\x01\x02\x05\x03\x12\x04\x8b\x11*+\n\r\n\x05\x04\x9a\
    \x01\x02\x06\x12\x04\x8c\x11\x04\x1e\n\x0e\n\x06\x04\x9a\x01\x02\x06\x04\
    \x12\x04\x8c\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x06\x05\x12\x04\x8c\
    \x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02\x06\x01\x12\x04\x8c\x11\x12\x18\n\
    \x0e\n\x06\x04\x9a\x01\x02\x06\x03\x12\x04\x8c\x11\x1b\x1d\n\r\n\x05\x04\
    \x9a\x01\x02\x07\x12\x04\x8d\x11\x04\x1f\n\x0e\n\x06\x04\x9a\x01\x02\x07\
    \x04\x12\x04\x8d\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x07\x05\x12\x04\
    \x8d\x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02\x07\x01\x12\x04\x8d\x11\x12\
    \x19\n\x0e\n\x06\x04\x9a\x01\x02\x07\x03\x12\x04\x8d\x11\x1c\x1e\n\r\n\
    \x05\x04\x9a\x01\x02\x08\x12\x04\x8e\x11\x04!\n\x0e\n\x06\x04\x9a\x01\
    \x02\x08\x04\x12\x04\x8e\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x08\x05\
    \x12\x04\x8e\x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02\x08\x01\x12\x04\x8e\
    \x11\x12\x1b\n\x0e\n\x06\x04\x9a\x01\x02\x08\x03\x12\x04\x8e\x11\x1e\x20\
    \n\r\n\x05\x04\x9a\x01\x02\t\x12\x04\x8f\x11\x04\"\n\x0e\n\x06\x04\x9a\
    \x01\x02\t\x04\x12\x04\x8f\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\t\x05\
    \x12\x04\x8f\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\t\x01\x12\x04\x8f\x11\
    \x14\x1c\n\x0e\n\x06\x04\x9a\x01\x02\t\x03\x12\x04\x8f\x11\x1f!\n\r\n\
    \x05\x04\x9a\x01\x02\n\x12\x04\x90\x11\x04.\n\x0e\n\x06\x04\x9a\x01\x02\
    \n\x04\x12\x04\x90\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\n\x05\x12\x04\
    \x90\x11\r\x12\n\x0e\n\x06\x04\x9a\x01\x02\n\x01\x12\x04\x90\x11\x13(\n\
    \x0e\n\x06\x04\x9a\x01\x02\n\x03\x12\x04\x90\x11+-\n\r\n\x05\x04\x9a\x01\
    \x02\x0b\x12\x04\x91\x11\x04!\n\x0e\n\x06\x04\x9a\x01\x02\x0b\x04\x12\
    \x04\x91\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x0b\x05\x12\x04\x91\x11\
    \r\x11\n\x0e\n\x06\x04\x9a\x01\x02\x0b\x01\x12\x04\x91\x11\x12\x1b\n\x0e\
    \n\x06\x04\x9a\x01\x02\x0b\x03\x12\x04\x91\x11\x1e\x20\n\r\n\x05\x04\x9a\
    \x01\x02\x0c\x12\x04\x92\x11\x04\x1f\n\x0e\n\x06\x04\x9a\x01\x02\x0c\x04\
    \x12\x04\x92\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x0c\x05\x12\x04\x92\
    \x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02\x0c\x01\x12\x04\x92\x11\x12\x19\n\
    \x0e\n\x06\x04\x9a\x01\x02\x0c\x03\x12\x04\x92\x11\x1c\x1e\n\r\n\x05\x04\
    \x9a\x01\x02\r\x12\x04\x93\x11\x04!\n\x0e\n\x06\x04\x9a\x01\x02\r\x04\
    \x12\x04\x93\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\r\x05\x12\x04\x93\
    \x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02\r\x01\x12\x04\x93\x11\x12\x1b\n\
    \x0e\n\x06\x04\x9a\x01\x02\r\x03\x12\x04\x93\x11\x1e\x20\n\r\n\x05\x04\
    \x9a\x01\x02\x0e\x12\x04\x94\x11\x04+\n\x0e\n\x06\x04\x9a\x01\x02\x0e\
    \x04\x12\x04\x94\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x0e\x06\x12\x04\
    \x94\x11\r\x15\n\x0e\n\x06\x04\x9a\x01\x02\x0e\x01\x12\x04\x94\x11\x16%\
    \n\x0e\n\x06\x04\x9a\x01\x02\x0e\x03\x12\x04\x94\x11(*\n\r\n\x05\x04\x9a\
    \x01\x02\x0f\x12\x04\x95\x11\x04\"\n\x0e\n\x06\x04\x9a\x01\x02\x0f\x04\
    \x12\x04\x95\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x0f\x05\x12\x04\x95\
    \x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02\x0f\x01\x12\x04\x95\x11\x12\x1c\n\
    \x0e\n\x06\x04\x9a\x01\x02\x0f\x03\x12\x04\x95\x11\x1f!\n\r\n\x05\x04\
    \x9a\x01\x02\x10\x12\x04\x96\x11\x04/\n\x0e\n\x06\x04\x9a\x01\x02\x10\
    \x04\x12\x04\x96\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x10\x05\x12\x04\
    \x96\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\x10\x01\x12\x04\x96\x11\x14)\
    \n\x0e\n\x06\x04\x9a\x01\x02\x10\x03\x12\x04\x96\x11,.\n\r\n\x05\x04\x9a\
    \x01\x02\x11\x12\x04\x97\x11\x04\"\n\x0e\n\x06\x04\x9a\x01\x02\x11\x04\
    \x12\x04\x97\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x11\x05\x12\x04\x97\
    \x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\x11\x01\x12\x04\x97\x11\x14\x1c\n\
    \x0e\n\x06\x04\x9a\x01\x02\x11\x03\x12\x04\x97\x11\x1f!\n\r\n\x05\x04\
    \x9a\x01\x02\x12\x12\x04\x98\x11\x04\x20\n\x0e\n\x06\x04\x9a\x01\x02\x12\
    \x04\x12\x04\x98\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x12\x05\x12\x04\
    \x98\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\x12\x01\x12\x04\x98\x11\x14\
    \x1a\n\x0e\n\x06\x04\x9a\x01\x02\x12\x03\x12\x04\x98\x11\x1d\x1f\n\r\n\
    \x05\x04\x9a\x01\x02\x13\x12\x04\x99\x11\x04*\n\x0e\n\x06\x04\x9a\x01\
    \x02\x13\x04\x12\x04\x99\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x13\x06\
    \x12\x04\x99\x11\r\x18\n\x0e\n\x06\x04\x9a\x01\x02\x13\x01\x12\x04\x99\
    \x11\x19$\n\x0e\n\x06\x04\x9a\x01\x02\x13\x03\x12\x04\x99\x11')\n\r\n\
    \x05\x04\x9a\x01\x02\x14\x12\x04\x9a\x11\x048\n\x0e\n\x06\x04\x9a\x01\
    \x02\x14\x04\x12\x04\x9a\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x14\x06\
    \x12\x04\x9a\x11\r\x20\n\x0e\n\x06\x04\x9a\x01\x02\x14\x01\x12\x04\x9a\
    \x11!2\n\x0e\n\x06\x04\x9a\x01\x02\x14\x03\x12\x04\x9a\x1157\n\r\n\x05\
    \x04\x9a\x01\x02\x15\x12\x04\x9b\x11\x040\n\x0e\n\x06\x04\x9a\x01\x02\
    \x15\x04\x12\x04\x9b\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x15\x06\x12\
    \x04\x9b\x11\r\x18\n\x0e\n\x06\x04\x9a\x01\x02\x15\x01\x12\x04\x9b\x11\
    \x19*\n\x0e\n\x06\x04\x9a\x01\x02\x15\x03\x12\x04\x9b\x11-/\n\r\n\x05\
    \x04\x9a\x01\x02\x16\x12\x04\x9c\x11\x041\n\x0e\n\x06\x04\x9a\x01\x02\
    \x16\x04\x12\x04\x9c\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x16\x05\x12\
    \x04\x9c\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\x16\x01\x12\x04\x9c\x11\
    \x14+\n\x0e\n\x06\x04\x9a\x01\x02\x16\x03\x12\x04\x9c\x11.0\n\r\n\x05\
    \x04\x9a\x01\x02\x17\x12\x04\x9d\x11\x04+\n\x0e\n\x06\x04\x9a\x01\x02\
    \x17\x04\x12\x04\x9d\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x17\x05\x12\
    \x04\x9d\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\x17\x01\x12\x04\x9d\x11\
    \x14%\n\x0e\n\x06\x04\x9a\x01\x02\x17\x03\x12\x04\x9d\x11(*\n\r\n\x05\
    \x04\x9a\x01\x02\x18\x12\x04\x9e\x11\x04(\n\x0e\n\x06\x04\x9a\x01\x02\
    \x18\x04\x12\x04\x9e\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x18\x05\x12\
    \x04\x9e\x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02\x18\x01\x12\x04\x9e\x11\
    \x12\"\n\x0e\n\x06\x04\x9a\x01\x02\x18\x03\x12\x04\x9e\x11%'\n\r\n\x05\
    \x04\x9a\x01\x02\x19\x12\x04\x9f\x11\x04*\n\x0e\n\x06\x04\x9a\x01\x02\
    \x19\x04\x12\x04\x9f\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x19\x05\x12\
    \x04\x9f\x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02\x19\x01\x12\x04\x9f\x11\
    \x12$\n\x0e\n\x06\x04\x9a\x01\x02\x19\x03\x12\x04\x9f\x11')\n\r\n\x05\
    \x04\x9a\x01\x02\x1a\x12\x04\xa0\x11\x044\n\x0e\n\x06\x04\x9a\x01\x02\
    \x1a\x04\x12\x04\xa0\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x1a\x06\x12\
    \x04\xa0\x11\r\x1d\n\x0e\n\x06\x04\x9a\x01\x02\x1a\x01\x12\x04\xa0\x11\
    \x1e.\n\x0e\n\x06\x04\x9a\x01\x02\x1a\x03\x12\x04\xa0\x1113\n\r\n\x05\
    \x04\x9a\x01\x02\x1b\x12\x04\xa1\x11\x04)\n\x0e\n\x06\x04\x9a\x01\x02\
    \x1b\x04\x12\x04\xa1\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x1b\x05\x12\
    \x04\xa1\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02\x1b\x01\x12\x04\xa1\x11\
    \x14#\n\x0e\n\x06\x04\x9a\x01\x02\x1b\x03\x12\x04\xa1\x11&(\n\r\n\x05\
    \x04\x9a\x01\x02\x1c\x12\x04\xa2\x11\x04&\n\x0e\n\x06\x04\x9a\x01\x02\
    \x1c\x04\x12\x04\xa2\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x1c\x06\x12\
    \x04\xa2\x11\r\x16\n\x0e\n\x06\x04\x9a\x01\x02\x1c\x01\x12\x04\xa2\x11\
    \x17\x20\n\x0e\n\x06\x04\x9a\x01\x02\x1c\x03\x12\x04\xa2\x11#%\n\r\n\x05\
    \x04\x9a\x01\x02\x1d\x12\x04\xa3\x11\x04*\n\x0e\n\x06\x04\x9a\x01\x02\
    \x1d\x04\x12\x04\xa3\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x1d\x06\x12\
    \x04\xa3\x11\r\x18\n\x0e\n\x06\x04\x9a\x01\x02\x1d\x01\x12\x04\xa3\x11\
    \x19$\n\x0e\n\x06\x04\x9a\x01\x02\x1d\x03\x12\x04\xa3\x11')\n\r\n\x05\
    \x04\x9a\x01\x02\x1e\x12\x04\xa4\x11\x04*\n\x0e\n\x06\x04\x9a\x01\x02\
    \x1e\x04\x12\x04\xa4\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x1e\x06\x12\
    \x04\xa4\x11\r\x18\n\x0e\n\x06\x04\x9a\x01\x02\x1e\x01\x12\x04\xa4\x11\
    \x19$\n\x0e\n\x06\x04\x9a\x01\x02\x1e\x03\x12\x04\xa4\x11')\n\r\n\x05\
    \x04\x9a\x01\x02\x1f\x12\x04\xa5\x11\x04%\n\x0e\n\x06\x04\x9a\x01\x02\
    \x1f\x04\x12\x04\xa5\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x1f\x06\x12\
    \x04\xa5\x11\r\x15\n\x0e\n\x06\x04\x9a\x01\x02\x1f\x01\x12\x04\xa5\x11\
    \x16\x1f\n\x0e\n\x06\x04\x9a\x01\x02\x1f\x03\x12\x04\xa5\x11\"$\n\r\n\
    \x05\x04\x9a\x01\x02\x20\x12\x04\xa6\x11\x04.\n\x0e\n\x06\x04\x9a\x01\
    \x02\x20\x04\x12\x04\xa6\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\x20\x06\
    \x12\x04\xa6\x11\r\x16\n\x0e\n\x06\x04\x9a\x01\x02\x20\x01\x12\x04\xa6\
    \x11\x17(\n\x0e\n\x06\x04\x9a\x01\x02\x20\x03\x12\x04\xa6\x11+-\n\r\n\
    \x05\x04\x9a\x01\x02!\x12\x04\xa7\x11\x04(\n\x0e\n\x06\x04\x9a\x01\x02!\
    \x04\x12\x04\xa7\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02!\x05\x12\x04\
    \xa7\x11\r\x12\n\x0e\n\x06\x04\x9a\x01\x02!\x01\x12\x04\xa7\x11\x13\"\n\
    \x0e\n\x06\x04\x9a\x01\x02!\x03\x12\x04\xa7\x11%'\n\r\n\x05\x04\x9a\x01\
    \x02\"\x12\x04\xa8\x11\x04&\n\x0e\n\x06\x04\x9a\x01\x02\"\x04\x12\x04\
    \xa8\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02\"\x06\x12\x04\xa8\x11\r\x16\
    \n\x0e\n\x06\x04\x9a\x01\x02\"\x01\x12\x04\xa8\x11\x17\x20\n\x0e\n\x06\
    \x04\x9a\x01\x02\"\x03\x12\x04\xa8\x11#%\n\r\n\x05\x04\x9a\x01\x02#\x12\
    \x04\xa9\x11\x04)\n\x0e\n\x06\x04\x9a\x01\x02#\x04\x12\x04\xa9\x11\x04\
    \x0c\n\x0e\n\x06\x04\x9a\x01\x02#\x06\x12\x04\xa9\x11\r\x17\n\x0e\n\x06\
    \x04\x9a\x01\x02#\x01\x12\x04\xa9\x11\x18#\n\x0e\n\x06\x04\x9a\x01\x02#\
    \x03\x12\x04\xa9\x11&(\n\r\n\x05\x04\x9a\x01\x02$\x12\x04\xaa\x11\x04@\n\
    \x0e\n\x06\x04\x9a\x01\x02$\x04\x12\x04\xaa\x11\x04\x0c\n\x0e\n\x06\x04\
    \x9a\x01\x02$\x06\x12\x04\xaa\x11\r#\n\x0e\n\x06\x04\x9a\x01\x02$\x01\
    \x12\x04\xaa\x11$:\n\x0e\n\x06\x04\x9a\x01\x02$\x03\x12\x04\xaa\x11=?\n\
    \r\n\x05\x04\x9a\x01\x02%\x12\x04\xab\x11\x04!\n\x0e\n\x06\x04\x9a\x01\
    \x02%\x04\x12\x04\xab\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02%\x05\x12\
    \x04\xab\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02%\x01\x12\x04\xab\x11\x14\
    \x1b\n\x0e\n\x06\x04\x9a\x01\x02%\x03\x12\x04\xab\x11\x1e\x20\n\r\n\x05\
    \x04\x9a\x01\x02&\x12\x04\xac\x11\x04+\n\x0e\n\x06\x04\x9a\x01\x02&\x04\
    \x12\x04\xac\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02&\x05\x12\x04\xac\
    \x11\r\x11\n\x0e\n\x06\x04\x9a\x01\x02&\x01\x12\x04\xac\x11\x12%\n\x0e\n\
    \x06\x04\x9a\x01\x02&\x03\x12\x04\xac\x11(*\n\r\n\x05\x04\x9a\x01\x02'\
    \x12\x04\xad\x11\x04&\n\x0e\n\x06\x04\x9a\x01\x02'\x04\x12\x04\xad\x11\
    \x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02'\x05\x12\x04\xad\x11\r\x12\n\x0e\n\
    \x06\x04\x9a\x01\x02'\x01\x12\x04\xad\x11\x13\x20\n\x0e\n\x06\x04\x9a\
    \x01\x02'\x03\x12\x04\xad\x11#%\n\r\n\x05\x04\x9a\x01\x02(\x12\x04\xae\
    \x11\x04(\n\x0e\n\x06\x04\x9a\x01\x02(\x04\x12\x04\xae\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9a\x01\x02(\x06\x12\x04\xae\x11\r\x17\n\x0e\n\x06\x04\x9a\
    \x01\x02(\x01\x12\x04\xae\x11\x18\"\n\x0e\n\x06\x04\x9a\x01\x02(\x03\x12\
    \x04\xae\x11%'\n\r\n\x05\x04\x9a\x01\x02)\x12\x04\xaf\x11\x049\n\x0e\n\
    \x06\x04\x9a\x01\x02)\x04\x12\x04\xaf\x11\x04\x0c\n\x0e\n\x06\x04\x9a\
    \x01\x02)\x05\x12\x04\xaf\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02)\x01\x12\
    \x04\xaf\x11\x143\n\x0e\n\x06\x04\x9a\x01\x02)\x03\x12\x04\xaf\x1168\n\r\
    \n\x05\x04\x9a\x01\x02*\x12\x04\xb0\x11\x040\n\x0e\n\x06\x04\x9a\x01\x02\
    *\x04\x12\x04\xb0\x11\x04\x0c\n\x0e\n\x06\x04\x9a\x01\x02*\x05\x12\x04\
    \xb0\x11\r\x13\n\x0e\n\x06\x04\x9a\x01\x02*\x01\x12\x04\xb0\x11\x14*\n\
    \x0e\n\x06\x04\x9a\x01\x02*\x03\x12\x04\xb0\x11-/\n\r\n\x03\x04\x9b\x01\
    \x12\x06\xb3\x11\0\xe7\x11\x01\n\x0c\n\x04\x04\x9b\x01\x01\x12\x04\xb3\
    \x11\x08\x13\n\x0f\n\x05\x04\x9b\x01\x04\0\x12\x06\xb4\x11\x04\xb9\x11\
    \x05\n\x0e\n\x06\x04\x9b\x01\x04\0\x01\x12\x04\xb4\x11\t\r\n\x0f\n\x07\
    \x04\x9b\x01\x04\0\x02\0\x12\x04\xb5\x11\x08\x18\n\x10\n\x08\x04\x9b\x01\
    \x04\0\x02\0\x01\x12\x04\xb5\x11\x08\x13\n\x10\n\x08\x04\x9b\x01\x04\0\
    \x02\0\x02\x12\x04\xb5\x11\x16\x17\n\x0f\n\x07\x04\x9b\x01\x04\0\x02\x01\
    \x12\x04\xb6\x11\x08\x1a\n\x10\n\x08\x04\x9b\x01\x04\0\x02\x01\x01\x12\
    \x04\xb6\x11\x08\x15\n\x10\n\x08\x04\x9b\x01\x04\0\x02\x01\x02\x12\x04\
    \xb6\x11\x18\x19\n\x0f\n\x07\x04\x9b\x01\x04\0\x02\x02\x12\x04\xb7\x11\
    \x08\x18\n\x10\n\x08\x04\x9b\x01\x04\0\x02\x02\x01\x12\x04\xb7\x11\x08\
    \x13\n\x10\n\x08\x04\x9b\x01\x04\0\x02\x02\x02\x12\x04\xb7\x11\x16\x17\n\
    \x0f\n\x07\x04\x9b\x01\x04\0\x02\x03\x12\x04\xb8\x11\x08\x17\n\x10\n\x08\
    \x04\x9b\x01\x04\0\x02\x03\x01\x12\x04\xb8\x11\x08\x12\n\x10\n\x08\x04\
    \x9b\x01\x04\0\x02\x03\x02\x12\x04\xb8\x11\x15\x16\n\r\n\x05\x04\x9b\x01\
    \x02\0\x12\x04\xba\x11\x04$\n\x0e\n\x06\x04\x9b\x01\x02\0\x04\x12\x04\
    \xba\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\0\x06\x12\x04\xba\x11\r\x11\
    \n\x0e\n\x06\x04\x9b\x01\x02\0\x01\x12\x04\xba\x11\x12\x1f\n\x0e\n\x06\
    \x04\x9b\x01\x02\0\x03\x12\x04\xba\x11\"#\n\r\n\x05\x04\x9b\x01\x02\x01\
    \x12\x04\xbb\x11\x04-\n\x0e\n\x06\x04\x9b\x01\x02\x01\x04\x12\x04\xbb\
    \x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x01\x06\x12\x04\xbb\x11\r\x11\n\
    \x0e\n\x06\x04\x9b\x01\x02\x01\x01\x12\x04\xbb\x11\x12(\n\x0e\n\x06\x04\
    \x9b\x01\x02\x01\x03\x12\x04\xbb\x11+,\n\r\n\x05\x04\x9b\x01\x02\x02\x12\
    \x04\xbc\x11\x04\x1f\n\x0e\n\x06\x04\x9b\x01\x02\x02\x04\x12\x04\xbc\x11\
    \x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x02\x06\x12\x04\xbc\x11\r\x11\n\x0e\
    \n\x06\x04\x9b\x01\x02\x02\x01\x12\x04\xbc\x11\x12\x1a\n\x0e\n\x06\x04\
    \x9b\x01\x02\x02\x03\x12\x04\xbc\x11\x1d\x1e\n\r\n\x05\x04\x9b\x01\x02\
    \x03\x12\x04\xbd\x11\x04%\n\x0e\n\x06\x04\x9b\x01\x02\x03\x04\x12\x04\
    \xbd\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x03\x06\x12\x04\xbd\x11\r\
    \x11\n\x0e\n\x06\x04\x9b\x01\x02\x03\x01\x12\x04\xbd\x11\x12\x20\n\x0e\n\
    \x06\x04\x9b\x01\x02\x03\x03\x12\x04\xbd\x11#$\n\r\n\x05\x04\x9b\x01\x02\
    \x04\x12\x04\xbe\x11\x04%\n\x0e\n\x06\x04\x9b\x01\x02\x04\x04\x12\x04\
    \xbe\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x04\x06\x12\x04\xbe\x11\r\
    \x11\n\x0e\n\x06\x04\x9b\x01\x02\x04\x01\x12\x04\xbe\x11\x12\x20\n\x0e\n\
    \x06\x04\x9b\x01\x02\x04\x03\x12\x04\xbe\x11#$\n\r\n\x05\x04\x9b\x01\x02\
    \x05\x12\x04\xbf\x11\x04-\n\x0e\n\x06\x04\x9b\x01\x02\x05\x04\x12\x04\
    \xbf\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x05\x06\x12\x04\xbf\x11\r\
    \x11\n\x0e\n\x06\x04\x9b\x01\x02\x05\x01\x12\x04\xbf\x11\x12(\n\x0e\n\
    \x06\x04\x9b\x01\x02\x05\x03\x12\x04\xbf\x11+,\n\r\n\x05\x04\x9b\x01\x02\
    \x06\x12\x04\xc0\x11\x04$\n\x0e\n\x06\x04\x9b\x01\x02\x06\x04\x12\x04\
    \xc0\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x06\x06\x12\x04\xc0\x11\r\
    \x11\n\x0e\n\x06\x04\x9b\x01\x02\x06\x01\x12\x04\xc0\x11\x12\x1f\n\x0e\n\
    \x06\x04\x9b\x01\x02\x06\x03\x12\x04\xc0\x11\"#\n\r\n\x05\x04\x9b\x01\
    \x02\x07\x12\x04\xc1\x11\x04!\n\x0e\n\x06\x04\x9b\x01\x02\x07\x04\x12\
    \x04\xc1\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x07\x06\x12\x04\xc1\x11\
    \r\x11\n\x0e\n\x06\x04\x9b\x01\x02\x07\x01\x12\x04\xc1\x11\x12\x1c\n\x0e\
    \n\x06\x04\x9b\x01\x02\x07\x03\x12\x04\xc1\x11\x1f\x20\n\r\n\x05\x04\x9b\
    \x01\x02\x08\x12\x04\xc2\x11\x04-\n\x0e\n\x06\x04\x9b\x01\x02\x08\x04\
    \x12\x04\xc2\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x08\x06\x12\x04\xc2\
    \x11\r\x11\n\x0e\n\x06\x04\x9b\x01\x02\x08\x01\x12\x04\xc2\x11\x12(\n\
    \x0e\n\x06\x04\x9b\x01\x02\x08\x03\x12\x04\xc2\x11+,\n\r\n\x05\x04\x9b\
    \x01\x02\t\x12\x04\xc3\x11\x04)\n\x0e\n\x06\x04\x9b\x01\x02\t\x04\x12\
    \x04\xc3\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\t\x06\x12\x04\xc3\x11\r\
    \x11\n\x0e\n\x06\x04\x9b\x01\x02\t\x01\x12\x04\xc3\x11\x12#\n\x0e\n\x06\
    \x04\x9b\x01\x02\t\x03\x12\x04\xc3\x11&(\n\r\n\x05\x04\x9b\x01\x02\n\x12\
    \x04\xc4\x11\x04\x20\n\x0e\n\x06\x04\x9b\x01\x02\n\x04\x12\x04\xc4\x11\
    \x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\n\x06\x12\x04\xc4\x11\r\x11\n\x0e\n\
    \x06\x04\x9b\x01\x02\n\x01\x12\x04\xc4\x11\x12\x1a\n\x0e\n\x06\x04\x9b\
    \x01\x02\n\x03\x12\x04\xc4\x11\x1d\x1f\n\r\n\x05\x04\x9b\x01\x02\x0b\x12\
    \x04\xc5\x11\x04(\n\x0e\n\x06\x04\x9b\x01\x02\x0b\x04\x12\x04\xc5\x11\
    \x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02\x0b\x06\x12\x04\xc5\x11\r\x11\n\x0e\
    \n\x06\x04\x9b\x01\x02\x0b\x01\x12\x04\xc5\x11\x12\"\n\x0e\n\x06\x04\x9b\
    \x01\x02\x0b\x03\x12\x04\xc5\x11%'\n\r\n\x05\x04\x9b\x01\x02\x0c\x12\x04\
    \xc6\x11\x04*\n\x0e\n\x06\x04\x9b\x01\x02\x0c\x04\x12\x04\xc6\x11\x04\
    \x0c\n\x0e\n\x06\x04\x9b\x01\x02\x0c\x06\x12\x04\xc6\x11\r\x11\n\x0e\n\
    \x06\x04\x9b\x01\x02\x0c\x01\x12\x04\xc6\x11\x12$\n\x0e\n\x06\x04\x9b\
    \x01\x02\x0c\x03\x12\x04\xc6\x11')\n\r\n\x05\x04\x9b\x01\x02\r\x12\x04\
    \xc7\x11\x04\"\n\x0e\n\x06\x04\x9b\x01\x02\r\x04\x12\x04\xc7\x11\x04\x0c\
    \n\x0e\n\x06\x04\x9b\x01\x02\r\x06\x12\x04\xc7\x11\r\x11\n\x0e\n\x06\x04\
    \x9b\x01\x02\r\x01\x12\x04\xc7\x11\x12\x1c\n\x0e\n\x06\x04\x9b\x01\x02\r\
    \x03\x12\x04\xc7\x11\x1f!\n\r\n\x05\x04\x9b\x01\x02\x0e\x12\x04\xc8\x11\
    \x04#\n\x0e\n\x06\x04\x9b\x01\x02\x0e\x04\x12\x04\xc8\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9b\x01\x02\x0e\x06\x12\x04\xc8\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x0e\x01\x12\x04\xc8\x11\x12\x1d\n\x0e\n\x06\x04\x9b\x01\x02\x0e\
    \x03\x12\x04\xc8\x11\x20\"\n\r\n\x05\x04\x9b\x01\x02\x0f\x12\x04\xc9\x11\
    \x043\n\x0e\n\x06\x04\x9b\x01\x02\x0f\x04\x12\x04\xc9\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9b\x01\x02\x0f\x06\x12\x04\xc9\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x0f\x01\x12\x04\xc9\x11\x12-\n\x0e\n\x06\x04\x9b\x01\x02\x0f\
    \x03\x12\x04\xc9\x1102\n\r\n\x05\x04\x9b\x01\x02\x10\x12\x04\xca\x11\x04\
    \x1f\n\x0e\n\x06\x04\x9b\x01\x02\x10\x04\x12\x04\xca\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x10\x06\x12\x04\xca\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x10\x01\x12\x04\xca\x11\x12\x19\n\x0e\n\x06\x04\x9b\x01\x02\x10\
    \x03\x12\x04\xca\x11\x1c\x1e\n\r\n\x05\x04\x9b\x01\x02\x11\x12\x04\xcb\
    \x11\x04(\n\x0e\n\x06\x04\x9b\x01\x02\x11\x04\x12\x04\xcb\x11\x04\x0c\n\
    \x0e\n\x06\x04\x9b\x01\x02\x11\x06\x12\x04\xcb\x11\r\x11\n\x0e\n\x06\x04\
    \x9b\x01\x02\x11\x01\x12\x04\xcb\x11\x12\"\n\x0e\n\x06\x04\x9b\x01\x02\
    \x11\x03\x12\x04\xcb\x11%'\n\r\n\x05\x04\x9b\x01\x02\x12\x12\x04\xcc\x11\
    \x04%\n\x0e\n\x06\x04\x9b\x01\x02\x12\x04\x12\x04\xcc\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9b\x01\x02\x12\x06\x12\x04\xcc\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x12\x01\x12\x04\xcc\x11\x12\x1f\n\x0e\n\x06\x04\x9b\x01\x02\x12\
    \x03\x12\x04\xcc\x11\"$\n\r\n\x05\x04\x9b\x01\x02\x13\x12\x04\xcd\x11\
    \x04+\n\x0e\n\x06\x04\x9b\x01\x02\x13\x04\x12\x04\xcd\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9b\x01\x02\x13\x06\x12\x04\xcd\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x13\x01\x12\x04\xcd\x11\x12%\n\x0e\n\x06\x04\x9b\x01\x02\x13\
    \x03\x12\x04\xcd\x11(*\n\r\n\x05\x04\x9b\x01\x02\x14\x12\x04\xce\x11\x04\
    *\n\x0e\n\x06\x04\x9b\x01\x02\x14\x04\x12\x04\xce\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x14\x06\x12\x04\xce\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x14\x01\x12\x04\xce\x11\x12$\n\x0e\n\x06\x04\x9b\x01\x02\x14\
    \x03\x12\x04\xce\x11')\n\r\n\x05\x04\x9b\x01\x02\x15\x12\x04\xcf\x11\x04\
    2\n\x0e\n\x06\x04\x9b\x01\x02\x15\x04\x12\x04\xcf\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x15\x06\x12\x04\xcf\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x15\x01\x12\x04\xcf\x11\x12,\n\x0e\n\x06\x04\x9b\x01\x02\x15\
    \x03\x12\x04\xcf\x11/1\n\r\n\x05\x04\x9b\x01\x02\x16\x12\x04\xd0\x11\x04\
    .\n\x0e\n\x06\x04\x9b\x01\x02\x16\x04\x12\x04\xd0\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x16\x06\x12\x04\xd0\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x16\x01\x12\x04\xd0\x11\x12(\n\x0e\n\x06\x04\x9b\x01\x02\x16\
    \x03\x12\x04\xd0\x11+-\n\r\n\x05\x04\x9b\x01\x02\x17\x12\x04\xd1\x11\x04\
    &\n\x0e\n\x06\x04\x9b\x01\x02\x17\x04\x12\x04\xd1\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x17\x06\x12\x04\xd1\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x17\x01\x12\x04\xd1\x11\x12\x20\n\x0e\n\x06\x04\x9b\x01\x02\x17\
    \x03\x12\x04\xd1\x11#%\n\r\n\x05\x04\x9b\x01\x02\x18\x12\x04\xd2\x11\x04\
    \x1f\n\x0e\n\x06\x04\x9b\x01\x02\x18\x04\x12\x04\xd2\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x18\x06\x12\x04\xd2\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x18\x01\x12\x04\xd2\x11\x12\x19\n\x0e\n\x06\x04\x9b\x01\x02\x18\
    \x03\x12\x04\xd2\x11\x1c\x1e\n\r\n\x05\x04\x9b\x01\x02\x19\x12\x04\xd3\
    \x11\x04'\n\x0e\n\x06\x04\x9b\x01\x02\x19\x04\x12\x04\xd3\x11\x04\x0c\n\
    \x0e\n\x06\x04\x9b\x01\x02\x19\x06\x12\x04\xd3\x11\r\x11\n\x0e\n\x06\x04\
    \x9b\x01\x02\x19\x01\x12\x04\xd3\x11\x12!\n\x0e\n\x06\x04\x9b\x01\x02\
    \x19\x03\x12\x04\xd3\x11$&\n\r\n\x05\x04\x9b\x01\x02\x1a\x12\x04\xd4\x11\
    \x04%\n\x0e\n\x06\x04\x9b\x01\x02\x1a\x04\x12\x04\xd4\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9b\x01\x02\x1a\x06\x12\x04\xd4\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x1a\x01\x12\x04\xd4\x11\x12\x1f\n\x0e\n\x06\x04\x9b\x01\x02\x1a\
    \x03\x12\x04\xd4\x11\"$\n\r\n\x05\x04\x9b\x01\x02\x1b\x12\x04\xd5\x11\
    \x04'\n\x0e\n\x06\x04\x9b\x01\x02\x1b\x04\x12\x04\xd5\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9b\x01\x02\x1b\x06\x12\x04\xd5\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x1b\x01\x12\x04\xd5\x11\x12!\n\x0e\n\x06\x04\x9b\x01\x02\x1b\
    \x03\x12\x04\xd5\x11$&\n\r\n\x05\x04\x9b\x01\x02\x1c\x12\x04\xd6\x11\x04\
    4\n\x0e\n\x06\x04\x9b\x01\x02\x1c\x04\x12\x04\xd6\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x1c\x06\x12\x04\xd6\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x1c\x01\x12\x04\xd6\x11\x12.\n\x0e\n\x06\x04\x9b\x01\x02\x1c\
    \x03\x12\x04\xd6\x1113\n\r\n\x05\x04\x9b\x01\x02\x1d\x12\x04\xd7\x11\x04\
    )\n\x0e\n\x06\x04\x9b\x01\x02\x1d\x04\x12\x04\xd7\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x1d\x06\x12\x04\xd7\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x1d\x01\x12\x04\xd7\x11\x12#\n\x0e\n\x06\x04\x9b\x01\x02\x1d\
    \x03\x12\x04\xd7\x11&(\n\r\n\x05\x04\x9b\x01\x02\x1e\x12\x04\xd8\x11\x04\
    +\n\x0e\n\x06\x04\x9b\x01\x02\x1e\x04\x12\x04\xd8\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x1e\x06\x12\x04\xd8\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x1e\x01\x12\x04\xd8\x11\x12%\n\x0e\n\x06\x04\x9b\x01\x02\x1e\
    \x03\x12\x04\xd8\x11(*\n\r\n\x05\x04\x9b\x01\x02\x1f\x12\x04\xd9\x11\x04\
    (\n\x0e\n\x06\x04\x9b\x01\x02\x1f\x04\x12\x04\xd9\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x1f\x06\x12\x04\xd9\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x1f\x01\x12\x04\xd9\x11\x12\"\n\x0e\n\x06\x04\x9b\x01\x02\x1f\
    \x03\x12\x04\xd9\x11%'\n\r\n\x05\x04\x9b\x01\x02\x20\x12\x04\xda\x11\x04\
    (\n\x0e\n\x06\x04\x9b\x01\x02\x20\x04\x12\x04\xda\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02\x20\x06\x12\x04\xda\x11\r\x11\n\x0e\n\x06\x04\x9b\
    \x01\x02\x20\x01\x12\x04\xda\x11\x12\"\n\x0e\n\x06\x04\x9b\x01\x02\x20\
    \x03\x12\x04\xda\x11%'\n\r\n\x05\x04\x9b\x01\x02!\x12\x04\xdb\x11\x04\"\
    \n\x0e\n\x06\x04\x9b\x01\x02!\x04\x12\x04\xdb\x11\x04\x0c\n\x0e\n\x06\
    \x04\x9b\x01\x02!\x06\x12\x04\xdb\x11\r\x11\n\x0e\n\x06\x04\x9b\x01\x02!\
    \x01\x12\x04\xdb\x11\x12\x1c\n\x0e\n\x06\x04\x9b\x01\x02!\x03\x12\x04\
    \xdb\x11\x1f!\n\r\n\x05\x04\x9b\x01\x02\"\x12\x04\xdc\x11\x04\x1f\n\x0e\
    \n\x06\x04\x9b\x01\x02\"\x04\x12\x04\xdc\x11\x04\x0c\n\x0e\n\x06\x04\x9b\
    \x01\x02\"\x06\x12\x04\xdc\x11\r\x11\n\x0e\n\x06\x04\x9b\x01\x02\"\x01\
    \x12\x04\xdc\x11\x12\x19\n\x0e\n\x06\x04\x9b\x01\x02\"\x03\x12\x04\xdc\
    \x11\x1c\x1e\n\r\n\x05\x04\x9b\x01\x02#\x12\x04\xdd\x11\x04'\n\x0e\n\x06\
    \x04\x9b\x01\x02#\x04\x12\x04\xdd\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\
    \x02#\x06\x12\x04\xdd\x11\r\x11\n\x0e\n\x06\x04\x9b\x01\x02#\x01\x12\x04\
    \xdd\x11\x12!\n\x0e\n\x06\x04\x9b\x01\x02#\x03\x12\x04\xdd\x11$&\n\r\n\
    \x05\x04\x9b\x01\x02$\x12\x04\xde\x11\x043\n\x0e\n\x06\x04\x9b\x01\x02$\
    \x04\x12\x04\xde\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02$\x06\x12\x04\
    \xde\x11\r\x11\n\x0e\n\x06\x04\x9b\x01\x02$\x01\x12\x04\xde\x11\x12-\n\
    \x0e\n\x06\x04\x9b\x01\x02$\x03\x12\x04\xde\x1102\n\r\n\x05\x04\x9b\x01\
    \x02%\x12\x04\xdf\x11\x04$\n\x0e\n\x06\x04\x9b\x01\x02%\x04\x12\x04\xdf\
    \x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02%\x06\x12\x04\xdf\x11\r\x11\n\
    \x0e\n\x06\x04\x9b\x01\x02%\x01\x12\x04\xdf\x11\x12\x1e\n\x0e\n\x06\x04\
    \x9b\x01\x02%\x03\x12\x04\xdf\x11!#\n\r\n\x05\x04\x9b\x01\x02&\x12\x04\
    \xe0\x11\x04!\n\x0e\n\x06\x04\x9b\x01\x02&\x04\x12\x04\xe0\x11\x04\x0c\n\
    \x0e\n\x06\x04\x9b\x01\x02&\x06\x12\x04\xe0\x11\r\x11\n\x0e\n\x06\x04\
    \x9b\x01\x02&\x01\x12\x04\xe0\x11\x12\x1b\n\x0e\n\x06\x04\x9b\x01\x02&\
    \x03\x12\x04\xe0\x11\x1e\x20\n\r\n\x05\x04\x9b\x01\x02'\x12\x04\xe1\x11\
    \x042\n\x0e\n\x06\x04\x9b\x01\x02'\x04\x12\x04\xe1\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9b\x01\x02'\x06\x12\x04\xe1\x11\r\x11\n\x0e\n\x06\x04\x9b\x01\
    \x02'\x01\x12\x04\xe1\x11\x12,\n\x0e\n\x06\x04\x9b\x01\x02'\x03\x12\x04\
    \xe1\x11/1\n\r\n\x05\x04\x9b\x01\x02(\x12\x04\xe2\x11\x04,\n\x0e\n\x06\
    \x04\x9b\x01\x02(\x04\x12\x04\xe2\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\
    \x02(\x06\x12\x04\xe2\x11\r\x11\n\x0e\n\x06\x04\x9b\x01\x02(\x01\x12\x04\
    \xe2\x11\x12&\n\x0e\n\x06\x04\x9b\x01\x02(\x03\x12\x04\xe2\x11)+\n\r\n\
    \x05\x04\x9b\x01\x02)\x12\x04\xe3\x11\x04&\n\x0e\n\x06\x04\x9b\x01\x02)\
    \x04\x12\x04\xe3\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02)\x06\x12\x04\
    \xe3\x11\r\x11\n\x0e\n\x06\x04\x9b\x01\x02)\x01\x12\x04\xe3\x11\x12\x20\
    \n\x0e\n\x06\x04\x9b\x01\x02)\x03\x12\x04\xe3\x11#%\n\r\n\x05\x04\x9b\
    \x01\x02*\x12\x04\xe4\x11\x04(\n\x0e\n\x06\x04\x9b\x01\x02*\x04\x12\x04\
    \xe4\x11\x04\x0c\n\x0e\n\x06\x04\x9b\x01\x02*\x06\x12\x04\xe4\x11\r\x11\
    \n\x0e\n\x06\x04\x9b\x01\x02*\x01\x12\x04\xe4\x11\x12\"\n\x0e\n\x06\x04\
    \x9b\x01\x02*\x03\x12\x04\xe4\x11%'\n\r\n\x05\x04\x9b\x01\x02+\x12\x04\
    \xe5\x11\x040\n\x0e\n\x06\x04\x9b\x01\x02+\x04\x12\x04\xe5\x11\x04\x0c\n\
    \x0e\n\x06\x04\x9b\x01\x02+\x06\x12\x04\xe5\x11\r\x11\n\x0e\n\x06\x04\
    \x9b\x01\x02+\x01\x12\x04\xe5\x11\x12*\n\x0e\n\x06\x04\x9b\x01\x02+\x03\
    \x12\x04\xe5\x11-/\n\r\n\x05\x04\x9b\x01\x02,\x12\x04\xe6\x11\x040\n\x0e\
    \n\x06\x04\x9b\x01\x02,\x04\x12\x04\xe6\x11\x04\x0c\n\x0e\n\x06\x04\x9b\
    \x01\x02,\x06\x12\x04\xe6\x11\r\x11\n\x0e\n\x06\x04\x9b\x01\x02,\x01\x12\
    \x04\xe6\x11\x12*\n\x0e\n\x06\x04\x9b\x01\x02,\x03\x12\x04\xe6\x11-/\n\r\
    \n\x03\x04\x9c\x01\x12\x06\xe9\x11\0\xf0\x11\x01\n\x0c\n\x04\x04\x9c\x01\
    \x01\x12\x04\xe9\x11\x08\x13\n\r\n\x05\x04\x9c\x01\x02\0\x12\x04\xea\x11\
    \x04\x20\n\x0e\n\x06\x04\x9c\x01\x02\0\x04\x12\x04\xea\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9c\x01\x02\0\x05\x12\x04\xea\x11\r\x13\n\x0e\n\x06\x04\x9c\
    \x01\x02\0\x01\x12\x04\xea\x11\x14\x1b\n\x0e\n\x06\x04\x9c\x01\x02\0\x03\
    \x12\x04\xea\x11\x1e\x1f\n\r\n\x05\x04\x9c\x01\x02\x01\x12\x04\xeb\x11\
    \x04(\n\x0e\n\x06\x04\x9c\x01\x02\x01\x04\x12\x04\xeb\x11\x04\x0c\n\x0e\
    \n\x06\x04\x9c\x01\x02\x01\x05\x12\x04\xeb\x11\r\x12\n\x0e\n\x06\x04\x9c\
    \x01\x02\x01\x01\x12\x04\xeb\x11\x13#\n\x0e\n\x06\x04\x9c\x01\x02\x01\
    \x03\x12\x04\xeb\x11&'\n\r\n\x05\x04\x9c\x01\x02\x02\x12\x04\xec\x11\x04\
    %\n\x0e\n\x06\x04\x9c\x01\x02\x02\x04\x12\x04\xec\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9c\x01\x02\x02\x05\x12\x04\xec\x11\r\x12\n\x0e\n\x06\x04\x9c\
    \x01\x02\x02\x01\x12\x04\xec\x11\x13\x20\n\x0e\n\x06\x04\x9c\x01\x02\x02\
    \x03\x12\x04\xec\x11#$\n\r\n\x05\x04\x9c\x01\x02\x03\x12\x04\xed\x11\x04\
    '\n\x0e\n\x06\x04\x9c\x01\x02\x03\x04\x12\x04\xed\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9c\x01\x02\x03\x05\x12\x04\xed\x11\r\x12\n\x0e\n\x06\x04\x9c\
    \x01\x02\x03\x01\x12\x04\xed\x11\x13\"\n\x0e\n\x06\x04\x9c\x01\x02\x03\
    \x03\x12\x04\xed\x11%&\n\r\n\x05\x04\x9c\x01\x02\x04\x12\x04\xee\x11\x04\
    )\n\x0e\n\x06\x04\x9c\x01\x02\x04\x04\x12\x04\xee\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9c\x01\x02\x04\x05\x12\x04\xee\x11\r\x13\n\x0e\n\x06\x04\x9c\
    \x01\x02\x04\x01\x12\x04\xee\x11\x14$\n\x0e\n\x06\x04\x9c\x01\x02\x04\
    \x03\x12\x04\xee\x11'(\n\r\n\x05\x04\x9c\x01\x02\x05\x12\x04\xef\x11\x04\
    +\n\x0e\n\x06\x04\x9c\x01\x02\x05\x04\x12\x04\xef\x11\x04\x0c\n\x0e\n\
    \x06\x04\x9c\x01\x02\x05\x05\x12\x04\xef\x11\r\x13\n\x0e\n\x06\x04\x9c\
    \x01\x02\x05\x01\x12\x04\xef\x11\x14&\n\x0e\n\x06\x04\x9c\x01\x02\x05\
    \x03\x12\x04\xef\x11)*\n\r\n\x03\x04\x9d\x01\x12\x06\xf2\x11\0\xf5\x11\
    \x01\n\x0c\n\x04\x04\x9d\x01\x01\x12\x04\xf2\x11\x08\x11\n\r\n\x05\x04\
    \x9d\x01\x02\0\x12\x04\xf3\x11\x04$\n\x0e\n\x06\x04\x9d\x01\x02\0\x04\
    \x12\x04\xf3\x11\x04\x0c\n\x0e\n\x06\x04\x9d\x01\x02\0\x05\x12\x04\xf3\
    \x11\r\x13\n\x0e\n\x06\x04\x9d\x01\x02\0\x01\x12\x04\xf3\x11\x14\x1e\n\
    \x0e\n\x06\x04\x9d\x01\x02\0\x03\x12\x04\xf3\x11!#\n\r\n\x05\x04\x9d\x01\
    \x02\x01\x12\x04\xf4\x11\x045\n\x0e\n\x06\x04\x9d\x01\x02\x01\x04\x12\
    \x04\xf4\x11\x04\x0c\n\x0e\n\x06\x04\x9d\x01\x02\x01\x05\x12\x04\xf4\x11\
    \r\x13\n\x0e\n\x06\x04\x9d\x01\x02\x01\x01\x12\x04\xf4\x11\x14/\n\x0e\n\
    \x06\x04\x9d\x01\x02\x01\x03\x12\x04\xf4\x1124\n\r\n\x03\x04\x9e\x01\x12\
    \x06\xf7\x11\0\xfd\x11\x01\n\x0c\n\x04\x04\x9e\x01\x01\x12\x04\xf7\x11\
    \x08\x10\n\r\n\x05\x04\x9e\x01\x02\0\x12\x04\xf8\x11\x04\x20\n\x0e\n\x06\
    \x04\x9e\x01\x02\0\x04\x12\x04\xf8\x11\x04\x0c\n\x0e\n\x06\x04\x9e\x01\
    \x02\0\x06\x12\x04\xf8\x11\r\x17\n\x0e\n\x06\x04\x9e\x01\x02\0\x01\x12\
    \x04\xf8\x11\x18\x1b\n\x0e\n\x06\x04\x9e\x01\x02\0\x03\x12\x04\xf8\x11\
    \x1e\x1f\n\r\n\x05\x04\x9e\x01\x02\x01\x12\x04\xf9\x11\x04\x1d\n\x0e\n\
    \x06\x04\x9e\x01\x02\x01\x04\x12\x04\xf9\x11\x04\x0c\n\x0e\n\x06\x04\x9e\
    \x01\x02\x01\x05\x12\x04\xf9\x11\r\x13\n\x0e\n\x06\x04\x9e\x01\x02\x01\
    \x01\x12\x04\xf9\x11\x14\x18\n\x0e\n\x06\x04\x9e\x01\x02\x01\x03\x12\x04\
    \xf9\x11\x1b\x1c\n\r\n\x05\x04\x9e\x01\x02\x02\x12\x04\xfa\x11\x04$\n\
    \x0e\n\x06\x04\x9e\x01\x02\x02\x04\x12\x04\xfa\x11\x04\x0c\n\x0e\n\x06\
    \x04\x9e\x01\x02\x02\x05\x12\x04\xfa\x11\r\x13\n\x0e\n\x06\x04\x9e\x01\
    \x02\x02\x01\x12\x04\xfa\x11\x14\x1f\n\x0e\n\x06\x04\x9e\x01\x02\x02\x03\
    \x12\x04\xfa\x11\"#\n\r\n\x05\x04\x9e\x01\x02\x03\x12\x04\xfb\x11\x04)\n\
    \x0e\n\x06\x04\x9e\x01\x02\x03\x04\x12\x04\xfb\x11\x04\x0c\n\x0e\n\x06\
    \x04\x9e\x01\x02\x03\x05\x12\x04\xfb\x11\r\x12\n\x0e\n\x06\x04\x9e\x01\
    \x02\x03\x01\x12\x04\xfb\x11\x13$\n\x0e\n\x06\x04\x9e\x01\x02\x03\x03\
    \x12\x04\xfb\x11'(\n\r\n\x05\x04\x9e\x01\x02\x04\x12\x04\xfc\x11\x04\x1d\
    \n\x0e\n\x06\x04\x9e\x01\x02\x04\x04\x12\x04\xfc\x11\x04\x0c\n\x0e\n\x06\
    \x04\x9e\x01\x02\x04\x05\x12\x04\xfc\x11\r\x11\n\x0e\n\x06\x04\x9e\x01\
    \x02\x04\x01\x12\x04\xfc\x11\x12\x18\n\x0e\n\x06\x04\x9e\x01\x02\x04\x03\
    \x12\x04\xfc\x11\x1b\x1c\n\r\n\x03\x04\x9f\x01\x12\x06\xff\x11\0\x85\x12\
    \x01\n\x0c\n\x04\x04\x9f\x01\x01\x12\x04\xff\x11\x08\x12\n\r\n\x05\x04\
    \x9f\x01\x02\0\x12\x04\x80\x12\x041\n\x0e\n\x06\x04\x9f\x01\x02\0\x04\
    \x12\x04\x80\x12\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\0\x06\x12\x04\x80\
    \x12\r\x17\n\x0e\n\x06\x04\x9f\x01\x02\0\x01\x12\x04\x80\x12\x18,\n\x0e\
    \n\x06\x04\x9f\x01\x02\0\x03\x12\x04\x80\x12/0\n\r\n\x05\x04\x9f\x01\x02\
    \x01\x12\x04\x81\x12\x04&\n\x0e\n\x06\x04\x9f\x01\x02\x01\x04\x12\x04\
    \x81\x12\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\x01\x06\x12\x04\x81\x12\r\
    \x1c\n\x0e\n\x06\x04\x9f\x01\x02\x01\x01\x12\x04\x81\x12\x1d!\n\x0e\n\
    \x06\x04\x9f\x01\x02\x01\x03\x12\x04\x81\x12$%\n\r\n\x05\x04\x9f\x01\x02\
    \x02\x12\x04\x82\x12\x04)\n\x0e\n\x06\x04\x9f\x01\x02\x02\x04\x12\x04\
    \x82\x12\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\x02\x05\x12\x04\x82\x12\r\
    \x12\n\x0e\n\x06\x04\x9f\x01\x02\x02\x01\x12\x04\x82\x12\x13$\n\x0e\n\
    \x06\x04\x9f\x01\x02\x02\x03\x12\x04\x82\x12'(\n\r\n\x05\x04\x9f\x01\x02\
    \x03\x12\x04\x83\x12\x04)\n\x0e\n\x06\x04\x9f\x01\x02\x03\x04\x12\x04\
    \x83\x12\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\x03\x05\x12\x04\x83\x12\r\
    \x12\n\x0e\n\x06\x04\x9f\x01\x02\x03\x01\x12\x04\x83\x12\x13$\n\x0e\n\
    \x06\x04\x9f\x01\x02\x03\x03\x12\x04\x83\x12'(\n\r\n\x05\x04\x9f\x01\x02\
    \x04\x12\x04\x84\x12\x04\x1d\n\x0e\n\x06\x04\x9f\x01\x02\x04\x04\x12\x04\
    \x84\x12\x04\x0c\n\x0e\n\x06\x04\x9f\x01\x02\x04\x05\x12\x04\x84\x12\r\
    \x11\n\x0e\n\x06\x04\x9f\x01\x02\x04\x01\x12\x04\x84\x12\x12\x18\n\x0e\n\
    \x06\x04\x9f\x01\x02\x04\x03\x12\x04\x84\x12\x1b\x1c\n\r\n\x03\x04\xa0\
    \x01\x12\x06\x87\x12\0\x89\x12\x01\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\
    \x87\x12\x08\x1e\n\r\n\x05\x04\xa0\x01\x02\0\x12\x04\x88\x12\x04&\n\x0e\
    \n\x06\x04\xa0\x01\x02\0\x04\x12\x04\x88\x12\x04\x0c\n\x0e\n\x06\x04\xa0\
    \x01\x02\0\x05\x12\x04\x88\x12\r\x11\n\x0e\n\x06\x04\xa0\x01\x02\0\x01\
    \x12\x04\x88\x12\x12!\n\x0e\n\x06\x04\xa0\x01\x02\0\x03\x12\x04\x88\x12$\
    %\n\r\n\x03\x04\xa1\x01\x12\x06\x8b\x12\0\x8f\x12\x01\n\x0c\n\x04\x04\
    \xa1\x01\x01\x12\x04\x8b\x12\x08\x13\n\r\n\x05\x04\xa1\x01\x02\0\x12\x04\
    \x8c\x12\x04\x20\n\x0e\n\x06\x04\xa1\x01\x02\0\x04\x12\x04\x8c\x12\x04\
    \x0c\n\x0e\n\x06\x04\xa1\x01\x02\0\x05\x12\x04\x8c\x12\r\x12\n\x0e\n\x06\
    \x04\xa1\x01\x02\0\x01\x12\x04\x8c\x12\x13\x1b\n\x0e\n\x06\x04\xa1\x01\
    \x02\0\x03\x12\x04\x8c\x12\x1e\x1f\n\r\n\x05\x04\xa1\x01\x02\x01\x12\x04\
    \x8d\x12\x04\x20\n\x0e\n\x06\x04\xa1\x01\x02\x01\x04\x12\x04\x8d\x12\x04\
    \x0c\n\x0e\n\x06\x04\xa1\x01\x02\x01\x05\x12\x04\x8d\x12\r\x12\n\x0e\n\
    \x06\x04\xa1\x01\x02\x01\x01\x12\x04\x8d\x12\x13\x1b\n\x0e\n\x06\x04\xa1\
    \x01\x02\x01\x03\x12\x04\x8d\x12\x1e\x1f\n\r\n\x05\x04\xa1\x01\x02\x02\
    \x12\x04\x8e\x12\x04#\n\x0e\n\x06\x04\xa1\x01\x02\x02\x04\x12\x04\x8e\
    \x12\x04\x0c\n\x0e\n\x06\x04\xa1\x01\x02\x02\x05\x12\x04\x8e\x12\r\x13\n\
    \x0e\n\x06\x04\xa1\x01\x02\x02\x01\x12\x04\x8e\x12\x14\x1e\n\x0e\n\x06\
    \x04\xa1\x01\x02\x02\x03\x12\x04\x8e\x12!\"\n\r\n\x03\x04\xa2\x01\x12\
    \x06\x91\x12\0\xd3\x12\x01\n\x0c\n\x04\x04\xa2\x01\x01\x12\x04\x91\x12\
    \x08\x13\n\x0f\n\x05\x04\xa2\x01\x04\0\x12\x06\x92\x12\x04\xb3\x12\x05\n\
    \x0e\n\x06\x04\xa2\x01\x04\0\x01\x12\x04\x92\x12\t\x12\n\x0f\n\x07\x04\
    \xa2\x01\x04\0\x02\0\x12\x04\x93\x12\x08\x14\n\x10\n\x08\x04\xa2\x01\x04\
    \0\x02\0\x01\x12\x04\x93\x12\x08\x0f\n\x10\n\x08\x04\xa2\x01\x04\0\x02\0\
    \x02\x12\x04\x93\x12\x12\x13\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x01\x12\
    \x04\x94\x12\x08\x1a\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x01\x01\x12\x04\
    \x94\x12\x08\x15\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x01\x02\x12\x04\x94\
    \x12\x18\x19\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x02\x12\x04\x95\x12\x08#\
    \n\x10\n\x08\x04\xa2\x01\x04\0\x02\x02\x01\x12\x04\x95\x12\x08\x1e\n\x10\
    \n\x08\x04\xa2\x01\x04\0\x02\x02\x02\x12\x04\x95\x12!\"\n\x0f\n\x07\x04\
    \xa2\x01\x04\0\x02\x03\x12\x04\x96\x12\x08\x11\n\x10\n\x08\x04\xa2\x01\
    \x04\0\x02\x03\x01\x12\x04\x96\x12\x08\x0c\n\x10\n\x08\x04\xa2\x01\x04\0\
    \x02\x03\x02\x12\x04\x96\x12\x0f\x10\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\
    \x04\x12\x04\x97\x12\x08\x14\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x04\x01\
    \x12\x04\x97\x12\x08\x0f\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x04\x02\x12\
    \x04\x97\x12\x12\x13\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x05\x12\x04\x98\
    \x12\x08\x16\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x05\x01\x12\x04\x98\x12\
    \x08\x11\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x05\x02\x12\x04\x98\x12\x14\
    \x15\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x06\x12\x04\x99\x12\x08\x13\n\x10\
    \n\x08\x04\xa2\x01\x04\0\x02\x06\x01\x12\x04\x99\x12\x08\x0e\n\x10\n\x08\
    \x04\xa2\x01\x04\0\x02\x06\x02\x12\x04\x99\x12\x11\x12\n\x0f\n\x07\x04\
    \xa2\x01\x04\0\x02\x07\x12\x04\x9a\x12\x08\x18\n\x10\n\x08\x04\xa2\x01\
    \x04\0\x02\x07\x01\x12\x04\x9a\x12\x08\x13\n\x10\n\x08\x04\xa2\x01\x04\0\
    \x02\x07\x02\x12\x04\x9a\x12\x16\x17\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\
    \x08\x12\x04\x9b\x12\x08\x1e\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x08\x01\
    \x12\x04\x9b\x12\x08\x19\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x08\x02\x12\
    \x04\x9b\x12\x1c\x1d\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\t\x12\x04\x9c\x12\
    \x08'\n\x10\n\x08\x04\xa2\x01\x04\0\x02\t\x01\x12\x04\x9c\x12\x08\"\n\
    \x10\n\x08\x04\xa2\x01\x04\0\x02\t\x02\x12\x04\x9c\x12%&\n\x0f\n\x07\x04\
    \xa2\x01\x04\0\x02\n\x12\x04\x9d\x12\x08\x17\n\x10\n\x08\x04\xa2\x01\x04\
    \0\x02\n\x01\x12\x04\x9d\x12\x08\x11\n\x10\n\x08\x04\xa2\x01\x04\0\x02\n\
    \x02\x12\x04\x9d\x12\x14\x16\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x0b\x12\
    \x04\x9e\x12\x08\x1d\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x0b\x01\x12\x04\
    \x9e\x12\x08\x17\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x0b\x02\x12\x04\x9e\
    \x12\x1a\x1c\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x0c\x12\x04\x9f\x12\x08\
    \x1a\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x0c\x01\x12\x04\x9f\x12\x08\x14\n\
    \x10\n\x08\x04\xa2\x01\x04\0\x02\x0c\x02\x12\x04\x9f\x12\x17\x19\n\x0f\n\
    \x07\x04\xa2\x01\x04\0\x02\r\x12\x04\xa0\x12\x08\x1b\n\x10\n\x08\x04\xa2\
    \x01\x04\0\x02\r\x01\x12\x04\xa0\x12\x08\x15\n\x10\n\x08\x04\xa2\x01\x04\
    \0\x02\r\x02\x12\x04\xa0\x12\x18\x1a\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\
    \x0e\x12\x04\xa1\x12\x08&\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x0e\x01\x12\
    \x04\xa1\x12\x08\x20\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x0e\x02\x12\x04\
    \xa1\x12#%\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x0f\x12\x04\xa2\x12\x08\x1e\
    \n\x10\n\x08\x04\xa2\x01\x04\0\x02\x0f\x01\x12\x04\xa2\x12\x08\x18\n\x10\
    \n\x08\x04\xa2\x01\x04\0\x02\x0f\x02\x12\x04\xa2\x12\x1b\x1d\n\x0f\n\x07\
    \x04\xa2\x01\x04\0\x02\x10\x12\x04\xa3\x12\x08\x19\n\x10\n\x08\x04\xa2\
    \x01\x04\0\x02\x10\x01\x12\x04\xa3\x12\x08\x13\n\x10\n\x08\x04\xa2\x01\
    \x04\0\x02\x10\x02\x12\x04\xa3\x12\x16\x18\n\x0f\n\x07\x04\xa2\x01\x04\0\
    \x02\x11\x12\x04\xa4\x12\x08\x1b\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x11\
    \x01\x12\x04\xa4\x12\x08\x15\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x11\x02\
    \x12\x04\xa4\x12\x18\x1a\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x12\x12\x04\
    \xa5\x12\x08+\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x12\x01\x12\x04\xa5\x12\
    \x08%\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x12\x02\x12\x04\xa5\x12(*\n\x0f\
    \n\x07\x04\xa2\x01\x04\0\x02\x13\x12\x04\xa6\x12\x08\x20\n\x10\n\x08\x04\
    \xa2\x01\x04\0\x02\x13\x01\x12\x04\xa6\x12\x08\x1a\n\x10\n\x08\x04\xa2\
    \x01\x04\0\x02\x13\x02\x12\x04\xa6\x12\x1d\x1f\n\x0f\n\x07\x04\xa2\x01\
    \x04\0\x02\x14\x12\x04\xa7\x12\x08\x1a\n\x10\n\x08\x04\xa2\x01\x04\0\x02\
    \x14\x01\x12\x04\xa7\x12\x08\x14\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x14\
    \x02\x12\x04\xa7\x12\x17\x19\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x15\x12\
    \x04\xa8\x12\x08\x1d\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x15\x01\x12\x04\
    \xa8\x12\x08\x17\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x15\x02\x12\x04\xa8\
    \x12\x1a\x1c\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x16\x12\x04\xa9\x12\x08\
    \x1c\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x16\x01\x12\x04\xa9\x12\x08\x16\n\
    \x10\n\x08\x04\xa2\x01\x04\0\x02\x16\x02\x12\x04\xa9\x12\x19\x1b\n\x0f\n\
    \x07\x04\xa2\x01\x04\0\x02\x17\x12\x04\xaa\x12\x08!\n\x10\n\x08\x04\xa2\
    \x01\x04\0\x02\x17\x01\x12\x04\xaa\x12\x08\x1b\n\x10\n\x08\x04\xa2\x01\
    \x04\0\x02\x17\x02\x12\x04\xaa\x12\x1e\x20\n\x0f\n\x07\x04\xa2\x01\x04\0\
    \x02\x18\x12\x04\xab\x12\x08\x1e\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x18\
    \x01\x12\x04\xab\x12\x08\x18\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x18\x02\
    \x12\x04\xab\x12\x1b\x1d\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x19\x12\x04\
    \xac\x12\x08\x1d\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x19\x01\x12\x04\xac\
    \x12\x08\x17\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x19\x02\x12\x04\xac\x12\
    \x1a\x1c\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x1a\x12\x04\xad\x12\x08\x1e\n\
    \x10\n\x08\x04\xa2\x01\x04\0\x02\x1a\x01\x12\x04\xad\x12\x08\x18\n\x10\n\
    \x08\x04\xa2\x01\x04\0\x02\x1a\x02\x12\x04\xad\x12\x1b\x1d\n\x0f\n\x07\
    \x04\xa2\x01\x04\0\x02\x1b\x12\x04\xae\x12\x08\x20\n\x10\n\x08\x04\xa2\
    \x01\x04\0\x02\x1b\x01\x12\x04\xae\x12\x08\x1a\n\x10\n\x08\x04\xa2\x01\
    \x04\0\x02\x1b\x02\x12\x04\xae\x12\x1d\x1f\n\x0f\n\x07\x04\xa2\x01\x04\0\
    \x02\x1c\x12\x04\xaf\x12\x08\x17\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x1c\
    \x01\x12\x04\xaf\x12\x08\x11\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x1c\x02\
    \x12\x04\xaf\x12\x14\x16\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x1d\x12\x04\
    \xb0\x12\x08\x1e\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x1d\x01\x12\x04\xb0\
    \x12\x08\x18\n\x10\n\x08\x04\xa2\x01\x04\0\x02\x1d\x02\x12\x04\xb0\x12\
    \x1b\x1d\n\x0f\n\x07\x04\xa2\x01\x04\0\x02\x1e\x12\x04\xb1\x12\x08\x1e\n\
    \x10\n\x08\x04\xa2\x01\x04\0\x02\x1e\x01\x12\x04\xb1\x12\x08\x18\n\x10\n\
    \x08\x04\xa2\x01\x04\0\x02\x1e\x02\x12\x04\xb1\x12\x1b\x1d\n\x0f\n\x07\
    \x04\xa2\x01\x04\0\x02\x1f\x12\x04\xb2\x12\x08\x1c\n\x10\n\x08\x04\xa2\
    \x01\x04\0\x02\x1f\x01\x12\x04\xb2\x12\x08\x16\n\x10\n\x08\x04\xa2\x01\
    \x04\0\x02\x1f\x02\x12\x04\xb2\x12\x19\x1b\n\x0f\n\x05\x04\xa2\x01\x04\
    \x01\x12\x06\xb4\x12\x04\xc1\x12\x05\n\x0e\n\x06\x04\xa2\x01\x04\x01\x01\
    \x12\x04\xb4\x12\t\x0f\n\x0f\n\x07\x04\xa2\x01\x04\x01\x02\0\x12\x04\xb5\
    \x12\x08\x1b\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\0\x01\x12\x04\xb5\x12\
    \x08\x16\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\0\x02\x12\x04\xb5\x12\x19\
    \x1a\n\x0f\n\x07\x04\xa2\x01\x04\x01\x02\x01\x12\x04\xb6\x12\x08\x17\n\
    \x10\n\x08\x04\xa2\x01\x04\x01\x02\x01\x01\x12\x04\xb6\x12\x08\x12\n\x10\
    \n\x08\x04\xa2\x01\x04\x01\x02\x01\x02\x12\x04\xb6\x12\x15\x16\n\x0f\n\
    \x07\x04\xa2\x01\x04\x01\x02\x02\x12\x04\xb7\x12\x08\x11\n\x10\n\x08\x04\
    \xa2\x01\x04\x01\x02\x02\x01\x12\x04\xb7\x12\x08\x0c\n\x10\n\x08\x04\xa2\
    \x01\x04\x01\x02\x02\x02\x12\x04\xb7\x12\x0f\x10\n\x0f\n\x07\x04\xa2\x01\
    \x04\x01\x02\x03\x12\x04\xb8\x12\x08\x1b\n\x10\n\x08\x04\xa2\x01\x04\x01\
    \x02\x03\x01\x12\x04\xb8\x12\x08\x16\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\
    \x03\x02\x12\x04\xb8\x12\x19\x1a\n\x0f\n\x07\x04\xa2\x01\x04\x01\x02\x04\
    \x12\x04\xb9\x12\x08\x15\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\x04\x01\x12\
    \x04\xb9\x12\x08\x10\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\x04\x02\x12\x04\
    \xb9\x12\x13\x14\n\x0f\n\x07\x04\xa2\x01\x04\x01\x02\x05\x12\x04\xba\x12\
    \x08\x1f\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\x05\x01\x12\x04\xba\x12\x08\
    \x1a\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\x05\x02\x12\x04\xba\x12\x1d\x1e\
    \n\x0f\n\x07\x04\xa2\x01\x04\x01\x02\x06\x12\x04\xbb\x12\x08\x15\n\x10\n\
    \x08\x04\xa2\x01\x04\x01\x02\x06\x01\x12\x04\xbb\x12\x08\x10\n\x10\n\x08\
    \x04\xa2\x01\x04\x01\x02\x06\x02\x12\x04\xbb\x12\x13\x14\n\x0f\n\x07\x04\
    \xa2\x01\x04\x01\x02\x07\x12\x04\xbc\x12\x08\x14\n\x10\n\x08\x04\xa2\x01\
    \x04\x01\x02\x07\x01\x12\x04\xbc\x12\x08\x0f\n\x10\n\x08\x04\xa2\x01\x04\
    \x01\x02\x07\x02\x12\x04\xbc\x12\x12\x13\n\x0f\n\x07\x04\xa2\x01\x04\x01\
    \x02\x08\x12\x04\xbd\x12\x08\x15\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\x08\
    \x01\x12\x04\xbd\x12\x08\x10\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\x08\x02\
    \x12\x04\xbd\x12\x13\x14\n\x0f\n\x07\x04\xa2\x01\x04\x01\x02\t\x12\x04\
    \xbe\x12\x08\x16\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\t\x01\x12\x04\xbe\
    \x12\x08\x11\n\x10\n\x08\x04\xa2\x01\x04\x01\x02\t\x02\x12\x04\xbe\x12\
    \x14\x15\n\x0f\n\x07\x04\xa2\x01\x04\x01\x02\n\x12\x04\xbf\x12\x08\x1f\n\
    \x10\n\x08\x04\xa2\x01\x04\x01\x02\n\x01\x12\x04\xbf\x12\x08\x19\n\x10\n\
    \x08\x04\xa2\x01\x04\x01\x02\n\x02\x12\x04\xbf\x12\x1c\x1e\n\x0f\n\x07\
    \x04\xa2\x01\x04\x01\x02\x0b\x12\x04\xc0\x12\x08\x15\n\x10\n\x08\x04\xa2\
    \x01\x04\x01\x02\x0b\x01\x12\x04\xc0\x12\x08\x0f\n\x10\n\x08\x04\xa2\x01\
    \x04\x01\x02\x0b\x02\x12\x04\xc0\x12\x12\x14\n\x0f\n\x05\x04\xa2\x01\x04\
    \x02\x12\x06\xc2\x12\x04\xc5\x12\x05\n\x0e\n\x06\x04\xa2\x01\x04\x02\x01\
    \x12\x04\xc2\x12\t\x11\n\x0f\n\x07\x04\xa2\x01\x04\x02\x02\0\x12\x04\xc3\
    \x12\x08\x1d\n\x10\n\x08\x04\xa2\x01\x04\x02\x02\0\x01\x12\x04\xc3\x12\
    \x08\x18\n\x10\n\x08\x04\xa2\x01\x04\x02\x02\0\x02\x12\x04\xc3\x12\x1b\
    \x1c\n\x0f\n\x07\x04\xa2\x01\x04\x02\x02\x01\x12\x04\xc4\x12\x08\x10\n\
    \x10\n\x08\x04\xa2\x01\x04\x02\x02\x01\x01\x12\x04\xc4\x12\x08\x0b\n\x10\
    \n\x08\x04\xa2\x01\x04\x02\x02\x01\x02\x12\x04\xc4\x12\x0e\x0f\n\r\n\x05\
    \x04\xa2\x01\x02\0\x12\x04\xc6\x12\x04-\n\x0e\n\x06\x04\xa2\x01\x02\0\
    \x04\x12\x04\xc6\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\0\x06\x12\x04\
    \xc6\x12\r\x15\n\x0e\n\x06\x04\xa2\x01\x02\0\x01\x12\x04\xc6\x12\x16(\n\
    \x0e\n\x06\x04\xa2\x01\x02\0\x03\x12\x04\xc6\x12+,\n\r\n\x05\x04\xa2\x01\
    \x02\x01\x12\x04\xc7\x12\x04#\n\x0e\n\x06\x04\xa2\x01\x02\x01\x04\x12\
    \x04\xc7\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x01\x05\x12\x04\xc7\x12\
    \r\x13\n\x0e\n\x06\x04\xa2\x01\x02\x01\x01\x12\x04\xc7\x12\x14\x1e\n\x0e\
    \n\x06\x04\xa2\x01\x02\x01\x03\x12\x04\xc7\x12!\"\n\r\n\x05\x04\xa2\x01\
    \x02\x02\x12\x04\xc8\x12\x04$\n\x0e\n\x06\x04\xa2\x01\x02\x02\x04\x12\
    \x04\xc8\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x02\x05\x12\x04\xc8\x12\
    \r\x13\n\x0e\n\x06\x04\xa2\x01\x02\x02\x01\x12\x04\xc8\x12\x14\x1f\n\x0e\
    \n\x06\x04\xa2\x01\x02\x02\x03\x12\x04\xc8\x12\"#\n\r\n\x05\x04\xa2\x01\
    \x02\x03\x12\x04\xc9\x12\x04\x1f\n\x0e\n\x06\x04\xa2\x01\x02\x03\x04\x12\
    \x04\xc9\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x03\x06\x12\x04\xc9\x12\
    \r\x13\n\x0e\n\x06\x04\xa2\x01\x02\x03\x01\x12\x04\xc9\x12\x14\x1a\n\x0e\
    \n\x06\x04\xa2\x01\x02\x03\x03\x12\x04\xc9\x12\x1d\x1e\n\r\n\x05\x04\xa2\
    \x01\x02\x04\x12\x04\xca\x12\x04-\n\x0e\n\x06\x04\xa2\x01\x02\x04\x04\
    \x12\x04\xca\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x04\x05\x12\x04\xca\
    \x12\r\x13\n\x0e\n\x06\x04\xa2\x01\x02\x04\x01\x12\x04\xca\x12\x14(\n\
    \x0e\n\x06\x04\xa2\x01\x02\x04\x03\x12\x04\xca\x12+,\n\r\n\x05\x04\xa2\
    \x01\x02\x05\x12\x04\xcb\x12\x04.\n\x0e\n\x06\x04\xa2\x01\x02\x05\x04\
    \x12\x04\xcb\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x05\x06\x12\x04\xcb\
    \x12\r\x17\n\x0e\n\x06\x04\xa2\x01\x02\x05\x01\x12\x04\xcb\x12\x18)\n\
    \x0e\n\x06\x04\xa2\x01\x02\x05\x03\x12\x04\xcb\x12,-\n\r\n\x05\x04\xa2\
    \x01\x02\x06\x12\x04\xcc\x12\x04(\n\x0e\n\x06\x04\xa2\x01\x02\x06\x04\
    \x12\x04\xcc\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x06\x05\x12\x04\xcc\
    \x12\r\x13\n\x0e\n\x06\x04\xa2\x01\x02\x06\x01\x12\x04\xcc\x12\x14#\n\
    \x0e\n\x06\x04\xa2\x01\x02\x06\x03\x12\x04\xcc\x12&'\n\r\n\x05\x04\xa2\
    \x01\x02\x07\x12\x04\xcd\x12\x04$\n\x0e\n\x06\x04\xa2\x01\x02\x07\x04\
    \x12\x04\xcd\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x07\x05\x12\x04\xcd\
    \x12\r\x11\n\x0e\n\x06\x04\xa2\x01\x02\x07\x01\x12\x04\xcd\x12\x12\x1f\n\
    \x0e\n\x06\x04\xa2\x01\x02\x07\x03\x12\x04\xcd\x12\"#\n\r\n\x05\x04\xa2\
    \x01\x02\x08\x12\x04\xce\x12\x04!\n\x0e\n\x06\x04\xa2\x01\x02\x08\x04\
    \x12\x04\xce\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x08\x05\x12\x04\xce\
    \x12\r\x13\n\x0e\n\x06\x04\xa2\x01\x02\x08\x01\x12\x04\xce\x12\x14\x1c\n\
    \x0e\n\x06\x04\xa2\x01\x02\x08\x03\x12\x04\xce\x12\x1f\x20\n\r\n\x05\x04\
    \xa2\x01\x02\t\x12\x04\xcf\x12\x04&\n\x0e\n\x06\x04\xa2\x01\x02\t\x04\
    \x12\x04\xcf\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\t\x06\x12\x04\xcf\
    \x12\r\x16\n\x0e\n\x06\x04\xa2\x01\x02\t\x01\x12\x04\xcf\x12\x17\x20\n\
    \x0e\n\x06\x04\xa2\x01\x02\t\x03\x12\x04\xcf\x12#%\n\r\n\x05\x04\xa2\x01\
    \x02\n\x12\x04\xd0\x12\x04)\n\x0e\n\x06\x04\xa2\x01\x02\n\x04\x12\x04\
    \xd0\x12\x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\n\x05\x12\x04\xd0\x12\r\x11\
    \n\x0e\n\x06\x04\xa2\x01\x02\n\x01\x12\x04\xd0\x12\x12#\n\x0e\n\x06\x04\
    \xa2\x01\x02\n\x03\x12\x04\xd0\x12&(\n\r\n\x05\x04\xa2\x01\x02\x0b\x12\
    \x04\xd1\x12\x04&\n\x0e\n\x06\x04\xa2\x01\x02\x0b\x04\x12\x04\xd1\x12\
    \x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x0b\x06\x12\x04\xd1\x12\r\x12\n\x0e\
    \n\x06\x04\xa2\x01\x02\x0b\x01\x12\x04\xd1\x12\x13\x20\n\x0e\n\x06\x04\
    \xa2\x01\x02\x0b\x03\x12\x04\xd1\x12#%\n\r\n\x05\x04\xa2\x01\x02\x0c\x12\
    \x04\xd2\x12\x04'\n\x0e\n\x06\x04\xa2\x01\x02\x0c\x04\x12\x04\xd2\x12\
    \x04\x0c\n\x0e\n\x06\x04\xa2\x01\x02\x0c\x06\x12\x04\xd2\x12\r\x12\n\x0e\
    \n\x06\x04\xa2\x01\x02\x0c\x01\x12\x04\xd2\x12\x13!\n\x0e\n\x06\x04\xa2\
    \x01\x02\x0c\x03\x12\x04\xd2\x12$&\n\r\n\x03\x04\xa3\x01\x12\x06\xd5\x12\
    \0\xda\x12\x01\n\x0c\n\x04\x04\xa3\x01\x01\x12\x04\xd5\x12\x08\x1f\n\r\n\
    \x05\x04\xa3\x01\x02\0\x12\x04\xd6\x12\x04\x20\n\x0e\n\x06\x04\xa3\x01\
    \x02\0\x04\x12\x04\xd6\x12\x04\x0c\n\x0e\n\x06\x04\xa3\x01\x02\0\x06\x12\
    \x04\xd6\x12\r\x17\n\x0e\n\x06\x04\xa3\x01\x02\0\x01\x12\x04\xd6\x12\x18\
    \x1b\n\x0e\n\x06\x04\xa3\x01\x02\0\x03\x12\x04\xd6\x12\x1e\x1f\n\r\n\x05\
    \x04\xa3\x01\x02\x01\x12\x04\xd7\x12\x04!\n\x0e\n\x06\x04\xa3\x01\x02\
    \x01\x04\x12\x04\xd7\x12\x04\x0c\n\x0e\n\x06\x04\xa3\x01\x02\x01\x06\x12\
    \x04\xd7\x12\r\x14\n\x0e\n\x06\x04\xa3\x01\x02\x01\x01\x12\x04\xd7\x12\
    \x15\x1c\n\x0e\n\x06\x04\xa3\x01\x02\x01\x03\x12\x04\xd7\x12\x1f\x20\n\r\
    \n\x05\x04\xa3\x01\x02\x02\x12\x04\xd8\x12\x04)\n\x0e\n\x06\x04\xa3\x01\
    \x02\x02\x04\x12\x04\xd8\x12\x04\x0c\n\x0e\n\x06\x04\xa3\x01\x02\x02\x05\
    \x12\x04\xd8\x12\r\x13\n\x0e\n\x06\x04\xa3\x01\x02\x02\x01\x12\x04\xd8\
    \x12\x14$\n\x0e\n\x06\x04\xa3\x01\x02\x02\x03\x12\x04\xd8\x12'(\n\r\n\
    \x05\x04\xa3\x01\x02\x03\x12\x04\xd9\x12\x04$\n\x0e\n\x06\x04\xa3\x01\
    \x02\x03\x04\x12\x04\xd9\x12\x04\x0c\n\x0e\n\x06\x04\xa3\x01\x02\x03\x05\
    \x12\x04\xd9\x12\r\x13\n\x0e\n\x06\x04\xa3\x01\x02\x03\x01\x12\x04\xd9\
    \x12\x14\x1f\n\x0e\n\x06\x04\xa3\x01\x02\x03\x03\x12\x04\xd9\x12\"#\n\r\
    \n\x03\x04\xa4\x01\x12\x06\xdc\x12\0\xde\x12\x01\n\x0c\n\x04\x04\xa4\x01\
    \x01\x12\x04\xdc\x12\x08\x11\n\r\n\x05\x04\xa4\x01\x02\0\x12\x04\xdd\x12\
    \x04\"\n\x0e\n\x06\x04\xa4\x01\x02\0\x04\x12\x04\xdd\x12\x04\x0c\n\x0e\n\
    \x06\x04\xa4\x01\x02\0\x05\x12\x04\xdd\x12\r\x13\n\x0e\n\x06\x04\xa4\x01\
    \x02\0\x01\x12\x04\xdd\x12\x14\x1d\n\x0e\n\x06\x04\xa4\x01\x02\0\x03\x12\
    \x04\xdd\x12\x20!\n\r\n\x03\x04\xa5\x01\x12\x06\xe0\x12\0\xe7\x12\x01\n\
    \x0c\n\x04\x04\xa5\x01\x01\x12\x04\xe0\x12\x08\x12\n\r\n\x05\x04\xa5\x01\
    \x02\0\x12\x04\xe1\x12\x04#\n\x0e\n\x06\x04\xa5\x01\x02\0\x04\x12\x04\
    \xe1\x12\x04\x0c\n\x0e\n\x06\x04\xa5\x01\x02\0\x06\x12\x04\xe1\x12\r\x15\
    \n\x0e\n\x06\x04\xa5\x01\x02\0\x01\x12\x04\xe1\x12\x16\x1e\n\x0e\n\x06\
    \x04\xa5\x01\x02\0\x03\x12\x04\xe1\x12!\"\n\r\n\x05\x04\xa5\x01\x02\x01\
    \x12\x04\xe2\x12\x04'\n\x0e\n\x06\x04\xa5\x01\x02\x01\x04\x12\x04\xe2\
    \x12\x04\x0c\n\x0e\n\x06\x04\xa5\x01\x02\x01\x05\x12\x04\xe2\x12\r\x12\n\
    \x0e\n\x06\x04\xa5\x01\x02\x01\x01\x12\x04\xe2\x12\x13\"\n\x0e\n\x06\x04\
    \xa5\x01\x02\x01\x03\x12\x04\xe2\x12%&\n\r\n\x05\x04\xa5\x01\x02\x02\x12\
    \x04\xe3\x12\x04\x20\n\x0e\n\x06\x04\xa5\x01\x02\x02\x04\x12\x04\xe3\x12\
    \x04\x0c\n\x0e\n\x06\x04\xa5\x01\x02\x02\x06\x12\x04\xe3\x12\r\x17\n\x0e\
    \n\x06\x04\xa5\x01\x02\x02\x01\x12\x04\xe3\x12\x18\x1b\n\x0e\n\x06\x04\
    \xa5\x01\x02\x02\x03\x12\x04\xe3\x12\x1e\x1f\n\r\n\x05\x04\xa5\x01\x02\
    \x03\x12\x04\xe4\x12\x04\"\n\x0e\n\x06\x04\xa5\x01\x02\x03\x04\x12\x04\
    \xe4\x12\x04\x0c\n\x0e\n\x06\x04\xa5\x01\x02\x03\x05\x12\x04\xe4\x12\r\
    \x13\n\x0e\n\x06\x04\xa5\x01\x02\x03\x01\x12\x04\xe4\x12\x14\x1d\n\x0e\n\
    \x06\x04\xa5\x01\x02\x03\x03\x12\x04\xe4\x12\x20!\n\r\n\x05\x04\xa5\x01\
    \x02\x04\x12\x04\xe5\x12\x04)\n\x0e\n\x06\x04\xa5\x01\x02\x04\x04\x12\
    \x04\xe5\x12\x04\x0c\n\x0e\n\x06\x04\xa5\x01\x02\x04\x05\x12\x04\xe5\x12\
    \r\x12\n\x0e\n\x06\x04\xa5\x01\x02\x04\x01\x12\x04\xe5\x12\x13$\n\x0e\n\
    \x06\x04\xa5\x01\x02\x04\x03\x12\x04\xe5\x12'(\n\r\n\x05\x04\xa5\x01\x02\
    \x05\x12\x04\xe6\x12\x04)\n\x0e\n\x06\x04\xa5\x01\x02\x05\x04\x12\x04\
    \xe6\x12\x04\x0c\n\x0e\n\x06\x04\xa5\x01\x02\x05\x05\x12\x04\xe6\x12\r\
    \x12\n\x0e\n\x06\x04\xa5\x01\x02\x05\x01\x12\x04\xe6\x12\x13$\n\x0e\n\
    \x06\x04\xa5\x01\x02\x05\x03\x12\x04\xe6\x12'(\n\r\n\x03\x04\xa6\x01\x12\
    \x06\xe9\x12\0\xf4\x12\x01\n\x0c\n\x04\x04\xa6\x01\x01\x12\x04\xe9\x12\
    \x08\x18\n\x0f\n\x05\x04\xa6\x01\x03\0\x12\x06\xea\x12\x04\xf0\x12\x05\n\
    \x0e\n\x06\x04\xa6\x01\x03\0\x01\x12\x04\xea\x12\x0c\x13\n\x0f\n\x07\x04\
    \xa6\x01\x03\0\x02\0\x12\x04\xeb\x12\x08#\n\x10\n\x08\x04\xa6\x01\x03\0\
    \x02\0\x04\x12\x04\xeb\x12\x08\x10\n\x10\n\x08\x04\xa6\x01\x03\0\x02\0\
    \x05\x12\x04\xeb\x12\x11\x17\n\x10\n\x08\x04\xa6\x01\x03\0\x02\0\x01\x12\
    \x04\xeb\x12\x18\x1e\n\x10\n\x08\x04\xa6\x01\x03\0\x02\0\x03\x12\x04\xeb\
    \x12!\"\n\x0f\n\x07\x04\xa6\x01\x03\0\x02\x01\x12\x04\xec\x12\x08#\n\x10\
    \n\x08\x04\xa6\x01\x03\0\x02\x01\x04\x12\x04\xec\x12\x08\x10\n\x10\n\x08\
    \x04\xa6\x01\x03\0\x02\x01\x05\x12\x04\xec\x12\x11\x17\n\x10\n\x08\x04\
    \xa6\x01\x03\0\x02\x01\x01\x12\x04\xec\x12\x18\x1e\n\x10\n\x08\x04\xa6\
    \x01\x03\0\x02\x01\x03\x12\x04\xec\x12!\"\n\x0f\n\x07\x04\xa6\x01\x03\0\
    \x02\x02\x12\x04\xed\x12\x08$\n\x10\n\x08\x04\xa6\x01\x03\0\x02\x02\x04\
    \x12\x04\xed\x12\x08\x10\n\x10\n\x08\x04\xa6\x01\x03\0\x02\x02\x05\x12\
    \x04\xed\x12\x11\x17\n\x10\n\x08\x04\xa6\x01\x03\0\x02\x02\x01\x12\x04\
    \xed\x12\x18\x1f\n\x10\n\x08\x04\xa6\x01\x03\0\x02\x02\x03\x12\x04\xed\
    \x12\"#\n\x0f\n\x07\x04\xa6\x01\x03\0\x02\x03\x12\x04\xee\x12\x08$\n\x10\
    \n\x08\x04\xa6\x01\x03\0\x02\x03\x04\x12\x04\xee\x12\x08\x10\n\x10\n\x08\
    \x04\xa6\x01\x03\0\x02\x03\x05\x12\x04\xee\x12\x11\x17\n\x10\n\x08\x04\
    \xa6\x01\x03\0\x02\x03\x01\x12\x04\xee\x12\x18\x1f\n\x10\n\x08\x04\xa6\
    \x01\x03\0\x02\x03\x03\x12\x04\xee\x12\"#\n\x0f\n\x07\x04\xa6\x01\x03\0\
    \x02\x04\x12\x04\xef\x12\x08\x1f\n\x10\n\x08\x04\xa6\x01\x03\0\x02\x04\
    \x04\x12\x04\xef\x12\x08\x10\n\x10\n\x08\x04\xa6\x01\x03\0\x02\x04\x05\
    \x12\x04\xef\x12\x11\x16\n\x10\n\x08\x04\xa6\x01\x03\0\x02\x04\x01\x12\
    \x04\xef\x12\x17\x1a\n\x10\n\x08\x04\xa6\x01\x03\0\x02\x04\x03\x12\x04\
    \xef\x12\x1d\x1e\n\r\n\x05\x04\xa6\x01\x02\0\x12\x04\xf2\x12\x04\x1f\n\
    \x0e\n\x06\x04\xa6\x01\x02\0\x04\x12\x04\xf2\x12\x04\x0c\n\x0e\n\x06\x04\
    \xa6\x01\x02\0\x05\x12\x04\xf2\x12\r\x12\n\x0e\n\x06\x04\xa6\x01\x02\0\
    \x01\x12\x04\xf2\x12\x13\x1a\n\x0e\n\x06\x04\xa6\x01\x02\0\x03\x12\x04\
    \xf2\x12\x1d\x1e\n\r\n\x05\x04\xa6\x01\x02\x01\x12\x04\xf3\x12\x04!\n\
    \x0e\n\x06\x04\xa6\x01\x02\x01\x04\x12\x04\xf3\x12\x04\x0c\n\x0e\n\x06\
    \x04\xa6\x01\x02\x01\x05\x12\x04\xf3\x12\r\x12\n\x0e\n\x06\x04\xa6\x01\
    \x02\x01\x01\x12\x04\xf3\x12\x13\x1c\n\x0e\n\x06\x04\xa6\x01\x02\x01\x03\
    \x12\x04\xf3\x12\x1f\x20\n\r\n\x03\x04\xa7\x01\x12\x06\xf6\x12\0\x86\x13\
    \x01\n\x0c\n\x04\x04\xa7\x01\x01\x12\x04\xf6\x12\x08\x11\n\x0f\n\x05\x04\
    \xa7\x01\x03\0\x12\x06\xf7\x12\x04\x82\x13\x05\n\x0e\n\x06\x04\xa7\x01\
    \x03\0\x01\x12\x04\xf7\x12\x0c\x1c\n\x11\n\x07\x04\xa7\x01\x03\0\x03\0\
    \x12\x06\xf8\x12\x08\xfe\x12\t\n\x10\n\x08\x04\xa7\x01\x03\0\x03\0\x01\
    \x12\x04\xf8\x12\x10\x17\n\x11\n\t\x04\xa7\x01\x03\0\x03\0\x02\0\x12\x04\
    \xf9\x12\x0c'\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\0\x04\x12\x04\xf9\
    \x12\x0c\x14\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\0\x05\x12\x04\xf9\x12\
    \x15\x1b\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\0\x01\x12\x04\xf9\x12\x1c\
    \"\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\0\x03\x12\x04\xf9\x12%&\n\x11\n\
    \t\x04\xa7\x01\x03\0\x03\0\x02\x01\x12\x04\xfa\x12\x0c-\n\x12\n\n\x04\
    \xa7\x01\x03\0\x03\0\x02\x01\x04\x12\x04\xfa\x12\x0c\x14\n\x12\n\n\x04\
    \xa7\x01\x03\0\x03\0\x02\x01\x05\x12\x04\xfa\x12\x15\x1b\n\x12\n\n\x04\
    \xa7\x01\x03\0\x03\0\x02\x01\x01\x12\x04\xfa\x12\x1c(\n\x12\n\n\x04\xa7\
    \x01\x03\0\x03\0\x02\x01\x03\x12\x04\xfa\x12+,\n\x11\n\t\x04\xa7\x01\x03\
    \0\x03\0\x02\x02\x12\x04\xfb\x12\x0c#\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\
    \x02\x02\x04\x12\x04\xfb\x12\x0c\x14\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\
    \x02\x02\x05\x12\x04\xfb\x12\x15\x1a\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\
    \x02\x02\x01\x12\x04\xfb\x12\x1b\x1e\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\
    \x02\x02\x03\x12\x04\xfb\x12!\"\n\x11\n\t\x04\xa7\x01\x03\0\x03\0\x02\
    \x03\x12\x04\xfc\x12\x0c*\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\x03\x04\
    \x12\x04\xfc\x12\x0c\x14\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\x03\x05\
    \x12\x04\xfc\x12\x15\x1b\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\x03\x01\
    \x12\x04\xfc\x12\x1c%\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\x03\x03\x12\
    \x04\xfc\x12()\n\x11\n\t\x04\xa7\x01\x03\0\x03\0\x02\x04\x12\x04\xfd\x12\
    \x0c)\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\x04\x04\x12\x04\xfd\x12\x0c\
    \x14\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\x04\x05\x12\x04\xfd\x12\x15\
    \x1b\n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\x04\x01\x12\x04\xfd\x12\x1c$\
    \n\x12\n\n\x04\xa7\x01\x03\0\x03\0\x02\x04\x03\x12\x04\xfd\x12'(\n\x0f\n\
    \x07\x04\xa7\x01\x03\0\x02\0\x12\x04\x80\x13\x08#\n\x10\n\x08\x04\xa7\
    \x01\x03\0\x02\0\x04\x12\x04\x80\x13\x08\x10\n\x10\n\x08\x04\xa7\x01\x03\
    \0\x02\0\x05\x12\x04\x80\x13\x11\x16\n\x10\n\x08\x04\xa7\x01\x03\0\x02\0\
    \x01\x12\x04\x80\x13\x17\x1e\n\x10\n\x08\x04\xa7\x01\x03\0\x02\0\x03\x12\
    \x04\x80\x13!\"\n\x0f\n\x07\x04\xa7\x01\x03\0\x02\x01\x12\x04\x81\x13\
    \x08%\n\x10\n\x08\x04\xa7\x01\x03\0\x02\x01\x04\x12\x04\x81\x13\x08\x10\
    \n\x10\n\x08\x04\xa7\x01\x03\0\x02\x01\x05\x12\x04\x81\x13\x11\x16\n\x10\
    \n\x08\x04\xa7\x01\x03\0\x02\x01\x01\x12\x04\x81\x13\x17\x20\n\x10\n\x08\
    \x04\xa7\x01\x03\0\x02\x01\x03\x12\x04\x81\x13#$\n\r\n\x05\x04\xa7\x01\
    \x02\0\x12\x04\x84\x13\x04'\n\x0e\n\x06\x04\xa7\x01\x02\0\x04\x12\x04\
    \x84\x13\x04\x0c\n\x0e\n\x06\x04\xa7\x01\x02\0\x06\x12\x04\x84\x13\r\x1d\
    \n\x0e\n\x06\x04\xa7\x01\x02\0\x01\x12\x04\x84\x13\x1e\"\n\x0e\n\x06\x04\
    \xa7\x01\x02\0\x03\x12\x04\x84\x13%&\n\r\n\x05\x04\xa7\x01\x02\x01\x12\
    \x04\x85\x13\x04/\n\x0e\n\x06\x04\xa7\x01\x02\x01\x04\x12\x04\x85\x13\
    \x04\x0c\n\x0e\n\x06\x04\xa7\x01\x02\x01\x06\x12\x04\x85\x13\r\x1d\n\x0e\
    \n\x06\x04\xa7\x01\x02\x01\x01\x12\x04\x85\x13\x1e*\n\x0e\n\x06\x04\xa7\
    \x01\x02\x01\x03\x12\x04\x85\x13-.\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(224);
            messages.push(ADVSignedKeyIndexList::generated_message_descriptor_data());
            messages.push(ADVSignedDeviceIdentity::generated_message_descriptor_data());
            messages.push(ADVSignedDeviceIdentityHMAC::generated_message_descriptor_data());
            messages.push(ADVKeyIndexList::generated_message_descriptor_data());
            messages.push(ADVDeviceIdentity::generated_message_descriptor_data());
            messages.push(DeviceProps::generated_message_descriptor_data());
            messages.push(PeerDataOperationRequestMessage::generated_message_descriptor_data());
            messages.push(PaymentInviteMessage::generated_message_descriptor_data());
            messages.push(OrderMessage::generated_message_descriptor_data());
            messages.push(LocationMessage::generated_message_descriptor_data());
            messages.push(LiveLocationMessage::generated_message_descriptor_data());
            messages.push(ListResponseMessage::generated_message_descriptor_data());
            messages.push(ListMessage::generated_message_descriptor_data());
            messages.push(KeepInChatMessage::generated_message_descriptor_data());
            messages.push(InvoiceMessage::generated_message_descriptor_data());
            messages.push(InteractiveResponseMessage::generated_message_descriptor_data());
            messages.push(InteractiveMessage::generated_message_descriptor_data());
            messages.push(InitialSecurityNotificationSettingSync::generated_message_descriptor_data());
            messages.push(ImageMessage::generated_message_descriptor_data());
            messages.push(HistorySyncNotification::generated_message_descriptor_data());
            messages.push(HighlyStructuredMessage::generated_message_descriptor_data());
            messages.push(GroupInviteMessage::generated_message_descriptor_data());
            messages.push(FutureProofMessage::generated_message_descriptor_data());
            messages.push(ExtendedTextMessage::generated_message_descriptor_data());
            messages.push(EncReactionMessage::generated_message_descriptor_data());
            messages.push(DocumentMessage::generated_message_descriptor_data());
            messages.push(DeviceSentMessage::generated_message_descriptor_data());
            messages.push(DeclinePaymentRequestMessage::generated_message_descriptor_data());
            messages.push(ContactsArrayMessage::generated_message_descriptor_data());
            messages.push(ContactMessage::generated_message_descriptor_data());
            messages.push(Chat::generated_message_descriptor_data());
            messages.push(CancelPaymentRequestMessage::generated_message_descriptor_data());
            messages.push(Call::generated_message_descriptor_data());
            messages.push(ButtonsResponseMessage::generated_message_descriptor_data());
            messages.push(ButtonsMessage::generated_message_descriptor_data());
            messages.push(AudioMessage::generated_message_descriptor_data());
            messages.push(AppStateSyncKey::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyShare::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyRequest::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyId::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyFingerprint::generated_message_descriptor_data());
            messages.push(AppStateSyncKeyData::generated_message_descriptor_data());
            messages.push(AppStateFatalExceptionNotification::generated_message_descriptor_data());
            messages.push(Location::generated_message_descriptor_data());
            messages.push(InteractiveAnnotation::generated_message_descriptor_data());
            messages.push(HydratedTemplateButton::generated_message_descriptor_data());
            messages.push(GroupMention::generated_message_descriptor_data());
            messages.push(DisappearingMode::generated_message_descriptor_data());
            messages.push(DeviceListMetadata::generated_message_descriptor_data());
            messages.push(ContextInfo::generated_message_descriptor_data());
            messages.push(ActionLink::generated_message_descriptor_data());
            messages.push(TemplateButton::generated_message_descriptor_data());
            messages.push(Point::generated_message_descriptor_data());
            messages.push(PaymentBackground::generated_message_descriptor_data());
            messages.push(Money::generated_message_descriptor_data());
            messages.push(Message::generated_message_descriptor_data());
            messages.push(MessageContextInfo::generated_message_descriptor_data());
            messages.push(VideoMessage::generated_message_descriptor_data());
            messages.push(TemplateMessage::generated_message_descriptor_data());
            messages.push(TemplateButtonReplyMessage::generated_message_descriptor_data());
            messages.push(StickerSyncRMRMessage::generated_message_descriptor_data());
            messages.push(StickerMessage::generated_message_descriptor_data());
            messages.push(SenderKeyDistributionMessage::generated_message_descriptor_data());
            messages.push(SendPaymentMessage::generated_message_descriptor_data());
            messages.push(ScheduledCallEditMessage::generated_message_descriptor_data());
            messages.push(ScheduledCallCreationMessage::generated_message_descriptor_data());
            messages.push(RequestPhoneNumberMessage::generated_message_descriptor_data());
            messages.push(RequestPaymentMessage::generated_message_descriptor_data());
            messages.push(ReactionMessage::generated_message_descriptor_data());
            messages.push(ProtocolMessage::generated_message_descriptor_data());
            messages.push(ProductMessage::generated_message_descriptor_data());
            messages.push(PollVoteMessage::generated_message_descriptor_data());
            messages.push(PollUpdateMessage::generated_message_descriptor_data());
            messages.push(PollUpdateMessageMetadata::generated_message_descriptor_data());
            messages.push(PollEncValue::generated_message_descriptor_data());
            messages.push(PollCreationMessage::generated_message_descriptor_data());
            messages.push(PinMessage::generated_message_descriptor_data());
            messages.push(PeerDataOperationRequestResponseMessage::generated_message_descriptor_data());
            messages.push(EphemeralSetting::generated_message_descriptor_data());
            messages.push(WallpaperSettings::generated_message_descriptor_data());
            messages.push(StickerMetadata::generated_message_descriptor_data());
            messages.push(Pushname::generated_message_descriptor_data());
            messages.push(PastParticipants::generated_message_descriptor_data());
            messages.push(PastParticipant::generated_message_descriptor_data());
            messages.push(HistorySync::generated_message_descriptor_data());
            messages.push(HistorySyncMsg::generated_message_descriptor_data());
            messages.push(GroupParticipant::generated_message_descriptor_data());
            messages.push(GlobalSettings::generated_message_descriptor_data());
            messages.push(Conversation::generated_message_descriptor_data());
            messages.push(AvatarUserSettings::generated_message_descriptor_data());
            messages.push(AutoDownloadSettings::generated_message_descriptor_data());
            messages.push(MsgRowOpaqueData::generated_message_descriptor_data());
            messages.push(MsgOpaqueData::generated_message_descriptor_data());
            messages.push(ServerErrorReceipt::generated_message_descriptor_data());
            messages.push(MediaRetryNotification::generated_message_descriptor_data());
            messages.push(MessageKey::generated_message_descriptor_data());
            messages.push(SyncdVersion::generated_message_descriptor_data());
            messages.push(SyncdValue::generated_message_descriptor_data());
            messages.push(SyncdSnapshot::generated_message_descriptor_data());
            messages.push(SyncdRecord::generated_message_descriptor_data());
            messages.push(SyncdPatch::generated_message_descriptor_data());
            messages.push(SyncdMutations::generated_message_descriptor_data());
            messages.push(SyncdMutation::generated_message_descriptor_data());
            messages.push(SyncdIndex::generated_message_descriptor_data());
            messages.push(KeyId::generated_message_descriptor_data());
            messages.push(ExternalBlobReference::generated_message_descriptor_data());
            messages.push(ExitCode::generated_message_descriptor_data());
            messages.push(SyncActionValue::generated_message_descriptor_data());
            messages.push(UserStatusMuteAction::generated_message_descriptor_data());
            messages.push(UnarchiveChatsSetting::generated_message_descriptor_data());
            messages.push(TimeFormatAction::generated_message_descriptor_data());
            messages.push(SyncActionMessage::generated_message_descriptor_data());
            messages.push(SyncActionMessageRange::generated_message_descriptor_data());
            messages.push(SubscriptionAction::generated_message_descriptor_data());
            messages.push(StickerAction::generated_message_descriptor_data());
            messages.push(StarAction::generated_message_descriptor_data());
            messages.push(SecurityNotificationSetting::generated_message_descriptor_data());
            messages.push(RemoveRecentStickerAction::generated_message_descriptor_data());
            messages.push(RecentEmojiWeightsAction::generated_message_descriptor_data());
            messages.push(QuickReplyAction::generated_message_descriptor_data());
            messages.push(PushNameSetting::generated_message_descriptor_data());
            messages.push(PrimaryVersionAction::generated_message_descriptor_data());
            messages.push(PrimaryFeature::generated_message_descriptor_data());
            messages.push(PnForLidChatAction::generated_message_descriptor_data());
            messages.push(PinAction::generated_message_descriptor_data());
            messages.push(NuxAction::generated_message_descriptor_data());
            messages.push(MuteAction::generated_message_descriptor_data());
            messages.push(MarkChatAsReadAction::generated_message_descriptor_data());
            messages.push(LocaleSetting::generated_message_descriptor_data());
            messages.push(LabelEditAction::generated_message_descriptor_data());
            messages.push(LabelAssociationAction::generated_message_descriptor_data());
            messages.push(KeyExpiration::generated_message_descriptor_data());
            messages.push(DeleteMessageForMeAction::generated_message_descriptor_data());
            messages.push(DeleteChatAction::generated_message_descriptor_data());
            messages.push(ContactAction::generated_message_descriptor_data());
            messages.push(ClearChatAction::generated_message_descriptor_data());
            messages.push(ChatAssignmentOpenedStatusAction::generated_message_descriptor_data());
            messages.push(ChatAssignmentAction::generated_message_descriptor_data());
            messages.push(ArchiveChatAction::generated_message_descriptor_data());
            messages.push(AndroidUnsupportedActions::generated_message_descriptor_data());
            messages.push(AgentAction::generated_message_descriptor_data());
            messages.push(SyncActionData::generated_message_descriptor_data());
            messages.push(RecentEmojiWeight::generated_message_descriptor_data());
            messages.push(VerifiedNameCertificate::generated_message_descriptor_data());
            messages.push(LocalizedName::generated_message_descriptor_data());
            messages.push(BizIdentityInfo::generated_message_descriptor_data());
            messages.push(BizAccountPayload::generated_message_descriptor_data());
            messages.push(BizAccountLinkInfo::generated_message_descriptor_data());
            messages.push(HandshakeMessage::generated_message_descriptor_data());
            messages.push(HandshakeServerHello::generated_message_descriptor_data());
            messages.push(HandshakeClientHello::generated_message_descriptor_data());
            messages.push(HandshakeClientFinish::generated_message_descriptor_data());
            messages.push(ClientPayload::generated_message_descriptor_data());
            messages.push(WebNotificationsInfo::generated_message_descriptor_data());
            messages.push(WebMessageInfo::generated_message_descriptor_data());
            messages.push(WebFeatures::generated_message_descriptor_data());
            messages.push(UserReceipt::generated_message_descriptor_data());
            messages.push(StatusPSA::generated_message_descriptor_data());
            messages.push(Reaction::generated_message_descriptor_data());
            messages.push(PollUpdate::generated_message_descriptor_data());
            messages.push(PollAdditionalMetadata::generated_message_descriptor_data());
            messages.push(PhotoChange::generated_message_descriptor_data());
            messages.push(PaymentInfo::generated_message_descriptor_data());
            messages.push(NotificationMessageInfo::generated_message_descriptor_data());
            messages.push(MediaData::generated_message_descriptor_data());
            messages.push(KeepInChat::generated_message_descriptor_data());
            messages.push(NoiseCertificate::generated_message_descriptor_data());
            messages.push(CertChain::generated_message_descriptor_data());
            messages.push(device_props::HistorySyncConfig::generated_message_descriptor_data());
            messages.push(device_props::AppVersion::generated_message_descriptor_data());
            messages.push(peer_data_operation_request_message::RequestUrlPreview::generated_message_descriptor_data());
            messages.push(peer_data_operation_request_message::RequestStickerReupload::generated_message_descriptor_data());
            messages.push(list_response_message::SingleSelectReply::generated_message_descriptor_data());
            messages.push(list_message::Section::generated_message_descriptor_data());
            messages.push(list_message::Row::generated_message_descriptor_data());
            messages.push(list_message::Product::generated_message_descriptor_data());
            messages.push(list_message::ProductSection::generated_message_descriptor_data());
            messages.push(list_message::ProductListInfo::generated_message_descriptor_data());
            messages.push(list_message::ProductListHeaderImage::generated_message_descriptor_data());
            messages.push(interactive_response_message::NativeFlowResponseMessage::generated_message_descriptor_data());
            messages.push(interactive_response_message::Body::generated_message_descriptor_data());
            messages.push(interactive_message::ShopMessage::generated_message_descriptor_data());
            messages.push(interactive_message::NativeFlowMessage::generated_message_descriptor_data());
            messages.push(interactive_message::Header::generated_message_descriptor_data());
            messages.push(interactive_message::Footer::generated_message_descriptor_data());
            messages.push(interactive_message::CollectionMessage::generated_message_descriptor_data());
            messages.push(interactive_message::Body::generated_message_descriptor_data());
            messages.push(interactive_message::native_flow_message::NativeFlowButton::generated_message_descriptor_data());
            messages.push(highly_structured_message::HSMLocalizableParameter::generated_message_descriptor_data());
            messages.push(highly_structured_message::hsmlocalizable_parameter::HSMDateTime::generated_message_descriptor_data());
            messages.push(highly_structured_message::hsmlocalizable_parameter::HSMCurrency::generated_message_descriptor_data());
            messages.push(highly_structured_message::hsmlocalizable_parameter::hsmdate_time::HSMDateTimeUnixEpoch::generated_message_descriptor_data());
            messages.push(highly_structured_message::hsmlocalizable_parameter::hsmdate_time::HSMDateTimeComponent::generated_message_descriptor_data());
            messages.push(buttons_message::Button::generated_message_descriptor_data());
            messages.push(buttons_message::button::NativeFlowInfo::generated_message_descriptor_data());
            messages.push(buttons_message::button::ButtonText::generated_message_descriptor_data());
            messages.push(hydrated_template_button::HydratedURLButton::generated_message_descriptor_data());
            messages.push(hydrated_template_button::HydratedQuickReplyButton::generated_message_descriptor_data());
            messages.push(hydrated_template_button::HydratedCallButton::generated_message_descriptor_data());
            messages.push(context_info::UTMInfo::generated_message_descriptor_data());
            messages.push(context_info::ExternalAdReplyInfo::generated_message_descriptor_data());
            messages.push(context_info::AdReplyInfo::generated_message_descriptor_data());
            messages.push(template_button::URLButton::generated_message_descriptor_data());
            messages.push(template_button::QuickReplyButton::generated_message_descriptor_data());
            messages.push(template_button::CallButton::generated_message_descriptor_data());
            messages.push(payment_background::MediaData::generated_message_descriptor_data());
            messages.push(template_message::HydratedFourRowTemplate::generated_message_descriptor_data());
            messages.push(template_message::FourRowTemplate::generated_message_descriptor_data());
            messages.push(product_message::ProductSnapshot::generated_message_descriptor_data());
            messages.push(product_message::CatalogSnapshot::generated_message_descriptor_data());
            messages.push(poll_creation_message::Option::generated_message_descriptor_data());
            messages.push(peer_data_operation_request_response_message::PeerDataOperationResult::generated_message_descriptor_data());
            messages.push(peer_data_operation_request_response_message::peer_data_operation_result::LinkPreviewResponse::generated_message_descriptor_data());
            messages.push(msg_opaque_data::PollOption::generated_message_descriptor_data());
            messages.push(verified_name_certificate::Details::generated_message_descriptor_data());
            messages.push(client_payload::WebInfo::generated_message_descriptor_data());
            messages.push(client_payload::UserAgent::generated_message_descriptor_data());
            messages.push(client_payload::DevicePairingRegistrationData::generated_message_descriptor_data());
            messages.push(client_payload::DNSSource::generated_message_descriptor_data());
            messages.push(client_payload::web_info::WebdPayload::generated_message_descriptor_data());
            messages.push(client_payload::user_agent::AppVersion::generated_message_descriptor_data());
            messages.push(noise_certificate::Details::generated_message_descriptor_data());
            messages.push(cert_chain::NoiseCertificate::generated_message_descriptor_data());
            messages.push(cert_chain::noise_certificate::Details::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(56);
            enums.push(KeepType::generated_enum_descriptor_data());
            enums.push(PeerDataOperationRequestType::generated_enum_descriptor_data());
            enums.push(MediaVisibility::generated_enum_descriptor_data());
            enums.push(device_props::PlatformType::generated_enum_descriptor_data());
            enums.push(payment_invite_message::ServiceType::generated_enum_descriptor_data());
            enums.push(order_message::OrderSurface::generated_enum_descriptor_data());
            enums.push(order_message::OrderStatus::generated_enum_descriptor_data());
            enums.push(list_response_message::ListType::generated_enum_descriptor_data());
            enums.push(list_message::ListType::generated_enum_descriptor_data());
            enums.push(invoice_message::AttachmentType::generated_enum_descriptor_data());
            enums.push(interactive_message::shop_message::Surface::generated_enum_descriptor_data());
            enums.push(history_sync_notification::HistorySyncType::generated_enum_descriptor_data());
            enums.push(highly_structured_message::hsmlocalizable_parameter::hsmdate_time::hsmdate_time_component::DayOfWeekType::generated_enum_descriptor_data());
            enums.push(highly_structured_message::hsmlocalizable_parameter::hsmdate_time::hsmdate_time_component::CalendarType::generated_enum_descriptor_data());
            enums.push(group_invite_message::GroupType::generated_enum_descriptor_data());
            enums.push(extended_text_message::PreviewType::generated_enum_descriptor_data());
            enums.push(extended_text_message::InviteLinkGroupType::generated_enum_descriptor_data());
            enums.push(extended_text_message::FontType::generated_enum_descriptor_data());
            enums.push(buttons_response_message::Type::generated_enum_descriptor_data());
            enums.push(buttons_message::HeaderType::generated_enum_descriptor_data());
            enums.push(buttons_message::button::Type::generated_enum_descriptor_data());
            enums.push(disappearing_mode::Initiator::generated_enum_descriptor_data());
            enums.push(context_info::external_ad_reply_info::MediaType::generated_enum_descriptor_data());
            enums.push(context_info::ad_reply_info::MediaType::generated_enum_descriptor_data());
            enums.push(payment_background::Type::generated_enum_descriptor_data());
            enums.push(video_message::Attribution::generated_enum_descriptor_data());
            enums.push(scheduled_call_edit_message::EditType::generated_enum_descriptor_data());
            enums.push(scheduled_call_creation_message::CallType::generated_enum_descriptor_data());
            enums.push(protocol_message::Type::generated_enum_descriptor_data());
            enums.push(pin_message::PinMessageType::generated_enum_descriptor_data());
            enums.push(past_participant::LeaveReason::generated_enum_descriptor_data());
            enums.push(history_sync::HistorySyncType::generated_enum_descriptor_data());
            enums.push(group_participant::Rank::generated_enum_descriptor_data());
            enums.push(conversation::EndOfHistoryTransferType::generated_enum_descriptor_data());
            enums.push(media_retry_notification::ResultType::generated_enum_descriptor_data());
            enums.push(syncd_mutation::SyncdOperation::generated_enum_descriptor_data());
            enums.push(biz_identity_info::VerifiedLevelValue::generated_enum_descriptor_data());
            enums.push(biz_identity_info::HostStorageType::generated_enum_descriptor_data());
            enums.push(biz_identity_info::ActualActorsType::generated_enum_descriptor_data());
            enums.push(biz_account_link_info::HostStorageType::generated_enum_descriptor_data());
            enums.push(biz_account_link_info::AccountType::generated_enum_descriptor_data());
            enums.push(client_payload::Product::generated_enum_descriptor_data());
            enums.push(client_payload::IOSAppExtension::generated_enum_descriptor_data());
            enums.push(client_payload::ConnectType::generated_enum_descriptor_data());
            enums.push(client_payload::ConnectReason::generated_enum_descriptor_data());
            enums.push(client_payload::web_info::WebSubPlatform::generated_enum_descriptor_data());
            enums.push(client_payload::user_agent::ReleaseChannel::generated_enum_descriptor_data());
            enums.push(client_payload::user_agent::Platform::generated_enum_descriptor_data());
            enums.push(client_payload::dnssource::DNSResolutionMethod::generated_enum_descriptor_data());
            enums.push(web_message_info::StubType::generated_enum_descriptor_data());
            enums.push(web_message_info::Status::generated_enum_descriptor_data());
            enums.push(web_message_info::BizPrivacyStatus::generated_enum_descriptor_data());
            enums.push(web_features::Flag::generated_enum_descriptor_data());
            enums.push(payment_info::TxnStatus::generated_enum_descriptor_data());
            enums.push(payment_info::Status::generated_enum_descriptor_data());
            enums.push(payment_info::Currency::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
